; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\lcdconf.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\lcdconf.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931 -I..\..\..\Driver\Source -I..\..\..\Driver\Include -I..\..\..\ThirdParty\FATFS\src -I..\..\..\ThirdParty\emWin\Config -I..\..\..\ThirdParty\emWin\Include -I..\..\FreeRTOS_with_emwin -I..\tslib -I..\Application -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\portable\RVDS\ARM9_N9H30 -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Demo\Common\include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Toshiba -D__UVISION_VERSION=526 -D_PANEL_E50A2V1_16BPP_ --omf_browse=.\obj\lcdconf.crf ..\..\..\ThirdParty\emWin\Config\LCDConf.c]
                          ARM

                          AREA ||i.GUI_TOUCH_X_ActivateX||, CODE, READONLY, ALIGN=2

                  GUI_TOUCH_X_ActivateX PROC
;;;144    
;;;145    void GUI_TOUCH_X_ActivateX(void) {
000000  e12fff1e          BX       lr
;;;146    }
;;;147    
                          ENDP


                          AREA ||i.GUI_TOUCH_X_ActivateY||, CODE, READONLY, ALIGN=2

                  GUI_TOUCH_X_ActivateY PROC
;;;147    
;;;148    void GUI_TOUCH_X_ActivateY(void) {
000000  e12fff1e          BX       lr
;;;149    }
;;;150    
                          ENDP


                          AREA ||i.GUI_TOUCH_X_MeasureX||, CODE, READONLY, ALIGN=2

                  GUI_TOUCH_X_MeasureX PROC
;;;152     
;;;153    int  GUI_TOUCH_X_MeasureX(void) {
000000  e92d401c          PUSH     {r2-r4,lr}
;;;154      int sumx;
;;;155      int sumy;
;;;156    	if (Read_TouchPanel(&sumx, &sumy))
000004  e28d1004          ADD      r1,sp,#4
000008  e1a0000d          MOV      r0,sp
00000c  ebfffffe          BL       Read_TouchPanel
000010  e3500000          CMP      r0,#0
;;;157    	{
;;;158    //		sysprintf("X = %d\n", sumx);
;;;159    		ts_phy2log(&sumx, &sumy);		
;;;160        return sumx;
;;;161    	}
;;;162    	return -1;
000014  03e00000          MVNEQ    r0,#0
000018  0a000003          BEQ      |L3.44|
00001c  e28d1004          ADD      r1,sp,#4              ;159
000020  e1a0000d          MOV      r0,sp                 ;159
000024  ebfffffe          BL       ts_phy2log
000028  e59d0000          LDR      r0,[sp,#0]            ;160
                  |L3.44|
;;;163    }
00002c  e8bd801c          POP      {r2-r4,pc}
;;;164    
                          ENDP


                          AREA ||i.GUI_TOUCH_X_MeasureY||, CODE, READONLY, ALIGN=2

                  GUI_TOUCH_X_MeasureY PROC
;;;164    
;;;165    int  GUI_TOUCH_X_MeasureY(void) {
000000  e92d401c          PUSH     {r2-r4,lr}
;;;166      int sumx;
;;;167      int sumy;
;;;168    	if ( Read_TouchPanel(&sumx, &sumy) )
000004  e1a0100d          MOV      r1,sp
000008  e28d0004          ADD      r0,sp,#4
00000c  ebfffffe          BL       Read_TouchPanel
000010  e3500000          CMP      r0,#0
;;;169    	{
;;;170    //		sysprintf("Y = %d\n", sumy);
;;;171    		ts_phy2log(&sumx, &sumy);				
;;;172        return sumy;
;;;173    	}
;;;174    	return -1;
000014  03e00000          MVNEQ    r0,#0
000018  0a000003          BEQ      |L4.44|
00001c  e1a0100d          MOV      r1,sp                 ;171
000020  e28d0004          ADD      r0,sp,#4              ;171
000024  ebfffffe          BL       ts_phy2log
000028  e59d0000          LDR      r0,[sp,#0]            ;172
                  |L4.44|
;;;175    }
00002c  e8bd801c          POP      {r2-r4,pc}
;;;176    /*********************************************************************
                          ENDP


                          AREA ||i.LCD_X_Config||, CODE, READONLY, ALIGN=2

                  LCD_X_Config PROC
;;;186    
;;;187    void LCD_X_Config(void) {
000000  e92d4008          PUSH     {r3,lr}
;;;188    
;;;189    	// LCD calibration
;;;190      #if (NUM_BUFFERS > 1)
;;;191        GUI_MULTIBUF_Config(NUM_BUFFERS);
;;;192      #endif
;;;193      //
;;;194      // Set display driver and color conversion for 1st layer
;;;195      //
;;;196      GUI_DEVICE_CreateAndLink(DISPLAY_DRIVER, COLOR_CONVERSION, 0, 0);
000004  e3a03000          MOV      r3,#0
000008  e59f109c          LDR      r1,|L5.172|
00000c  e59f009c          LDR      r0,|L5.176|
000010  e1a02003          MOV      r2,r3
000014  ebfffffe          BL       GUI_DEVICE_CreateAndLink
;;;197      if (LCD_GetSwapXY()) {
000018  ebfffffe          BL       LCD_GetSwapXY
00001c  e3500000          CMP      r0,#0
000020  0a000006          BEQ      |L5.64|
;;;198        LCD_SetSizeEx (0, YSIZE_PHYS, XSIZE_PHYS);
000024  e3a02e32          MOV      r2,#0x320
000028  e3a01e1e          MOV      r1,#0x1e0
00002c  e3a00000          MOV      r0,#0
000030  ebfffffe          BL       LCD_SetSizeEx
;;;199        LCD_SetVSizeEx(0, YSIZE_PHYS * NUM_VSCREENS, XSIZE_PHYS);
000034  e3a02e32          MOV      r2,#0x320
000038  e3a01e1e          MOV      r1,#0x1e0
00003c  ea000005          B        |L5.88|
                  |L5.64|
;;;200      } else {
;;;201        LCD_SetSizeEx (0, XSIZE_PHYS, YSIZE_PHYS);
000040  e3a02e1e          MOV      r2,#0x1e0
000044  e3a01e32          MOV      r1,#0x320
000048  e3a00000          MOV      r0,#0
00004c  ebfffffe          BL       LCD_SetSizeEx
;;;202        LCD_SetVSizeEx(0, XSIZE_PHYS, YSIZE_PHYS * NUM_VSCREENS);
000050  e3a02e1e          MOV      r2,#0x1e0
000054  e3a01e32          MOV      r1,#0x320
                  |L5.88|
000058  e3a00000          MOV      r0,#0
00005c  ebfffffe          BL       LCD_SetVSizeEx
;;;203      }
;;;204      LCD_SetVRAMAddrEx(0, (void *)g_VAFrameBuf);
000060  e59f004c          LDR      r0,|L5.180|
000064  e5901000          LDR      r1,[r0,#0]  ; g_VAFrameBuf
000068  e3a00000          MOV      r0,#0
00006c  ebfffffe          BL       LCD_SetVRAMAddrEx
;;;205    
;;;206      //
;;;207      // Set user palette data (only required if no fixed palette is used)
;;;208      //
;;;209      #if defined(PALETTE)
;;;210        LCD_SetLUTEx(0, PALETTE);
;;;211      #endif
;;;212    
;;;213    // LCD calibration
;;;214    //
;;;215    // Calibrate touch screen
;;;216    //
;;;217    	GUI_TOUCH_Calibrate(GUI_COORD_X, 0, XSIZE_PHYS, 0, XSIZE_PHYS);
000070  e3a00e32          MOV      r0,#0x320
000074  e3a03000          MOV      r3,#0
000078  e1a02000          MOV      r2,r0
00007c  e58d0000          STR      r0,[sp,#0]
000080  e1a01003          MOV      r1,r3
000084  e1a00003          MOV      r0,r3
000088  ebfffffe          BL       GUI_TOUCH_Calibrate
;;;218    	GUI_TOUCH_Calibrate(GUI_COORD_Y, 0, YSIZE_PHYS, 0, YSIZE_PHYS);
00008c  e3a00e1e          MOV      r0,#0x1e0
000090  e3a03000          MOV      r3,#0
000094  e1a02000          MOV      r2,r0
000098  e58d0000          STR      r0,[sp,#0]
00009c  e1a01003          MOV      r1,r3
0000a0  e3a00001          MOV      r0,#1
0000a4  ebfffffe          BL       GUI_TOUCH_Calibrate
;;;219    	
;;;220    }
0000a8  e8bd8008          POP      {r3,pc}
;;;221    
                          ENDP

                  |L5.172|
                          DCD      LCD_API_ColorConv_M565
                  |L5.176|
                          DCD      GUIDRV_Lin_16_API
                  |L5.180|
                          DCD      g_VAFrameBuf

                          AREA ||i.LCD_X_DisplayDriver||, CODE, READONLY, ALIGN=2

                  LCD_X_DisplayDriver PROC
;;;237    */
;;;238    int LCD_X_DisplayDriver(unsigned LayerIndex, unsigned Cmd, void * pData) {
000000  e92d4010          PUSH     {r4,lr}
;;;239      int r;
;;;240    
;;;241      switch (Cmd) {
000004  e3510004          CMP      r1,#4
000008  0a00000d          BEQ      |L6.68|
00000c  ca000006          BGT      |L6.44|
000010  e3510001          CMP      r1,#1
000014  0a000009          BEQ      |L6.64|
000018  e3510002          CMP      r1,#2
00001c  13510003          CMPNE    r1,#3
000020  0a000007          BEQ      |L6.68|
                  |L6.36|
;;;242      //
;;;243      // Required
;;;244      //
;;;245      case LCD_X_INITCONTROLLER: {
;;;246        //
;;;247        // Called during the initialization process in order to set up the
;;;248        // display controller and put it into operation. If the display
;;;249        // controller is not initialized by any external routine this needs
;;;250        // to be adapted by the customer...
;;;251        //
;;;252    		//LCD_ON();
;;;253          vpostVAStartTrigger();
;;;254        return 0;  
;;;255      }
;;;256     case LCD_X_SETVRAMADDR: {
;;;257        //
;;;258        // Required for setting the address of the video RAM for drivers
;;;259        // with memory mapped video RAM which is passed in the 'pVRAM' element of p
;;;260        //
;;;261        LCD_X_SETVRAMADDR_INFO * p;
;;;262        p = (LCD_X_SETVRAMADDR_INFO *)pData;
;;;263    		pData=(void*)g_VAFrameBuf;
;;;264        GUI_USE_PARA(p);
;;;265        //...
;;;266        return 0;
;;;267      }
;;;268      case LCD_X_SETORG: {
;;;269        //
;;;270        // Required for setting the display origin which is passed in the 'xPos' and 'yPos' element of p
;;;271        //
;;;272        LCD_X_SETORG_INFO * p;
;;;273        p = (LCD_X_SETORG_INFO *)pData;
;;;274    		pData=(void*)g_VAFrameBuf;
;;;275        GUI_USE_PARA(p);
;;;276        //...
;;;277        return 0;
;;;278      }
;;;279      case LCD_X_SHOWBUFFER: {
;;;280        //
;;;281        // Required if multiple buffers are used. The 'Index' element of p contains the buffer index.
;;;282        //
;;;283        LCD_X_SHOWBUFFER_INFO * p;
;;;284        p = (LCD_X_SHOWBUFFER_INFO *)pData;
;;;285        GUI_USE_PARA(p);
;;;286        //...
;;;287        return 0;
;;;288      }
;;;289      case LCD_X_SETLUTENTRY: {
;;;290        //
;;;291        // Required for setting a lookup table entry which is passed in the 'Pos' and 'Color' element of p
;;;292        //
;;;293        LCD_X_SETLUTENTRY_INFO * p;
;;;294        p = (LCD_X_SETLUTENTRY_INFO *)pData;
;;;295        GUI_USE_PARA(p);
;;;296        //...
;;;297        return 0;
;;;298      }
;;;299      case LCD_X_ON: {
;;;300        //
;;;301        // Required if the display controller should support switching on and off
;;;302        //
;;;303    		
;;;304        return 0;
;;;305      }
;;;306      case LCD_X_OFF: {
;;;307        //
;;;308        // Required if the display controller should support switching on and off
;;;309        //
;;;310        // ...
;;;311        return 0;
;;;312      }  
;;;313      default:
;;;314        r = -1;
000024  e3e00000          MVN      r0,#0
;;;315      }
;;;316      return r;
;;;317    }
000028  e8bd8010          POP      {r4,pc}
                  |L6.44|
00002c  e3510005          CMP      r1,#5                 ;241
000030  13510006          CMPNE    r1,#6                 ;241
000034  1351000e          CMPNE    r1,#0xe               ;241
000038  1afffff9          BNE      |L6.36|
00003c  ea000000          B        |L6.68|
                  |L6.64|
000040  ebfffffe          BL       vpostVAStartTrigger
                  |L6.68|
000044  e3a00000          MOV      r0,#0                 ;311
000048  e8bd8010          POP      {r4,pc}
;;;318    
                          ENDP

