; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\adc.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\adc.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931 -I..\..\..\Driver\Source -I..\..\..\Driver\Include -I..\..\..\ThirdParty\FATFS\src -I..\..\..\ThirdParty\emWin\Config -I..\..\..\ThirdParty\emWin\Include -I..\..\FreeRTOS_with_emwin -I..\tslib -I..\Application -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\portable\RVDS\ARM9_N9H30 -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Demo\Common\include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Toshiba -D__UVISION_VERSION=526 -D_PANEL_E50A2V1_16BPP_ --omf_browse=.\obj\adc.crf ..\..\..\Driver\Source\adc.c]
                          ARM

                          AREA ||i.adcChangeChannel||, CODE, READONLY, ALIGN=2

                  adcChangeChannel PROC
;;;910     */
;;;911    INT adcChangeChannel(int channel)
000000  e3a01008          MOV      r1,#8
;;;912    {
;;;913        UINT32 reg;
;;;914        if ((channel>>3) < 0 || (channel>>3) > 7) {
000004  e15101c0          CMP      r1,r0,ASR #3
;;;915            return ADC_ERR_ARGS;
000008  93a00001          MOVLS    r0,#1
;;;916        }
;;;917        reg = inpw(REG_ADC_CONF);
;;;918        reg = (reg & ~ADC_CONF_CHSEL_Msk) | channel;
;;;919        outpw(REG_ADC_CONF,reg);
;;;920        return Successful;
;;;921    }
00000c  912fff1e          BXLS     lr
000010  e59f2014          LDR      r2,|L1.44|
000014  e5921004          LDR      r1,[r2,#4]            ;917
000018  e3c11038          BIC      r1,r1,#0x38           ;918
00001c  e1800001          ORR      r0,r0,r1              ;918
000020  e5820004          STR      r0,[r2,#4]            ;919
000024  e3a00000          MOV      r0,#0                 ;920
000028  e12fff1e          BX       lr
;;;922    
                          ENDP

                  |L1.44|
                          DCD      0xb800a000

                          AREA ||i.adcClose||, CODE, READONLY, ALIGN=2

                  adcClose PROC
;;;190     */
;;;191    int adcClose(void)
000000  e92d4010          PUSH     {r4,lr}
;;;192    {
;;;193        /* Disable interrupt */
;;;194        sysDisableInterrupt(ADC_IRQn);
000004  e3a00012          MOV      r0,#0x12
000008  ebfffffe          BL       sysDisableInterrupt
;;;195        sysSetLocalInterrupt(DISABLE_IRQ);   /* Disable CPSR I bit */
00000c  e3a00080          MOV      r0,#0x80
000010  ebfffffe          BL       sysSetLocalInterrupt
;;;196    
;;;197        /* Disable ADC Power */
;;;198        outpw(REG_ADC_CTL, inpw(REG_ADC_CTL) & ~ADC_CTL_ADEN);
000014  e59f0020          LDR      r0,|L2.60|
000018  e5901000          LDR      r1,[r0,#0]
00001c  e3c11001          BIC      r1,r1,#1
000020  e5801000          STR      r1,[r0,#0]
;;;199    
;;;200        /* Disable ADC engine clock */
;;;201        outpw(REG_CLK_PCLKEN1, inpw(REG_CLK_PCLKEN1) & ~(1<<24));
000024  e3a0020b          MOV      r0,#0xb0000000
000028  e590121c          LDR      r1,[r0,#0x21c]
00002c  e3c11401          BIC      r1,r1,#0x1000000
000030  e580121c          STR      r1,[r0,#0x21c]
;;;202    
;;;203        return Successful;
000034  e3a00000          MOV      r0,#0
;;;204    }
000038  e8bd8010          POP      {r4,pc}
;;;205    
                          ENDP

                  |L2.60|
                          DCD      0xb800a000

                          AREA ||i.adcISR||, CODE, READONLY, ALIGN=2

                  adcISR PROC
;;;751     */
;;;752    void adcISR(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;753    {
;;;754        unsigned int isr,ier,wkisr,conf;
;;;755        conf=inpw(REG_ADC_CONF);
000004  e59f72e0          LDR      r7,|L3.748|
000008  e24dd01c          SUB      sp,sp,#0x1c           ;753
00000c  e5970004          LDR      r0,[r7,#4]
;;;756        isr=inpw(REG_ADC_ISR);
000010  e58d0014          STR      r0,[sp,#0x14]
000014  e597400c          LDR      r4,[r7,#0xc]
;;;757        ier=inpw(REG_ADC_IER);
000018  e597a008          LDR      r10,[r7,#8]
;;;758        wkisr=inpw(REG_ADC_WKISR);
00001c  e5970010          LDR      r0,[r7,#0x10]
;;;759        //sysprintf("ADC_IRQHandler Interrupt(0x%08x): ",isr);
;;;760        DbgPrintf("REG_ADC_CTL=0x%08x\n",inpw(REG_ADC_CTL));
;;;761        DbgPrintf("REG_ADC_IER=0x%08x\n",inpw(REG_ADC_IER));
;;;762        DbgPrintf("REG_ADC_ISR=0x%08x\n",inpw(REG_ADC_ISR));
;;;763        DbgPrintf("REG_ADC_WKISR=0x%08x\n",inpw(REG_ADC_WKISR));
;;;764        DbgPrintf("SYS_WKUPSSR=0x%08x\n",inpw(REG_SYS_WKUPSSR));
;;;765        DbgPrintf("SYS_WKUPSER=0x%08x\n",inpw(REG_SYS_WKUPSER));
;;;766        if(isr & ADC_ISR_SELFTF) {
000020  e3140a02          TST      r4,#0x2000
000024  e58d000c          STR      r0,[sp,#0xc]
;;;767            outpw(REG_ADC_ISR,ADC_ISR_SELFTF);
000028  13a00a02          MOVNE    r0,#0x2000
00002c  1587000c          STRNE    r0,[r7,#0xc]
;;;768            DbgPrintf("menu self-test complete\n");
;;;769        }
;;;770    
;;;771        if(isr & ADC_ISR_TF) {
;;;772            unsigned int value;
;;;773            INT32 tailX, lengthX;
;;;774            INT32 tailY, lengthY;
;;;775            INT16 *fifoX, *fifoY;
;;;776            tailX   = adcHandler.fifoTailX;
000030  e59fb2b8          LDR      r11,|L3.752|
000034  e3140c01          TST      r4,#0x100             ;771
000038  0a000029          BEQ      |L3.228|
;;;777            lengthX = adcHandler.fifoLengthX;
;;;778            tailY   = adcHandler.fifoTailY;
;;;779            lengthY = adcHandler.fifoLengthY;
00003c  e59b5268          LDR      r5,[r11,#0x268]  ; adcHandler, adcHandler, adcHandler, adcHandler
000040  e59b826c          LDR      r8,[r11,#0x26c]
000044  e59b615c          LDR      r6,[r11,#0x15c]
000048  e59b9160          LDR      r9,[r11,#0x160]
;;;780            fifoX  = adcHandler.fifoX;
00004c  e28b0058          ADD      r0,r11,#0x58
000050  e58d0008          STR      r0,[sp,#8]
;;;781            fifoY  = adcHandler.fifoY;
000054  e28b0f59          ADD      r0,r11,#0x164
000058  e58d0004          STR      r0,[sp,#4]
;;;782            outpw(REG_ADC_ISR,ADC_ISR_TF); //Clear TF flags
00005c  e3a00c01          MOV      r0,#0x100
000060  e587000c          STR      r0,[r7,#0xc]
;;;783            value = inpw(REG_ADC_XYDATA);
000064  e5970020          LDR      r0,[r7,#0x20]
;;;784            if(adcHandler.touch_callback!=NULL)
000068  e58d0000          STR      r0,[sp,#0]
00006c  e59b2000          LDR      r2,[r11,#0]  ; adcHandler
000070  e3520000          CMP      r2,#0
;;;785                adcHandler.touch_callback(value, adcHandler.touch_userData);
000074  159b1004          LDRNE    r1,[r11,#4]  ; adcHandler
000078  112fff32          BLXNE    r2
;;;786    
;;;787            if ( (lengthX<ADC_FIFO_LENGTH) && (lengthY<ADC_FIFO_LENGTH)) {
00007c  e3590080          CMP      r9,#0x80
000080  b3580080          CMPLT    r8,#0x80
000084  aa000012          BGE      |L3.212|
;;;788                fifoX[tailX] = value & 0xFFF;
000088  e59d0000          LDR      r0,[sp,#0]
;;;789                lengthX++;
;;;790                tailX++;
;;;791                if (tailX == ADC_FIFO_LENGTH) tailX = 0;
00008c  e2899001          ADD      r9,r9,#1
000090  e3c01a0f          BIC      r1,r0,#0xf000         ;788
000094  e59d0008          LDR      r0,[sp,#8]            ;788
;;;792    
;;;793                fifoY[tailY] = (value >>16) & 0xFFF;
;;;794                lengthY++;
;;;795                tailY++;
;;;796                if (tailY == ADC_FIFO_LENGTH) tailY = 0;
000098  e2888001          ADD      r8,r8,#1
00009c  e0800086          ADD      r0,r0,r6,LSL #1       ;788
0000a0  e1c010b0          STRH     r1,[r0,#0]            ;788
0000a4  e59d0000          LDR      r0,[sp,#0]            ;793
0000a8  e3e01a0f          MVN      r1,#0xf000            ;793
0000ac  e0011820          AND      r1,r1,r0,LSR #16      ;793
0000b0  e59d0004          LDR      r0,[sp,#4]            ;793
0000b4  e2866001          ADD      r6,r6,#1              ;788
0000b8  e0800085          ADD      r0,r0,r5,LSL #1       ;793
0000bc  e3560080          CMP      r6,#0x80              ;791
0000c0  03a06000          MOVEQ    r6,#0                 ;791
0000c4  e2855001          ADD      r5,r5,#1              ;793
0000c8  e3550080          CMP      r5,#0x80
0000cc  03a05000          MOVEQ    r5,#0
0000d0  e1c010b0          STRH     r1,[r0,#0]            ;793
                  |L3.212|
;;;797            }
;;;798            /* Update FIFO status */
;;;799            adcHandler.fifoTailX = tailX;
;;;800            adcHandler.fifoLengthX = lengthX;
;;;801            adcHandler.fifoTailY = tailY;
;;;802            adcHandler.fifoLengthY = lengthY;
0000d4  e58b5268          STR      r5,[r11,#0x268]  ; adcHandler, adcHandler, adcHandler, adcHandler
0000d8  e58b826c          STR      r8,[r11,#0x26c]
0000dc  e58b615c          STR      r6,[r11,#0x15c]
0000e0  e58b9160          STR      r9,[r11,#0x160]
                  |L3.228|
;;;803            DbgPrintf("touch detect complete\n");
;;;804        }
;;;805    
;;;806        if((isr & ADC_ISR_KPEF) && (ier & ADC_IER_KPEIEN)) {
0000e4  e3140002          TST      r4,#2
0000e8  131a0002          TSTNE    r10,#2
;;;807            outpw(REG_ADC_ISR,ADC_ISR_KPEF);
0000ec  e3a09002          MOV      r9,#2
0000f0  0a000005          BEQ      |L3.268|
0000f4  e587900c          STR      r9,[r7,#0xc]
;;;808            if(adcHandler.keypad_press_callback!=NULL)
0000f8  e59b2030          LDR      r2,[r11,#0x30]  ; adcHandler
0000fc  e3520000          CMP      r2,#0
;;;809                adcHandler.keypad_press_callback(1, adcHandler.keypad_press_userData);
000100  159b1034          LDRNE    r1,[r11,#0x34]  ; adcHandler
000104  13a00001          MOVNE    r0,#1
000108  112fff32          BLXNE    r2
                  |L3.268|
;;;810            DbgPrintf("key press complete\n");
;;;811        }
;;;812    
;;;813        if((isr & ADC_ISR_ZF) && (conf & ADC_CONF_ZEN)) {
00010c  e3140c02          TST      r4,#0x200
000110  159d0014          LDRNE    r0,[sp,#0x14]
000114  13100002          TSTNE    r0,#2
000118  0a000039          BEQ      |L3.516|
;;;814            unsigned int value;
;;;815            volatile INT32 tailZ1, lengthZ1;
;;;816            volatile INT32 tailZ2, lengthZ2;
;;;817            volatile INT16 *fifoZ1, *fifoZ2;
;;;818            tailZ1   = adcHandler.fifoTailZ1;
00011c  e59b0374          LDR      r0,[r11,#0x374]  ; adcHandler
;;;819            lengthZ1 = adcHandler.fifoLengthZ1;
;;;820            tailZ2   = adcHandler.fifoTailZ2;
;;;821            lengthZ2 = adcHandler.fifoLengthZ2;
;;;822    
;;;823            fifoZ1  = adcHandler.fifoZ1;
000120  e28b8e27          ADD      r8,r11,#0x270
000124  e58d0000          STR      r0,[sp,#0]            ;819
000128  e59b0378          LDR      r0,[r11,#0x378]       ;819  ; adcHandler
;;;824            fifoZ2  = adcHandler.fifoZ2;
00012c  e28b6fdf          ADD      r6,r11,#0x37c
000130  e58d0008          STR      r0,[sp,#8]            ;820
000134  e59b0480          LDR      r0,[r11,#0x480]       ;820  ; adcHandler
000138  e58d0004          STR      r0,[sp,#4]            ;821
00013c  e59b0484          LDR      r0,[r11,#0x484]       ;821  ; adcHandler
000140  e58d0010          STR      r0,[sp,#0x10]
;;;825            outpw(REG_ADC_ISR,ADC_ISR_ZF); //clear TF flags
000144  e3a00c02          MOV      r0,#0x200
000148  e587000c          STR      r0,[r7,#0xc]
;;;826            value = inpw(REG_ADC_ZDATA);
00014c  e5975024          LDR      r5,[r7,#0x24]
;;;827            if(adcHandler.touchz_callback!=NULL)
000150  e59b2008          LDR      r2,[r11,#8]  ; adcHandler
000154  e3520000          CMP      r2,#0
;;;828                adcHandler.touchz_callback(value, adcHandler.touchz_userData);
000158  159b100c          LDRNE    r1,[r11,#0xc]  ; adcHandler
00015c  11a00005          MOVNE    r0,r5
000160  112fff32          BLXNE    r2
;;;829            if ( (lengthZ1<ADC_FIFO_LENGTH) && (lengthZ2<ADC_FIFO_LENGTH)) {
000164  e59d0008          LDR      r0,[sp,#8]
000168  e3500080          CMP      r0,#0x80
00016c  b59d0010          LDRLT    r0,[sp,#0x10]
000170  b3500080          CMPLT    r0,#0x80
000174  aa00001a          BGE      |L3.484|
;;;830                fifoZ1[tailZ1] = value & 0xFFF;
000178  e59d1000          LDR      r1,[sp,#0]
00017c  e3c50a0f          BIC      r0,r5,#0xf000
000180  e0881081          ADD      r1,r8,r1,LSL #1
000184  e1c100b0          STRH     r0,[r1,#0]
;;;831                lengthZ1++;
000188  e59d0008          LDR      r0,[sp,#8]
;;;832                tailZ1++;
;;;833                if (tailZ1 == ADC_FIFO_LENGTH) tailZ1 = 0;
;;;834    
;;;835                fifoZ2[tailZ2] = (value >>16) & 0xFFF;
00018c  e59d2004          LDR      r2,[sp,#4]
000190  e2800001          ADD      r0,r0,#1              ;831
000194  e58d0008          STR      r0,[sp,#8]            ;832
000198  e59d0000          LDR      r0,[sp,#0]            ;832
00019c  e0862082          ADD      r2,r6,r2,LSL #1
0001a0  e2800001          ADD      r0,r0,#1              ;832
0001a4  e1a01000          MOV      r1,r0                 ;833
0001a8  e3510080          CMP      r1,#0x80              ;833
0001ac  e58d0000          STR      r0,[sp,#0]            ;832
0001b0  e3a00000          MOV      r0,#0                 ;833
0001b4  e3e01a0f          MVN      r1,#0xf000
0001b8  e0011825          AND      r1,r1,r5,LSR #16
0001bc  058d0000          STREQ    r0,[sp,#0]            ;833
0001c0  e1c210b0          STRH     r1,[r2,#0]
;;;836                lengthZ2++;
0001c4  e59d1010          LDR      r1,[sp,#0x10]
0001c8  e2811001          ADD      r1,r1,#1
;;;837                tailZ2++;
0001cc  e58d1010          STR      r1,[sp,#0x10]
0001d0  e59d1004          LDR      r1,[sp,#4]
0001d4  e2811001          ADD      r1,r1,#1
;;;838                if (tailZ2 == ADC_FIFO_LENGTH) tailZ2 = 0;
0001d8  e3510080          CMP      r1,#0x80
0001dc  e58d1004          STR      r1,[sp,#4]            ;837
0001e0  058d0004          STREQ    r0,[sp,#4]
                  |L3.484|
;;;839            }
;;;840            /* Update FIFO status */
;;;841            adcHandler.fifoTailZ1 = tailZ1;
0001e4  e59d0000          LDR      r0,[sp,#0]
;;;842            adcHandler.fifoLengthZ1 = lengthZ1;
0001e8  e58b0374          STR      r0,[r11,#0x374]  ; adcHandler
0001ec  e59d0008          LDR      r0,[sp,#8]
;;;843            adcHandler.fifoTailZ2 = tailZ2;
0001f0  e58b0378          STR      r0,[r11,#0x378]  ; adcHandler
0001f4  e59d0004          LDR      r0,[sp,#4]
;;;844            adcHandler.fifoLengthZ2 = lengthZ2;
0001f8  e58b0480          STR      r0,[r11,#0x480]  ; adcHandler
0001fc  e59d0010          LDR      r0,[sp,#0x10]
000200  e58b0484          STR      r0,[r11,#0x484]  ; adcHandler
                  |L3.516|
;;;845            DbgPrintf("z conversion complete\n");
;;;846        }
;;;847    
;;;848        if((isr & ADC_ISR_NACF) && (conf & ADC_CONF_NACEN)) {
000204  e3140b01          TST      r4,#0x400
000208  159d0014          LDRNE    r0,[sp,#0x14]
00020c  13100004          TSTNE    r0,#4
000210  0a000006          BEQ      |L3.560|
;;;849            outpw(REG_ADC_ISR,ADC_ISR_NACF);
000214  e3a00b01          MOV      r0,#0x400
000218  e587000c          STR      r0,[r7,#0xc]
;;;850            if(adcHandler.normal_callback!=NULL)
00021c  e59b2050          LDR      r2,[r11,#0x50]  ; adcHandler
000220  e3520000          CMP      r2,#0
;;;851                adcHandler.normal_callback(inpw(REG_ADC_DATA), adcHandler.normal_userData);
000224  159b1054          LDRNE    r1,[r11,#0x54]  ; adcHandler
000228  15970028          LDRNE    r0,[r7,#0x28]
00022c  112fff32          BLXNE    r2
                  |L3.560|
;;;852            DbgPrintf("normal AD conversion complete\n");
;;;853        }
;;;854    
;;;855    
;;;856    
;;;857        if((isr & ADC_ISR_PEUEF) && (ier & ADC_IER_PEUEIEN)) {
000230  e3140010          TST      r4,#0x10
000234  131a0040          TSTNE    r10,#0x40
;;;858            outpw(REG_ADC_ISR,ADC_ISR_PEUEF | ADC_ISR_PEDEF);
000238  e3a05014          MOV      r5,#0x14
00023c  1a000006          BNE      |L3.604|
;;;859            DbgPrintf("menu pen up complete\n");
;;;860        } else if((isr & ADC_ISR_PEDEF) && (isr & ADC_IER_PEDEIEN)) {
000240  e3140004          TST      r4,#4
000244  0a000005          BEQ      |L3.608|
;;;861            if(adcHandler.pendown_callback!=NULL)
000248  e59b2018          LDR      r2,[r11,#0x18]  ; adcHandler
00024c  e3520000          CMP      r2,#0
;;;862                adcHandler.pendown_callback(isr, adcHandler.pendown_userData);
000250  159b101c          LDRNE    r1,[r11,#0x1c]  ; adcHandler
000254  11a00004          MOVNE    r0,r4
000258  112fff32          BLXNE    r2
                  |L3.604|
;;;863            outpw(REG_ADC_ISR,ADC_ISR_PEUEF | ADC_ISR_PEDEF);
00025c  e587500c          STR      r5,[r7,#0xc]
                  |L3.608|
;;;864            DbgPrintf("pen down complete\n");
;;;865        }
;;;866    
;;;867        if(isr & ADC_ISR_MF) {
000260  e3140001          TST      r4,#1
000264  e3a06001          MOV      r6,#1                 ;809
;;;868            outpw(REG_ADC_ISR,ADC_ISR_MF);
000268  1587600c          STRNE    r6,[r7,#0xc]
;;;869            mst_complete=1;
00026c  159f0080          LDRNE    r0,|L3.756|
000270  15806000          STRNE    r6,[r0,#0]  ; mst_complete
;;;870            DbgPrintf("menu complete\n");
;;;871        }
;;;872    
;;;873        if((wkisr & ADC_WKISR_WKPEF) && (ier & ADC_IER_WKPIEN)) {
000274  e59d000c          LDR      r0,[sp,#0xc]
;;;874            if(adcHandler.keypad_wakeup_callback!=NULL)
;;;875                adcHandler.keypad_wakeup_callback(wkisr, adcHandler.keypad_wakeup_userData);
;;;876            outpw(REG_ADC_WKISR,ADC_WKISR_WKPEF);
;;;877    
;;;878            if(inpw(REG_SYS_WKUPSSR) & (1<<26))
;;;879                outpw(REG_SYS_WKUPSSR,(1<<26));
000278  e3a05301          MOV      r5,#0x4000000
00027c  e3100001          TST      r0,#1                 ;873
000280  131a0010          TSTNE    r10,#0x10             ;873
000284  e3a0420b          MOV      r4,#0xb0000000        ;878
000288  0a000008          BEQ      |L3.688|
00028c  e59b2040          LDR      r2,[r11,#0x40]        ;874  ; adcHandler
000290  e3520000          CMP      r2,#0                 ;874
000294  159b1044          LDRNE    r1,[r11,#0x44]        ;875  ; adcHandler
000298  159d000c          LDRNE    r0,[sp,#0xc]          ;875
00029c  112fff32          BLXNE    r2                    ;875
0002a0  e5876010          STR      r6,[r7,#0x10]         ;876
0002a4  e594005c          LDR      r0,[r4,#0x5c]         ;878
0002a8  e3100301          TST      r0,#0x4000000         ;878
0002ac  1584505c          STRNE    r5,[r4,#0x5c]
                  |L3.688|
;;;880            DbgPrintf("key press event wakeup\n");
;;;881        }
;;;882    
;;;883        if((wkisr & ADC_WKISR_WPEDEF) && (ier & ADC_IER_WKTIEN) ) {
0002b0  e59d000c          LDR      r0,[sp,#0xc]
0002b4  e3100002          TST      r0,#2
0002b8  131a0008          TSTNE    r10,#8
0002bc  0a000008          BEQ      |L3.740|
;;;884            if(adcHandler.touch_wakeup_callback!=NULL)
0002c0  e59b2010          LDR      r2,[r11,#0x10]  ; adcHandler
0002c4  e3520000          CMP      r2,#0
;;;885                adcHandler.touch_wakeup_callback(wkisr, adcHandler.touch_wakeup_userData);
0002c8  159b1014          LDRNE    r1,[r11,#0x14]  ; adcHandler
0002cc  159d000c          LDRNE    r0,[sp,#0xc]
0002d0  112fff32          BLXNE    r2
;;;886            outpw(REG_ADC_WKISR,ADC_WKISR_WPEDEF);
0002d4  e5879010          STR      r9,[r7,#0x10]
;;;887            if(inpw(REG_SYS_WKUPSSR) & (1<<26))
0002d8  e594005c          LDR      r0,[r4,#0x5c]
0002dc  e3100301          TST      r0,#0x4000000
;;;888                outpw(REG_SYS_WKUPSSR,(1<<26));
0002e0  1584505c          STRNE    r5,[r4,#0x5c]
                  |L3.740|
;;;889            DbgPrintf("pen down event wakeup\n");
;;;890        }
;;;891    }
0002e4  e28dd01c          ADD      sp,sp,#0x1c
0002e8  e8bd8ff0          POP      {r4-r11,pc}
;;;892    
                          ENDP

                  |L3.748|
                          DCD      0xb800a000
                  |L3.752|
                          DCD      ||.bss||
                  |L3.756|
                          DCD      ||.data||

                          AREA ||i.adcIoctl||, CODE, READONLY, ALIGN=2

                  adcIoctl PROC
;;;384     */
;;;385    INT adcIoctl(ADC_CMD cmd, INT32 arg1, INT32 arg2)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;386    {
;;;387        UINT32 reg;
;;;388        switch(cmd) {
;;;389            case START_MST: {           //Menu Start Conversion
;;;390                mst_complete=0;
;;;391                reg = inpw(REG_ADC_IER);
000004  e59f344c          LDR      r3,|L4.1112|
;;;392                reg = reg | ADC_IER_MIEN;
;;;393                outpw(REG_ADC_IER, reg);
;;;394                reg = inpw(REG_ADC_CTL);
;;;395                reg = reg | ADC_CTL_MST;
;;;396                outpw(REG_ADC_CTL, reg);
;;;397                while(!mst_complete);
;;;398            }
;;;399            break;
;;;400           case START_MST_POLLING:             //Menu Start Conversion
;;;401           {
;;;402              reg = inpw(REG_ADC_IER);
;;;403              reg = reg & ~ADC_IER_MIEN;
;;;404              outpw(REG_ADC_IER, reg);
;;;405              reg = inpw(REG_ADC_CTL);
;;;406              reg = reg | ADC_CTL_MST;
;;;407              outpw(REG_ADC_CTL, reg);
;;;408              while((inpw(REG_ADC_ISR)&ADC_ISR_MF)==0);
;;;409              adcISR();
;;;410           }
;;;411           break;
;;;412            case VBPOWER_ON: {         //Enable ADC Internal Bandgap Power
;;;413                reg = inpw(REG_ADC_CTL);
;;;414                reg = reg | ADC_CTL_VBGEN;
;;;415                outpw(REG_ADC_CTL, reg);
;;;416            }
;;;417            break;
;;;418            case VBPOWER_OFF: {        //Disable ADC Internal Bandgap Power
;;;419                reg = inpw(REG_ADC_CTL);
;;;420                reg = reg & ~ADC_CTL_VBGEN;
;;;421                outpw(REG_ADC_CTL, reg);
;;;422            }
;;;423            break;
;;;424            case KPPOWER_ON: {        //Enable ADC Keypad Power
;;;425                reg = inpw(REG_ADC_CTL);
;;;426                reg = reg | ADC_CTL_PWKPEN;
;;;427                outpw(REG_ADC_CTL, reg);
;;;428            }
;;;429            break;
;;;430            case KPPOWER_OFF: {       //Disable ADC Keypad Power
;;;431                reg = inpw(REG_ADC_CTL);
;;;432                reg = reg & ~ADC_CTL_PWKPEN;
;;;433                outpw(REG_ADC_CTL, reg);
;;;434            }
;;;435            break;
;;;436            case PEPOWER_ON: {        //Enable Pen Power
;;;437                UINT32 treg;
;;;438                treg = inpw(REG_ADC_IER);
;;;439                outpw(REG_ADC_IER, treg & ~(ADC_IER_PEDEIEN | ADC_IER_PEUEIEN));
;;;440    
;;;441                reg = inpw(REG_ADC_CTL);
;;;442                reg = reg | ADC_CTL_PEDEEN;
;;;443                outpw(REG_ADC_CTL, reg);
;;;444    
;;;445                do {
;;;446                    reg = (ADC_ISR_PEDEF | ADC_ISR_PEUEF);
;;;447                    outpw(REG_ADC_ISR, reg);
;;;448                } while(inpw(REG_ADC_ISR)&(ADC_ISR_PEDEF | ADC_ISR_PEUEF));
;;;449    
;;;450                outpw(REG_ADC_IER,treg);
;;;451            }
;;;452            break;
;;;453            case PEPOWER_OFF: {       //Disable Pen Power
;;;454                reg = inpw(REG_ADC_CTL);
;;;455                reg = reg & ~ADC_CTL_PEDEEN;
;;;456                outpw(REG_ADC_CTL, reg);
;;;457            }
;;;458            break;
;;;459            case KPPRESS_ON: {       //Enable Keypad press event
;;;460                ADC_CALLBACK keypad_press_callback;
;;;461                reg = inpw(REG_ADC_IER);
;;;462                reg = reg | ADC_IER_KPEIEN;
;;;463                outpw(REG_ADC_IER, reg);
;;;464                keypad_press_callback = (ADC_CALLBACK) arg1;
;;;465                if (keypad_press_callback != NULL ) {
;;;466                    adcHandler.keypad_press_callback = keypad_press_callback;
000008  e59fc44c          LDR      r12,|L4.1116|
00000c  e3500022          CMP      r0,#0x22              ;388
000010  e3a04000          MOV      r4,#0                 ;386
;;;467                    adcHandler.keypad_press_userData = (UINT32)arg2;
;;;468                }
;;;469            }
;;;470            break;
;;;471            case KPPRESS_OFF: {      //Disable Keypad press event
;;;472                reg = inpw(REG_ADC_IER);
;;;473                reg = reg & ~ADC_IER_KPEIEN;
;;;474                outpw(REG_ADC_IER, reg);
;;;475                adcHandler.keypad_press_callback = NULL;
;;;476                adcHandler.keypad_press_userData = NULL;
;;;477            }
;;;478            break;
;;;479            case KPUP_ON: {         //Enable Keypad up event
;;;480                ADC_CALLBACK keypad_up_callback;
;;;481                reg = inpw(REG_ADC_IER);
;;;482                reg = reg | ADC_IER_KPUEIEN;
;;;483                outpw(REG_ADC_IER, reg);
;;;484                keypad_up_callback = (ADC_CALLBACK) arg1;
;;;485                if (keypad_up_callback != NULL ) {
;;;486                    adcHandler.keypad_up_callback = keypad_up_callback;
;;;487                    adcHandler.keypad_up_userData = (UINT32)arg2;
;;;488                }
;;;489            }
;;;490            break;
;;;491            case KPUP_OFF: {       //Disable Keypad up event
;;;492                reg = inpw(REG_ADC_IER);
;;;493                reg = reg & ~ADC_IER_KPUEIEN;
;;;494                outpw(REG_ADC_IER, reg);
;;;495                adcHandler.keypad_up_callback = NULL;
;;;496                adcHandler.keypad_up_userData = NULL;
;;;497            }
;;;498            break;
;;;499            case PEDEF_ON: {        //Enable Pen Down Event
;;;500                ADC_CALLBACK pendown_callback;
;;;501                reg = inpw(REG_ADC_IER);
;;;502                reg = reg | ADC_IER_PEDEIEN;
;;;503                outpw(REG_ADC_IER, reg);
;;;504                pendown_callback = (ADC_CALLBACK) arg1;
;;;505                if (pendown_callback != NULL ) {
;;;506                    adcHandler.pendown_callback = pendown_callback;
;;;507                    adcHandler.pendown_userData = (UINT32)arg2;
;;;508                }
;;;509            }
;;;510            break;
;;;511            case PEDEF_OFF: {       //Disable Pen Down Event
;;;512                reg = inpw(REG_ADC_IER);
;;;513                reg = reg & ~ADC_IER_PEDEIEN;
;;;514                outpw(REG_ADC_IER, reg);
;;;515                adcHandler.pendown_callback = NULL;
;;;516                adcHandler.pendown_userData = NULL;
;;;517            }
;;;518            break;
;;;519            case WKP_ON: {         //Enable Keypad Press Wake Up
;;;520                ADC_CALLBACK keypad_wakeup_callback;
;;;521                reg = inpw(REG_ADC_CTL);
;;;522                reg = reg | ADC_CTL_WKPEN;
;;;523                outpw(REG_ADC_CTL, reg);
;;;524                reg = inpw(REG_ADC_IER);
;;;525                reg = reg | ADC_IER_WKPIEN;
;;;526                outpw(REG_ADC_IER, reg);
;;;527                reg=inpw(REG_SYS_WKUPSER);
000014  e3a0520b          MOV      r5,#0xb0000000
000018  308ff100          ADDCC    pc,pc,r0,LSL #2       ;388
00001c  ea00010b          B        |L4.1104|
000020  ea000020          B        |L4.168|
000024  ea00002b          B        |L4.216|
000028  ea000035          B        |L4.260|
00002c  ea000037          B        |L4.272|
000030  ea0000e8          B        |L4.984|
000034  ea0000ee          B        |L4.1012|
000038  ea000038          B        |L4.288|
00003c  ea00003a          B        |L4.300|
000040  ea0000f1          B        |L4.1036|
000044  ea0000fa          B        |L4.1076|
000048  ea00004a          B        |L4.376|
00004c  ea000050          B        |L4.404|
000050  ea000055          B        |L4.428|
000054  ea00005b          B        |L4.456|
000058  ea000036          B        |L4.312|
00005c  ea000042          B        |L4.364|
000060  ea00005e          B        |L4.480|
000064  ea000064          B        |L4.508|
000068  ea000069          B        |L4.532|
00006c  ea000075          B        |L4.584|
000070  ea000080          B        |L4.632|
000074  ea00008c          B        |L4.684|
000078  ea000094          B        |L4.720|
00007c  ea000096          B        |L4.732|
000080  ea000098          B        |L4.744|
000084  ea0000a3          B        |L4.792|
000088  ea0000a8          B        |L4.816|
00008c  ea0000aa          B        |L4.828|
000090  ea0000ad          B        |L4.844|
000094  ea0000b9          B        |L4.896|
000098  ea0000bb          B        |L4.908|
00009c  ea0000bd          B        |L4.920|
0000a0  ea0000bf          B        |L4.932|
0000a4  ea0000c5          B        |L4.960|
                  |L4.168|
0000a8  e59f03b0          LDR      r0,|L4.1120|
0000ac  e5804000          STR      r4,[r0,#0]            ;390  ; mst_complete
0000b0  e5931008          LDR      r1,[r3,#8]            ;391
0000b4  e3811001          ORR      r1,r1,#1              ;392
0000b8  e5831008          STR      r1,[r3,#8]            ;393
0000bc  e5931000          LDR      r1,[r3,#0]            ;394
0000c0  e3811c01          ORR      r1,r1,#0x100          ;395
0000c4  e5831000          STR      r1,[r3,#0]            ;396
                  |L4.200|
0000c8  e5901000          LDR      r1,[r0,#0]            ;397  ; mst_complete
0000cc  e3510000          CMP      r1,#0                 ;397
0000d0  0afffffc          BEQ      |L4.200|
0000d4  ea0000db          B        |L4.1096|
                  |L4.216|
0000d8  e5930008          LDR      r0,[r3,#8]            ;402
0000dc  e3c00001          BIC      r0,r0,#1              ;403
0000e0  e5830008          STR      r0,[r3,#8]            ;404
0000e4  e5930000          LDR      r0,[r3,#0]            ;405
0000e8  e3800c01          ORR      r0,r0,#0x100          ;406
0000ec  e5830000          STR      r0,[r3,#0]            ;407
                  |L4.240|
0000f0  e593000c          LDR      r0,[r3,#0xc]          ;408
0000f4  e3100001          TST      r0,#1                 ;408
0000f8  0afffffc          BEQ      |L4.240|
0000fc  ebfffffe          BL       adcISR
000100  ea0000d0          B        |L4.1096|
                  |L4.260|
000104  e5930000          LDR      r0,[r3,#0]            ;413
000108  e3800002          ORR      r0,r0,#2              ;414
00010c  ea000001          B        |L4.280|
                  |L4.272|
000110  e5930000          LDR      r0,[r3,#0]            ;419
000114  e3c00002          BIC      r0,r0,#2              ;420
                  |L4.280|
000118  e5830000          STR      r0,[r3,#0]            ;415
00011c  ea0000c9          B        |L4.1096|
                  |L4.288|
000120  e5930000          LDR      r0,[r3,#0]            ;425
000124  e3800004          ORR      r0,r0,#4              ;426
000128  eafffffa          B        |L4.280|
                  |L4.300|
00012c  e5930000          LDR      r0,[r3,#0]            ;431
000130  e3c00004          BIC      r0,r0,#4              ;432
000134  eafffff7          B        |L4.280|
                  |L4.312|
000138  e5931008          LDR      r1,[r3,#8]            ;438
00013c  e3c10044          BIC      r0,r1,#0x44           ;439
000140  e5830008          STR      r0,[r3,#8]            ;439
000144  e5930000          LDR      r0,[r3,#0]            ;441
000148  e3800c02          ORR      r0,r0,#0x200          ;442
00014c  e5830000          STR      r0,[r3,#0]            ;443
                  |L4.336|
000150  e3a00014          MOV      r0,#0x14              ;446
000154  e583000c          STR      r0,[r3,#0xc]          ;447
000158  e593000c          LDR      r0,[r3,#0xc]          ;448
00015c  e3100014          TST      r0,#0x14              ;448
000160  05831008          STREQ    r1,[r3,#8]            ;450
000164  1afffff9          BNE      |L4.336|
000168  ea0000b6          B        |L4.1096|
                  |L4.364|
00016c  e5930000          LDR      r0,[r3,#0]            ;454
000170  e3c00c02          BIC      r0,r0,#0x200          ;455
000174  eaffffe7          B        |L4.280|
                  |L4.376|
000178  e5930008          LDR      r0,[r3,#8]            ;461
00017c  e3800002          ORR      r0,r0,#2              ;462
000180  e5830008          STR      r0,[r3,#8]            ;463
000184  e3510000          CMP      r1,#0                 ;465
000188  158c1030          STRNE    r1,[r12,#0x30]        ;466  ; adcHandler
00018c  158c2034          STRNE    r2,[r12,#0x34]        ;467  ; adcHandler
000190  ea0000ac          B        |L4.1096|
                  |L4.404|
000194  e5930008          LDR      r0,[r3,#8]            ;472
000198  e3c00002          BIC      r0,r0,#2              ;473
00019c  e5830008          STR      r0,[r3,#8]            ;474
0001a0  e58c4030          STR      r4,[r12,#0x30]        ;476  ; adcHandler
0001a4  e58c4034          STR      r4,[r12,#0x34]        ;476  ; adcHandler
0001a8  ea0000a6          B        |L4.1096|
                  |L4.428|
0001ac  e5930008          LDR      r0,[r3,#8]            ;481
0001b0  e3800020          ORR      r0,r0,#0x20           ;482
0001b4  e5830008          STR      r0,[r3,#8]            ;483
0001b8  e3510000          CMP      r1,#0                 ;485
0001bc  158c1038          STRNE    r1,[r12,#0x38]        ;486  ; adcHandler
0001c0  158c203c          STRNE    r2,[r12,#0x3c]        ;487  ; adcHandler
0001c4  ea00009f          B        |L4.1096|
                  |L4.456|
0001c8  e5930008          LDR      r0,[r3,#8]            ;492
0001cc  e3c00020          BIC      r0,r0,#0x20           ;493
0001d0  e5830008          STR      r0,[r3,#8]            ;494
0001d4  e58c4038          STR      r4,[r12,#0x38]        ;496  ; adcHandler
0001d8  e58c403c          STR      r4,[r12,#0x3c]        ;496  ; adcHandler
0001dc  ea000099          B        |L4.1096|
                  |L4.480|
0001e0  e5930008          LDR      r0,[r3,#8]            ;501
0001e4  e3800004          ORR      r0,r0,#4              ;502
0001e8  e5830008          STR      r0,[r3,#8]            ;503
0001ec  e3510000          CMP      r1,#0                 ;505
0001f0  158c1018          STRNE    r1,[r12,#0x18]        ;506  ; adcHandler
0001f4  158c201c          STRNE    r2,[r12,#0x1c]        ;507  ; adcHandler
0001f8  ea000092          B        |L4.1096|
                  |L4.508|
0001fc  e5930008          LDR      r0,[r3,#8]            ;512
000200  e3c00004          BIC      r0,r0,#4              ;513
000204  e5830008          STR      r0,[r3,#8]            ;514
000208  e58c4018          STR      r4,[r12,#0x18]        ;516  ; adcHandler
00020c  e58c401c          STR      r4,[r12,#0x1c]        ;516  ; adcHandler
000210  ea00008c          B        |L4.1096|
                  |L4.532|
000214  e5930000          LDR      r0,[r3,#0]            ;521
000218  e3800b01          ORR      r0,r0,#0x400          ;522
00021c  e5830000          STR      r0,[r3,#0]            ;523
000220  e5930008          LDR      r0,[r3,#8]            ;524
000224  e3800010          ORR      r0,r0,#0x10           ;525
000228  e5830008          STR      r0,[r3,#8]            ;526
00022c  e5950058          LDR      r0,[r5,#0x58]
;;;528                reg = reg | (1<<26); //Enable ADC Wake System Up.
000230  e3800301          ORR      r0,r0,#0x4000000
;;;529                outpw(REG_SYS_WKUPSER,reg);
000234  e5850058          STR      r0,[r5,#0x58]
;;;530                keypad_wakeup_callback = (ADC_CALLBACK) arg1;
;;;531                if (keypad_wakeup_callback != NULL ) {
000238  e3510000          CMP      r1,#0
;;;532                    adcHandler.keypad_wakeup_callback = keypad_wakeup_callback;
00023c  158c1040          STRNE    r1,[r12,#0x40]  ; adcHandler
;;;533                    adcHandler.keypad_wakeup_userData = (UINT32)arg2;
000240  158c2044          STRNE    r2,[r12,#0x44]  ; adcHandler
000244  ea00007f          B        |L4.1096|
                  |L4.584|
;;;534                }
;;;535            }
;;;536            break;
;;;537            case WKP_OFF: {        //Disable Keypad Press Wake Up
;;;538                reg = inpw(REG_ADC_CTL);
000248  e5930000          LDR      r0,[r3,#0]
;;;539                reg = reg & ~ADC_CTL_WKPEN;
00024c  e3c00b01          BIC      r0,r0,#0x400
;;;540                outpw(REG_ADC_CTL, reg);
000250  e5830000          STR      r0,[r3,#0]
;;;541                reg = inpw(REG_ADC_IER);
000254  e5930008          LDR      r0,[r3,#8]
;;;542                reg = reg & ~ADC_IER_WKPIEN;
000258  e3c00010          BIC      r0,r0,#0x10
;;;543                outpw(REG_ADC_IER, reg);
00025c  e5830008          STR      r0,[r3,#8]
;;;544                reg=inpw(REG_SYS_WKUPSER);
000260  e5950058          LDR      r0,[r5,#0x58]
;;;545                reg = reg & ~(1<<26); //Enable ADC Wake System Up.
000264  e3c00301          BIC      r0,r0,#0x4000000
;;;546                outpw(REG_SYS_WKUPSER,reg);
000268  e5850058          STR      r0,[r5,#0x58]
;;;547                adcHandler.keypad_wakeup_callback = NULL;
;;;548                adcHandler.keypad_wakeup_userData = NULL;
00026c  e58c4040          STR      r4,[r12,#0x40]  ; adcHandler
000270  e58c4044          STR      r4,[r12,#0x44]  ; adcHandler
;;;549            }
;;;550            break;
000274  ea000073          B        |L4.1096|
                  |L4.632|
;;;551            case WKT_ON: {         //Enable Touch Wake Up
;;;552                ADC_CALLBACK touch_wakeup_callback;
;;;553                reg = inpw(REG_ADC_CTL);
000278  e5930000          LDR      r0,[r3,#0]
;;;554                reg = reg | ADC_CTL_WKTEN;
00027c  e3800b02          ORR      r0,r0,#0x800
;;;555                outpw(REG_ADC_CTL, reg);
000280  e5830000          STR      r0,[r3,#0]
;;;556                reg = inpw(REG_ADC_IER);
000284  e5930008          LDR      r0,[r3,#8]
;;;557                reg = reg | ADC_IER_WKTIEN;
000288  e3800008          ORR      r0,r0,#8
;;;558                outpw(REG_ADC_IER, reg);
00028c  e5830008          STR      r0,[r3,#8]
;;;559                reg=inpw(REG_SYS_WKUPSER);
000290  e5950058          LDR      r0,[r5,#0x58]
;;;560                reg = reg | (1<<26); //Enable ADC Wake System Up.
000294  e3800301          ORR      r0,r0,#0x4000000
;;;561                outpw(REG_SYS_WKUPSER,reg);
000298  e5850058          STR      r0,[r5,#0x58]
;;;562                touch_wakeup_callback = (ADC_CALLBACK) arg1;
;;;563                if (touch_wakeup_callback != NULL ) {
00029c  e3510000          CMP      r1,#0
;;;564                    adcHandler.touch_wakeup_callback = touch_wakeup_callback;
0002a0  158c1010          STRNE    r1,[r12,#0x10]  ; adcHandler
;;;565                    adcHandler.touch_wakeup_userData = (UINT32)arg2;
0002a4  158c2014          STRNE    r2,[r12,#0x14]  ; adcHandler
0002a8  ea000066          B        |L4.1096|
                  |L4.684|
;;;566                }
;;;567            }
;;;568            break;
;;;569            case WKT_OFF: {        //Disable Touch Wake Up
;;;570                reg = inpw(REG_ADC_CTL);
0002ac  e5930000          LDR      r0,[r3,#0]
;;;571                reg = reg & ~ADC_CTL_WKTEN;
0002b0  e3c00b02          BIC      r0,r0,#0x800
;;;572                outpw(REG_ADC_CTL, reg);
0002b4  e5830000          STR      r0,[r3,#0]
;;;573                reg = inpw(REG_ADC_IER);
0002b8  e5930008          LDR      r0,[r3,#8]
;;;574                reg = reg & ~ADC_IER_WKTIEN;
0002bc  e3c00008          BIC      r0,r0,#8
;;;575                outpw(REG_ADC_IER, reg);
0002c0  e5830008          STR      r0,[r3,#8]
;;;576                adcHandler.touch_wakeup_callback = NULL;
;;;577                adcHandler.touch_wakeup_userData = NULL;
0002c4  e58c4010          STR      r4,[r12,#0x10]  ; adcHandler
0002c8  e58c4014          STR      r4,[r12,#0x14]  ; adcHandler
;;;578            }
;;;579            break;
0002cc  ea00005d          B        |L4.1096|
                  |L4.720|
;;;580            case SWITCH_5WIRE_ON: { //Wire Mode Switch to 5-Wire
;;;581                reg = inpw(REG_ADC_CTL);
0002d0  e5930000          LDR      r0,[r3,#0]
;;;582                reg = reg | ADC_CTL_WMSWCH;
0002d4  e3800801          ORR      r0,r0,#0x10000
;;;583                outpw(REG_ADC_CTL, reg);
;;;584            }
;;;585            break;
0002d8  eaffff8e          B        |L4.280|
                  |L4.732|
;;;586            case SWITCH_5WIRE_OFF: { //Wire Mode Switch to 4-Wire
;;;587                reg = inpw(REG_ADC_CTL);
0002dc  e5930000          LDR      r0,[r3,#0]
;;;588                reg = reg & ~ADC_CTL_WMSWCH;
0002e0  e3c00801          BIC      r0,r0,#0x10000
;;;589                outpw(REG_ADC_CTL, reg);
;;;590            }
;;;591            break;
0002e4  eaffff8b          B        |L4.280|
                  |L4.744|
;;;592    
;;;593            case T_ON: { //Enable Touch detection function
;;;594                ADC_CALLBACK touch_callback;
;;;595                reg = inpw(REG_ADC_CONF);
0002e8  e5930004          LDR      r0,[r3,#4]
;;;596                reg = reg | ADC_CONF_TEN;
0002ec  e3800001          ORR      r0,r0,#1
;;;597                outpw(REG_ADC_CONF, reg);
0002f0  e5830004          STR      r0,[r3,#4]
;;;598                touch_callback = (ADC_CALLBACK) arg1;
;;;599                if (touch_callback != NULL ) {
0002f4  e3510000          CMP      r1,#0
0002f8  188c0006          STMNE    r12,{r1,r2}
;;;600                    adcHandler.touch_callback = touch_callback;
;;;601                    adcHandler.touch_userData = (UINT32)arg2;
;;;602                }
;;;603                /* Flush the FIFO */
;;;604                adcHandler.fifoHeadX = 0;
;;;605                adcHandler.fifoTailX = 0;
0002fc  e58c4158          STR      r4,[r12,#0x158]  ; adcHandler
;;;606                adcHandler.fifoLengthX = 0;
000300  e58c415c          STR      r4,[r12,#0x15c]  ; adcHandler
;;;607                adcHandler.fifoHeadY = 0;
000304  e58c4160          STR      r4,[r12,#0x160]  ; adcHandler
;;;608                adcHandler.fifoTailY = 0;
000308  e58c4264          STR      r4,[r12,#0x264]  ; adcHandler
;;;609                adcHandler.fifoLengthY = 0;
00030c  e58c4268          STR      r4,[r12,#0x268]  ; adcHandler
000310  e58c426c          STR      r4,[r12,#0x26c]  ; adcHandler
000314  ea00004b          B        |L4.1096|
                  |L4.792|
;;;610            }
;;;611            break;
;;;612            case T_OFF: { //Disable Touch detection function
;;;613                reg = inpw(REG_ADC_CONF);
000318  e5930004          LDR      r0,[r3,#4]
;;;614                reg = reg & ~ADC_CONF_TEN;
00031c  e3c00001          BIC      r0,r0,#1
;;;615                outpw(REG_ADC_CONF, reg);
000320  e5830004          STR      r0,[r3,#4]
;;;616                adcHandler.touch_callback = NULL;
;;;617                adcHandler.touch_userData = NULL;
000324  e58c4000          STR      r4,[r12,#0]  ; adcHandler
000328  e58c4004          STR      r4,[r12,#4]  ; adcHandler
;;;618            }
;;;619            break;
00032c  ea000045          B        |L4.1096|
                  |L4.816|
;;;620            case TAVG_ON: { //Enable Touch Mean average for X and Y function
;;;621                reg = inpw(REG_ADC_CONF);
000330  e5930004          LDR      r0,[r3,#4]
;;;622                reg = reg | ADC_CONF_DISTMAVEN;
000334  e3800601          ORR      r0,r0,#0x100000
;;;623                outpw(REG_ADC_CONF, reg);
;;;624            }
;;;625            break;
000338  ea000001          B        |L4.836|
                  |L4.828|
;;;626            case TAVG_OFF: { //Disable Touch Mean average for X and Y function
;;;627                reg = inpw(REG_ADC_CONF);
00033c  e5930004          LDR      r0,[r3,#4]
;;;628                reg = reg & ~ADC_CONF_DISTMAVEN;
000340  e3c00601          BIC      r0,r0,#0x100000
                  |L4.836|
000344  e5830004          STR      r0,[r3,#4]            ;623
000348  ea00003e          B        |L4.1096|
                  |L4.844|
;;;629                outpw(REG_ADC_CONF, reg);
;;;630            }
;;;631            break;
;;;632            case Z_ON: { //Enable Press measure function
;;;633                ADC_CALLBACK touchz_callback;
;;;634                reg = inpw(REG_ADC_CONF);
00034c  e5930004          LDR      r0,[r3,#4]
;;;635                reg = reg | ADC_CONF_ZEN;
000350  e3800002          ORR      r0,r0,#2
;;;636                outpw(REG_ADC_CONF, reg);
000354  e5830004          STR      r0,[r3,#4]
;;;637                touchz_callback = (ADC_CALLBACK) arg1;
;;;638                if (touchz_callback != NULL ) {
000358  e3510000          CMP      r1,#0
;;;639                    adcHandler.touchz_callback = touchz_callback;
00035c  158c1008          STRNE    r1,[r12,#8]  ; adcHandler
;;;640                    adcHandler.touchz_userData = (UINT32)arg2;
000360  158c200c          STRNE    r2,[r12,#0xc]  ; adcHandler
;;;641                }
;;;642                /* Flush the FIFO */
;;;643                adcHandler.fifoHeadZ1 = 0;
;;;644                adcHandler.fifoTailZ1 = 0;
000364  e58c4370          STR      r4,[r12,#0x370]  ; adcHandler
;;;645                adcHandler.fifoLengthZ1 = 0;
000368  e58c4374          STR      r4,[r12,#0x374]  ; adcHandler
;;;646                adcHandler.fifoHeadZ2 = 0;
00036c  e58c4378          STR      r4,[r12,#0x378]  ; adcHandler
;;;647                adcHandler.fifoTailZ2 = 0;
000370  e58c447c          STR      r4,[r12,#0x47c]  ; adcHandler
;;;648                adcHandler.fifoLengthZ2 = 0;
000374  e58c4480          STR      r4,[r12,#0x480]  ; adcHandler
000378  e58c4484          STR      r4,[r12,#0x484]  ; adcHandler
00037c  ea000031          B        |L4.1096|
                  |L4.896|
;;;649            }
;;;650            break;
;;;651            case Z_OFF: { //Disable Press measure function
;;;652                reg = inpw(REG_ADC_CONF);
000380  e5930004          LDR      r0,[r3,#4]
;;;653                reg = reg & ~ADC_CONF_ZEN;
000384  e3c00002          BIC      r0,r0,#2
;;;654                outpw(REG_ADC_CONF, reg);
;;;655            }
;;;656            break;
000388  eaffffed          B        |L4.836|
                  |L4.908|
;;;657            case TZAVG_ON: { //Enable Pressure Mean average for Z1 and Z2 function
;;;658                reg = inpw(REG_ADC_CONF);
00038c  e5930004          LDR      r0,[r3,#4]
;;;659                reg = reg | ADC_CONF_DISZMAVEN;
000390  e3800602          ORR      r0,r0,#0x200000
;;;660                outpw(REG_ADC_CONF, reg);
;;;661            }
;;;662            break;
000394  eaffffea          B        |L4.836|
                  |L4.920|
;;;663            case TZAVG_OFF: { //Disable Pressure Mean average for Z1 and Z2 function
;;;664                reg = inpw(REG_ADC_CONF);
000398  e5930004          LDR      r0,[r3,#4]
;;;665                reg = reg & ~ADC_CONF_DISZMAVEN;
00039c  e3c00602          BIC      r0,r0,#0x200000
;;;666                outpw(REG_ADC_CONF, reg);
;;;667            }
;;;668            break;
0003a0  eaffffe7          B        |L4.836|
                  |L4.932|
;;;669            case NAC_ON: { //Enable Normal AD Conversion
;;;670                ADC_CALLBACK normal_callback;
;;;671                reg = inpw(REG_ADC_CONF);
0003a4  e5930004          LDR      r0,[r3,#4]
;;;672                reg = reg | ADC_CONF_NACEN | ADC_CONF_REFSEL_AVDD33;
0003a8  e38000c4          ORR      r0,r0,#0xc4
;;;673                outpw(REG_ADC_CONF, reg);
0003ac  e5830004          STR      r0,[r3,#4]
;;;674                normal_callback = (ADC_CALLBACK) arg1;
;;;675                if (normal_callback != NULL ) {
0003b0  e3510000          CMP      r1,#0
;;;676                    adcHandler.normal_callback = normal_callback;
0003b4  158c1050          STRNE    r1,[r12,#0x50]  ; adcHandler
;;;677                    adcHandler.normal_userData = (UINT32)arg2;
0003b8  158c2054          STRNE    r2,[r12,#0x54]  ; adcHandler
0003bc  ea000021          B        |L4.1096|
                  |L4.960|
;;;678                }
;;;679            }
;;;680            break;
;;;681            case NAC_OFF: { //Disable Normal AD Conversion
;;;682                reg = inpw(REG_ADC_CONF);
0003c0  e5930004          LDR      r0,[r3,#4]
;;;683                reg = reg & ~ADC_CONF_NACEN;
0003c4  e3c00004          BIC      r0,r0,#4
;;;684                outpw(REG_ADC_CONF, reg);
0003c8  e5830004          STR      r0,[r3,#4]
;;;685                adcHandler.normal_callback = NULL;
;;;686                adcHandler.normal_userData = NULL;
0003cc  e58c4050          STR      r4,[r12,#0x50]  ; adcHandler
0003d0  e58c4054          STR      r4,[r12,#0x54]  ; adcHandler
;;;687            }
;;;688            break;
0003d4  ea00001b          B        |L4.1096|
                  |L4.984|
;;;689            case VBAT_ON: { //Enable Voltage Battery Conversion
;;;690                ADC_CALLBACK voltage_battery_callback;
;;;691                reg = inpw(REG_ADC_CONF);
0003d8  e5930004          LDR      r0,[r3,#4]
;;;692                reg = reg | ADC_CONF_VBATEN;
0003dc  e3800c01          ORR      r0,r0,#0x100
;;;693                outpw(REG_ADC_CONF, reg);
0003e0  e5830004          STR      r0,[r3,#4]
;;;694                voltage_battery_callback = (ADC_CALLBACK) arg1;
;;;695                if (voltage_battery_callback != NULL ) {
0003e4  e3510000          CMP      r1,#0
;;;696                    adcHandler.voltage_battery_callback = voltage_battery_callback;
0003e8  158c1048          STRNE    r1,[r12,#0x48]  ; adcHandler
;;;697                    adcHandler.voltage_battery_userData = (UINT32)arg2;
0003ec  158c204c          STRNE    r2,[r12,#0x4c]  ; adcHandler
0003f0  ea000014          B        |L4.1096|
                  |L4.1012|
;;;698                }
;;;699            }
;;;700            break;
;;;701            case VBAT_OFF: { //Disable Voltage Battery
;;;702                reg = inpw(REG_ADC_CONF);
0003f4  e5930004          LDR      r0,[r3,#4]
;;;703                reg = reg & ~ADC_CONF_VBATEN;
0003f8  e3c00c01          BIC      r0,r0,#0x100
;;;704                outpw(REG_ADC_CONF, reg);
0003fc  e5830004          STR      r0,[r3,#4]
;;;705                adcHandler.voltage_battery_callback = NULL;
;;;706                adcHandler.voltage_battery_userData = NULL;
000400  e58c4048          STR      r4,[r12,#0x48]  ; adcHandler
000404  e58c404c          STR      r4,[r12,#0x4c]  ; adcHandler
;;;707            }
;;;708            break;
000408  ea00000e          B        |L4.1096|
                  |L4.1036|
;;;709            case KPCONV_ON: { //Enable Keypad conversion function
;;;710                ADC_CALLBACK keypad_conv_callback;
;;;711                reg = inpw(REG_ADC_CONF);
00040c  e5930004          LDR      r0,[r3,#4]
;;;712                reg = reg | ADC_CONF_KPCEN;
000410  e3800c02          ORR      r0,r0,#0x200
;;;713                outpw(REG_ADC_CONF, reg);
000414  e5830004          STR      r0,[r3,#4]
;;;714    
;;;715                reg = inpw(REG_ADC_IER);
000418  e5930008          LDR      r0,[r3,#8]
;;;716                reg = reg | ADC_IER_KPEIEN;
00041c  e3800002          ORR      r0,r0,#2
;;;717                outpw(REG_ADC_IER, reg);
000420  e5830008          STR      r0,[r3,#8]
;;;718    
;;;719                keypad_conv_callback = (ADC_CALLBACK) arg1;
;;;720                if (keypad_conv_callback != NULL ) {
000424  e3510000          CMP      r1,#0
;;;721                    adcHandler.keypad_conv_callback = keypad_conv_callback;
000428  158c1028          STRNE    r1,[r12,#0x28]  ; adcHandler
;;;722                    adcHandler.keypad_conv_userData = (UINT32)arg2;
00042c  158c202c          STRNE    r2,[r12,#0x2c]  ; adcHandler
000430  ea000004          B        |L4.1096|
                  |L4.1076|
;;;723                }
;;;724            }
;;;725            break;
;;;726            case KPCONV_OFF: { //Disable Keypad conversion function
;;;727                reg = inpw(REG_ADC_CONF);
000434  e5930004          LDR      r0,[r3,#4]
;;;728                reg = reg & ~ADC_CONF_KPCEN;
000438  e3c00c02          BIC      r0,r0,#0x200
;;;729                outpw(REG_ADC_CONF, reg);
00043c  e5830004          STR      r0,[r3,#4]
;;;730                adcHandler.keypad_conv_callback = NULL;
;;;731                adcHandler.keypad_conv_userData = NULL;
000440  e58c4028          STR      r4,[r12,#0x28]  ; adcHandler
000444  e58c402c          STR      r4,[r12,#0x2c]  ; adcHandler
                  |L4.1096|
;;;732            }
;;;733            break;
;;;734            default:
;;;735                return ADC_ERR_CMD;
;;;736        }
;;;737        return Successful;
000448  e3a00000          MOV      r0,#0
;;;738    }
00044c  e8bd8070          POP      {r4-r6,pc}
                  |L4.1104|
000450  e3a00002          MOV      r0,#2                 ;735
000454  e8bd8070          POP      {r4-r6,pc}
;;;739    
                          ENDP

                  |L4.1112|
                          DCD      0xb800a000
                  |L4.1116|
                          DCD      ||.bss||
                  |L4.1120|
                          DCD      ||.data||

                          AREA ||i.adcOpen||, CODE, READONLY, ALIGN=2

                  adcOpen PROC
;;;94      */
;;;95     INT adcOpen(void)
000000  e3a00ffa          MOV      r0,#0x3e8
;;;96     {
;;;97         return adcOpen2(1000);
000004  eafffffe          B        adcOpen2
;;;98     }
;;;99     
                          ENDP


                          AREA ||i.adcOpen2||, CODE, READONLY, ALIGN=2

                  adcOpen2 PROC
;;;109     */
;;;110    INT adcOpen2(uint32_t freqKhz)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;111    {
;;;112        uint32_t div;
;;;113        /* Enable ADC engine clock */
;;;114        outpw(REG_CLK_PCLKEN1, 1<<24);
000004  e3a01401          MOV      r1,#0x1000000
000008  e3a0520b          MOV      r5,#0xb0000000
00000c  e585121c          STR      r1,[r5,#0x21c]
;;;115    
;;;116        /* Reset the ADC IP */
;;;117        outpw(REG_SYS_APBIPRST1, (1<<24));
000010  e5851068          STR      r1,[r5,#0x68]
;;;118        outpw(REG_SYS_APBIPRST1, 0);
000014  e3a04000          MOV      r4,#0
000018  e5854068          STR      r4,[r5,#0x68]
;;;119    
;;;120        /* ADC Engine Clock is set to freq Khz */
;;;121        if(freqKhz>3000) freqKhz=3000;
00001c  e59f1100          LDR      r1,|L6.292|
000020  e1500001          CMP      r0,r1
000024  81a00001          MOVHI    r0,r1
000028  8a000001          BHI      |L6.52|
;;;122        if(freqKhz<1000) freqKhz=1000;
00002c  e3500ffa          CMP      r0,#0x3e8
000030  33a00ffa          MOVCC    r0,#0x3e8
                  |L6.52|
;;;123        div=12000/freqKhz;
000034  e1a01000          MOV      r1,r0
000038  e59f00e8          LDR      r0,|L6.296|
00003c  ebfffffe          BL       __aeabi_uidivmod
;;;124        outpw(REG_CLK_DIVCTL7, inpw(REG_CLK_DIVCTL7) & ~((0x3<<19)|(0x7<<16)|(0xFFul<<24)));
000040  e595123c          LDR      r1,[r5,#0x23c]
000044  e3c114ff          BIC      r1,r1,#0xff000000
000048  e3c1181f          BIC      r1,r1,#0x1f0000
00004c  e585123c          STR      r1,[r5,#0x23c]
000050  e2400001          SUB      r0,r0,#1
;;;125        outpw(REG_CLK_DIVCTL7, (0<<19)|(0<<16)|((div-1)<<24));
000054  e1a00c00          LSL      r0,r0,#24
000058  e585023c          STR      r0,[r5,#0x23c]
;;;126    
;;;127        /* Enable ADC Power */
;;;128        outpw(REG_ADC_CTL, ADC_CTL_ADEN);
00005c  e59f00c8          LDR      r0,|L6.300|
000060  e3a01001          MOV      r1,#1
000064  e5801000          STR      r1,[r0,#0]
;;;129    
;;;130        /* Enable ADC to high speed mode */
;;;131        outpw(REG_ADC_CONF, inpw(REG_ADC_CONF)|ADC_CONF_HSPEED);
000068  e5901004          LDR      r1,[r0,#4]
00006c  e3811501          ORR      r1,r1,#0x400000
000070  e5801004          STR      r1,[r0,#4]
;;;132    
;;;133        /* Set interrupt */
;;;134        sysSetInterruptType(ADC_IRQn, HIGH_LEVEL_SENSITIVE);
000074  e3a01040          MOV      r1,#0x40
000078  e3a00012          MOV      r0,#0x12
00007c  ebfffffe          BL       sysSetInterruptType
;;;135        sysInstallISR(IRQ_LEVEL_7, ADC_IRQn, (PVOID)adcISR);
000080  e59f20a8          LDR      r2,|L6.304|
000084  e3a01012          MOV      r1,#0x12
000088  e3a00007          MOV      r0,#7
00008c  ebfffffe          BL       sysInstallISR
;;;136        sysSetLocalInterrupt(ENABLE_IRQ);                            /* enable CPSR I bit */
000090  e3a0007f          MOV      r0,#0x7f
000094  ebfffffe          BL       sysSetLocalInterrupt
;;;137        sysEnableInterrupt(ADC_IRQn);
000098  e3a00012          MOV      r0,#0x12
00009c  ebfffffe          BL       sysEnableInterrupt
;;;138    
;;;139        /* Init the FIFO buffer */
;;;140        adcHandler.fifoHeadX = 0;
0000a0  e59f008c          LDR      r0,|L6.308|
;;;141        adcHandler.fifoTailX = 0;
0000a4  e5804158          STR      r4,[r0,#0x158]  ; adcHandler
;;;142        adcHandler.fifoLengthX = 0;
0000a8  e580415c          STR      r4,[r0,#0x15c]  ; adcHandler
;;;143        adcHandler.fifoHeadY = 0;
0000ac  e5804160          STR      r4,[r0,#0x160]  ; adcHandler
;;;144        adcHandler.fifoTailY = 0;
0000b0  e5804264          STR      r4,[r0,#0x264]  ; adcHandler
;;;145        adcHandler.fifoLengthY = 0;
0000b4  e5804268          STR      r4,[r0,#0x268]  ; adcHandler
;;;146        adcHandler.fifoHeadZ1 = 0;
0000b8  e580426c          STR      r4,[r0,#0x26c]  ; adcHandler
;;;147        adcHandler.fifoTailZ1 = 0;
0000bc  e5804370          STR      r4,[r0,#0x370]  ; adcHandler
;;;148        adcHandler.fifoLengthZ1 = 0;
0000c0  e5804374          STR      r4,[r0,#0x374]  ; adcHandler
;;;149        adcHandler.fifoHeadZ2 = 0;
0000c4  e5804378          STR      r4,[r0,#0x378]  ; adcHandler
;;;150        adcHandler.fifoTailZ2 = 0;
0000c8  e580447c          STR      r4,[r0,#0x47c]  ; adcHandler
;;;151        adcHandler.fifoLengthZ2 = 0;
0000cc  e5804480          STR      r4,[r0,#0x480]  ; adcHandler
;;;152    
;;;153        adcHandler.touch_callback=NULL;
0000d0  e5804484          STR      r4,[r0,#0x484]  ; adcHandler
;;;154        adcHandler.touch_userData=NULL;
0000d4  e5804000          STR      r4,[r0,#0]  ; adcHandler
;;;155    
;;;156        adcHandler.touchz_callback=NULL;
0000d8  e5804004          STR      r4,[r0,#4]  ; adcHandler
;;;157        adcHandler.touchz_userData=NULL;
0000dc  e5804008          STR      r4,[r0,#8]  ; adcHandler
;;;158    
;;;159        adcHandler.pendown_callback=NULL;
0000e0  e580400c          STR      r4,[r0,#0xc]  ; adcHandler
;;;160        adcHandler.pendown_userData=NULL;
0000e4  e5804018          STR      r4,[r0,#0x18]  ; adcHandler
;;;161    
;;;162        adcHandler.penup_callback=NULL;
0000e8  e580401c          STR      r4,[r0,#0x1c]  ; adcHandler
;;;163        adcHandler.penup_userData=NULL;
0000ec  e5804020          STR      r4,[r0,#0x20]  ; adcHandler
;;;164    
;;;165        adcHandler.keypad_conv_callback=NULL;
0000f0  e5804024          STR      r4,[r0,#0x24]  ; adcHandler
;;;166        adcHandler.keypad_conv_userData=NULL;
0000f4  e5804028          STR      r4,[r0,#0x28]  ; adcHandler
;;;167    
;;;168        adcHandler.keypad_press_callback=NULL;
0000f8  e580402c          STR      r4,[r0,#0x2c]  ; adcHandler
;;;169        adcHandler.keypad_press_userData=NULL;
0000fc  e5804030          STR      r4,[r0,#0x30]  ; adcHandler
;;;170    
;;;171        adcHandler.keypad_up_callback=NULL;
000100  e5804034          STR      r4,[r0,#0x34]  ; adcHandler
;;;172        adcHandler.keypad_up_userData=NULL;
000104  e5804038          STR      r4,[r0,#0x38]  ; adcHandler
;;;173    
;;;174        adcHandler.voltage_battery_callback=NULL;
000108  e580403c          STR      r4,[r0,#0x3c]  ; adcHandler
;;;175        adcHandler.voltage_battery_userData=NULL;
00010c  e5804048          STR      r4,[r0,#0x48]  ; adcHandler
;;;176    
;;;177        adcHandler.normal_callback=NULL;
000110  e580404c          STR      r4,[r0,#0x4c]  ; adcHandler
;;;178        adcHandler.normal_userData=NULL;
000114  e5804050          STR      r4,[r0,#0x50]  ; adcHandler
000118  e5804054          STR      r4,[r0,#0x54]  ; adcHandler
;;;179    
;;;180        return Successful;
00011c  e3a00000          MOV      r0,#0
;;;181    }
000120  e8bd8070          POP      {r4-r6,pc}
;;;182    
                          ENDP

                  |L6.292|
                          DCD      0x00000bb8
                  |L6.296|
                          DCD      0x00002ee0
                  |L6.300|
                          DCD      0xb800a000
                  |L6.304|
                          DCD      adcISR
                  |L6.308|
                          DCD      ||.bss||

                          AREA ||i.adcReadXY||, CODE, READONLY, ALIGN=2

                  adcReadXY PROC
;;;216     */
;;;217    INT adcReadXY(INT16 *bufX, INT16 *bufY,int dataCnt)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;218    {
;;;219        INT32 i;
;;;220        volatile INT16 *fifoX, *fifoY;
;;;221        volatile INT32 headX, headY;
;;;222        volatile INT32 fifoLengthX, readLengthX;
;;;223        volatile INT32 fifoLengthY, readLengthY;
;;;224    
;;;225        fifoX = adcHandler.fifoX;
000004  e59f6110          LDR      r6,|L7.284|
000008  e24dd020          SUB      sp,sp,#0x20           ;218
;;;226        fifoY = adcHandler.fifoY;
;;;227        headX = adcHandler.fifoHeadX;
00000c  e5963158          LDR      r3,[r6,#0x158]  ; adcHandler
;;;228        headY = adcHandler.fifoHeadY;
;;;229        fifoLengthX = adcHandler.fifoLengthX;
;;;230        fifoLengthY = adcHandler.fifoLengthY;
;;;231    
;;;232        readLengthX = 0;
000010  e3a0c000          MOV      r12,#0
000014  e58d3018          STR      r3,[sp,#0x18]         ;228
000018  e5963264          LDR      r3,[r6,#0x264]        ;228  ; adcHandler
00001c  e2864058          ADD      r4,r6,#0x58           ;225
000020  e58d301c          STR      r3,[sp,#0x1c]         ;229
000024  e5963160          LDR      r3,[r6,#0x160]        ;229  ; adcHandler
000028  e2865f59          ADD      r5,r6,#0x164          ;226
00002c  e58d3010          STR      r3,[sp,#0x10]         ;230
000030  e596326c          LDR      r3,[r6,#0x26c]        ;230  ; adcHandler
;;;233        readLengthY = 0;
000034  e58dc000          STR      r12,[sp,#0]
000038  e58d3008          STR      r3,[sp,#8]
;;;234    
;;;235        for (i = 0; i < dataCnt; i++) {
00003c  e1a0300c          MOV      r3,r12
000040  e58dc004          STR      r12,[sp,#4]           ;233
                  |L7.68|
000044  e1530002          CMP      r3,r2
;;;236            if (fifoLengthX > readLengthX) {
000048  b59d7010          LDRLT    r7,[sp,#0x10]
00004c  b59d8000          LDRLT    r8,[sp,#0]
000050  b1580007          CMPLT    r8,r7
;;;237                bufX[i] = fifoX[headX];
;;;238                readLengthX++;
;;;239                headX++;
;;;240                if (headX >= ADC_FIFO_LENGTH) {
;;;241                    headX = 0;
;;;242                }
;;;243            } else {
;;;244                /* FIFO is empty, just return */
;;;245                break;
;;;246            }
;;;247        }
;;;248    
;;;249        for (i = 0; i < dataCnt; i++) {
000054  a3a00000          MOVGE    r0,#0
000058  aa00001c          BGE      |L7.208|
00005c  e59d7018          LDR      r7,[sp,#0x18]         ;237
000060  e0847087          ADD      r7,r4,r7,LSL #1       ;237
000064  e1d770b0          LDRH     r7,[r7,#0]            ;237
000068  e0808083          ADD      r8,r0,r3,LSL #1       ;237
00006c  e2833001          ADD      r3,r3,#1              ;241
000070  e1c870b0          STRH     r7,[r8,#0]            ;237
000074  e59d7000          LDR      r7,[sp,#0]            ;238
000078  e2877001          ADD      r7,r7,#1              ;238
00007c  e58d7000          STR      r7,[sp,#0]            ;239
000080  e59d7018          LDR      r7,[sp,#0x18]         ;239
000084  e2877001          ADD      r7,r7,#1              ;239
000088  e3570080          CMP      r7,#0x80              ;240
00008c  e58d7018          STR      r7,[sp,#0x18]         ;239
000090  a58dc018          STRGE    r12,[sp,#0x18]        ;241
000094  eaffffea          B        |L7.68|
                  |L7.152|
;;;250            if (fifoLengthY > readLengthY) {
;;;251                bufY[i] = fifoY[headY];
000098  e59d301c          LDR      r3,[sp,#0x1c]
00009c  e0853083          ADD      r3,r5,r3,LSL #1
0000a0  e1d330b0          LDRH     r3,[r3,#0]
0000a4  e0814080          ADD      r4,r1,r0,LSL #1
;;;252                readLengthY++;
;;;253                headY++;
;;;254                if (headY >= ADC_FIFO_LENGTH) {
;;;255                    headY = 0;
0000a8  e2800001          ADD      r0,r0,#1
0000ac  e1c430b0          STRH     r3,[r4,#0]            ;251
0000b0  e59d3004          LDR      r3,[sp,#4]            ;252
0000b4  e2833001          ADD      r3,r3,#1              ;252
0000b8  e58d3004          STR      r3,[sp,#4]            ;253
0000bc  e59d301c          LDR      r3,[sp,#0x1c]         ;253
0000c0  e2833001          ADD      r3,r3,#1              ;253
0000c4  e3530080          CMP      r3,#0x80              ;254
0000c8  e58d301c          STR      r3,[sp,#0x1c]         ;253
0000cc  a58dc01c          STRGE    r12,[sp,#0x1c]
                  |L7.208|
0000d0  e1500002          CMP      r0,r2                 ;249
0000d4  b59d4008          LDRLT    r4,[sp,#8]            ;250
0000d8  b59d3004          LDRLT    r3,[sp,#4]            ;250
0000dc  b1530004          CMPLT    r3,r4                 ;250
0000e0  baffffec          BLT      |L7.152|
;;;256                }
;;;257            } else {
;;;258                /* FIFO is empty, just return */
;;;259                break;
;;;260            }
;;;261        }
;;;262    
;;;263        /* Update FIFO information */
;;;264        adcHandler.fifoHeadX = headX;
0000e4  e59d1018          LDR      r1,[sp,#0x18]
;;;265        adcHandler.fifoLengthX -= readLengthX;
0000e8  e5861158          STR      r1,[r6,#0x158]  ; adcHandler
0000ec  e5961160          LDR      r1,[r6,#0x160]  ; adcHandler
0000f0  e59d2000          LDR      r2,[sp,#0]
0000f4  e0411002          SUB      r1,r1,r2
;;;266        adcHandler.fifoHeadY = headY;
0000f8  e5861160          STR      r1,[r6,#0x160]  ; adcHandler
0000fc  e59d101c          LDR      r1,[sp,#0x1c]
;;;267        adcHandler.fifoLengthY -= readLengthY;
000100  e5861264          STR      r1,[r6,#0x264]  ; adcHandler
000104  e596126c          LDR      r1,[r6,#0x26c]  ; adcHandler
000108  e59d2004          LDR      r2,[sp,#4]
00010c  e0411002          SUB      r1,r1,r2
000110  e586126c          STR      r1,[r6,#0x26c]  ; adcHandler
000114  e28dd020          ADD      sp,sp,#0x20
;;;268        return i;
;;;269    }
000118  e8bd81f0          POP      {r4-r8,pc}
;;;270    
                          ENDP

                  |L7.284|
                          DCD      ||.bss||

                          AREA ||i.adcReadZ||, CODE, READONLY, ALIGN=2

                  adcReadZ PROC
;;;281     */
;;;282    int adcReadZ(short *bufZ1, short *bufZ2, int dataCnt)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;283    {
;;;284        INT32 i;
;;;285        volatile INT16 *fifoZ1, *fifoZ2;
;;;286        volatile INT32 headZ1, headZ2;
;;;287        volatile INT32 fifoLengthZ1, readLengthZ1;
;;;288        volatile INT32 fifoLengthZ2, readLengthZ2;
;;;289    
;;;290        fifoZ1 = adcHandler.fifoZ1;
000004  e59f6110          LDR      r6,|L8.284|
000008  e24dd020          SUB      sp,sp,#0x20           ;283
;;;291        fifoZ2 = adcHandler.fifoZ2;
;;;292        headZ1 = adcHandler.fifoHeadZ1;
00000c  e5963370          LDR      r3,[r6,#0x370]  ; adcHandler
;;;293        headZ2 = adcHandler.fifoHeadZ2;
;;;294        fifoLengthZ1 = adcHandler.fifoLengthZ1;
;;;295        fifoLengthZ2 = adcHandler.fifoLengthZ2;
;;;296    
;;;297        readLengthZ1 = 0;
000010  e3a0c000          MOV      r12,#0
000014  e58d3018          STR      r3,[sp,#0x18]         ;293
000018  e596347c          LDR      r3,[r6,#0x47c]        ;293  ; adcHandler
00001c  e2864e27          ADD      r4,r6,#0x270          ;290
000020  e58d301c          STR      r3,[sp,#0x1c]         ;294
000024  e5963378          LDR      r3,[r6,#0x378]        ;294  ; adcHandler
000028  e2865fdf          ADD      r5,r6,#0x37c          ;291
00002c  e58d3010          STR      r3,[sp,#0x10]         ;295
000030  e5963484          LDR      r3,[r6,#0x484]        ;295  ; adcHandler
;;;298        readLengthZ2 = 0;
000034  e58dc000          STR      r12,[sp,#0]
000038  e58d3008          STR      r3,[sp,#8]
;;;299    
;;;300        for (i = 0; i < dataCnt; i++) {
00003c  e1a0300c          MOV      r3,r12
000040  e58dc004          STR      r12,[sp,#4]           ;298
                  |L8.68|
000044  e1530002          CMP      r3,r2
;;;301            if (fifoLengthZ1 > readLengthZ1) {
000048  b59d7010          LDRLT    r7,[sp,#0x10]
00004c  b59d8000          LDRLT    r8,[sp,#0]
000050  b1580007          CMPLT    r8,r7
;;;302                bufZ1[i] = fifoZ1[headZ1];
;;;303                readLengthZ1++;
;;;304                headZ1++;
;;;305                if (headZ1 >= ADC_FIFO_LENGTH) {
;;;306                    headZ1 = 0;
;;;307                }
;;;308            } else {
;;;309                /* FIFO is empty, just return */
;;;310                break;
;;;311            }
;;;312        }
;;;313    
;;;314        for (i = 0; i < dataCnt; i++) {
000054  a3a00000          MOVGE    r0,#0
000058  aa00001c          BGE      |L8.208|
00005c  e59d7018          LDR      r7,[sp,#0x18]         ;302
000060  e0847087          ADD      r7,r4,r7,LSL #1       ;302
000064  e1d770b0          LDRH     r7,[r7,#0]            ;302
000068  e0808083          ADD      r8,r0,r3,LSL #1       ;302
00006c  e2833001          ADD      r3,r3,#1              ;306
000070  e1c870b0          STRH     r7,[r8,#0]            ;302
000074  e59d7000          LDR      r7,[sp,#0]            ;303
000078  e2877001          ADD      r7,r7,#1              ;303
00007c  e58d7000          STR      r7,[sp,#0]            ;304
000080  e59d7018          LDR      r7,[sp,#0x18]         ;304
000084  e2877001          ADD      r7,r7,#1              ;304
000088  e3570080          CMP      r7,#0x80              ;305
00008c  e58d7018          STR      r7,[sp,#0x18]         ;304
000090  a58dc018          STRGE    r12,[sp,#0x18]        ;306
000094  eaffffea          B        |L8.68|
                  |L8.152|
;;;315            if (fifoLengthZ2 > readLengthZ2) {
;;;316                bufZ2[i] = fifoZ2[headZ2];
000098  e59d301c          LDR      r3,[sp,#0x1c]
00009c  e0853083          ADD      r3,r5,r3,LSL #1
0000a0  e1d330b0          LDRH     r3,[r3,#0]
0000a4  e0814080          ADD      r4,r1,r0,LSL #1
;;;317                readLengthZ2++;
;;;318                headZ2++;
;;;319                if (headZ2 >= ADC_FIFO_LENGTH) {
;;;320                    headZ2 = 0;
0000a8  e2800001          ADD      r0,r0,#1
0000ac  e1c430b0          STRH     r3,[r4,#0]            ;316
0000b0  e59d3004          LDR      r3,[sp,#4]            ;317
0000b4  e2833001          ADD      r3,r3,#1              ;317
0000b8  e58d3004          STR      r3,[sp,#4]            ;318
0000bc  e59d301c          LDR      r3,[sp,#0x1c]         ;318
0000c0  e2833001          ADD      r3,r3,#1              ;318
0000c4  e3530080          CMP      r3,#0x80              ;319
0000c8  e58d301c          STR      r3,[sp,#0x1c]         ;318
0000cc  a58dc01c          STRGE    r12,[sp,#0x1c]
                  |L8.208|
0000d0  e1500002          CMP      r0,r2                 ;314
0000d4  b59d4008          LDRLT    r4,[sp,#8]            ;315
0000d8  b59d3004          LDRLT    r3,[sp,#4]            ;315
0000dc  b1530004          CMPLT    r3,r4                 ;315
0000e0  baffffec          BLT      |L8.152|
;;;321                }
;;;322            } else {
;;;323                /* FIFO is empty, just return */
;;;324                break;
;;;325            }
;;;326        }
;;;327    
;;;328        /* Update FIFO information */
;;;329        adcHandler.fifoHeadZ1 = headZ1;
0000e4  e59d1018          LDR      r1,[sp,#0x18]
;;;330        adcHandler.fifoLengthZ1 -= readLengthZ1;
0000e8  e5861370          STR      r1,[r6,#0x370]  ; adcHandler
0000ec  e5961378          LDR      r1,[r6,#0x378]  ; adcHandler
0000f0  e59d2000          LDR      r2,[sp,#0]
0000f4  e0411002          SUB      r1,r1,r2
;;;331        adcHandler.fifoHeadZ2 = headZ2;
0000f8  e5861378          STR      r1,[r6,#0x378]  ; adcHandler
0000fc  e59d101c          LDR      r1,[sp,#0x1c]
;;;332        adcHandler.fifoLengthZ2 -= readLengthZ2;
000100  e586147c          STR      r1,[r6,#0x47c]  ; adcHandler
000104  e5961484          LDR      r1,[r6,#0x484]  ; adcHandler
000108  e59d2004          LDR      r2,[sp,#4]
00010c  e0411002          SUB      r1,r1,r2
000110  e5861484          STR      r1,[r6,#0x484]  ; adcHandler
000114  e28dd020          ADD      sp,sp,#0x20
;;;333        return i;
;;;334    }
000118  e8bd81f0          POP      {r4-r8,pc}
;;;335    
                          ENDP

                  |L8.284|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  adcHandler
                          %        1160

                          AREA ||.data||, DATA, ALIGN=2

                  mst_complete
                          DCD      0x00000000
