L 1 "..\Application\FramewinDLG.c"
N/*********************************************************************
N*                                                                    *
N*                SEGGER Microcontroller GmbH & Co. KG                *
N*        Solutions for real time microcontroller applications        *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N* C-file generated by:                                               *
N*                                                                    *
N*        GUI_Builder for emWin version 5.46                          *
N*        Compiled Dec 12 2017, 16:38:40                              *
N*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*        Internet: www.segger.com  Support: support@segger.com       *
N*                                                                    *
N**********************************************************************
N*/
N
N// USER START (Optionally insert additional includes)
N#include "N9H30.h"
L 1 "..\..\..\Driver\Include\N9H30.h" 1
N/**************************************************************************//**
N * @file     N9H30.h
N * @version  V1.00
N * @brief    N9H30 peripheral access layer header file.
N *           This file contains all the peripheral register's definitions
N *           and memory mapping for NuMicro N9H30 MCU.
N *
N * @copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N/**
N   \mainpage NuMicro N9H30 Family Driver Reference Guide
N   *
N   * <b>Introduction</b>
N   *
N   * This user manual describes the usage of N9H30 family device driver
N   *
N   * <b>Disclaimer</b>
N   *
N   * The Software is furnished "AS IS", without warranty as to performance or results, and
N   * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N   * warranties, express, implied or otherwise, with regard to the Software, its use, or
N   * operation, including without limitation any and all warranties of merchantability, fitness
N   * for a particular purpose, and non-infringement of intellectual property rights.
N   *
N   * <b>Important Notice</b>
N   *
N   * Nuvoton Products are neither intended nor warranted for usage in systems or equipment,
N   * any malfunction or failure of which may cause loss of human life, bodily injury or severe
N   * property damage. Such applications are deemed, "Insecure Usage".
N   *
N   * Insecure usage includes, but is not limited to: equipment for surgical implementation,
N   * atomic energy control instruments, airplane or spaceship instruments, the control or
N   * operation of dynamic, brake or safety systems designed for vehicular use, traffic signal
N   * instruments, all types of safety devices, and other applications intended to support or
N   * sustain life.
N   *
N   * All Insecure Usage shall be made at customer's risk, and in the event that third parties
N   * lay claims to Nuvoton as a result of customer's Insecure Usage, customer shall indemnify
N   * the damages and liabilities thus incurred by Nuvoton.
N   *
N   * Please note that all data and specifications are subject to change without notice. All the
N   * trademarks of products and companies mentioned in this document belong to their respective
N   * owners.
N   *
N   * <b>Copyright Notice</b>
N   *
N   * Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N   */
N
N#ifndef __N9H30_H__
N#define __N9H30_H__
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 54 "..\..\..\Driver\Include\N9H30.h" 2
N
N/** @addtogroup N9H30_PERIPHERAL_MEM_MAP N9H30 Peripheral Memory Base
N  Memory Mapped Structure for N9H30 Peripheral
N  @{
N */
N
N/*!< AHB peripherals */
N#define    SYS_BA    0xB0000000  /*!< System Global Control */
N#define    CLK_BA    0xB0000200  /*!< Clock Control */
N#define    EBI_BA    0xB0001000  /*!< EBI Control */
N#define    SDIC_BA   0xB0001800  /*!< SDRAM (SDR/DDR/DDR2) Control */
N#define    EMC0_BA   0xB0002000  /*!< Ethernet MAC 0 Control */
N#define    EMC1_BA   0xB0003000  /*!< Ethernet MAC 1 Control */
N#define    GDMA_BA   0xB0004000  /*!< GDMA control */
N#define    USBH_BA   0xB0005000  /*!< USB Host EHCI Control */
N#define    USBD_BA   0xB0006000  /*!< USB Device Control */
N#define    USBO_BA   0xB0007000  /*!< OHCI USB Host Control */
N#define    LCM_BA    0xB0008000  /*!< Display, LCM Interface */
N#define    ACTL_BA   0xB0009000  /*!< Audio Control */
N#define    JPEG_BA   0xB000A000  /*!< JPEG Engine Control */
N#define    GE_BA     0xB000B000  /*!< 2-D Graphic Engine */
N#define    SDH_BA    0xB000C000  /*!< SD/SDIO Host Controller */
N#define    FMI_BA    0xB000D000  /*!< Flash Memory Card Interface */
N#define    CAP_BA    0xB000E000  /*!< Sensor (Capture) Interface Control */
N
N/*!< APB peripherals */
N#define    UART0_BA  0xB8000000  /*!< UART0 Control */
N#define    UART1_BA  0xB8000100  /*!< UART1 Control (High-Speed UART) */
N#define    UART2_BA  0xB8000200  /*!< UART2 Control (High-Speed UART) */
N#define    UART3_BA  0xB8000300  /*!< UART3 Control  */
N#define    UART4_BA  0xB8000400  /*!< UART4 Control (High-Speed UART) */
N#define    UART5_BA  0xB8000500  /*!< UART5 Control */
N#define    UART6_BA  0xB8000600  /*!< UART6 Control (High-Speed UART) */
N#define    UART7_BA  0xB8000700  /*!< UART7 Control */
N#define    UART8_BA  0xB8000800  /*!< UART8 Control (High-Speed UART) */
N#define    UART9_BA  0xB8000900  /*!< UART9 Control */
N#define    UARTA_BA  0xB8000A00  /*!< UARTA Control (High-Speed UART) */
N#define    TMR0_BA   0xB8001000  /*!< Timer 0 */
N#define    TMR1_BA   0xB8001010  /*!< Timer 1 */
N#define    TMR2_BA   0xB8001020  /*!< Timer 2 */
N#define    TMR3_BA   0xB8001030  /*!< Timer 3 */
N#define    TMR4_BA   0xB8001040  /*!< Timer 4 */
N#define    ETMR0_BA  0xB8001400  /*!< Enhanced Timer 0 */
N#define    ETMR1_BA  0xB8001500  /*!< Enhanced Timer 1 */
N#define    ETMR2_BA  0xB8001600  /*!< Enhanced Timer 2 */
N#define    ETMR3_BA  0xB8001700  /*!< Enhanced Timer 3 */
N#define    WDT_BA    0xB8001800  /*!< Watch Dog Timer */
N#define    WWDT_BA   0xB8001900  /*!< Window Watch Dog Timer */
N#define    AIC_BA    0xB8002000  /*!< Interrupt Controller */
N#define    GPIO_BA   0xB8003000  /*!< GPIO Control */
N#define    RTC_BA    0xB8004000  /*!< Real Time Clock Control */
N#define    SC0_BA    0xB8005000  /*!< Smart Card 0 Control */
N#define    SC1_BA    0xB8005400  /*!< Smart Card 1 Control */
N#define    I2C0_BA   0xB8006000  /*!< I2C 0 Control */
N#define    I2C1_BA   0xB8006100  /*!< I2C 1 Control */
N#define    SPI0_BA   0xB8006200  /*!< Serial Peripheral Interface 0 */
N#define    SPI1_BA   0xB8006300  /*!< Serial Peripheral Interface 1 */
N#define    PWM_BA    0xB8007000  /*!< Pulse Width Modulation (PWM) Control */
N#define    ADC_BA    0xB800A000  /*!< ADC Control */
N#define    CAN0_BA   0xB800B000  /*!< CAN 0 Control */
N#define    CAN1_BA   0xB800B400  /*!< CAN 1 Control */
N
N/*@}*/ /* end of group N9H30_PERIPHERAL_MEM_MAP */
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N/** @addtogroup N9H30_Peripherals N9H30 Control Register
N  N9H30 Device Specific Peripheral registers structures
N  @{
N*/
N
N/*---------------------- System Manger Controller -------------------------*/
N/**
N    @addtogroup SYS System Manger Controller(SYS)
N    Memory Mapped Structure for SYS Controller
N@{ */
N
N#define    REG_SYS_PDID         (SYS_BA+0x000)  /*!< Product Identifier Register */
N#define    REG_SYS_PWRON        (SYS_BA+0x004)  /*!< Power-On Setting Register */
N#define    REG_SYS_ARBCON       (SYS_BA+0x008)  /*!< Arbitration Control Register */
N#define    REG_SYS_LVRDCR       (SYS_BA+0x020)  /*!< Low Voltage Reset & Detect Control Register */
N#define    REG_SYS_MISCFCR      (SYS_BA+0x030)  /*!< Miscellaneous Function Control Register */
N#define    REG_SYS_MISCIER      (SYS_BA+0x040)  /*!< Miscellaneous Interrupt Enable Register */
N#define    REG_SYS_MISCISR      (SYS_BA+0x044)  /*!< Miscellaneous Interrupt Status Register */
N#define    REG_SYS_WKUPSER      (SYS_BA+0x058)  /*!< System Wakeup Source Enable Register */
N#define    REG_SYS_WKUPSSR      (SYS_BA+0x05C)  /*!< System Wakeup Source Status Register */
N#define    REG_SYS_AHBIPRST     (SYS_BA+0x060)  /*!< AHB IP Reset Control Register */
N#define    REG_SYS_APBIPRST0    (SYS_BA+0x064)  /*!< APB IP Reset Control Register 0 */
N#define    REG_SYS_APBIPRST1    (SYS_BA+0x068)  /*!< APB IP Reset Control Register 1 */
N#define    REG_SYS_RSTSTS       (SYS_BA+0x06C)  /*!< Reset Source Active Status Register */
N#define    REG_SYS_GPA_MFPL     (SYS_BA+0x070)  /*!< GPIOA Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPA_MFPH     (SYS_BA+0x074)  /*!< GPIOA High Byte Multiple Function Control Register */
N#define    REG_SYS_GPB_MFPL     (SYS_BA+0x078)  /*!< GPIOB Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPB_MFPH     (SYS_BA+0x07C)  /*!< GPIOB High Byte Multiple Function Control Register */
N#define    REG_SYS_GPC_MFPL     (SYS_BA+0x080)  /*!< GPIOC Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPC_MFPH     (SYS_BA+0x084)  /*!< GPIOC High Byte Multiple Function Control Register */
N#define    REG_SYS_GPD_MFPL     (SYS_BA+0x088)  /*!< GPIOD Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPD_MFPH     (SYS_BA+0x08C)  /*!< GPIOD High Byte Multiple Function Control Register */
N#define    REG_SYS_GPE_MFPL     (SYS_BA+0x090)  /*!< GPIOE Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPE_MFPH     (SYS_BA+0x094)  /*!< GPIOE High Byte Multiple Function Control Register */
N#define    REG_SYS_GPF_MFPL     (SYS_BA+0x098)  /*!< GPIOF Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPF_MFPH     (SYS_BA+0x09C)  /*!< GPIOF High Byte Multiple Function Control Register */
N#define    REG_SYS_GPG_MFPL     (SYS_BA+0x0A0)  /*!< GPIOG Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPG_MFPH     (SYS_BA+0x0A4)  /*!< GPIOG High Byte Multiple Function Control Register */
N#define    REG_SYS_GPH_MFPL     (SYS_BA+0x0A8)  /*!< GPIOH Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPH_MFPH     (SYS_BA+0x0AC)  /*!< GPIOH High Byte Multiple Function Control Register */
N#define    REG_SYS_GPI_MFPL     (SYS_BA+0x0B0)  /*!< GPIOI Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPI_MFPH     (SYS_BA+0x0B4)  /*!< GPIOI High Byte Multiple Function Control Register */
N#define    REG_SYS_GPJ_MFPL     (SYS_BA+0x0B8)  /*!< GPIOJ Low Byte Multiple Function Control Register */
N#define    REG_SYS_DDR_DSCTL    (SYS_BA+0x0F0)  /*!< DDR I/O Driving Strength Control Register */
N#define    REG_SYS_PORDISCR     (SYS_BA+0x100)  /*!< Power-On-Reset Disable Control Register */
N#define    REG_SYS_ICEDBGCR     (SYS_BA+0x104)  /*!< ICE Debug Interface Control Register */
N#define    REG_SYS_ERRADDCR     (SYS_BA+0x108)  /*!< Error Response Address Control Regsiter */
N#define    REG_SYS_REGWPCTL     (SYS_BA+0x1FC)  /*!< Register Write-Protection Control Register */
N
N/**@}*/ /* end of SYS register group */
N
N/*---------------------- System Clock Controller -------------------------*/
N/**
N    @addtogroup CLK System Clock Controller(CLK)
N    Memory Mapped Structure for CLK Controller
N@{ */
N
N#define    REG_CLK_PMCON        (CLK_BA+0x00) /*!< Power Management Control Register */
N#define    REG_CLK_HCLKEN       (CLK_BA+0x10) /*!< AHB IP Clock Enable Control Register */
N#define    REG_CLK_PCLKEN0      (CLK_BA+0x18) /*!< APB IP Clock Enable Control Register 0 */
N#define    REG_CLK_PCLKEN1      (CLK_BA+0x1C) /*!< APB IP Clock Enable Control Register 1 */
N#define    REG_CLK_DIVCTL0      (CLK_BA+0x20) /*!< Clock Divider Control Register 0 */
N#define    REG_CLK_DIVCTL1      (CLK_BA+0x24) /*!< Clock Divider Control Register 1 */
N#define    REG_CLK_DIVCTL2      (CLK_BA+0x28) /*!< Clock Divider Control Register 2 */
N#define    REG_CLK_DIVCTL3      (CLK_BA+0x2C) /*!< Clock Divider Control Register 3 */
N#define    REG_CLK_DIVCTL4      (CLK_BA+0x30) /*!< Clock Divider Control Register 4 */
N#define    REG_CLK_DIVCTL5      (CLK_BA+0x34) /*!< Clock Divider Control Register 5 */
N#define    REG_CLK_DIVCTL6      (CLK_BA+0x38) /*!< Clock Divider Control Register 6 */
N#define    REG_CLK_DIVCTL7      (CLK_BA+0x3C) /*!< Clock Divider Control Register 7 */
N#define    REG_CLK_DIVCTL8      (CLK_BA+0x40) /*!< Clock Divider Control Register 8 */
N#define    REG_CLK_DIVCTL9      (CLK_BA+0x44) /*!< Clock Divider Control Register 9 */
N#define    REG_CLK_APLLCON      (CLK_BA+0x60) /*!< APLL Control Register */
N#define    REG_CLK_UPLLCON      (CLK_BA+0x64) /*!< UPLL Control Register */
N#define    REG_CLK_PLLSTBCNTR   (CLK_BA+0x80) /*!< PLL Stable Counter and Test Clock Control Register */
N
N/**@}*/ /* end of CLK register group */
N
N
N/*---------------------- External Bus Interface Controller -------------------------*/
N/**
N    @addtogroup EBI External Bus Interface Controller(EBI)
N    Memory Mapped Structure for EBI Controller
N@{ */
N
N#define    REG_EBI_CTL          (EBI_BA+0x000)  /*!< EBI control register */
N#define    REG_EBI_BNKCTL0      (EBI_BA+0x018)  /*!< External I/O 0 control register */
N#define    REG_EBI_BNKCTL1      (EBI_BA+0x01C)  /*!< External I/O 1 control register */
N#define    REG_EBI_BNKCTL2      (EBI_BA+0x020)  /*!< External I/O 2 control register */
N#define    REG_EBI_BNKCTL3      (EBI_BA+0x024)  /*!< External I/O 3 control register */
N#define    REG_EBI_BNKCTL4      (EBI_BA+0x028)  /*!< External I/O 4 control register */
N
N/**@}*/ /* end of EBI register group */
N
N
N/*---------------------- Ethernet MAC Controller -------------------------*/
N/**
N    @addtogroup EMAC Ethernet MAC Controller(EMAC)
N    Memory Mapped Structure for EMAC Controller
N@{ */
N
N#define     REG_EMAC0_CAMCMR      (EMC0_BA+0x000) /*!< CAM Command Register */
N#define     REG_EMAC0_CAMEN       (EMC0_BA+0x004) /*!< CAM Enable Register */
N#define     REG_EMAC0_CAM0M       (EMC0_BA+0x008)  /*!< CAM0 Most Significant Word Register */
N#define     REG_EMAC0_CAM0L       (EMC0_BA+0x00c)  /*!< CAM0 Least Significant Word Register */
N#define     REG_EMAC0_CAMxM_Reg(x)(REG_EMAC0_CAM0M+(x)*0x8)  /*!< CAMx Most Significant Word Register */
N#define     REG_EMAC0_CAMxL_Reg(x)(REG_EMAC0_CAM0L+(x)*0x8)  /*!< CAMx Least Significant Word Register */
N#define     REG_EMAC0_TXDLSA      (EMC0_BA+0x088) /*!< Transmit Descriptor Link List Start Address Register */
N#define     REG_EMAC0_RXDLSA      (EMC0_BA+0x08C) /*!< Receive Descriptor Link List Start Address Register */
N#define     REG_EMAC0_MCMDR       (EMC0_BA+0x090) /*!< MAC Command Register */
N#define     REG_EMAC0_MIID        (EMC0_BA+0x094) /*!< MII Management Data Register */
N#define     REG_EMAC0_MIIDA       (EMC0_BA+0x098) /*!< MII Management Control and Address Register */
N#define     REG_EMAC0_FFTCR       (EMC0_BA+0x09C) /*!< FIFO Threshold Control Register */
N#define     REG_EMAC0_TSDR        (EMC0_BA+0x0a0) /*!< Transmit Start Demand Register */
N#define     REG_EMAC0_RSDR        (EMC0_BA+0x0a4) /*!< Receive Start Demand Register */
N#define     REG_EMAC0_DMARFC      (EMC0_BA+0x0a8) /*!< Maximum Receive Frame Control Register */
N#define     REG_EMAC0_MIEN        (EMC0_BA+0x0ac) /*!< MAC Interrupt Enable Register */
N#define     REG_EMAC0_MISTA       (EMC0_BA+0x0b0) /*!< MAC Interrupt Status Register */
N#define     REG_EMAC0_MGSTA       (EMC0_BA+0x0b4) /*!< MAC General Status Register */
N#define     REG_EMAC0_MPCNT       (EMC0_BA+0x0b8) /*!< Missed Packet Count Register */
N#define     REG_EMAC0_MRPC        (EMC0_BA+0x0bc) /*!< MAC Receive Pause Count Register */
N#define     REG_EMAC0_DMARFS      (EMC0_BA+0x0c8) /*!< DMA Receive Frame Status Register */
N#define     REG_EMAC0_CTXDSA      (EMC0_BA+0x0cc) /*!< Current Transmit Descriptor Start Address Register */
N#define     REG_EMAC0_CTXBSA      (EMC0_BA+0x0d0) /*!< Current Transmit Buffer Start Address Register */
N#define     REG_EMAC0_CRXDSA      (EMC0_BA+0x0d4) /*!< Current Receive Descriptor Start Address Register */
N#define     REG_EMAC0_CRXBSA      (EMC0_BA+0x0d8) /*!< Current Receive Buffer Start Address Register */
N#define     REG_EMAC0_TSCTL       (EMC0_BA+0x100) /*!< Time Stamp Control Register */
N#define     REG_EMAC0_TSSEC       (EMC0_BA+0x110) /*!< Time Stamp Counter Second Register */
N#define     REG_EMAC0_TSSUBSEC    (EMC0_BA+0x114) /*!< Time Stamp Counter Sub Second Register */
N#define     REG_EMAC0_TSINC       (EMC0_BA+0x118) /*!< Time Stamp Increment Register  */
N#define     REG_EMAC0_TSADDEN     (EMC0_BA+0x11c) /*!< Time Stamp Addend Register */
N#define     REG_EMAC0_TSUPDSEC    (EMC0_BA+0x120) /*!< Time Stamp Update Second Register */
N#define     REG_EMAC0_TSUPDSUBSEC (EMC0_BA+0x124) /*!< Time Stamp Update Sub Second Register */
N#define     REG_EMAC0_TSALMSEC    (EMC0_BA+0x128) /*!< Time Stamp Alarm Second Register */
N#define     REG_EMAC0_TSALMSUBSEC (EMC0_BA+0x12c) /*!< Time Stamp Alarm Sub Second Register */
N
N#define     REG_EMAC1_CAMCMR      (EMC1_BA+0x000) /*!< CAM Command Register */
N#define     REG_EMAC1_CAMEN       (EMC1_BA+0x004) /*!< CAM Enable Register */
N#define     REG_EMAC1_CAM0M       (EMC1_BA+0x008)  /*!< CAM0 Most Significant Word Register */
N#define     REG_EMAC1_CAM0L       (EMC1_BA+0x00c)  /*!< CAM0 Least Significant Word Register */
N#define     REG_EMAC1_CAMxM_Reg(x)(REG_EMAC1_CAM0M+(x)*0x8)  /*!< CAMx Most Significant Word Register */
N#define     REG_EMAC1_CAMxL_Reg(x)(REG_EMAC1_CAM0L+(x)*0x8)  /*!< CAMx Least Significant Word Register */
N#define     REG_EMAC1_TXDLSA      (EMC1_BA+0x088) /*!< Transmit Descriptor Link List Start Address Register */
N#define     REG_EMAC1_RXDLSA      (EMC1_BA+0x08C) /*!< Receive Descriptor Link List Start Address Register */
N#define     REG_EMAC1_MCMDR       (EMC1_BA+0x090) /*!< MAC Command Register */
N#define     REG_EMAC1_MIID        (EMC1_BA+0x094) /*!< MII Management Data Register */
N#define     REG_EMAC1_MIIDA       (EMC1_BA+0x098) /*!< MII Management Control and Address Register */
N#define     REG_EMAC1_FFTCR       (EMC1_BA+0x09C) /*!< FIFO Threshold Control Register */
N#define     REG_EMAC1_TSDR        (EMC1_BA+0x0a0) /*!< Transmit Start Demand Register */
N#define     REG_EMAC1_RSDR        (EMC1_BA+0x0a4) /*!< Receive Start Demand Register */
N#define     REG_EMAC1_DMARFC      (EMC1_BA+0x0a8) /*!< Maximum Receive Frame Control Register */
N#define     REG_EMAC1_MIEN        (EMC1_BA+0x0ac) /*!< MAC Interrupt Enable Register */
N#define     REG_EMAC1_MISTA       (EMC1_BA+0x0b0) /*!< MAC Interrupt Status Register */
N#define     REG_EMAC1_MGSTA       (EMC1_BA+0x0b4) /*!< MAC General Status Register */
N#define     REG_EMAC1_MPCNT       (EMC1_BA+0x0b8) /*!< Missed Packet Count Register */
N#define     REG_EMAC1_MRPC        (EMC1_BA+0x0bc) /*!< MAC Receive Pause Count Register */
N#define     REG_EMAC1_DMARFS      (EMC1_BA+0x0c8) /*!< DMA Receive Frame Status Register */
N#define     REG_EMAC1_CTXDSA      (EMC1_BA+0x0cc) /*!< Current Transmit Descriptor Start Address Register */
N#define     REG_EMAC1_CTXBSA      (EMC1_BA+0x0d0) /*!< Current Transmit Buffer Start Address Register */
N#define     REG_EMAC1_CRXDSA      (EMC1_BA+0x0d4) /*!< Current Receive Descriptor Start Address Register */
N#define     REG_EMAC1_CRXBSA      (EMC1_BA+0x0d8) /*!< Current Receive Buffer Start Address Register */
N#define     REG_EMAC1_TSCTL       (EMC1_BA+0x100) /*!< Time Stamp Control Register */
N#define     REG_EMAC1_TSSEC       (EMC1_BA+0x110) /*!< Time Stamp Counter Second Register */
N#define     REG_EMAC1_TSSUBSEC    (EMC1_BA+0x114) /*!< Time Stamp Counter Sub Second Register */
N#define     REG_EMAC1_TSINC       (EMC1_BA+0x118) /*!< Time Stamp Increment Register  */
N#define     REG_EMAC1_TSADDEN     (EMC1_BA+0x11c) /*!< Time Stamp Addend Register */
N#define     REG_EMAC1_TSUPDSEC    (EMC1_BA+0x120) /*!< Time Stamp Update Second Register */
N#define     REG_EMAC1_TSUPDSUBSEC (EMC1_BA+0x124) /*!< Time Stamp Update Sub Second Register */
N#define     REG_EMAC1_TSALMSEC    (EMC1_BA+0x128) /*!< Time Stamp Alarm Second Register */
N#define     REG_EMAC1_TSALMSUBSEC (EMC1_BA+0x12c) /*!< Time Stamp Alarm Sub Second Register */
N
N/**@}*/ /* end of EMAC register group */
N
N/*----------------------  General Direct Memory Access Controller -------------------------*/
N/**
N    @addtogroup GDMA  General Direct Memory Access Controller(GDMA)
N    Memory Mapped Structure for GDMA Controller
N@{ */
N
N#define     REG_GDMA_CTL0   (GDMA_BA+0x000)  /*!< Channel 0 Control Register */
N#define     REG_GDMA_SRCB0  (GDMA_BA+0x004)  /*!< Channel 0 Source Base Address Register */
N#define     REG_GDMA_DSTB0  (GDMA_BA+0x008)  /*!< Channel 0 Destination Base Address Register */
N#define     REG_GDMA_TCNT0  (GDMA_BA+0x00C)  /*!< Channel 0 Transfer Count Register */
N#define     REG_GDMA_CSRC0  (GDMA_BA+0x010)  /*!< Channel 0 Current Source Address Register */
N#define     REG_GDMA_CDST0  (GDMA_BA+0x014)  /*!< Channel 0 Current Destination Address Register */
N#define     REG_GDMA_CTCNT0 (GDMA_BA+0x018)  /*!< Channel 0 Current Transfer Count Register */
N#define     REG_GDMA_DADR0  (GDMA_BA+0x01C)  /*!< Channel 0 Descriptor Address Register */
N#define     REG_GDMA_CTL1   (GDMA_BA+0x020)  /*!< Channel 1 Control Register */
N#define     REG_GDMA_SRCB1  (GDMA_BA+0x024)  /*!< Channel 1 Source Base Address Register */
N#define     REG_GDMA_DSTB1  (GDMA_BA+0x028)  /*!< Channel 1 Destination Base Address Register */
N#define     REG_GDMA_TCNT1  (GDMA_BA+0x02C)  /*!< Channel 1 Transfer Count Register */
N#define     REG_GDMA_CSRC1  (GDMA_BA+0x030)  /*!< Channel 1 Current Source Address Register */
N#define     REG_GDMA_CDST1  (GDMA_BA+0x034)  /*!< Channel 1 Current Destination Address Register */
N#define     REG_GDMA_CTCNT1 (GDMA_BA+0x038)  /*!< Channel 1 Current Transfer Count Register */
N#define     REG_GDMA_DADR1  (GDMA_BA+0x03C)  /*!< Channel 1 Descriptor Address Register */
N#define     REG_GDMA_INTBUF0    (GDMA_BA+0x080)  /*!< GDMA Internal Buffer Word 0 */
N#define     REG_GDMA_INTBUF1    (GDMA_BA+0x084)  /*!< GDMA Internal Buffer Word 1 */
N#define     REG_GDMA_INTBUF2    (GDMA_BA+0x088)  /*!< GDMA Internal Buffer Word 2 */
N#define     REG_GDMA_INTBUF3    (GDMA_BA+0x08C)  /*!< GDMA Internal Buffer Word 3 */
N#define     REG_GDMA_INTBUF4    (GDMA_BA+0x090)  /*!< GDMA Internal Buffer Word 4 */
N#define     REG_GDMA_INTBUF5    (GDMA_BA+0x094)  /*!< GDMA Internal Buffer Word 5 */
N#define     REG_GDMA_INTBUF6    (GDMA_BA+0x098)  /*!< GDMA Internal Buffer Word 6 */
N#define     REG_GDMA_INTBUF7    (GDMA_BA+0x09C)  /*!< GDMA Internal Buffer Word 7 */
N#define     REG_GDMA_INTCS  (GDMA_BA+0x0A0)  /*!< Interrupt Control and Status Register */
N
N/**@}*/ /* end of GDMA register group */
N
N
N
N/*---------------------- USB Device Controller -------------------------*/
N/**
N    @addtogroup USBD USB Device Controller(USBD)
N    Memory Mapped Structure for USBD Controller
N@{ */
N#define     REG_USBD_GINTSTS        (USBD_BA+0x00)  /*!< Interrupt Status Low Register */
N#define     REG_USBD_GINTEN         (USBD_BA+0x08)  /*!< Interrupt Enable Low Register */
N#define     REG_USBD_BUSINTSTS      (USBD_BA+0x10)  /*!< USB Bus Interrupt Status Register */
N#define     REG_USBD_BUSINTEN       (USBD_BA+0x14)  /*!< USB Bus Interrupt Enable Register */
N#define     REG_USBD_OPER           (USBD_BA+0x18)  /*!< USB Operational Register */
N#define     REG_USBD_FRAMECNT       (USBD_BA+0x1C)  /*!< USB Frame Count Register */
N#define     REG_USBD_FADDR          (USBD_BA+0x20)  /*!< USB Function Address Register */
N#define     REG_USBD_TEST           (USBD_BA+0x24)  /*!< USB Test Mode Register */
N#define     REG_USBD_CEPDAT         (USBD_BA+0x28)  /*!< Control-ep data buffer register */
N#define     REG_USBD_CEPCTL         (USBD_BA+0x2C)  /*!< Control-ep control and status register */
N#define     REG_USBD_CEPINTEN       (USBD_BA+0x30)  /*!< Control-ep interrupt enable register */
N#define     REG_USBD_CEPINTSTS      (USBD_BA+0x34)  /*!< Control-ep interrupt status register */
N#define     REG_USBD_CEPTXCNT       (USBD_BA+0x38)  /*!< In-transfer data count register */
N#define     REG_USBD_CEPRXCNT       (USBD_BA+0x3C)  /*!< Out-transfer data count register */
N#define     REG_USBD_CEPDATCNT      (USBD_BA+0x40)  /*!< Control-ep data count register */
N#define     REG_USBD_SETUP1_0       (USBD_BA+0x44)  /*!< Setup byte1 & byte0 register */
N#define     REG_USBD_SETUP3_2       (USBD_BA+0x48)  /*!< Setup byte3 & byte2 register */
N#define     REG_USBD_SETUP5_4       (USBD_BA+0x4C)  /*!< Setup byte5 & byte4 register */
N#define     REG_USBD_SETUP7_6       (USBD_BA+0x50)  /*!< Setup byte7 & byte6 register */
N#define     REG_USBD_CEPBUFSTART    (USBD_BA+0x54)  /*!< Control-ep ram start address register */
N#define     REG_USBD_CEPBUFEND      (USBD_BA+0x58)  /*!< Control-ep ram end address register */
N#define     REG_USBD_DMACTL         (USBD_BA+0x5C)  /*!< Dma control and status register */
N#define     REG_USBD_DMACNT         (USBD_BA+0x60)  /*!< Dma count register */
N
N#define     REG_USBD_EPADAT         (USBD_BA+0x64)  /*!< Endpoint A data buffer register */
N#define     REG_USBD_EPAINTSTS      (USBD_BA+0x68)  /*!< Endpoint A interrupt status register */
N#define     REG_USBD_EPAINTEN       (USBD_BA+0x6C)  /*!< Endpoint A interrupt enable register */
N#define     REG_USBD_EPADATCNT      (USBD_BA+0x70)  /*!< Data count available in endpoint A buffer */
N#define     REG_USBD_EPARSPCTL      (USBD_BA+0x74)  /*!< Endpoint A response register set/clear */
N#define     REG_USBD_EPAMPS         (USBD_BA+0x78)  /*!< Endpoint A max packet size register */
N#define     REG_USBD_EPATXCNT       (USBD_BA+0x7C)  /*!< Endpoint A transfer count register */
N#define     REG_USBD_EPACFG         (USBD_BA+0x80)  /*!< Endpoint A configuration register */
N#define     REG_USBD_EPABUFSTART    (USBD_BA+0x84)  /*!< Endpoint A ram start address register */
N#define     REG_USBD_EPABUFEND      (USBD_BA+0x88)  /*!< Endpoint A ram end address register */
N
N#define     REG_USBD_EPBDAT         (USBD_BA+0x8C)  /*!< Endpoint B data buffer register */
N#define     REG_USBD_EPBINTSTS      (USBD_BA+0x90)  /*!< Endpoint B interrupt status register */
N#define     REG_USBD_EPBINTEN       (USBD_BA+0x94)  /*!< Endpoint B interrupt enable register */
N#define     REG_USBD_EPBDATCNT      (USBD_BA+0x98)  /*!< Data count available in endpoint B buffer */
N#define     REG_USBD_EPBRSPCTL      (USBD_BA+0x9C)  /*!< Endpoint B response register set/clear */
N#define     REG_USBD_EPBMPS         (USBD_BA+0xA0)  /*!< Endpoint B max packet size register */
N#define     REG_USBD_EPBTXCNT       (USBD_BA+0xA4)  /*!< Endpoint B transfer count register */
N#define     REG_USBD_EPBCFG         (USBD_BA+0xA8)  /*!< Endpoint B configuration register */
N#define     REG_USBD_EPBBUFSTART    (USBD_BA+0xAC)  /*!< Endpoint B ram start address register */
N#define     REG_USBD_EPBBUFEND      (USBD_BA+0xB0)  /*!< Endpoint B ram end address register */
N
N#define     REG_USBD_EPCDAT         (USBD_BA+0xB4)  /*!< Endpoint C data buffer register */
N#define     REG_USBD_EPCINTSTS      (USBD_BA+0xB8)  /*!< Endpoint C interrupt status register */
N#define     REG_USBD_EPCINTEN       (USBD_BA+0xBC)  /*!< Endpoint C interrupt enable register */
N#define     REG_USBD_EPCDATCNT      (USBD_BA+0xC0)  /*!< Data count available in endpoint C buffer */
N#define     REG_USBD_EPCRSPCTL      (USBD_BA+0xC4)  /*!< Endpoint C response register set/clear */
N#define     REG_USBD_EPCMPS         (USBD_BA+0xC8)  /*!< Endpoint C max packet size register */
N#define     REG_USBD_EPCTXCNT       (USBD_BA+0xCC)  /*!< Endpoint C transfer count register */
N#define     REG_USBD_EPCCFG         (USBD_BA+0xD0)  /*!< Endpoint C configuration register */
N#define     REG_USBD_EPCBUFSTART    (USBD_BA+0xD4)  /*!< Endpoint C ram start address register */
N#define     REG_USBD_EPCBUFEND      (USBD_BA+0xD8)  /*!< Endpoint C ram end address register */
N
N#define     REG_USBD_EPDDAT         (USBD_BA+0xDC)  /*!< Endpoint D data buffer register */
N#define     REG_USBD_EPDINTSTS      (USBD_BA+0xE0)  /*!< Endpoint D interrupt status register */
N#define     REG_USBD_EPDINTEN       (USBD_BA+0xE4)  /*!< Endpoint D interrupt enable register */
N#define     REG_USBD_EPDDATCNT      (USBD_BA+0xE8)  /*!< Data count available in endpoint D buffer */
N#define     REG_USBD_EPDRSPCTL      (USBD_BA+0xEC)  /*!< Endpoint D response register set/clear */
N#define     REG_USBD_EPDMPS         (USBD_BA+0xF0)  /*!< Endpoint D max packet size register */
N#define     REG_USBD_EPDTXCNT       (USBD_BA+0xF4)  /*!< Endpoint D transfer count register */
N#define     REG_USBD_EPDCFG         (USBD_BA+0xF8)  /*!< Endpoint D configuration register */
N#define     REG_USBD_EPDBUFSTART    (USBD_BA+0xFC)  /*!< Endpoint D ram start address register */
N#define     REG_USBD_EPDBUFEND      (USBD_BA+0x100) /*!< Endpoint D ram end address register */
N
N#define     REG_USBD_EPEDAT         (USBD_BA+0x104) /*!< Endpoint E data buffer register */
N#define     REG_USBD_EPEINTSTS      (USBD_BA+0x108) /*!< Endpoint E interrupt status register */
N#define     REG_USBD_EPEINTEN       (USBD_BA+0x10C) /*!< Endpoint E interrupt enable register */
N#define     REG_USBD_EPEDATCNT      (USBD_BA+0x110) /*!< Data count available in endpoint E buffer */
N#define     REG_USBD_EPERSPCTL      (USBD_BA+0x114) /*!< Endpoint E response register set/clear */
N#define     REG_USBD_EPEMPS         (USBD_BA+0x118) /*!< Endpoint E max packet size register */
N#define     REG_USBD_EPETXCNT       (USBD_BA+0x11C) /*!< Endpoint E transfer count register */
N#define     REG_USBD_EPECFG         (USBD_BA+0x120) /*!< Endpoint E configuration register */
N#define     REG_USBD_EPEBUFSTART    (USBD_BA+0x124) /*!< Endpoint E ram start address register */
N#define     REG_USBD_EPEBUFEND      (USBD_BA+0x128) /*!< Endpoint E ram end address register */
N
N#define     REG_USBD_EPFDAT         (USBD_BA+0x12C) /*!< Endpoint F data buffer register */
N#define     REG_USBD_EPFINTSTS      (USBD_BA+0x130) /*!< Endpoint F interrupt status register */
N#define     REG_USBD_EPFINTEN       (USBD_BA+0x134) /*!< Endpoint F interrupt enable register */
N#define     REG_USBD_EPFDATCNT      (USBD_BA+0x138) /*!< Data count available in endpoint F buffer */
N#define     REG_USBD_EPFRSPCTL      (USBD_BA+0x13C) /*!< Endpoint F response register set/clear */
N#define     REG_USBD_EPFMPS         (USBD_BA+0x140) /*!< Endpoint F max packet size register */
N#define     REG_USBD_EPFTXCNT       (USBD_BA+0x144) /*!< Endpoint F transfer count register */
N#define     REG_USBD_EPFCFG         (USBD_BA+0x148) /*!< Endpoint F configuration register */
N#define     REG_USBD_EPFBUFSTART    (USBD_BA+0x14C) /*!< Endpoint F ram start address register */
N#define     REG_USBD_EPFBUFEND      (USBD_BA+0x150) /*!< Endpoint F ram end address register */
N
N#define     REG_USBD_EPGDAT         (USBD_BA+0x154) /*!< Endpoint G data buffer register */
N#define     REG_USBD_EPGINTSTS      (USBD_BA+0x158) /*!< Endpoint G interrupt status register */
N#define     REG_USBD_EPGINTEN       (USBD_BA+0x15C) /*!< Endpoint G interrupt enable register */
N#define     REG_USBD_EPGDATCNT      (USBD_BA+0x160) /*!< Data count available in endpoint G buffer */
N#define     REG_USBD_EPGRSPCTL      (USBD_BA+0x164) /*!< Endpoint G response register set/clear */
N#define     REG_USBD_EPGMPS         (USBD_BA+0x168) /*!< Endpoint G max packet size register */
N#define     REG_USBD_EPGTXCNT       (USBD_BA+0x16C) /*!< Endpoint G transfer count register */
N#define     REG_USBD_EPGCFG         (USBD_BA+0x170) /*!< Endpoint G configuration register */
N#define     REG_USBD_EPGBUFSTART    (USBD_BA+0x174) /*!< Endpoint G ram start address register */
N#define     REG_USBD_EPGBUFEND      (USBD_BA+0x178) /*!< Endpoint G ram end address register */
N
N#define     REG_USBD_EPHDAT         (USBD_BA+0x17C) /*!< Endpoint H data buffer register */
N#define     REG_USBD_EPHINTSTS      (USBD_BA+0x180) /*!< Endpoint H interrupt status register */
N#define     REG_USBD_EPHINTEN       (USBD_BA+0x184) /*!< Endpoint H interrupt enable register */
N#define     REG_USBD_EPHDATCNT      (USBD_BA+0x188) /*!< Data count available in endpoint H buffer */
N#define     REG_USBD_EPHRSPCTL      (USBD_BA+0x18C) /*!< Endpoint H response register set/clear */
N#define     REG_USBD_EPHMPS         (USBD_BA+0x190) /*!< Endpoint H max packet size register */
N#define     REG_USBD_EPHTXCNT       (USBD_BA+0x194) /*!< Endpoint H transfer count register */
N#define     REG_USBD_EPHCFG         (USBD_BA+0x198) /*!< Endpoint H configuration register */
N#define     REG_USBD_EPHBUFSTART    (USBD_BA+0x19C) /*!< Endpoint H ram start address register */
N#define     REG_USBD_EPHBUFEND      (USBD_BA+0x1A0) /*!< Endpoint H ram end address register */
N
N#define     REG_USBD_EPIDAT         (USBD_BA+0x1A4) /*!< Endpoint I data buffer register */
N#define     REG_USBD_EPIINTSTS      (USBD_BA+0x1A8) /*!< Endpoint I interrupt status register */
N#define     REG_USBD_EPIINTEN       (USBD_BA+0x1AC) /*!< Endpoint I interrupt enable register */
N#define     REG_USBD_EPIDATCNT      (USBD_BA+0x1B0) /*!< Data count available in endpoint I buffer */
N#define     REG_USBD_EPIRSPCTL      (USBD_BA+0x1B4) /*!< Endpoint I response register set/clear */
N#define     REG_USBD_EPIMPS         (USBD_BA+0x1B8) /*!< Endpoint I max packet size register */
N#define     REG_USBD_EPITXCNT       (USBD_BA+0x1BC) /*!< Endpoint I transfer count register */
N#define     REG_USBD_EPICFG         (USBD_BA+0x1C0) /*!< Endpoint I configuration register */
N#define     REG_USBD_EPIBUFSTART    (USBD_BA+0x1C4) /*!< Endpoint I ram start address register */
N#define     REG_USBD_EPIBUFEND      (USBD_BA+0x1C8) /*!< Endpoint I ram end address register */
N
N#define     REG_USBD_EPJDAT         (USBD_BA+0x1CC) /*!< Endpoint J data buffer register */
N#define     REG_USBD_EPJINTSTS      (USBD_BA+0x1D0) /*!< Endpoint J interrupt status register */
N#define     REG_USBD_EPJINTEN       (USBD_BA+0x1D4) /*!< Endpoint J interrupt enable register */
N#define     REG_USBD_EPJDATCNT      (USBD_BA+0x1D8) /*!< Data count available in endpoint J buffer */
N#define     REG_USBD_EPJRSPCTL      (USBD_BA+0x1DC) /*!< Endpoint J response register set/clear */
N#define     REG_USBD_EPJMPS         (USBD_BA+0x1E0) /*!< Endpoint J max packet size register */
N#define     REG_USBD_EPJTXCNT       (USBD_BA+0x1E4) /*!< Endpoint J transfer count register */
N#define     REG_USBD_EPJCFG         (USBD_BA+0x1E8) /*!< Endpoint J configuration register */
N#define     REG_USBD_EPJBUFSTART    (USBD_BA+0x1EC) /*!< Endpoint J ram start address register */
N#define     REG_USBD_EPJBUFEND      (USBD_BA+0x1F0) /*!< Endpoint J ram end address register */
N
N#define     REG_USBD_EPKDAT         (USBD_BA+0x1F4) /*!< Endpoint K data buffer register */
N#define     REG_USBD_EPKINTSTS      (USBD_BA+0x1F8) /*!< Endpoint K interrupt status register */
N#define     REG_USBD_EPKINTEN       (USBD_BA+0x1FC) /*!< Endpoint K interrupt enable register */
N#define     REG_USBD_EPKDATCNT      (USBD_BA+0x200) /*!< Data count available in endpoint K buffer */
N#define     REG_USBD_EPKRSPCTL      (USBD_BA+0x204) /*!< Endpoint K response register set/clear */
N#define     REG_USBD_EPKMPS         (USBD_BA+0x208) /*!< Endpoint K max packet size register */
N#define     REG_USBD_EPKTXCNT       (USBD_BA+0x20C) /*!< Endpoint K transfer count register */
N#define     REG_USBD_EPKCFG         (USBD_BA+0x210) /*!< Endpoint K configuration register */
N#define     REG_USBD_EPKBUFSTART    (USBD_BA+0x214) /*!< Endpoint K ram start address register */
N#define     REG_USBD_EPKBUFEND      (USBD_BA+0x218) /*!< Endpoint K ram end address register */
N
N#define     REG_USBD_EPLDAT         (USBD_BA+0x21C) /*!< Endpoint L data buffer register */
N#define     REG_USBD_EPLINTSTS      (USBD_BA+0x220) /*!< Endpoint L interrupt status register */
N#define     REG_USBD_EPLINTEN       (USBD_BA+0x224) /*!< Endpoint L interrupt enable register */
N#define     REG_USBD_EPLDATCNT      (USBD_BA+0x228) /*!< Data count available in endpoint L buffer */
N#define     REG_USBD_EPLRSPCTL      (USBD_BA+0x22C) /*!< Endpoint L response register set/clear */
N#define     REG_USBD_EPLMPS         (USBD_BA+0x230) /*!< Endpoint L max packet size register */
N#define     REG_USBD_EPLTXCNT       (USBD_BA+0x234) /*!< Endpoint L transfer count register */
N#define     REG_USBD_EPLCFG         (USBD_BA+0x238) /*!< Endpoint L configuration register */
N#define     REG_USBD_EPLBUFSTART    (USBD_BA+0x23C) /*!< Endpoint L ram start address register */
N#define     REG_USBD_EPLBUFEND      (USBD_BA+0x240) /*!< Endpoint L ram end address register */
N#define     REG_USBD_DMAADDR        (USBD_BA+0x700) /*!< AHB_DMA address register */
N#define     REG_USBD_PHYCTL         (USBD_BA+0x704) /*!< USB PHY control register */
N
N/**@}*/ /* end of USBD register group */
N
N
N/*----------------------  LCD Display Interface Controller -------------------------*/
N/**
N    @addtogroup LCM  LCD Display Interface Controller(LCM)
N    Memory Mapped Structure for LCM Controller
N@{ */
N
N#define     REG_LCM_DCCS        (LCM_BA+0x00)  /*!< Display Controller Control/Status Register */
N#define     REG_LCM_DEV_CTRL    (LCM_BA+0x04)  /*!< Display Output Device Control Register */
N#define     REG_LCM_MPU_CMD     (LCM_BA+0x08)  /*!< MPU-Interface LCD Write Command */
N#define     REG_LCM_INT_CS      (LCM_BA+0x0c)  /*!< Interrupt Control/Status Register */
N#define     REG_LCM_CRTC_SIZE   (LCM_BA+0x10)  /*!< CRTC Display Size Control Register */
N#define     REG_LCM_CRTC_DEND   (LCM_BA+0x14)  /*!< CRTC Display Enable End */
N#define     REG_LCM_CRTC_HR     (LCM_BA+0x18)  /*!< CRTC Internal Horizontal Retrace Control Register */
N#define     REG_LCM_CRTC_HSYNC  (LCM_BA+0x1C)  /*!< CRTC Horizontal Sync Control Register */
N#define     REG_LCM_CRTC_VR     (LCM_BA+0x20)  /*!< CRTC Internal Vertical Retrace Control Register */
N#define     REG_LCM_VA_BADDR0   (LCM_BA+0x24)  /*!< Video Stream Frame Buffer-0 Starting Address */
N#define     REG_LCM_VA_BADDR1   (LCM_BA+0x28)  /*!< Video Stream Frame Buffer-1 Starting Address */
N#define     REG_LCM_VA_FBCTRL   (LCM_BA+0x2C)  /*!< Video Stream Frame Buffer Control Register */
N#define     REG_LCM_VA_SCALE    (LCM_BA+0x30)  /*!< Video Stream Scaling Control Register */
N#define     REG_LCM_VA_WIN      (LCM_BA+0x38)  /*!< Image Stream Active Window Coordinates */
N#define     REG_LCM_VA_STUFF    (LCM_BA+0x3C)  /*!< Image Stream Stuff Pixel */
N#define     REG_LCM_OSD_WINS    (LCM_BA+0x40)  /*!< OSD Window Starting Coordinates */
N#define     REG_LCM_OSD_WINE    (LCM_BA+0x44)  /*!< OSD Window Ending Coordinates */
N#define     REG_LCM_OSD_BADDR   (LCM_BA+0x48)  /*!< OSD Stream Frame Buffer Starting Address */
N#define     REG_LCM_OSD_FBCTRL  (LCM_BA+0x4c)  /*!< OSD Stream Frame Buffer Control Register */
N#define     REG_LCM_OSD_OVERLAY (LCM_BA+0x50)  /*!< OSD Overlay Control Register */
N#define     REG_LCM_OSD_CKEY    (LCM_BA+0x54)  /*!< OSD Overlay Color-Key Pattern Register */
N#define     REG_LCM_OSD_CMASK   (LCM_BA+0x58)  /*!< OSD Overlay Color-Key Mask Register */
N#define     REG_LCM_OSD_SKIP1   (LCM_BA+0x5C)  /*!< OSD Window Skip1 Register */
N#define     REG_LCM_OSD_SKIP2   (LCM_BA+0x60)  /*!< OSD Window Skip2 Register */
N#define     REG_LCM_OSD_SCALE   (LCM_BA+0x64)  /*!< OSD horizontal up scaling control register */
N#define     REG_LCM_MPU_VSYNC   (LCM_BA+0x68)  /*!< MPU Vsync control register */
N#define     REG_LCM_HC_CTRL     (LCM_BA+0x6C)  /*!< Hardware cursor control Register */
N#define     REG_LCM_HC_POS      (LCM_BA+0x70)  /*!< Hardware cursot tip point potison on va picture */
N#define     REG_LCM_HC_WBCTRL   (LCM_BA+0x74)  /*!< Hardware Cursor Window Buffer Control Register */
N#define     REG_LCM_HC_BADDR    (LCM_BA+0x78)  /*!< Hardware cursor memory base address register */
N#define     REG_LCM_HC_COLOR0   (LCM_BA+0x7C)  /*!< Hardware cursor color ram register mapped to bpp = 0 */
N#define     REG_LCM_HC_COLOR1   (LCM_BA+0x80)  /*!< Hardware cursor color ram register mapped to bpp = 1 */
N#define     REG_LCM_HC_COLOR2   (LCM_BA+0x84)  /*!< Hardware cursor color ram register mapped to bpp = 2 */
N#define     REG_LCM_HC_COLOR3   (LCM_BA+0x88)  /*!< Hardware cursor color ram register mapped to bpp = 3 */
N
N/**@}*/ /* end of LCM register group */
N
N
N/*---------------------- I2S Interface Controller -------------------------*/
N/**
N    @addtogroup I2S I2S Interface Controller(I2S)
N    Memory Mapped Structure for I2S Controller
N@{ */
N
N#define     REG_ACTL_CON            (ACTL_BA+0x00)      /*!< Audio controller control register */
N#define     REG_ACTL_RESET          (ACTL_BA+0x04)      /*!< Sub block reset control register */
N#define     REG_ACTL_RDESB          (ACTL_BA+0x08)      /*!< DMA destination base address register for record */
N#define     REG_ACTL_RDES_LENGTH    (ACTL_BA+0x0C)      /*!< DMA destination length register for record */
N#define     REG_ACTL_RDESC          (ACTL_BA+0x10)      /*!< DMA destination current address for record */
N#define     REG_ACTL_PDESB          (ACTL_BA+0x14)      /*!< DMA destination current address for play */
N#define     REG_ACTL_PDES_LENGTH    (ACTL_BA+0x18)      /*!< DMA destination length register for play */
N#define     REG_ACTL_PDESC          (ACTL_BA+0x1C)      /*!< DMA destination current address register for play */
N#define     REG_ACTL_RSR            (ACTL_BA+0x20)      /*!< Record status register */
N#define     REG_ACTL_PSR            (ACTL_BA+0x24)      /*!< Play status register */
N#define     REG_ACTL_I2SCON         (ACTL_BA+0x28)      /*!< I2S control register */
N#define     REG_ACTL_COUNTER        (ACTL_BA+0x2C)      /*!< DMA count down values */
N#define     REG_ACTL_PCMCON         (ACTL_BA+0x30)      /*!< PCM interface control register */
N#define     REG_ACTL_PCMS1ST        (ACTL_BA+0x34)      /*!< PCM interface slot1 start register */
N#define     REG_ACTL_PCMS2ST        (ACTL_BA+0x38)      /*!< PCM interface slot2 start register */
N#define     REG_ACTL_RDESB2         (ACTL_BA+0x40)      /*!< DMA destination base address register for record right channel */
N#define     REG_ACTL_PDESB2         (ACTL_BA+0x44)      /*!< DMA destination base address register for play right channel */
N
N/**@}*/ /* end of I2S register group */
N
N/*---------------------- 2D Graphic Engine -------------------------*/
N/**
N    @addtogroup GE2D 2D Graphic Engine(GE2D)
N    Memory Mapped Structure for GE2D Controller
N@{ */
N
N#define     REG_GE2D_TRG            (GE_BA+0x00)  /*!< Graphic Engine Trigger Control Register */
N#define     REG_GE2D_XYSORG         (GE_BA+0x04)  /*!< Graphic Engine XY Mode Source Origin Starting Register */
N#define     REG_GE2D_TCNTVHSF       (GE_BA+0x08)  /*!< Graphic Engine Tile Width/Height or V/H Scale Factor N/M */
N#define     REG_GE2D_XYRRP          (GE_BA+0x0C)  /*!< Graphic Engine Rotate Reference Point XY Address */
N#define     REG_GE2D_INTSTS         (GE_BA+0x10)  /*!< Graphic Engine Interrupt Status Register */
N#define     REG_GE2D_PATSA          (GE_BA+0x14)  /*!< Graphic Engine Pattern Location Starting Address Register */
N#define     REG_GE2D_BETSC          (GE_BA+0x18)  /*!< GE Bresenham Error Term Stepping Constant Register */
N#define     REG_GE2D_BIEPC          (GE_BA+0x1C)  /*!< GE Bresenham Initial Error, Pixel Count Major M Register */
N#define     REG_GE2D_CTL            (GE_BA+0x20)  /*!< Graphic Engine Control Register */
N#define     REG_GE2D_BGCOLR         (GE_BA+0x24)  /*!< Graphic Engine Background Color Register */
N#define     REG_GE2D_FGCOLR         (GE_BA+0x28)  /*!< Graphic Engine Foreground Color Register */
N#define     REG_GE2D_TRNSCOLR       (GE_BA+0x2C)  /*!< Graphic Engine Transparency Color Register */
N#define     REG_GE2D_TCMSK          (GE_BA+0x30)  /*!< Graphic Engine Transparency Color Mask Register */
N#define     REG_GE2D_XYDORG         (GE_BA+0x34)  /*!< Graphic Engine XY Mode Display Origin Starting Register */
N#define     REG_GE2D_SDPITCH        (GE_BA+0x38)  /*!< Graphic Engine Source/Destination Pitch Register */
N#define     REG_GE2D_SRCSPA         (GE_BA+0x3C)  /*!< Graphic Engine Source Start XY/Linear Address Register */
N#define     REG_GE2D_DSTSPA         (GE_BA+0x40)  /*!< Graphic Engine Destination Start XY/Linear Register */
N#define     REG_GE2D_RTGLSZ         (GE_BA+0x44)  /*!< Graphic Engine Dimension XY/Linear Register */
N#define     REG_GE2D_CLPBTL         (GE_BA+0x48)  /*!< Graphic Engine Clipping Boundary Top/Left Register */
N#define     REG_GE2D_CLPBBR         (GE_BA+0x4C)  /*!< Graphic Engine Clipping Boundary Bottom/Right Register */
N#define     REG_GE2D_PTNA           (GE_BA+0x50)  /*!< Graphic Engine Pattern A Register */
N#define     REG_GE2D_PTNB           (GE_BA+0x54)  /*!< Graphic Engine Pattern B Register */
N#define     REG_GE2D_WRPLNMSK       (GE_BA+0x58)  /*!< Graphic Engine Write Plane Mask Register */
N#define     REG_GE2D_MISCTL         (GE_BA+0x5C)  /*!< Graphic Engine Miscellaneous Control Register */
N#define     REG_GE2D_GEHBDW0        (GE_BA+0x60)  /*!< Graphic Engine HostBLT data Port 0 Register */
N#define     REG_GE2D_GEHBDW1        (GE_BA+0x64)  /*!< Graphic Engine HostBLT data Port 1 Register */
N#define     REG_GE2D_GEHBDW2        (GE_BA+0x68)  /*!< Graphic Engine HostBLT data Port 2 Register */
N#define     REG_GE2D_GEHBDW3        (GE_BA+0x6C)  /*!< Graphic Engine HostBLT data Port 3 Register */
N#define     REG_GE2D_GEHBDW4        (GE_BA+0x70)  /*!< Graphic Engine HostBLT data Port 4 Register */
N#define     REG_GE2D_GEHBDW5        (GE_BA+0x74)  /*!< Graphic Engine HostBLT data Port 5 Register */
N#define     REG_GE2D_GEHBDW6        (GE_BA+0x78)  /*!< Graphic Engine HostBLT data Port 6 Register */
N#define     REG_GE2D_GEHBDW7        (GE_BA+0x7C)  /*!< Graphic Engine HostBLT data Port 7 Register */
N
N/**@}*/ /* end of GE2D register group */
N
N/*---------------------- Flash Memory Interface -------------------------*/
N/**
N    @addtogroup FMI Flash Memory Interface(FMI)
N    Memory Mapped Structure for FMI Controller
N@{ */
N
N/* DMAC Control Registers*/
N#define     REG_FMI_BUFFER      (FMI_BA+0x000)   /*!< FMI Embedded Buffer Word */
N#define     REG_FMI_DMACTL      (FMI_BA+0x400)   /*!< FMI DMA Control Register */
N#define     REG_FMI_DMASA       (FMI_BA+0x408)   /*!< FMI DMA Transfer Starting Address Register */
N#define     REG_FMI_DMABCNT     (FMI_BA+0x40C)   /*!< FMI DMA Transfer Byte Count Register */
N#define     REG_FMI_DMAINTEN    (FMI_BA+0x410)   /*!< FMI DMA Interrupt Enable Register */
N#define     REG_FMI_DMAINTSTS   (FMI_BA+0x414)   /*!< FMI DMA Interrupt Status Register */
N
N#define     REG_FMI_CTL         (FMI_BA+0x800)   /*!< Global Control and Status Register */
N#define     REG_FMI_INTEN       (FMI_BA+0x804)   /*!< Global Interrupt Control Register */
N#define     REG_FMI_INTSTS      (FMI_BA+0x808)   /*!< Global Interrupt Status Register */
N
N/* eMMC Registers */
N#define     REG_FMI_EMMCCTL     (FMI_BA+0x820)   /*!< eMMC control and status register */
N#define     REG_FMI_EMMCCMD     (FMI_BA+0x824)   /*!< eMMC command argument register */
N#define     REG_FMI_EMMCINTEN   (FMI_BA+0x828)   /*!< eMMC interrupt enable register */
N#define     REG_FMI_EMMCINTSTS  (FMI_BA+0x82C)   /*!< eMMC interrupt status register */
N#define     REG_FMI_EMMCRESP0   (FMI_BA+0x830)   /*!< eMMC receive response token register 0 */
N#define     REG_FMI_EMMCRESP1   (FMI_BA+0x834)   /*!< eMMC receive response token register 1 */
N#define     REG_FMI_EMMCBLEN    (FMI_BA+0x838)   /*!< eMMC block length register */
N#define     REG_FMI_EMMCTOUT    (FMI_BA+0x83C)   /*!< eMMC block length register */
N
N/* NAND-type Flash Registers */
N#define     REG_NANDCTL         (FMI_BA+0x8A0)   /*!< NAND Flash Control and Status Register */
N#define     REG_NANDTMCTL       (FMI_BA+0x8A4)   /*!< NAND Flash Timing Control Register */
N#define     REG_NANDINTEN       (FMI_BA+0x8A8)   /*!< NAND Flash Interrupt Control Register */
N#define     REG_NANDINTSTS      (FMI_BA+0x8AC)   /*!< NAND Flash Interrupt Status Register */
N#define     REG_NANDCMD         (FMI_BA+0x8B0)   /*!< NAND Flash Command Port Register */
N#define     REG_NANDADDR        (FMI_BA+0x8B4)   /*!< NAND Flash Address Port Register */
N#define     REG_NANDDATA        (FMI_BA+0x8B8)   /*!< NAND Flash Data Port Register */
N#define     REG_NANDRACTL       (FMI_BA+0x8BC)   /*!< NAND Flash Redundant Area Control Register */
N#define     REG_NANDECTL        (FMI_BA+0x8C0)   /*!< NAND Flash Extend Control Regsiter */
N#define     REG_NANDECCES0      (FMI_BA+0x8D0)   /*!< NAND Flash ECC Error Status 0 */
N#define     REG_NANDECCES1      (FMI_BA+0x8D4)   /*!< NAND Flash ECC Error Status 1 */
N#define     REG_NANDECCES2      (FMI_BA+0x8D8)   /*!< NAND Flash ECC Error Status 2 */
N#define     REG_NANDECCES3      (FMI_BA+0x8DC)   /*!< NAND Flash ECC Error Status 3 */
N#define     REG_NANDPROTA0      (FMI_BA+0x8E0)   /*!< NAND Flash Protect Region End Address 0 */
N#define     REG_NANDPROTA1      (FMI_BA+0x8E4)   /*!< NAND Flash Protect Region End Address 1 */
N
N/* NAND-type Flash BCH Error Address Registers */
N#define     REG_NANDECCEA0      (FMI_BA+0x900)   /*!< NAND Flash ECC Error Byte Address 0 */
N#define     REG_NANDECCEA1      (FMI_BA+0x904)   /*!< NAND Flash ECC Error Byte Address 1 */
N#define     REG_NANDECCEA2      (FMI_BA+0x908)   /*!< NAND Flash ECC Error Byte Address 2 */
N#define     REG_NANDECCEA3      (FMI_BA+0x90C)   /*!< NAND Flash ECC Error Byte Address 3 */
N#define     REG_NANDECCEA4      (FMI_BA+0x910)   /*!< NAND Flash ECC Error Byte Address 4 */
N#define     REG_NANDECCEA5      (FMI_BA+0x914)   /*!< NAND Flash ECC Error Byte Address 5 */
N#define     REG_NANDECCEA6      (FMI_BA+0x918)   /*!< NAND Flash ECC Error Byte Address 6 */
N#define     REG_NANDECCEA7      (FMI_BA+0x91C)   /*!< NAND Flash ECC Error Byte Address 7 */
N#define     REG_NANDECCEA8      (FMI_BA+0x920)   /*!< NAND Flash ECC Error Byte Address 8 */
N#define     REG_NANDECCEA9      (FMI_BA+0x924)   /*!< NAND Flash ECC Error Byte Address 9 */
N#define     REG_NANDECCEA10     (FMI_BA+0x928)   /*!< NAND Flash ECC Error Byte Address 10 */
N#define     REG_NANDECCEA11     (FMI_BA+0x92C)   /*!< NAND Flash ECC Error Byte Address 11 */
N
N/* NAND-type Flash BCH Error Data Registers */
N#define     REG_NANDECCED0      (FMI_BA+0x960)   /*!< NAND Flash ECC Error Data Register 0 */
N#define     REG_NANDECCED1      (FMI_BA+0x964)   /*!< NAND Flash ECC Error Data Register 1 */
N#define     REG_NANDECCED2      (FMI_BA+0x968)   /*!< NAND Flash ECC Error Data Register 2 */
N#define     REG_NANDECCED3      (FMI_BA+0x96C)   /*!< NAND Flash ECC Error Data Register 3 */
N#define     REG_NANDECCED4      (FMI_BA+0x970)   /*!< NAND Flash ECC Error Data Register 4 */
N#define     REG_NANDECCED5      (FMI_BA+0x974)   /*!< NAND Flash ECC Error Data Register 5 */
N
N/* NAND-type Flash Redundant Area Registers */
N#define     REG_NANDRA0         (FMI_BA+0xA00)   /*!< NAND Flash Redundant Area Register */
N#define     REG_NANDRA1         (FMI_BA+0xA04)   /*!< NAND Flash Redundant Area Register */
N
N/**@}*/ /* end of FMI register group */
N
N
N/*---------------------- SD/SDIO Host Controller -------------------------*/
N/**
N    @addtogroup SDH SD/SDIO Host Controller(SDH)
N    Memory Mapped Structure for SDH Controller
N@{ */
N
N/* DMAC Control Registers*/
N#define     REG_SDH_FB0         (SDH_BA+0x000)   /*!< SD Host Embedded Buffer Word */
N#define     REG_SDH_DMACTL      (SDH_BA+0x400)   /*!< SD Host DMA Control and Status Register */
N#define     REG_SDH_DMASA       (SDH_BA+0x408)   /*!< SD Host DMA Transfer Starting Address Register */
N#define     REG_SDH_DMABCNT     (SDH_BA+0x40C)   /*!< SD Host DMA Transfer Byte Count Register */
N#define     REG_SDH_DMAINTEN    (SDH_BA+0x410)   /*!< SD Host DMA Interrupt Enable Register */
N#define     REG_SDH_DMAINTSTS   (SDH_BA+0x414)   /*!< SD Host DMA Interrupt Status Register */
N
N#define     REG_SDH_GCTL        (SDH_BA+0x800)   /*!< SD Host Global Control and Status Register */
N#define     REG_SDH_GINTEN      (SDH_BA+0x804)   /*!< SD Host Global Interrupt Control Register */
N#define     REG_SDH_GINTSTS     (SDH_BA+0x808)   /*!< SD Host Global Interrupt Status Register */
N
N/* Secure Digit Registers */
N#define     REG_SDH_CTL         (SDH_BA+0x820)   /*!< SD Host control and status register */
N#define     REG_SDH_CMD         (SDH_BA+0x824)   /*!< SD Host command argument register */
N#define     REG_SDH_INTEN       (SDH_BA+0x828)   /*!< SD Host interrupt enable register */
N#define     REG_SDH_INTSTS      (SDH_BA+0x82C)   /*!< SD Host interrupt status register */
N#define     REG_SDH_RESP0       (SDH_BA+0x830)   /*!< SD Host receive response token register 0 */
N#define     REG_SDH_RESP1       (SDH_BA+0x834)   /*!< SD Host receive response token register 1 */
N#define     REG_SDH_BLEN        (SDH_BA+0x838)   /*!< SD Host block length register */
N#define     REG_SDH_TMOUT       (SDH_BA+0x83C)   /*!< SD Host Response/Data-in Time-out register */
N#define     REG_SDH_ECTL        (SDH_BA+0x840)   /*!< SD Host Extend Control Register */
N
N/**@}*/ /* end of SDH register group */
N
N
N
N/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
N/**
N    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
N    Memory Mapped Structure for UART Controller
N@{ */
N
N#define     REG_UART0_RBR    (UART0_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART0_THR    (UART0_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART0_IER    (UART0_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART0_FCR    (UART0_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART0_LCR    (UART0_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART0_MCR   (UART0_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART0_MSR    (UART0_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART0_FSR    (UART0_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART0_ISR   (UART0_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART0_TOR       (UART0_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART0_BAUD      (UART0_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART0_IRCR   (UART0_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART0_ALT_CSR   (UART0_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART0_FUN_SEL   (UART0_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART0_LIN_CTL   (UART0_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART0_LIN_SR    (UART0_BA+0x38)  /*!< LIN Status Register */
N
N
N
N
N/*
N  UART1 Control Registers
N*/
N#define     REG_UART1_RBR   (UART1_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART1_THR   (UART1_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART1_IER   (UART1_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART1_FCR   (UART1_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART1_LCR   (UART1_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART1_MCR   (UART1_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART1_MSR   (UART1_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART1_FSR       (UART1_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART1_ISR   (UART1_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART1_TOR       (UART1_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART1_BAUD      (UART1_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART1_IRCR      (UART1_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART1_ALT_CSR   (UART1_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART1_FUN_SEL   (UART1_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART1_LIN_CTL   (UART1_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART1_LIN_SR    (UART1_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART2 Control Registers
N*/
N#define     REG_UART2_RBR   (UART2_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART2_THR   (UART2_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART2_IER   (UART2_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART2_FCR   (UART2_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART2_LCR   (UART2_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART2_MCR   (UART2_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART2_MSR   (UART2_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART2_FSR   (UART2_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART2_ISR   (UART2_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART2_TOR   (UART2_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART2_BAUD  (UART2_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART2_IRCR  (UART2_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART2_ALT_CSR   (UART2_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART2_FUN_SEL   (UART2_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART2_LIN_CTL   (UART2_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART2_LIN_SR    (UART2_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART3 Control Registers
N*/
N#define     REG_UART3_RBR   (UART3_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART3_THR   (UART3_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART3_IER   (UART3_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART3_FCR   (UART3_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART3_LCR   (UART3_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART3_MCR   (UART3_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART3_MSR   (UART3_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART3_FSR   (UART3_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART3_ISR   (UART3_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART3_TOR   (UART3_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART3_BAUD  (UART3_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART3_IRCR  (UART3_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART3_ALT_CSR   (UART3_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART3_FUN_SEL   (UART3_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART3_LIN_CTL   (UART3_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART3_LIN_SR    (UART3_BA+0x38)  /*!< LIN Status Register */
N
N
N/*
N  UART4 Control Registers
N*/
N#define     REG_UART4_RBR   (UART4_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART4_THR   (UART4_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART4_IER   (UART4_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART4_FCR   (UART4_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART4_LCR   (UART4_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART4_MCR   (UART4_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART4_MSR   (UART4_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART4_FSR   (UART4_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART4_ISR   (UART4_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART4_TOR   (UART4_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART4_BAUD  (UART4_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART4_IRCR  (UART4_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART4_ALT_CSR   (UART4_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART4_FUN_SEL   (UART4_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART4_LIN_CTL   (UART4_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART4_LIN_SR    (UART4_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART5 Control Registers
N*/
N#define     REG_UART5_RBR   (UART5_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART5_THR   (UART5_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART5_IER   (UART5_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART5_FCR   (UART5_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART5_LCR   (UART5_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART5_MCR   (UART5_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART5_MSR   (UART5_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART5_FSR   (UART5_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART5_ISR   (UART5_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART5_TOR   (UART5_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART5_BAUD  (UART5_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART5_IRCR  (UART5_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART5_ALT_CSR   (UART5_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART5_FUN_SEL   (UART5_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART5_LIN_CTL   (UART5_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART5_LIN_SR    (UART5_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART6 Control Registers
N*/
N#define     REG_UART6_RBR   (UART6_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART6_THR   (UART6_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART6_IER   (UART6_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART6_FCR   (UART6_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART6_LCR   (UART6_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART6_MCR   (UART6_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART6_MSR   (UART6_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART6_FSR   (UART6_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART6_ISR   (UART6_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART6_TOR   (UART6_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART6_BAUD  (UART6_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART6_IRCR  (UART6_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART6_ALT_CSR   (UART6_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART6_FUN_SEL   (UART6_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART6_LIN_CTL   (UART6_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART6_LIN_SR    (UART6_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART7 Control Registers
N*/
N#define     REG_UART7_RBR   (UART7_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART7_THR   (UART7_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART7_IER   (UART7_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART7_FCR   (UART7_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART7_LCR   (UART7_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART7_MCR   (UART7_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART7_MSR   (UART7_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART7_FSR   (UART7_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART7_ISR   (UART7_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART7_TOR   (UART7_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART7_BAUD  (UART7_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART7_IRCR  (UART7_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART7_ALT_CSR   (UART7_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART7_FUN_SEL   (UART7_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART7_LIN_CTL   (UART7_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART7_LIN_SR    (UART7_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART8 Control Registers
N*/
N#define     REG_UART8_RBR   (UART8_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART8_THR   (UART8_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART8_IER   (UART8_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART8_FCR   (UART8_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART8_LCR   (UART8_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART8_MCR   (UART8_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART8_MSR   (UART8_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART8_FSR   (UART8_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART8_ISR   (UART8_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART8_TOR   (UART8_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART8_BAUD  (UART8_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART8_IRCR  (UART8_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART8_ALT_CSR   (UART8_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART8_FUN_SEL   (UART8_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART8_LIN_CTL   (UART8_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART8_LIN_SR    (UART8_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART9 Control Registers
N*/
N#define     REG_UART9_RBR   (UART9_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART9_THR   (UART9_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART9_IER   (UART9_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART9_FCR   (UART9_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART9_LCR   (UART9_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART9_MCR   (UART9_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART9_MSR   (UART9_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART9_FSR   (UART9_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART9_ISR   (UART9_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART9_TOR   (UART9_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART9_BAUD  (UART9_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART9_IRCR  (UART9_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART9_ALT_CSR   (UART9_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART9_FUN_SEL   (UART9_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART9_LIN_CTL   (UART9_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART9_LIN_SR    (UART9_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UARTA Control Registers
N*/
N#define     REG_UARTA_RBR   (UARTA_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UARTA_THR   (UARTA_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UARTA_IER   (UARTA_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UARTA_FCR   (UARTA_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UARTA_LCR   (UARTA_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UARTA_MCR   (UARTA_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UARTA_MSR   (UARTA_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UARTA_FSR   (UARTA_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UARTA_ISR   (UARTA_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UARTA_TOR   (UARTA_BA+0x20)  /*!< Time-out Register */
N#define     REG_UARTA_BAUD  (UARTA_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UARTA_IRCR  (UARTA_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UARTA_ALT_CSR   (UARTA_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UARTA_FUN_SEL   (UARTA_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UARTA_LIN_CTL   (UARTA_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UARTA_LIN_SR    (UARTA_BA+0x38)  /*!< LIN Status Register */
N
N
N/**@}*/ /* end of UART register group */
N
N
N/*---------------------- Timer Controller -------------------------*/
N/**
N    @addtogroup TIMER Timer Controller(TIMER)
N    Memory Mapped Structure for TIMER Controller
N@{ */
N
N#define     REG_TMR0_TCSR   (TMR0_BA+0x00)  /*!< Timer Control and Status Register 0  */
N#define     REG_TMR0_TICR   (TMR0_BA+0x04)  /*!< Timer Compare Register 0             */
N#define     REG_TMR0_TDR    (TMR0_BA+0x08)  /*!< Timer Data Register 0                */
N
N#define     REG_TMR1_TCSR   (TMR1_BA+0x00)  /*!< Timer Control and Status Register 1  */
N#define     REG_TMR1_TICR   (TMR1_BA+0x04)  /*!< Timer Compare Register 1             */
N#define     REG_TMR1_TDR    (TMR1_BA+0x08)  /*!< Timer Data Register 1                */
N
N#define     REG_TMR2_TCSR   (TMR2_BA+0x00)  /*!< Timer Control and Status Register 2  */
N#define     REG_TMR2_TICR   (TMR2_BA+0x04)  /*!< Timer Compare Register 2             */
N#define     REG_TMR2_TDR    (TMR2_BA+0x08)  /*!< Timer Data Register 2                */
N
N#define     REG_TMR3_TCSR   (TMR3_BA+0x00)  /*!< Timer Control and Status Register 3  */
N#define     REG_TMR3_TICR   (TMR3_BA+0x04)  /*!< Timer Compare Register 3             */
N#define     REG_TMR3_TDR    (TMR3_BA+0x08)  /*!< Timer Data Register 3                */
N
N#define     REG_TMR4_TCSR   (TMR4_BA+0x00)  /*!< Timer Control and Status Register 4  */
N#define     REG_TMR4_TICR   (TMR4_BA+0x04)  /*!< Timer Compare Register 4             */
N#define     REG_TMR4_TDR    (TMR4_BA+0x08)  /*!< Timer Data Register 4                */
N
N#define     REG_TMR_TISR    (TMR0_BA+0x60)  /*!< Timer Interrupt Status Register      */
N
N/**@}*/ /* end of TIMER register group */
N
N/*---------------------- Enhance Timer Controller -------------------------*/
N/**
N    @addtogroup ETIMER Enhance Timer Controller(ETIMER)
N    Memory Mapped Structure for TIMER Controller
N@{ */
N
N#define     REG_ETMR0_CTL       (ETMR0_BA+0x00)  /*!< Enhance Timer 0 Control Register */
N#define     REG_ETMR0_PRECNT    (ETMR0_BA+0x04)  /*!< Enhance Timer 0 Pre-Scale Counter Register */
N#define     REG_ETMR0_CMPR      (ETMR0_BA+0x08)  /*!< Enhance Timer 0 Compare Register */
N#define     REG_ETMR0_IER       (ETMR0_BA+0x0C)  /*!< Enhance Timer 0 Interrupt Enable Register */
N#define     REG_ETMR0_ISR       (ETMR0_BA+0x10)  /*!< Enhance Timer 0 Interrupt Status Register  */
N#define     REG_ETMR0_DR        (ETMR0_BA+0x14)  /*!< Enhance Timer 0 Data Register */
N#define     REG_ETMR0_TCAP      (ETMR0_BA+0x18)  /*!< Enhance Timer 0 Capture Data Register  */
N
N#define     REG_ETMR1_CTL       (ETMR1_BA+0x00)  /*!< Enhance Timer 1 Control Register */
N#define     REG_ETMR1_PRECNT    (ETMR1_BA+0x04)  /*!< Enhance Timer 1 Pre-Scale Counter Register */
N#define     REG_ETMR1_CMPR      (ETMR1_BA+0x08)  /*!< Enhance Timer 1 Compare Register */
N#define     REG_ETMR1_IER       (ETMR1_BA+0x0C)  /*!< Enhance Timer 1 Interrupt Enable Register */
N#define     REG_ETMR1_ISR       (ETMR1_BA+0x10)  /*!< Enhance Timer 1 Interrupt Status Register  */
N#define     REG_ETMR1_DR        (ETMR1_BA+0x14)  /*!< Enhance Timer 1 Data Register */
N#define     REG_ETMR1_TCAP      (ETMR1_BA+0x18)  /*!< Enhance Timer 1 Capture Data Register  */
N
N#define     REG_ETMR2_CTL       (ETMR2_BA+0x00)  /*!< Enhance Timer 2 Control Register */
N#define     REG_ETMR2_PRECNT    (ETMR2_BA+0x04)  /*!< Enhance Timer 2 Pre-Scale Counter Register */
N#define     REG_ETMR2_CMPR      (ETMR2_BA+0x08)  /*!< Enhance Timer 2 Compare Register */
N#define     REG_ETMR2_IER       (ETMR2_BA+0x0C)  /*!< Enhance Timer 2 Interrupt Enable Register */
N#define     REG_ETMR2_ISR       (ETMR2_BA+0x10)  /*!< Enhance Timer 2 Interrupt Status Register  */
N#define     REG_ETMR2_DR        (ETMR2_BA+0x14)  /*!< Enhance Timer 2 Data Register */
N#define     REG_ETMR2_TCAP      (ETMR2_BA+0x18)  /*!< Enhance Timer 2 Capture Data Register  */
N
N#define     REG_ETMR3_CTL       (ETMR3_BA+0x00)  /*!< Enhance Timer 3 Control Register */
N#define     REG_ETMR3_PRECNT    (ETMR3_BA+0x04)  /*!< Enhance Timer 3 Pre-Scale Counter Register */
N#define     REG_ETMR3_CMPR      (ETMR3_BA+0x08)  /*!< Enhance Timer 3 Compare Register */
N#define     REG_ETMR3_IER       (ETMR3_BA+0x0C)  /*!< Enhance Timer 3 Interrupt Enable Register */
N#define     REG_ETMR3_ISR       (ETMR3_BA+0x10)  /*!< Enhance Timer 3 Interrupt Status Register  */
N#define     REG_ETMR3_DR        (ETMR3_BA+0x14)  /*!< Enhance Timer 3 Data Register */
N#define     REG_ETMR3_TCAP      (ETMR3_BA+0x18)  /*!< Enhance Timer 3 Capture Data Register  */
N/**@}*/ /* end of ETIMER register group */
N
N/*---------------------- WDT Controller -------------------------*/
N/**
N    @addtogroup WDT Watch Dog Timer Controller(WDT)
N    Memory Mapped Structure for WDT Controller
N@{ */
N
N#define     REG_WDT_CTL         (WDT_BA+0x00)  /*!< WDT Control Register              */
N#define     REG_WDT_ATLCTL      (WDT_BA+0x04)  /*!< WDT Alternative Control Register  */
N
N/**@}*/ /* end of WDT register group */
N
N/*---------------------- WWDT Controller -------------------------*/
N/**
N    @addtogroup WWDT Window Watch Dog Timer Controller(WWDT)
N    Memory Mapped Structure for WWDT Controller
N@{ */
N
N#define     REG_WWDT_RLDCNT     (WWDT_BA+0x00)  /*!< WWDT Reload Counter Register             */
N#define     REG_WWDT_CTL        (WWDT_BA+0x04)  /*!< WWDT Control Register                    */
N#define     REG_WWDT_STATUS     (WWDT_BA+0x08)  /*!< WWDT Status Register                     */
N#define     REG_WWDT_CNT        (WWDT_BA+0x0C)  /*!< WWDT Counter Value Register              */
N
N/**@}*/ /* end of WWDT register group */
N
N/*---------------------- SC Host Interface -------------------------*/
N/**
N    @addtogroup SC Smart Card Host Interface (SC)
N    Memory Mapped Structure for Smart Card Host Interface
N@{ */
N
N#define     REG_SC0_DAT     (SC0_BA+0x00)  /*!< SC0 Receiving/Transmit Holding Buffer Register */
N#define     REG_SC0_CTL     (SC0_BA+0x04)  /*!< SC0 Control Register */
N#define     REG_SC0_ALTCTL  (SC0_BA+0x08)  /*!< SC0 Alternate Control Register  */
N#define     REG_SC0_EGT     (SC0_BA+0x0C)  /*!< SC0 Extend Guard Time Register  */
N#define     REG_SC0_RXTOUT  (SC0_BA+0x10)  /*!< SC0 Receive Buffer Time-out Register */
N#define     REG_SC0_ETUCTL  (SC0_BA+0x14)  /*!< SC0 ETU Control Register */
N#define     REG_SC0_INTEN   (SC0_BA+0x18)  /*!< SC0 Interrupt Enable Control Register */
N#define     REG_SC0_INTSTS  (SC0_BA+0x1C)  /*!< SC0 Interrupt Status Register */
N#define     REG_SC0_STATUS  (SC0_BA+0x20)  /*!< SC0 Status Register */
N#define     REG_SC0_PINCTL  (SC0_BA+0x24)  /*!< SC0 Pin Control State Register */
N#define     REG_SC0_TMRCTL0 (SC0_BA+0x28)  /*!< SC0 Internal Timer Control Register 0 */
N#define     REG_SC0_TMRCTL1 (SC0_BA+0x2C)  /*!< SC0 Internal Timer Control Register 1 */
N#define     REG_SC0_TMRCTL2 (SC0_BA+0x30)  /*!< SC0 Internal Timer Control Register 2 */
N#define     REG_SC0_UARTCTL (SC0_BA+0x34)  /*!< SC0 UART Mode Control Register */
N#define     REG_SC0_TMRDAT0 (SC0_BA+0x38)  /*!< SC0 Timer Current Data Register 0 */
N#define     REG_SC0_TMRDAT1 (SC0_BA+0x3C)  /*!< SC0 Timer Current Data Register 1 */
N
N#define     REG_SC1_DAT     (SC1_BA+0x00)  /*!< SC1 Receiving/Transmit Holding Buffer Register */
N#define     REG_SC1_CTL     (SC1_BA+0x04)  /*!< SC1 Control Register */
N#define     REG_SC1_ALTCTL  (SC1_BA+0x08)  /*!< SC1 Alternate Control Register  */
N#define     REG_SC1_EGT     (SC1_BA+0x0C)  /*!< SC1 Extend Guard Time Register  */
N#define     REG_SC1_RXTOUT  (SC1_BA+0x10)  /*!< SC1 Receive Buffer Time-out Register */
N#define     REG_SC1_ETUCTL  (SC1_BA+0x14)  /*!< SC1 ETU Control Register */
N#define     REG_SC1_INTEN   (SC1_BA+0x18)  /*!< SC1 Interrupt Enable Control Register */
N#define     REG_SC1_INTSTS  (SC1_BA+0x1C)  /*!< SC1 Interrupt Status Register */
N#define     REG_SC1_STATUS  (SC1_BA+0x20)  /*!< SC1 Status Register */
N#define     REG_SC1_PINCTL  (SC1_BA+0x24)  /*!< SC1 Pin Control State Register */
N#define     REG_SC1_TMRCTL0 (SC1_BA+0x28)  /*!< SC1 Internal Timer Control Register 0 */
N#define     REG_SC1_TMRCTL1 (SC1_BA+0x2C)  /*!< SC1 Internal Timer Control Register 1 */
N#define     REG_SC1_TMRCTL2 (SC1_BA+0x30)  /*!< SC1 Internal Timer Control Register 2 */
N#define     REG_SC1_UARTCTL (SC1_BA+0x34)  /*!< SC1 UART Mode Control Register */
N#define     REG_SC1_TMRDAT0 (SC1_BA+0x38)  /*!< SC1 Timer Current Data Register 0 */
N#define     REG_SC1_TMRDAT1 (SC1_BA+0x3C)  /*!< SC1 Timer Current Data Register 1 */
N
N/**@}*/ /* end of SC register group */
N
N
N/*---------------------- Advance Interrupt Controller -------------------------*/
N/**
N    @addtogroup AIC Advance Interrupt Controller(AIC)
N    Memory Mapped Structure for AIC Controller
N@{ */
N
N#define     REG_AIC_SCR1    (AIC_BA+0x00)    /*!< Source control register 1 */
N#define     REG_AIC_SCR2    (AIC_BA+0x04)    /*!< Source control register 2 */
N#define     REG_AIC_SCR3    (AIC_BA+0x08)    /*!< Source control register 3 */
N#define     REG_AIC_SCR4    (AIC_BA+0x0C)    /*!< Source control register 4 */
N#define     REG_AIC_SCR5    (AIC_BA+0x10)    /*!< Source control register 5 */
N#define     REG_AIC_SCR6    (AIC_BA+0x14)    /*!< Source control register 6 */
N#define     REG_AIC_SCR7    (AIC_BA+0x18)    /*!< Source control register 7 */
N#define     REG_AIC_SCR8    (AIC_BA+0x1C)    /*!< Source control register 8 */
N#define     REG_AIC_SCR9    (AIC_BA+0x20)    /*!< Source control register 9 */
N#define     REG_AIC_SCR10   (AIC_BA+0x24)    /*!< Source control register 10 */
N#define     REG_AIC_SCR11   (AIC_BA+0x28)    /*!< Source control register 11 */
N#define     REG_AIC_SCR12   (AIC_BA+0x2C)    /*!< Source control register 12 */
N#define     REG_AIC_SCR13   (AIC_BA+0x30)    /*!< Source control register 13 */
N#define     REG_AIC_SCR14   (AIC_BA+0x34)    /*!< Source control register 14 */
N#define     REG_AIC_SCR15   (AIC_BA+0x38)    /*!< Source control register 15 */
N#define     REG_AIC_SCR16   (AIC_BA+0x3C)    /*!< Source control register 16 */
N#define     REG_AIC_IRSR    (AIC_BA+0x100)   /*!< Interrupt raw status register */
N#define     REG_AIC_IRSRH   (AIC_BA+0x104)   /*!< Interrupt raw status register (Hign) */
N#define     REG_AIC_IASR    (AIC_BA+0x108)   /*!< Interrupt active status register */
N#define     REG_AIC_IASRH   (AIC_BA+0x10C)   /*!< Interrupt active status register (Hign) */
N#define     REG_AIC_ISR     (AIC_BA+0x110)   /*!< Interrupt status register */
N#define     REG_AIC_ISRH    (AIC_BA+0x114)   /*!< Interrupt status register (High) */
N#define     REG_AIC_IPER    (AIC_BA+0x118)   /*!< Interrupt priority encoding register */
N#define     REG_AIC_ISNR    (AIC_BA+0x120)   /*!< Interrupt source number register */
N#define     REG_AIC_OISR    (AIC_BA+0x124)   /*!< Output interrupt status register */
N#define     REG_AIC_IMR     (AIC_BA+0x128)   /*!< Interrupt mask register */
N#define     REG_AIC_IMRH    (AIC_BA+0x12C)   /*!< Interrupt mask register (High) */
N#define     REG_AIC_MECR    (AIC_BA+0x130)   /*!< Mask enable command register */
N#define     REG_AIC_MECRH   (AIC_BA+0x134)   /*!< Mask enable command register (High) */
N#define     REG_AIC_MDCR    (AIC_BA+0x138)   /*!< Mask disable command register */
N#define     REG_AIC_MDCRH   (AIC_BA+0x13C)   /*!< Mask disable command register (High) */
N#define     REG_AIC_SSCR    (AIC_BA+0x140)   /*!< Source Set Command Register */
N#define     REG_AIC_SSCRH   (AIC_BA+0x144)   /*!< Source Set Command Register (High) */
N#define     REG_AIC_SCCR    (AIC_BA+0x148)   /*!< Source Clear Command Register */
N#define     REG_AIC_SCCRH   (AIC_BA+0x14C)   /*!< Source Clear Command Register (High) */
N#define     REG_AIC_EOSCR   (AIC_BA+0x150)   /*!< End of service command register */
N
N/**@}*/ /* end of AIC register group */
N
N
N/*---------------------- General Purpose Input/Output Controller -------------------------*/
N/**
N    @addtogroup GPIO General Purpose Input/Output Controller(GPIO)
N    Memory Mapped Structure for GPIO Controller
N@{ */
N
N#define     REG_GPIOA_DIR       (GPIO_BA+0x000)  /*!< GPIO portA direction control register */
N#define     REG_GPIOA_DATAOUT   (GPIO_BA+0x004)  /*!< GPIO portA data output register */
N#define     REG_GPIOA_DATAIN    (GPIO_BA+0x008)  /*!< GPIO portA data input register */
N#define     REG_GPIOA_IMD       (GPIO_BA+0x00C)  /*!< GPIO Port A Interrupt Mode Register */
N#define     REG_GPIOA_IREN      (GPIO_BA+0x010)  /*!< GPIO Port A Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOA_IFEN      (GPIO_BA+0x014)  /*!< GPIO Port A Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOA_ISR       (GPIO_BA+0x018)  /*!< GPIO Port A Interrupt Status Register */
N#define     REG_GPIOA_DBEN      (GPIO_BA+0x01C)  /*!< GPIO Port A De-bounce Enable Register */
N#define     REG_GPIOA_PUEN      (GPIO_BA+0x020)  /*!< GPIO Port A Pull-Up Enable Register */
N#define     REG_GPIOA_PDEN      (GPIO_BA+0x024)  /*!< GPIO Port A Pull-Down Enable Register */
N#define     REG_GPIOA_ICEN      (GPIO_BA+0x028)  /*!< GPIO Port A CMOS Input Enable Register */
N#define     REG_GPIOA_ISEN      (GPIO_BA+0x02C)  /*!< GPIO Port A Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOB_DIR       (GPIO_BA+0x040)  /*!< GPIO port B direction control register */
N#define     REG_GPIOB_DATAOUT   (GPIO_BA+0x044)  /*!< GPIO port B data output register */
N#define     REG_GPIOB_DATAIN    (GPIO_BA+0x048)  /*!< GPIO port B data input register */
N#define     REG_GPIOB_IMD       (GPIO_BA+0x04C)  /*!< GPIO Port B Interrupt Mode Register */
N#define     REG_GPIOB_IREN      (GPIO_BA+0x050)  /*!< GPIO Port B Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOB_IFEN      (GPIO_BA+0x054)  /*!< GPIO Port B Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOB_ISR       (GPIO_BA+0x058)  /*!< GPIO Port B Interrupt Status Register */
N#define     REG_GPIOB_DBEN      (GPIO_BA+0x05C)  /*!< GPIO Port B De-bounce Enable Register */
N#define     REG_GPIOB_PUEN      (GPIO_BA+0x060)  /*!< GPIO Port B Pull-Up Enable Register */
N#define     REG_GPIOB_PDEN      (GPIO_BA+0x064)  /*!< GPIO Port B Pull-Down Enable Register */
N#define     REG_GPIOB_ICEN      (GPIO_BA+0x068)  /*!< GPIO Port B CMOS Input Enable Register */
N#define     REG_GPIOB_ISEN      (GPIO_BA+0x06C)  /*!< GPIO Port B Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOC_DIR       (GPIO_BA+0x080)  /*!< GPIO port C direction control register */
N#define     REG_GPIOC_DATAOUT   (GPIO_BA+0x084)  /*!< GPIO port C data output register */
N#define     REG_GPIOC_DATAIN    (GPIO_BA+0x088)  /*!< GPIO port C data input register */
N#define     REG_GPIOC_IMD       (GPIO_BA+0x08C)  /*!< GPIO Port C Interrupt Mode Register */
N#define     REG_GPIOC_IREN      (GPIO_BA+0x090)  /*!< GPIO Port C Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOC_IFEN      (GPIO_BA+0x094)  /*!< GPIO Port C Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOC_ISR       (GPIO_BA+0x098)  /*!< GPIO Port C Interrupt Status Register */
N#define     REG_GPIOC_DBEN      (GPIO_BA+0x09C)  /*!< GPIO Port C De-bounce Enable Register */
N#define     REG_GPIOC_PUEN      (GPIO_BA+0x0A0)  /*!< GPIO Port C Pull-Up Enable Register */
N#define     REG_GPIOC_PDEN      (GPIO_BA+0x0A4)  /*!< GPIO Port C Pull-Down Enable Register */
N#define     REG_GPIOC_ICEN      (GPIO_BA+0x0A8)  /*!< GPIO Port C CMOS Input Enable Register */
N#define     REG_GPIOC_ISEN      (GPIO_BA+0x0AC)  /*!< GPIO Port C Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOD_DIR       (GPIO_BA+0x0C0)  /*!< GPIO port D direction control register */
N#define     REG_GPIOD_DATAOUT   (GPIO_BA+0x0C4)  /*!< GPIO port D data output register */
N#define     REG_GPIOD_DATAIN    (GPIO_BA+0x0C8)  /*!< GPIO port D data input register */
N#define     REG_GPIOD_IMD       (GPIO_BA+0x0CC)  /*!< GPIO Port D Interrupt Mode Register */
N#define     REG_GPIOD_IREN      (GPIO_BA+0x0D0)  /*!< GPIO Port D Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOD_IFEN      (GPIO_BA+0x0D4)  /*!< GPIO Port D Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOD_ISR       (GPIO_BA+0x0D8)  /*!< GPIO Port D Interrupt Status Register */
N#define     REG_GPIOD_DBEN      (GPIO_BA+0x0DC)  /*!< GPIO Port D De-bounce Enable Register */
N#define     REG_GPIOD_PUEN      (GPIO_BA+0x0E0)  /*!< GPIO Port D Pull-Up Enable Register */
N#define     REG_GPIOD_PDEN      (GPIO_BA+0x0E4)  /*!< GPIO Port D Pull-Down Enable Register */
N#define     REG_GPIOD_ICEN      (GPIO_BA+0x0E8)  /*!< GPIO Port D CMOS Input Enable Register */
N#define     REG_GPIOD_ISEN      (GPIO_BA+0x0EC)  /*!< GPIO Port D Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOE_DIR       (GPIO_BA+0x100)  /*!< GPIO port E direction control register */
N#define     REG_GPIOE_DATAOUT   (GPIO_BA+0x104)  /*!< GPIO port E data output register */
N#define     REG_GPIOE_DATAIN    (GPIO_BA+0x108)  /*!< GPIO port E data input register */
N#define     REG_GPIOE_IMD       (GPIO_BA+0x10C)  /*!< GPIO Port E Interrupt Mode Register */
N#define     REG_GPIOE_IREN      (GPIO_BA+0x110)  /*!< GPIO Port E Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOE_IFEN      (GPIO_BA+0x114)  /*!< GPIO Port E Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOE_ISR       (GPIO_BA+0x118)  /*!< GPIO Port E Interrupt Status Register */
N#define     REG_GPIOE_DBEN      (GPIO_BA+0x11C)  /*!< GPIO Port E De-bounce Enable Register */
N#define     REG_GPIOE_PUEN      (GPIO_BA+0x120)  /*!< GPIO Port E Pull-Up Enable Register */
N#define     REG_GPIOE_PDEN      (GPIO_BA+0x124)  /*!< GPIO Port E Pull-Down Enable Register */
N#define     REG_GPIOE_ICEN      (GPIO_BA+0x128)  /*!< GPIO Port E CMOS Input Enable Register */
N#define     REG_GPIOE_ISEN      (GPIO_BA+0x12C)  /*!< GPIO Port E Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOF_DIR       (GPIO_BA+0x140)  /*!< GPIO port F direction control register */
N#define     REG_GPIOF_DATAOUT   (GPIO_BA+0x144)  /*!< GPIO port F data output register */
N#define     REG_GPIOF_DATAIN    (GPIO_BA+0x148)  /*!< GPIO port F data input register */
N#define     REG_GPIOF_IMD       (GPIO_BA+0x14C)  /*!< GPIO Port F Interrupt Mode Register */
N#define     REG_GPIOF_IREN      (GPIO_BA+0x150)  /*!< GPIO Port F Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOF_IFEN      (GPIO_BA+0x154)  /*!< GPIO Port F Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOF_ISR       (GPIO_BA+0x158)  /*!< GPIO Port F Interrupt Status Register */
N#define     REG_GPIOF_DBEN      (GPIO_BA+0x15C)  /*!< GPIO Port F De-bounce Enable Register */
N#define     REG_GPIOF_PUEN      (GPIO_BA+0x160)  /*!< GPIO Port F Pull-Up Enable Register */
N#define     REG_GPIOF_PDEN      (GPIO_BA+0x164)  /*!< GPIO Port F Pull-Down Enable Register */
N#define     REG_GPIOF_ICEN      (GPIO_BA+0x168)  /*!< GPIO Port F CMOS Input Enable Register */
N#define     REG_GPIOF_ISEN      (GPIO_BA+0x16C)  /*!< GPIO Port F Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOG_DIR       (GPIO_BA+0x180)  /*!< GPIO port G direction control register */
N#define     REG_GPIOG_DATAOUT   (GPIO_BA+0x184)  /*!< GPIO port G data output register */
N#define     REG_GPIOG_DATAIN    (GPIO_BA+0x188)  /*!< GPIO port G data input register */
N#define     REG_GPIOG_IMD       (GPIO_BA+0x18C)  /*!< GPIO Port G Interrupt Mode Register */
N#define     REG_GPIOG_IREN      (GPIO_BA+0x190)  /*!< GPIO Port G Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOG_IFEN      (GPIO_BA+0x194)  /*!< GPIO Port G Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOG_ISR       (GPIO_BA+0x198)  /*!< GPIO Port G Interrupt Status Register */
N#define     REG_GPIOG_DBEN      (GPIO_BA+0x19C)  /*!< GPIO Port G De-bounce Enable Register */
N#define     REG_GPIOG_PUEN      (GPIO_BA+0x1A0)  /*!< GPIO Port G Pull-Up Enable Register */
N#define     REG_GPIOG_PDEN      (GPIO_BA+0x1A4)  /*!< GPIO Port G Pull-Down Enable Register */
N#define     REG_GPIOG_ICEN      (GPIO_BA+0x1A8)  /*!< GPIO Port G CMOS Input Enable Register */
N#define     REG_GPIOG_ISEN      (GPIO_BA+0x1AC)  /*!< GPIO Port G Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOH_DIR       (GPIO_BA+0x1C0)  /*!< GPIO port H direction control register */
N#define     REG_GPIOH_DATAOUT   (GPIO_BA+0x1C4)  /*!< GPIO port H data output register */
N#define     REG_GPIOH_DATAIN    (GPIO_BA+0x1C8)  /*!< GPIO port H data input register */
N#define     REG_GPIOH_IMD       (GPIO_BA+0x1CC)  /*!< GPIO Port H Interrupt Mode Register */
N#define     REG_GPIOH_IREN      (GPIO_BA+0x1D0)  /*!< GPIO Port H Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOH_IFEN      (GPIO_BA+0x1D4)  /*!< GPIO Port H Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOH_ISR       (GPIO_BA+0x1D8)  /*!< GPIO Port H Interrupt Status Register */
N#define     REG_GPIOH_DBEN      (GPIO_BA+0x1DC)  /*!< GPIO Port H De-bounce Enable Register */
N#define     REG_GPIOH_PUEN      (GPIO_BA+0x1E0)  /*!< GPIO Port H Pull-Up Enable Register */
N#define     REG_GPIOH_PDEN      (GPIO_BA+0x1E4)  /*!< GPIO Port H Pull-Down Enable Register */
N#define     REG_GPIOH_ICEN      (GPIO_BA+0x1E8)  /*!< GPIO Port H CMOS Input Enable Register */
N#define     REG_GPIOH_ISEN      (GPIO_BA+0x1EC)  /*!< GPIO Port H Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOI_DIR       (GPIO_BA+0x200)  /*!< GPIO port I direction control register */
N#define     REG_GPIOI_DATAOUT   (GPIO_BA+0x204)  /*!< GPIO port I data output register */
N#define     REG_GPIOI_DATAIN    (GPIO_BA+0x208)  /*!< GPIO port I data input register */
N#define     REG_GPIOI_IMD       (GPIO_BA+0x20C)  /*!< GPIO Port I Interrupt Mode Register */
N#define     REG_GPIOI_IREN      (GPIO_BA+0x210)  /*!< GPIO Port I Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOI_IFEN      (GPIO_BA+0x214)  /*!< GPIO Port I Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOI_ISR       (GPIO_BA+0x218)  /*!< GPIO Port I Interrupt Status Register */
N#define     REG_GPIOI_DBEN      (GPIO_BA+0x21C)  /*!< GPIO Port I De-bounce Enable Register */
N#define     REG_GPIOI_PUEN      (GPIO_BA+0x220)  /*!< GPIO Port I Pull-Up Enable Register */
N#define     REG_GPIOI_PDEN      (GPIO_BA+0x224)  /*!< GPIO Port I Pull-Down Enable Register */
N#define     REG_GPIOI_ICEN      (GPIO_BA+0x228)  /*!< GPIO Port I CMOS Input Enable Register */
N#define     REG_GPIOI_ISEN      (GPIO_BA+0x22C)  /*!< GPIO Port I Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOJ_DIR       (GPIO_BA+0x240)  /*!< GPIO port J direction control register */
N#define     REG_GPIOJ_DATAOUT   (GPIO_BA+0x244)  /*!< GPIO port J data output register */
N#define     REG_GPIOJ_DATAIN    (GPIO_BA+0x248)  /*!< GPIO port J data input register */
N#define     REG_GPIOJ_IMD       (GPIO_BA+0x24C)  /*!< GPIO Port J Interrupt Mode Register */
N#define     REG_GPIOJ_IREN      (GPIO_BA+0x250)  /*!< GPIO Port J Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOJ_IFEN      (GPIO_BA+0x254)  /*!< GPIO Port J Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOJ_ISR       (GPIO_BA+0x258)  /*!< GPIO Port J Interrupt Status Register */
N#define     REG_GPIOJ_DBEN      (GPIO_BA+0x25C)  /*!< GPIO Port J De-bounce Enable Register */
N#define     REG_GPIOJ_PUEN      (GPIO_BA+0x260)  /*!< GPIO Port J Pull-Up Enable Register */
N#define     REG_GPIOJ_PDEN      (GPIO_BA+0x264)  /*!< GPIO Port J Pull-Down Enable Register */
N#define     REG_GPIOJ_ICEN      (GPIO_BA+0x268)  /*!< GPIO Port J CMOS Input Enable Register */
N#define     REG_GPIOJ_ISEN      (GPIO_BA+0x26C)  /*!< GPIO Port J Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIO_DBNCECON   (GPIO_BA+0x3F0)  /*!< GPIO Debounce Control Register */
N#define     REG_GPIO_ISR        (GPIO_BA+0x3FC)  /*!< GPIO Port Interrupt Status Register */
N
N/**@}*/ /* end of GPIO register group */
N
N
N/*---------------------- Real Time Clock Controller -------------------------*/
N/**
N    @addtogroup RTC Real Time Clock Controller(RTC)
N    Memory Mapped Structure for RTC Controller
N@{ */
N
N#define     REG_RTC_INIT    (RTC_BA+0x00)   /*!< RTC Initiation Register */
N#define     REG_RTC_RWEN    (RTC_BA+0x04)   /*!< RTC Access Enable Register */
N#define     REG_RTC_FREQADJ (RTC_BA+0x08)   /*!< RTC Frequency Compensation Register */
N#define     REG_RTC_TIME    (RTC_BA+0x0C)   /*!< Time Loading Register */
N#define     REG_RTC_CAL     (RTC_BA+0x10)   /*!< Calendar Loading Register */
N#define     REG_RTC_TIMEFMT (RTC_BA+0x14)   /*!< Time Format Selection Register */
N#define     REG_RTC_WEEKDAY (RTC_BA+0x18)   /*!< Day of the Week Register */
N#define     REG_RTC_TALM    (RTC_BA+0x1C)   /*!< Time Alarm Register */
N#define     REG_RTC_CALM    (RTC_BA+0x20)   /*!< Calendar Alarm Register */
N#define     REG_RTC_LEAPYEAR    (RTC_BA+0x24)   /*!< Leap year Indicator Register */
N#define     REG_RTC_INTEN   (RTC_BA+0x28)   /*!< RTC Interrupt Enable Register */
N#define     REG_RTC_INTSTS  (RTC_BA+0x2C)   /*!< RTC Interrupt Indicator Register */
N#define     REG_RTC_TICK    (RTC_BA+0x30)   /*!< RTC Time Tick Register */
N#define     REG_RTC_PWRCTL      (RTC_BA+0x34)   /*!< Power Control Register */
N#define     REG_RTC_PWRCNT      (RTC_BA+0x38)   /*!< Power Control Counter Register */
N#define     REG_RTC_SPR0        (RTC_BA+0x40)   /*!< Spare REgistger 0 */
N#define     REG_RTC_SPR1        (RTC_BA+0x44)   /*!< Spare REgistger 1 */
N#define     REG_RTC_SPR2        (RTC_BA+0x48)   /*!< Spare REgistger 2 */
N#define     REG_RTC_SPR3        (RTC_BA+0x4C)   /*!< Spare REgistger 3 */
N#define     REG_RTC_SPR4        (RTC_BA+0x50)   /*!< Spare REgistger 4 */
N#define     REG_RTC_SPR5        (RTC_BA+0x54)   /*!< Spare REgistger 5 */
N#define     REG_RTC_SPR6        (RTC_BA+0x58)   /*!< Spare REgistger 6 */
N#define     REG_RTC_SPR7        (RTC_BA+0x5C)   /*!< Spare REgistger 7 */
N#define     REG_RTC_SPR8        (RTC_BA+0x60)   /*!< Spare REgistger 8 */
N#define     REG_RTC_SPR9        (RTC_BA+0x64)   /*!< Spare REgistger 9 */
N#define     REG_RTC_SPR10       (RTC_BA+0x68)   /*!< Spare REgistger 10 */
N#define     REG_RTC_SPR11       (RTC_BA+0x6C)   /*!< Spare REgistger 11 */
N#define     REG_RTC_SPR12       (RTC_BA+0x70)   /*!< Spare REgistger 12 */
N#define     REG_RTC_SPR13       (RTC_BA+0x74)   /*!< Spare REgistger 13 */
N#define     REG_RTC_SPR14       (RTC_BA+0x78)   /*!< Spare REgistger 14 */
N#define     REG_RTC_SPR15       (RTC_BA+0x7C)   /*!< Spare REgistger 15 */
N
N/**@}*/ /* end of RTC register group */
N
N/*---------------------- Inter-IC Bus Controller -------------------------*/
N/**
N    @addtogroup I2C Inter-IC Bus Controller(I2C)
N    Memory Mapped Structure for I2C Controller
N@{ */
N
N#define     REG_I2C0_CSR        (I2C0_BA+0x00)  /*!< Control and Status Register */
N#define     REG_I2C0_DIVIDER    (I2C0_BA+0x04)  /*!< Clock Prescale Register */
N#define     REG_I2C0_CMDR       (I2C0_BA+0x08)  /*!< Command Register */
N#define     REG_I2C0_SWR        (I2C0_BA+0x0C)  /*!< Software Mode Control Register */
N#define     REG_I2C0_RXR        (I2C0_BA+0x10)  /*!< Data Receive Register */
N#define     REG_I2C0_TXR        (I2C0_BA+0x14)  /*!< Data Transmit Register */
N
N#define     REG_I2C1_CSR        (I2C1_BA+0x00)  /*!< Control and Status Register */
N#define     REG_I2C1_DIVIDER    (I2C1_BA+0x04)  /*!< Clock Prescale Register */
N#define     REG_I2C1_CMDR       (I2C1_BA+0x08)  /*!< Command Register */
N#define     REG_I2C1_SWR        (I2C1_BA+0x0C)  /*!< Software Mode Control Register */
N#define     REG_I2C1_RXR        (I2C1_BA+0x10)  /*!< Data Receive Register */
N#define     REG_I2C1_TXR        (I2C1_BA+0x14)  /*!< Data Transmit Register */
N
N/**@}*/ /* end of I2C register group */
N
N
N/*---------------------- Serial Peripheral Interface Controller -------------------------*/
N/**
N    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
N    Memory Mapped Structure for SPI Controller
N@{ */
N
N#define     REG_SPI0_CNTRL   (SPI0_BA+0x00)  /*!< Control and Status Register */
N#define     REG_SPI0_DIVIDER (SPI0_BA+0x04)  /*!< Clock Divider Register */
N#define     REG_SPI0_SSR     (SPI0_BA+0x08)  /*!< Slave Select Register */
N#define     REG_SPI0_RX0     (SPI0_BA+0x10)  /*!< Data Receive Register 0 */
N#define     REG_SPI0_RX1     (SPI0_BA+0x14)  /*!< Data Receive Register 1 */
N#define     REG_SPI0_RX2     (SPI0_BA+0x18)  /*!< Data Receive Register 2 */
N#define     REG_SPI0_RX3     (SPI0_BA+0x1C)  /*!< Data Receive Register 3 */
N#define     REG_SPI0_TX0     (SPI0_BA+0x10)  /*!< Data Transmit Register 0 */
N#define     REG_SPI0_TX1     (SPI0_BA+0x14)  /*!< Data Transmit Register 1 */
N#define     REG_SPI0_TX2     (SPI0_BA+0x18)  /*!< Data Transmit Register 2 */
N#define     REG_SPI0_TX3     (SPI0_BA+0x1C)  /*!< Data Transmit Register 3 */
N
N#define     REG_SPI1_CNTRL   (SPI1_BA+0x00)  /*!< Control and Status Register */
N#define     REG_SPI1_DIVIDER (SPI1_BA+0x04)  /*!< Clock Divider Register */
N#define     REG_SPI1_SSR     (SPI1_BA+0x08)  /*!< Slave Select Register */
N#define     REG_SPI1_RX0     (SPI1_BA+0x10)  /*!< Data Receive Register 0 */
N#define     REG_SPI1_RX1     (SPI1_BA+0x14)  /*!< Data Receive Register 1 */
N#define     REG_SPI1_RX2     (SPI1_BA+0x18)  /*!< Data Receive Register 2 */
N#define     REG_SPI1_RX3     (SPI1_BA+0x1C)  /*!< Data Receive Register 3 */
N#define     REG_SPI1_TX0     (SPI1_BA+0x10)  /*!< Data Transmit Register 0 */
N#define     REG_SPI1_TX1     (SPI1_BA+0x14)  /*!< Data Transmit Register 1 */
N#define     REG_SPI1_TX2     (SPI1_BA+0x18)  /*!< Data Transmit Register 2 */
N#define     REG_SPI1_TX3     (SPI1_BA+0x1C)  /*!< Data Transmit Register 3 */
N
N/**@}*/ /* end of SPI register group */
N
N
N/*---------------------- Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup PWM Pulse Width Modulation Controller(PWM)
N    Memory Mapped Structure for PWM Controller
N@{ */
N
N#define     REG_PWM_PPR     (PWM_BA+0x00)  /*!< PWM Pre-scale Register 0 */
N#define     REG_PWM_CSR     (PWM_BA+0x04)  /*!< PWM Clock Select Register */
N#define     REG_PWM_PCR     (PWM_BA+0x08)  /*!< PWM Control Register */
N#define     REG_PWM_CNR0    (PWM_BA+0x0C)  /*!< PWM Counter Register 0 */
N#define     REG_PWM_CMR0    (PWM_BA+0x10)  /*!< PWM Comparator Register 0 */
N#define     REG_PWM_PDR0    (PWM_BA+0x14)  /*!< PWM Data Register 0 */
N#define     REG_PWM_CNR1    (PWM_BA+0x18)  /*!< PWM Counter Register 1 */
N#define     REG_PWM_CMR1    (PWM_BA+0x1C)  /*!< PWM Comparator Register 1 */
N#define     REG_PWM_PDR1    (PWM_BA+0x20)  /*!< PWM Data Register 1 */
N#define     REG_PWM_CNR2    (PWM_BA+0x24)  /*!< PWM Counter Register 2 */
N#define     REG_PWM_CMR2    (PWM_BA+0x28)  /*!< PWM Comparator Register 2 */
N#define     REG_PWM_PDR2    (PWM_BA+0x2C)  /*!< PWM Data Register 2 */
N#define     REG_PWM_CNR3    (PWM_BA+0x30)  /*!< PWM Counter Register 3 */
N#define     REG_PWM_CMR3    (PWM_BA+0x34)  /*!< PWM Comparator Register 3 */
N#define     REG_PWM_PDR3    (PWM_BA+0x38)  /*!< PWM Data Register 3 */
N#define     REG_PWM_PIER    (PWM_BA+0x3C)  /*!< PWM Timer Interrupt Enable Register */
N#define     REG_PWM_PIIR    (PWM_BA+0x40)  /*!< PWM Timer Interrupt Identification Register */
N
N/**@}*/ /* end of PWM register group */
N
N
N/*---------------------- Analog to Digital Converter -------------------------*/
N/**
N    @addtogroup ADC Analog to Digital Converter(ADC)
N    Memory Mapped Structure for ADC Controller
N@{ */
N
N#define REG_ADC_CTL       (ADC_BA+0x000) /*!< ADC Contrl */
N#define REG_ADC_CONF      (ADC_BA+0x004) /*!< ADC Configure */
N#define REG_ADC_IER       (ADC_BA+0x008) /*!< ADC Interrupt Enable Register */
N#define REG_ADC_ISR       (ADC_BA+0x00C) /*!< ADC Interrupt Status Register */
N#define REG_ADC_WKISR     (ADC_BA+0x010) /*!< ADC Wake Up Interrupt Status Register */
N#define REG_ADC_XYDATA    (ADC_BA+0x020) /*!< ADC Touch XY Pressure Data */
N#define REG_ADC_ZDATA     (ADC_BA+0x024) /*!< ADC Touch Z Pressure Data */
N#define REG_ADC_DATA      (ADC_BA+0x028) /*!< ADC Normal Conversion Data */
N#define REG_ADC_VBADATA   (ADC_BA+0x02C) /*!< ADC Battery Detection Data */
N#define REG_ADC_KPDATA    (ADC_BA+0x030) /*!< ADC Key Pad Data */
N#define REG_ADC_SELFDATA  (ADC_BA+0x034) /*!< ADC Self-Test Data */
N#define REG_ADC_XYSORT0   (ADC_BA+0x1F4) /*!< ADC Touch XY Position Mean Value Sort 0 */
N#define REG_ADC_XYSORT1   (ADC_BA+0x1F8) /*!< ADC Touch XY Position Mean Value Sort 1 */
N#define REG_ADC_XYSORT2   (ADC_BA+0x1FC) /*!< ADC Touch XY Position Mean Value Sort 2 */
N#define REG_ADC_XYSORT3   (ADC_BA+0x200) /*!< ADC Touch XY Position Mean Value Sort 3 */
N#define REG_ADC_ZSORT0    (ADC_BA+0x204) /*!< ADC Touch Z Pressure Mean Value Sort 0 */
N#define REG_ADC_ZSORT1    (ADC_BA+0x208) /*!< ADC Touch Z Pressure Mean Value Sort 1 */
N#define REG_ADC_ZSORT2    (ADC_BA+0x20C) /*!< ADC Touch Z Pressure Mean Value Sort 2 */
N#define REG_ADC_ZSORT3    (ADC_BA+0x210) /*!< ADC Touch Z Pressure Mean Value Sort 3 */
N#define REG_ADC_MTMULCK   (ADC_BA+0x220) /*!< ADC Manual Test Mode Unlock */
N#define REG_ADC_MTCONF    (ADC_BA+0x224) /*!< ADC Manual Test Mode Configure */
N#define REG_ADC_MTCON     (ADC_BA+0x228) /*!< ADC Manual Test Mode Control */
N#define REG_ADC_ADCAII    (ADC_BA+0x22C) /*!< ADC Analog Interface Information */
N#define REG_ADC_ADCAIIRLT (ADC_BA+0x230) /*!< ADC Analog Interface Information Result */
N
N/**@}*/ /* end of ADC register group */
N
N/*------------------ Capture Sensor Interface Controller ---------------------*/
N/**
N    @addtogroup CAP Capture Sensor Interface Controller(CAP)
N    Memory Mapped Structure for CAP Controller
N@{ */
N
N#define REG_CAP_CTL            (CAP_BA+0x000)  /*!< Image Capture Interface Control Register */
N#define REG_CAP_PAR            (CAP_BA+0x004)  /*!< Image Capture Interface Parameter Register */
N#define REG_CAP_INT            (CAP_BA+0x008)  /*!< Image Capture Interface Interrupt Registe */
N#define REG_CAP_POSTERIZE      (CAP_BA+0x00C)  /*!< YUV Component Posterizing Factor Register */
N#define REG_CAP_MD             (CAP_BA+0x010)  /*!< Motion Detection Register */
N#define REG_CAP_MDADDR         (CAP_BA+0x014)  /*!< Motion Detection Output Address Register */
N#define REG_CAP_MDYADDR        (CAP_BA+0x018)  /*!< Motion Detection Temp YOutput Address Register */
N#define REG_CAP_SEPIA          (CAP_BA+0x01C)  /*!< Sepia Effect Control Register */
N#define REG_CAP_CWSP           (CAP_BA+0x020)  /*!< Cropping Window Starting Address Register */
N#define REG_CAP_CWS            (CAP_BA+0x024)  /*!< Cropping Window Size Register */
N#define REG_CAP_PKTSL          (CAP_BA+0x028)  /*!< Packet Scaling Vertical/Horizontal Factor Register (LSB) */
N#define REG_CAP_PLNSL          (CAP_BA+0x02C)  /*!< Planar Scaling Vertical/Horizontal Factor Register (LSB) */
N#define REG_CAP_FRCTL          (CAP_BA+0x030)  /*!< Scaling Frame Rate Factor Register */
N#define REG_CAP_STRIDE         (CAP_BA+0x034)  /*!< Frame Output Pixel Stride Register */
N#define REG_CAP_FIFOTH         (CAP_BA+0x03C)  /*!< FIFO threshold Register */
N#define REG_CAP_CMPADDR        (CAP_BA+0x040)  /*!< Compare Packet Memory Base Address Register */
N#define REG_CAP_PKTSM          (CAP_BA+0x048)  /*!< Packet Scaling Vertical/Horizontal Factor Register (MSB) */
N#define REG_CAP_PLNSM          (CAP_BA+0x04C)  /*!< Planar Scaling Vertical/Horizontal Factor Register (MSB) */
N#define REG_CAP_CURADDRP       (CAP_BA+0x050)  /*!< Current Packet System Memory Address Register */
N#define REG_CAP_CURADDRY       (CAP_BA+0x054)  /*!< Current Planar Y System Memory Address Register */
N#define REG_CAP_CURADDRU       (CAP_BA+0x058)  /*!< Current Planar U System Memory Address Register */
N#define REG_CAP_CURADDRV       (CAP_BA+0x05C)  /*!< Current Planar V System Memory Address Register */
N#define REG_CAP_PKTBA0         (CAP_BA+0x060)  /*!< System Memory Packet Base Address Register */
N#define REG_CAP_PKTBA1         (CAP_BA+0x064)  /*!< System Memory Packet Base Address Register */
N#define REG_CAP_YBA            (CAP_BA+0x080)  /*!< System Memory Planar Y Base Address Register */
N#define REG_CAP_UBA            (CAP_BA+0x084)  /*!< System Memory Planar U Base Address Register */
N#define REG_CAP_VBA            (CAP_BA+0x088)  /*!< System Memory Planar V Base Address Register */
N
N/**@}*/ /* end of CAP register group */
N
N/*------------------ SDRAM Interface Controller ---------------------*/
N/**
N    @addtogroup SDIC SDRAM Interface Controller(SDIC)
N    Memory Mapped Structure for SDIC Controller
N@{ */
N
N#define REG_SDIC_OPMCTL     (SDIC_BA+0x000)    /*!< SDRAM Controller Operation Mode Control Register */
N#define REG_SDIC_CMD        (SDIC_BA+0x004)    /*!< SDRAM Command Register */
N#define REG_SDIC_REFCTL     (SDIC_BA+0x008)    /*!< SDRAM Controller Refresh Control Register */
N#define REG_SDIC_SIZE0      (SDIC_BA+0x010)    /*!< SDRAM 0 Size Register */
N#define REG_SDIC_SIZE1      (SDIC_BA+0x014)    /*!< SDRAM 1 Size Register */
N#define REG_SDIC_MR         (SDIC_BA+0x018)    /*!< SDRAM Mode Register */
N#define REG_SDIC_EMR        (SDIC_BA+0x01C)    /*!< SDRAM Extended Mode Register */
N#define REG_SDIC_EMR2       (SDIC_BA+0x020)    /*!< SDRAM Extended Mode Register 2 */
N#define REG_SDIC_EMR3       (SDIC_BA+0x024)    /*!< SDRAM Extended Mode Register 3 */
N#define REG_SDIC_TIME       (SDIC_BA+0x028)    /*!< SDRAM Timing Control Register */
N#define REG_SDIC_DQSODS     (SDIC_BA+0x030)    /*!< DQS Output Delay Selection Register */
N#define REG_SDIC_CKDQSDS    (SDIC_BA+0x034)    /*!< Clock and DQS Delay Selection Register */
N#define REG_SDIC_DAENSEL    (SDIC_BA+0x038)    /*!< Data Latch Enable Selection Register */
N
N/**@}*/ /* end of SDIC register group */
N
N/*---------------------- Controller Area Network -------------------------*/
N/**
N    @addtogroup CAN Controller Area Network(CAN)
N    Memory Mapped Structure for CAN Controller
N@{ */
N
N#define REG_CAN0_CON       (CAN0_BA+0x00) /*!< Control Register */
N#define REG_CAN0_STATUS    (CAN0_BA+0x04) /*!< Status Register */
N#define REG_CAN0_ERR       (CAN0_BA+0x08) /*!< Error Counter Register */
N#define REG_CAN0_BTIME     (CAN0_BA+0x0C) /*!< Bit Time Register */
N#define REG_CAN0_IIDR      (CAN0_BA+0x10) /*!< Interrupt Identifier Register */
N#define REG_CAN0_TEST      (CAN0_BA+0x14) /*!< Test Register */
N#define REG_CAN0_BRPE      (CAN0_BA+0x18) /*!< BRP Extension Register */
N#define REG_CAN0_IF1_CREQ  (CAN0_BA+0x20) /*!< IF1 Command Request Register */
N#define REG_CAN0_IF2_CREQ  (CAN0_BA+0x80) /*!< IF2 Command Request Register */
N#define REG_CAN0_IF1_CMASK (CAN0_BA+0x24) /*!< IF1 Command Mask Register */
N#define REG_CAN0_IF2_CMASK (CAN0_BA+0x84) /*!< IF2 Command Mask Register */
N#define REG_CAN0_IF1_MASK1 (CAN0_BA+0x28) /*!< IF1 Msak 1 Register */
N#define REG_CNA0_IF2_MASK1 (CAN0_BA+0x88) /*!< IF2 Mask 1 Register */
N#define REG_CAN0_IF1_MASK2 (CAN0_BA+0x2C) /*!< IF1 Mask 2 Register */
N#define REG_CAN0_IF2_MASK2 (CAN0_BA+0x8C) /*!< IF2 Mask 2 REgister */
N#define REG_CAN0_IF1_ARB1  (CAN0_BA+0x30) /*!< IF1 Arbitration 1 Register */
N#define REG_CAN0_IF2_ARB1  (CAN0_BA+0x90) /*!< IF2 Arbitration 1 Register */
N#define REG_CAN0_IF1_ARB2  (CAN0_BA+0x34) /*!< IF1 Arbitration 2 Register */
N#define REG_CAN0_IF2_ARB2  (CAN0_BA+0x94) /*!< IF2 Arbitration 2 Register */
N#define REG_CAN0_IF1_MCON  (CAN0_BA+0x38) /*!< IF1 Message Control Register */
N#define REG_CAN0_IF2_MCON  (CAN0_BA+0x98) /*!< IF2 Message Control Register */
N#define REG_CAN0_IF1_DAT_A1 (CAN0_BA+0x3C) /*!< IF1 Data A1 Register */
N#define REG_CAN0_IF1_DAT_A2 (CAN0_BA+0x40) /*!< IF1 Data A2 Register */
N#define REG_CAN0_IF1_DAT_B1 (CAN0_BA+0x44) /*!< IF1 Data B1 Register */
N#define REG_CAN0_IF1_DAT_B2 (CAN0_BA+0x48) /*!< IF1 Data B2 Register */
N#define REG_CAN0_IF2_DAT_A1 (CAN0_BA+0x9C) /*!< IF2 Data A1 Register */
N#define REG_CAN0_IF2_DAT_A2 (CAN0_BA+0xA0) /*!< IF2 Data A2 Register */
N#define REG_CAN0_IF2_DAT_B1 (CAN0_BA+0xA4) /*!< IF2 Data B1 Register */
N#define REG_CAN0_IF2_DAT_B2 (CAN0_BA+0xA8) /*!< IF2 Data B2 Register */
N#define REG_CAN0_TXREQ1     (CAN0_BA+0x100) /*!< Transmission Request Register 1 */
N#define REG_CAN0_TXREQ2     (CAN0_BA+0x104) /*!< Transmission Request Register 2 */
N#define REG_CAN0_NDAT1      (CAN0_BA+0x120) /*!< New Data Register 1 */
N#define REG_CAN0_NDAT2      (CAN0_BA+0x124) /*!< New Data Register 2 */
N#define REG_CAN0_IPND1      (CAN0_BA+0x140) /*!< Interrupt Pending Register 1 */
N#define REG_CAN0_IPND2      (CAN0_BA+0x142) /*!< Interrupt Pending Register 2 */
N#define REG_CAN0_MVLD1      (CAN0_BA+0x160) /*!< Message Valid Register 1 */
N#define REG_CAN0_MVLD2      (CAN0_BA+0x164) /*!< Message Valid Register 2 */
N#define REG_CAN0_WU_EN      (CAN0_BA+0x168) /*!< Wake-up Function Enable */
N#define REG_CAN0_WU_STATUS  (CAN0_BA+0x16C) /*!< Wake-up Function Status */
N
N#define REG_CAN1_CON       (CAN1_BA+0x00) /*!< Control Register */
N#define REG_CAN1_STATUS    (CAN1_BA+0x04) /*!< Status Register */
N#define REG_CAN1_ERR       (CAN1_BA+0x08) /*!< Error Counter Register */
N#define REG_CAN1_BTIME     (CAN1_BA+0x0C) /*!< Bit Time Register */
N#define REG_CAN1_IIDR      (CAN1_BA+0x10) /*!< Interrupt Identifier Register */
N#define REG_CAN1_TEST      (CAN1_BA+0x14) /*!< Test Register */
N#define REG_CAN1_BRPE      (CAN1_BA+0x18) /*!< BRP Extension Register */
N#define REG_CAN1_IF1_CREQ  (CAN1_BA+0x20) /*!< IF1 Command Request Register */
N#define REG_CAN1_IF2_CREQ  (CAN1_BA+0x80) /*!< IF2 Command Request Register */
N#define REG_CAN1_IF1_CMASK (CAN1_BA+0x24) /*!< IF1 Command Mask Register */
N#define REG_CAN1_IF2_CMASK (CAN1_BA+0x84) /*!< IF2 Command Mask Register */
N#define REG_CAN1_IF1_MASK1 (CAN1_BA+0x28) /*!< IF1 Msak 1 Register */
N#define REG_CNA1_IF2_MASK1 (CAN1_BA+0x88) /*!< IF2 Mask 1 Register */
N#define REG_CAN1_IF1_MASK2 (CAN1_BA+0x2C) /*!< IF1 Mask 2 Register */
N#define REG_CAN1_IF2_MASK2 (CAN1_BA+0x8C) /*!< IF2 Mask 2 REgister */
N#define REG_CAN1_IF1_ARB1  (CAN1_BA+0x30) /*!< IF1 Arbitration 1 Register */
N#define REG_CAN1_IF2_ARB1  (CAN1_BA+0x90) /*!< IF2 Arbitration 1 Register */
N#define REG_CAN1_IF1_ARB2  (CAN1_BA+0x34) /*!< IF1 Arbitration 2 Register */
N#define REG_CAN1_IF2_ARB2  (CAN1_BA+0x94) /*!< IF2 Arbitration 2 Register */
N#define REG_CAN1_IF1_MCON  (CAN1_BA+0x38) /*!< IF1 Message Control Register */
N#define REG_CAN1_IF2_MCON  (CAN1_BA+0x98) /*!< IF2 Message Control Register */
N#define REG_CAN1_IF1_DAT_A1 (CAN1_BA+0x3C) /*!< IF1 Data A1 Register */
N#define REG_CAN1_IF1_DAT_A2 (CAN1_BA+0x40) /*!< IF1 Data A2 Register */
N#define REG_CAN1_IF1_DAT_B1 (CAN1_BA+0x44) /*!< IF1 Data B1 Register */
N#define REG_CAN1_IF1_DAT_B2 (CAN1_BA+0x48) /*!< IF1 Data B2 Register */
N#define REG_CAN1_IF2_DAT_A1 (CAN1_BA+0x9C) /*!< IF2 Data A1 Register */
N#define REG_CAN1_IF2_DAT_A2 (CAN1_BA+0xA0) /*!< IF2 Data A2 Register */
N#define REG_CAN1_IF2_DAT_B1 (CAN1_BA+0xA4) /*!< IF2 Data B1 Register */
N#define REG_CAN1_IF2_DAT_B2 (CAN1_BA+0xA8) /*!< IF2 Data B2 Register */
N#define REG_CAN1_TXREQ1     (CAN1_BA+0x100) /*!< Transmission Request Register 1 */
N#define REG_CAN1_TXREQ2     (CAN1_BA+0x104) /*!< Transmission Request Register 2 */
N#define REG_CAN1_NDAT1      (CAN1_BA+0x120) /*!< New Data Register 1 */
N#define REG_CAN1_NDAT2      (CAN1_BA+0x124) /*!< New Data Register 2 */
N#define REG_CAN1_IPND1      (CAN1_BA+0x140) /*!< Interrupt Pending Register 1 */
N#define REG_CAN1_IPND2      (CAN1_BA+0x142) /*!< Interrupt Pending Register 2 */
N#define REG_CAN1_MVLD1      (CAN1_BA+0x160) /*!< Message Valid Register 1 */
N#define REG_CAN1_MVLD2      (CAN1_BA+0x164) /*!< Message Valid Register 2 */
N#define REG_CAN1_WU_EN      (CAN1_BA+0x168) /*!< Wake-up Function Enable */
N#define REG_CAN1_WU_STATUS  (CAN1_BA+0x16C) /*!< Wake-up Function Status */
N
N/**@}*/ /* end of CAN register group */
N
N
N/*------------------- JPEG Controller --------------------*/
N/**
N    @addtogroup JPEG JPEG Controller (JPEG)
N    Memory Mapped Structure for JPEG Controller
N@{ */
N#define JMCR           (JPEG_BA+0x00)           /*!< JPEG Mode Control Register  */
N#define JHEADER        (JPEG_BA+0x04)           /*!< JPEG Encode Header Control Register  */
N#define JITCR          (JPEG_BA+0x08)           /*!< JPEG Image Type Control Register  */
N#define JPRIQC         (JPEG_BA+0x10)           /*!< JPEG Primary Q-Table Control Register  */
N#define JTHBQC         (JPEG_BA+0x14)           /*!< JPEG Thumbnail Q-Table Control Register  */
N#define JPRIWH         (JPEG_BA+0x18)           /*!< JPEG Encode Primary Width/Height Register  */
N#define JTHBWH         (JPEG_BA+0x1C)           /*!< JPEG Encode Thumbnail Width/Height Register  */
N#define JPRST          (JPEG_BA+0x20)           /*!< JPEG Encode Primary Restart Interval Register  */
N#define JTRST          (JPEG_BA+0x24)           /*!< JPEG Encode Thumbnail Restart Interval  */
N#define JDECWH         (JPEG_BA+0x28)           /*!< JPEG Decode Image Width/Height Register  */
N#define JINTCR         (JPEG_BA+0x2C)           /*!< JPEG Interrupt Control and Status Register  */
N#define JDOWFBS        (JPEG_BA+0x3c)           /*!< JPEG Decoding Output Wait Frame Buffer Size  */
N#define JPEG_BSBAD     (JPEG_BA+0x40)           /*!< JPEG Test Control Register  */
N#define JWINDEC0       (JPEG_BA+0x44)           /*!< JPEG Window Decode Mode Control Register 0  */
N#define JWINDEC1       (JPEG_BA+0x48)           /*!< JPEG Window Decode Mode Control Register 1  */
N#define JWINDEC2       (JPEG_BA+0x4C)           /*!< JPEG Window Decode Mode Control Register 2  */
N#define JMACR          (JPEG_BA+0x50)           /*!< JPEG Memory Address Mode Control Register  */
N#define JPSCALU        (JPEG_BA+0x54)           /*!< JPEG Primary Scaling-Up Control Register  */
N#define JPSCALD        (JPEG_BA+0x58)           /*!< JPEG Primary Scaling-Down Control Register  */
N#define JTSCALD        (JPEG_BA+0x5C)           /*!< JPEG Thumbnail  Scaling-Down Control Register  */
N#define JDBCR          (JPEG_BA+0x60)           /*!< JPEG Dual-Buffer Control Register  */
N#define JRESERVE       (JPEG_BA+0x70)           /*!< JPEG Encode Primary Bit-stream Reserved Size Register  */
N#define JOFFSET        (JPEG_BA+0x74)           /*!< JPEG Offset Between Primary & Thumbnail Register  */
N#define JFSTRIDE       (JPEG_BA+0x78)           /*!< JPEG Encode Bit-stream Frame Stride Register  */
N#define JYADDR0        (JPEG_BA+0x7C)           /*!< JPEG Y Component Frame Buffer-0 Starting Address Register  */
N#define JUADDR0        (JPEG_BA+0x80)           /*!< JPEG U Component Frame Buffer-0 Starting Address Register  */
N#define JVADDR0        (JPEG_BA+0x84)           /*!< JPEG V Component Frame Buffer-0 Starting Address Register  */
N#define JYADDR1        (JPEG_BA+0x88)           /*!< JPEG Y Component Frame Buffer-1 Starting Address Register  */
N#define JUADDR1        (JPEG_BA+0x8C)           /*!< JPEG U Component Frame Buffer-1 Starting Address Register  */
N#define JVADDR1        (JPEG_BA+0x90)           /*!< JPEG V Component Frame Buffer-1 Starting Address Register  */
N#define JYSTRIDE       (JPEG_BA+0x94)           /*!< JPEG Y Component Frame Buffer Stride Register  */
N#define JUSTRIDE       (JPEG_BA+0x98)           /*!< JPEG U Component Frame Buffer Stride Register  */
N#define JVSTRIDE       (JPEG_BA+0x9C)           /*!< JPEG V Component Frame Buffer Stride Register  */
N#define JIOADDR0       (JPEG_BA+0xA0)           /*!< JPEG Bit-stream Frame Buffer-0 Starting Address Register  */
N#define JIOADDR1       (JPEG_BA+0xA4)           /*!< JPEG Bit-stream Frame Buffer-1 Starting Address Register  */
N#define JPRI_SIZE      (JPEG_BA+0xA8)           /*!< JPEG Encode Primary Image Bit-stream Size Register  */
N#define JTHB_SIZE      (JPEG_BA+0xAC)           /*!< JPEG Encode Thumbnail Image Bit-stream Size Register  */
N#define JUPRAT         (JPEG_BA+0xB0)           /*!< JPEG Encode Up-Scale Ratio Register  */
N#define JBSFIFO        (JPEG_BA+0xB4)           /*!< JPEG Bit-stream FIFO Control Register  */
N#define JSRCH          (JPEG_BA+0xB8)           /*!< JPEG Encode Source Image Height  */
N#define JQTAB0         (JPEG_BA+0x100)          /*!< JPEG Quantization-Table 0 Register  */
N#define JQTAB1         (JPEG_BA+0x140)          /*!< JPEG Quantization-Table 1 Register  */
N#define JQTAB2         (JPEG_BA+0x180)          /*!< JPEG Quantization-Table 2 Register  */
N
N/**@}*/ /* end of JPEG register group */
N
N
N
N/*@}*/ /* end of group N9H30_Peripherals */
N
N
N/** @addtogroup N9H30_IO_ROUTINE N9H30 I/O Routines
N  The Declaration of N9H30 I/O Routines
N  @{
N */
N
Ntypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Ntypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Ntypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
N
N/**
N  * @brief Get a 8-bit unsigned value from specified address
N  * @param[in] addr Address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified address
N  */
N#define M8(addr)  (*((vu8  *) (addr)))
N
N/**
N  * @brief Get a 16-bit unsigned value from specified address
N  * @param[in] addr Address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified address
N  * @note The input address must be 16-bit aligned
N  */
N#define M16(addr) (*((vu16 *) (addr)))
N
N/**
N  * @brief Get a 32-bit unsigned value from specified address
N  * @param[in] addr Address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified address
N  * @note The input address must be 32-bit aligned
N  */
N#define M32(addr) (*((vu32 *) (addr)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outpw(port,value)     *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inpw(port)            (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outps(port,value)     *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inps(port)            (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outpb(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inpb(port)            (*((volatile unsigned char *)(port)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outp32(port,value)    *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inp32(port)           (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outp16(port,value)    *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inp16(port)           (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outp8(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inp8(port)            (*((volatile unsigned char *)(port)))
N
N
N/*@}*/ /* end of group N9H30_IO_ROUTINE */
N
N/******************************************************************************/
N/*                Legacy Constants                                            */
N/******************************************************************************/
N/** @addtogroup N9H30_legacy_Constants N9H30 Legacy Constants
N  N9H30 Legacy Constants
N  @{
N*/
Ntypedef void *            PVOID;    ///< Define void pointer data type
Ntypedef void              VOID;     ///< Define void data type
Ntypedef char              BOOL;     ///< Define bool data type
Ntypedef char *            PBOOL;    ///< Define bool pointer data type
N
Ntypedef char              INT8;     ///< Define 8-bit singed data type
Ntypedef char              CHAR;     ///< Define char data type
Ntypedef char *            PINT8;    ///< Define 8-bit singed pointer data type
Ntypedef char *            PCHAR;    ///< Define char pointer data type
Ntypedef unsigned char     UINT8;    ///< Define 8-bit unsigned data type
Ntypedef unsigned char     UCHAR;    ///< Define char unsigned data type
Ntypedef unsigned char *   PUINT8;   ///< Define 8-bit unsigned pointer data type
Ntypedef unsigned char *   PUCHAR;   ///< Define char unsigned pointer data type
Ntypedef char *            PSTR;     ///< Define string pointer data type
Ntypedef const char *      PCSTR;    ///< Define constant string pointer data type
N
Ntypedef short             SHORT;    ///< Define short signed data type
Ntypedef short *           PSHORT;   ///< Define short signed pointer data type
Ntypedef unsigned short    USHORT;   ///< Define short unsigned data type
Ntypedef unsigned short *  PUSHORT;  ///< Define short unsigned pointer data type
N
Ntypedef short             INT16;    ///< Define 16-bit signed data type
Ntypedef short *           PINT16;   ///< Define 16-bit signed pointer data type
Ntypedef unsigned short    UINT16;   ///< Define 16-bit unsigned data type
Ntypedef unsigned short *  PUINT16;  ///< Define 16-bit unsigned pointer data type
N
Ntypedef int               INT;      ///< Define integer signed data type
Ntypedef int *             PINT;     ///< Define integer signed pointer data type
Ntypedef unsigned int      UINT;     ///< Define integer unsigned data type
Ntypedef unsigned int *    PUINT;    ///< Define integer unsigned pointer data type
N
Ntypedef int               INT32;    ///< Define 32-bit signed data type
Ntypedef int *             PINT32;   ///< Define 32-bit signed pointer data type
Ntypedef unsigned int      UINT32;   ///< Define 32-bit unsigned data type
Ntypedef unsigned int *    PUINT32;  ///< Define 32-bit unsigned pointer data type
N
Ntypedef __int64           INT64;    ///< Define 64-bit signed data type
Ntypedef unsigned __int64  UINT64;   ///< Define 64-bit unsigned data type
N
Ntypedef float             FLOAT;    ///< Define float data type
Ntypedef float *           PFLOAT;   ///< Define float pointer data type
N
Ntypedef double            DOUBLE;   ///< Define double data type
Ntypedef double *          PDOUBLE;  ///< Define double pointer data type
N
Ntypedef int               SIZE_T;   ///< Define size of data type
N
Ntypedef unsigned char     REG8;     ///< Define 8-bit register data type
Ntypedef unsigned short    REG16;    ///< Define 16-bit register data type
Ntypedef unsigned int      REG32;    ///< Define 32-bit register data type
N
N
N#ifndef NULL
N#define NULL           (0)      ///< NULL pointer
N#endif
N
N#define TRUE           (1)      ///< Boolean true, define to use in API parameters or return value
N#define FALSE          (0)      ///< Boolean false, define to use in API parameters or return value
N
N#define ENABLE         (1)      ///< Enable, define to use in API parameters
N#define DISABLE        (0)      ///< Disable, define to use in API parameters
N
N
N#define   Successful  0         ///< Function return value success
N#define   Fail        1         ///< Function return value failed
N
N/* Define one bit mask */
N#define BIT0     (0x00000001)       ///< Bit 0 mask of an 32 bit integer
N#define BIT1     (0x00000002)       ///< Bit 1 mask of an 32 bit integer
N#define BIT2     (0x00000004)       ///< Bit 2 mask of an 32 bit integer
N#define BIT3     (0x00000008)       ///< Bit 3 mask of an 32 bit integer
N#define BIT4     (0x00000010)       ///< Bit 4 mask of an 32 bit integer
N#define BIT5     (0x00000020)       ///< Bit 5 mask of an 32 bit integer
N#define BIT6     (0x00000040)       ///< Bit 6 mask of an 32 bit integer
N#define BIT7     (0x00000080)       ///< Bit 7 mask of an 32 bit integer
N#define BIT8     (0x00000100)       ///< Bit 8 mask of an 32 bit integer
N#define BIT9     (0x00000200)       ///< Bit 9 mask of an 32 bit integer
N#define BIT10    (0x00000400)       ///< Bit 10 mask of an 32 bit integer
N#define BIT11    (0x00000800)       ///< Bit 11 mask of an 32 bit integer
N#define BIT12    (0x00001000)       ///< Bit 12 mask of an 32 bit integer
N#define BIT13    (0x00002000)       ///< Bit 13 mask of an 32 bit integer
N#define BIT14    (0x00004000)       ///< Bit 14 mask of an 32 bit integer
N#define BIT15    (0x00008000)       ///< Bit 15 mask of an 32 bit integer
N#define BIT16    (0x00010000)       ///< Bit 16 mask of an 32 bit integer
N#define BIT17    (0x00020000)       ///< Bit 17 mask of an 32 bit integer
N#define BIT18    (0x00040000)       ///< Bit 18 mask of an 32 bit integer
N#define BIT19    (0x00080000)       ///< Bit 19 mask of an 32 bit integer
N#define BIT20    (0x00100000)       ///< Bit 20 mask of an 32 bit integer
N#define BIT21    (0x00200000)       ///< Bit 21 mask of an 32 bit integer
N#define BIT22    (0x00400000)       ///< Bit 22 mask of an 32 bit integer
N#define BIT23    (0x00800000)       ///< Bit 23 mask of an 32 bit integer
N#define BIT24    (0x01000000)       ///< Bit 24 mask of an 32 bit integer
N#define BIT25    (0x02000000)       ///< Bit 25 mask of an 32 bit integer
N#define BIT26    (0x04000000)       ///< Bit 26 mask of an 32 bit integer
N#define BIT27    (0x08000000)       ///< Bit 27 mask of an 32 bit integer
N#define BIT28    (0x10000000)       ///< Bit 28 mask of an 32 bit integer
N#define BIT29    (0x20000000)       ///< Bit 29 mask of an 32 bit integer
N#define BIT30    (0x40000000)       ///< Bit 30 mask of an 32 bit integer
N#define BIT31    (0x80000000)       ///< Bit 31 mask of an 32 bit integer
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk              (0x000000FF)         ///< Mask to get bit0~bit7 from a 32 bit integer
N#define BYTE1_Msk              (0x0000FF00)         ///< Mask to get bit8~bit15 from a 32 bit integer
N#define BYTE2_Msk              (0x00FF0000)         ///< Mask to get bit16~bit23 from a 32 bit integer
N#define BYTE3_Msk              (0xFF000000)         ///< Mask to get bit24~bit31 from a 32 bit integer
N
N#define GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N
N#endif /* __N9H30_H__ */
N
N/*@}*/ /* end of group N9H30_legacy_Constants */
L 23 "..\Application\FramewinDLG.c" 2
N#include "sys.h"
L 1 "..\..\..\Driver\Include\sys.h" 1
N/**************************************************************************//**
N* @file     sys.h
N* @brief    N9H30 SYS driver header file
N*
N* @note
N* Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup N9H30_Device_Driver N9H30 Device Driver
N  @{
N*/
N
N/** @addtogroup N9H30_SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup N9H30_SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/
N
N/**
N * @details  Interrupt Number Definition.
N */
Ntypedef enum IRQn {
N
N    /******  N9H30 Specific Interrupt Numbers *****************************************/
N
N    WDT_IRQn                = 1,       /*!< Watch Dog Timer Interrupt                  */
N    WWDT_IRQn               = 2,       /*!< Windowed-WDT Interrupt                     */
N    LVD_IRQn                = 3,       /*!< Low Voltage Detect Interrupt               */
N    EINT0_IRQn              = 4,       /*!< External Interrupt 0                       */
N    EINT1_IRQn              = 5,       /*!< External Interrupt 1                       */
N    EINT2_IRQn              = 6,       /*!< External Interrupt 2                       */
N    EINT3_IRQn              = 7,       /*!< External Interrupt 3                       */
N    EINT4_IRQn              = 8,       /*!< External Interrupt 4                       */
N    EINT5_IRQn              = 9,       /*!< External Interrupt 5                       */
N    EINT6_IRQn              = 10,      /*!< External Interrupt 6                       */
N    EINT7_IRQn              = 11,      /*!< External Interrupt 7                       */
N    ACTL_IRQn               = 12,      /*!< Audio Controller Interrupt                 */
N    LCD_IRQn                = 13,      /*!< LCD Controller Interrupt                   */
N    CAP_IRQn                = 14,      /*!< Sensor Interface Controller Interrupt      */
N    RTC_IRQn                = 15,      /*!< Real Time Clock Interrupt                  */
N    TMR0_IRQn               = 16,      /*!< Timer 0 Interrupt                          */
N    TMR1_IRQn               = 17,      /*!< Timer 1 Interrupt                          */
N    ADC_IRQn                = 18,      /*!< ADC Interrupt                              */
N    EMC0_RX_IRQn            = 19,      /*!< EMC 0 RX Interrupt                         */
N    EMC1_RX_IRQn            = 20,      /*!< EMC 1 RX Interrupt                         */
N    EMC0_TX_IRQn            = 21,      /*!< EMC 0 TX Interrupt                         */
N    EMC1_TX_IRQn            = 22,      /*!< EMC 1 TX Interrupt                         */
N    EHCI_IRQn               = 23,      /*!< USB 2.0 Host Controller Interrupt          */
N    OHCI_IRQn               = 24,      /*!< USB 1.1 Host Controller Interrupt          */
N    GDMA0_IRQn              = 25,      /*!< GDMA Channel 0 Interrupt                   */
N    GDMA1_IRQn              = 26,      /*!< GDMA Channel 1 Interrupt                   */
N    SDH_IRQn                = 27,      /*!< SD/SDIO Host Interrupt                     */
N    FMI_IRQn                = 28,      /*!< FMI Interrupt                              */
N    USBD_IRQn               = 29,      /*!< USB Device Interrupt                       */
N    TMR2_IRQn               = 30,      /*!< Timer 2 Interrupt                          */
N    TMR3_IRQn               = 31,      /*!< Timer 3 Interrupt                          */
N    TMR4_IRQn               = 32,      /*!< Timer 4 Interrupt                          */
N    JPEG_IRQn               = 33,      /*!< JPEG Engine Interrupt                      */
N    GE2D_IRQn               = 34,      /*!< 2D Graphic Engine Interrupt                */
N    UART0_IRQn              = 36,      /*!< UART 0 Interrupt                           */
N    UART1_IRQn              = 37,      /*!< UART 1 Interrupt                           */
N    UART2_IRQn              = 38,      /*!< UART 2 Interrupt                           */
N    UART4_IRQn              = 39,      /*!< UART 4 Interrupt                           */
N    UART6_IRQn              = 40,      /*!< UART 6 Interrupt                           */
N    UART8_IRQn              = 41,      /*!< UART 8 Interrupt                           */
N    UART10_IRQn             = 42,      /*!< UART 10 Interrupt                          */
N    UART3_IRQn              = 43,      /*!< UART 3 Interrupt                           */
N    UART5_IRQn              = 44,      /*!< UART 5 Interrupt                           */
N    UART7_IRQn              = 45,      /*!< UART 7 Interrupt                           */
N    UART9_IRQn              = 46,      /*!< UART 9 Interrupt                           */
N    ETMR0_IRQn              = 47,      /*!< Enhanced Timer 0 Interrupt                 */
N    ETMR1_IRQn              = 48,      /*!< Enhanced Timer 1 Interrupt                 */
N    ETMR2_IRQn              = 49,      /*!< Enhanced Timer 2 Interrupt                 */
N    ETMR3_IRQn              = 50,      /*!< Enhanced Timer 3 Interrupt                 */
N    SPI0_IRQn               = 51,      /*!< SPI 0 Interrupt                            */
N    SPI1_IRQn               = 52,      /*!< SPI 1 Interrupt                            */
N    I2C0_IRQn               = 53,      /*!< I2C 0 Interrupt                            */
N    I2C1_IRQn               = 54,      /*!< I2C 1 Interrupt                            */
N    SC0_IRQn                = 55,      /*!< Smart Card 0 Interrupt                     */
N    SC1_IRQn                = 56,      /*!< Smart Card 1 Interrupt                     */
N    GPIO_IRQn               = 57,      /*!< GPIO Interrupt                             */
N    CAN0_IRQn               = 58,      /*!< CAN 0 Interrupt                            */
N    CAN1_IRQn               = 59,      /*!< CAN 1 Interrupt                            */
N    PWM_IRQn                = 60,      /*!< PWM Interrupt                              */
N}
NIRQn_Type;
N
N/* Define constants for use timer in service parameters.  */
N#define TIMER0            0     /*!< Select Timer0 */
N#define TIMER1            1     /*!< Select Timer1 */
N
N#define ONE_SHOT_MODE     0     /*!< Timer Operation Mode - One Shot */
N#define PERIODIC_MODE     1     /*!< Timer Operation Mode - Periodic */
N#define TOGGLE_MODE       2     /*!< Timer Operation Mode - Toggle */
N
N/* The parameters for sysSetInterruptPriorityLevel() and
N   sysInstallISR() use */
N#define FIQ_LEVEL_0     0       /*!< FIQ Level 0 */
N#define IRQ_LEVEL_1     1       /*!< IRQ Level 1 */
N#define IRQ_LEVEL_2     2       /*!< IRQ Level 2 */
N#define IRQ_LEVEL_3     3       /*!< IRQ Level 3 */
N#define IRQ_LEVEL_4     4       /*!< IRQ Level 4 */
N#define IRQ_LEVEL_5     5       /*!< IRQ Level 5 */
N#define IRQ_LEVEL_6     6       /*!< IRQ Level 6 */
N#define IRQ_LEVEL_7     7       /*!< IRQ Level 7 */
N
N#define ONE_HALF_SECS     0     /*!< WDT interval - 1.5s */
N#define FIVE_SECS         1     /*!< WDT interval - 5s */
N#define TEN_SECS          2     /*!< WDT interval - 10s */
N#define TWENTY_SECS       3     /*!< WDT interval - 20s */
N
N/* Define constants for use AIC in service parameters.  */
N#define SYS_SWI           0     /*!< Exception - SWI */
N#define SYS_D_ABORT       1     /*!< Exception - Data abort */
N#define SYS_I_ABORT       2     /*!< Exception - Instruction abort */
N#define SYS_UNDEFINE      3     /*!< Exception - undefine */
N
N/* The parameters for sysSetLocalInterrupt() use */
N#define ENABLE_IRQ        0x7F  /*!< Enable I-bit of CP15  */
N#define ENABLE_FIQ        0xBF  /*!< Enable F-bit of CP15  */
N#define ENABLE_FIQ_IRQ    0x3F  /*!< Enable I-bit and F-bit of CP15  */
N#define DISABLE_IRQ       0x80  /*!< Disable I-bit of CP15  */
N#define DISABLE_FIQ       0x40  /*!< Disable F-bit of CP15  */
N#define DISABLE_FIQ_IRQ   0xC0  /*!< Disable I-bit and F-bit of CP15  */
N
N/* Define Cache type  */
N#define CACHE_WRITE_BACK        0     /*!< Cache Write-back mode  */
N#define CACHE_WRITE_THROUGH     1     /*!< Cache Write-through mode  */
N#define CACHE_DISABLE           -1    /*!< Cache Disable  */
N
N/** \brief  Structure type of clock source
N */
Ntypedef enum CLKn {
N
N    SYS_UPLL     = 1,   /*!< UPLL clock */
N    SYS_APLL     = 2,   /*!< APLL clock */
N    SYS_SYSTEM   = 3,   /*!< System clock */
N    SYS_HCLK1    = 4,   /*!< HCLK1 clock */
N    SYS_HCLK234  = 5,   /*!< HCLK234 clock */
N    SYS_PCLK     = 6,   /*!< PCLK clock */
N    SYS_CPU      = 7,   /*!< CPU clock */
N
N}  CLK_Type;
N
N
N
N/// @cond HIDDEN_SYMBOLS
Ntypedef struct datetime_t {
N    UINT32  year;
N    UINT32  mon;
N    UINT32  day;
N    UINT32  hour;
N    UINT32  min;
N    UINT32  sec;
N} DateTime_T;
N
N/* The parameters for sysSetInterruptType() use */
N#define LOW_LEVEL_SENSITIVE        0x00
N#define HIGH_LEVEL_SENSITIVE       0x40
N#define NEGATIVE_EDGE_TRIGGER      0x80
N#define POSITIVE_EDGE_TRIGGER      0xC0
N
N/* The parameters for sysSetGlobalInterrupt() use */
N#define ENABLE_ALL_INTERRUPTS      0
N#define DISABLE_ALL_INTERRUPTS     1
N
N#define MMU_DIRECT_MAPPING  0
N#define MMU_INVERSE_MAPPING 1
N
N
N/* Define constants for use Cache in service parameters.  */
N#define CACHE_4M        2
N#define CACHE_8M        3
N#define CACHE_16M       4
N#define CACHE_32M       5
N#define I_CACHE         6
N#define D_CACHE         7
N#define I_D_CACHE       8
N
N
N/// @endcond HIDDEN_SYMBOLS
N
N/*@}*/ /* end of group N9H30_SYS_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup N9H30_SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N/* Define system library Timer functions */
NUINT32  sysGetTicks (INT32 nTimeNo);
NINT32   sysResetTicks (INT32 nTimeNo);
NINT32   sysUpdateTickCount(INT32 nTimeNo, UINT32 uCount);
NINT32   sysSetTimerReferenceClock (INT32 nTimeNo, UINT32 uClockRate);
NINT32   sysStartTimer (INT32 nTimeNo, UINT32 uTicksPerSecond, INT32 nOpMode);
NINT32   sysStopTimer (INT32 nTimeNo);
Nvoid    sysClearWatchDogTimerCount (void);
Nvoid    sysClearWatchDogTimerInterruptStatus(void);
Nvoid    sysDisableWatchDogTimer (void);
Nvoid    sysDisableWatchDogTimerReset(void);
Nvoid    sysEnableWatchDogTimer (void);
Nvoid    sysEnableWatchDogTimerReset(void);
NPVOID   sysInstallWatchDogTimerISR (INT32 nIntTypeLevel, PVOID pvNewISR);
NINT32   sysSetWatchDogTimerInterval (INT32 nWdtInterval);
NINT32   sysSetTimerEvent(INT32 nTimeNo, UINT32 uTimeTick, PVOID pvFun);
Nvoid    sysClearTimerEvent(INT32 nTimeNo, UINT32 uTimeEventNo);
Nvoid    sysSetLocalTime(DateTime_T ltime);          /*!< Set local time \hideinitializer */
Nvoid    sysGetCurrentTime(DateTime_T *curTime);     /*!< Get current time \hideinitializer */
Nvoid    sysDelay(UINT32 uTicks);
N
N/* Define system library UART functions */
NINT8    sysGetChar (void);
NINT32   sysInitializeUART (void);
Nvoid    sysprintf (PINT8 pcStr,...);
Nvoid    sysPutChar (UINT8 ucCh);
NINT     sysIsKbHit(void);
N
N/* Define system library AIC functions */
NINT32   sysDisableInterrupt (IRQn_Type eIntNo);
NINT32   sysEnableInterrupt (IRQn_Type eIntNo);
NBOOL    sysGetIBitState(void);              /*!< Get I bit state \hideinitializer */
NUINT32  sysGetInterruptEnableStatus(void);  /*!< Get interrupt enable status \hideinitializer */
NUINT32  sysGetInterruptEnableStatusH(void); /*!< Get interrupt enable status \hideinitializer */
NPVOID   sysInstallExceptionHandler (INT32 nExceptType, PVOID pvNewHandler);
NPVOID   sysInstallFiqHandler (PVOID pvNewISR);
NPVOID   sysInstallIrqHandler (PVOID pvNewISR);
NPVOID   sysInstallISR (INT32 nIntTypeLevel, IRQn_Type eIntNo, PVOID pvNewISR);
NINT32   sysSetGlobalInterrupt (INT32 nIntState);    /*!< Enable/Disable all interrupt \hideinitializer */
NINT32   sysSetInterruptPriorityLevel (IRQn_Type eIntNo, UINT32 uIntLevel);
NINT32   sysSetInterruptType (IRQn_Type eIntNo, UINT32 uIntSourceType);      /*!< Change interrupt type \hideinitializer */
NINT32   sysSetLocalInterrupt (INT32 nIntState);
N
N
N/* Define system library Cache functions */
Nvoid    sysDisableCache(void);
NINT32   sysEnableCache(UINT32 uCacheOpMode);
Nvoid    sysFlushCache(INT32 nCacheType);    /*!< flush cache \hideinitializer */
NBOOL    sysGetCacheState(void);             /*!< get cache state \hideinitializer */
NINT32   sysGetSdramSizebyMB(void);          /*!< Get DRAM size \hideinitializer */
Nvoid    sysInvalidCache(void);              /*!< invalid cache \hideinitializer */
NINT32   sysSetCachePages(UINT32 addr, INT32 size, INT32 cache_mode);    /*!< set cache page \hideinitializer */
N
Nint sysSetMMUMappingMethod(int mode);   /*!< MMU mapping \hideinitializer */
N
NUINT32 sysGetClock(CLK_Type clk);
N
Ntypedef void (*sys_pvFunPtr)();   /* function pointer */
N/// @cond HIDDEN_SYMBOLS
Nextern sys_pvFunPtr sysIrqHandlerTable[];
Nextern BOOL volatile _sys_bIsAICInitial;
N/// @endcond
N#ifdef __cplusplus
S}
N#endif
N
N/*@}*/ /* end of group N9H30_SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group N9H30_SYS_Driver */
N
N/*@}*/ /* end of group N9H30_Device_Driver */
N
N#endif //__SYS_H__
N
N/*** (C) COPYRIGHT 2018 Nuvoton Technology Corp. ***/
N
L 24 "..\Application\FramewinDLG.c" 2
N
N// USER END
N#include "stdio.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060037
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 27 "..\Application\FramewinDLG.c" 2
N#include "DIALOG.h"
L 1 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : Dialog.h
NPurpose     : Dialog box include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef DIALOG_H
N#define DIALOG_H
N
N#include "WM.h"
L 1 "..\..\..\ThirdParty\emWin\Include\WM.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WM.h
NPurpose     : Windows manager include
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_H            /* Make sure we only include it once */
N#define WM_H
N
N
N#include "GUI_ConfDefaults.h"
L 1 "..\..\..\ThirdParty\emWin\Include\GUI_ConfDefaults.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_ConfDefaults.h
NPurpose     : Defaults for GUI config switches.
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUI_CONFDEFAULTS_H
N#define  GUI_CONFDEFAULTS_H
N
N#include "GUIConf.h"
L 1 "..\..\..\ThirdParty\emWin\Config\GUIConf.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUIConf.h
NPurpose     : Configures emWins abilities, fonts etc.
N----------------------------------------------------------------------
N*/
N
N#ifndef GUICONF_H
N#define GUICONF_H
N
N/*********************************************************************
N*
N*       Multi layer/display support
N*/
N#define GUI_NUM_LAYERS            1    // Maximum number of available layers
N
N/*********************************************************************
N*
N*       Multi tasking support
N*/
N#define GUI_OS                    (1)  // Compile with multitasking support
N
N/*********************************************************************
N*
N*       Configuration of touch support
N*/
N#define GUI_SUPPORT_TOUCH         (1)  // Support a touch screen (req. win-manager)
N
N/*********************************************************************
N*
N*       Default font
N*/
N#define GUI_DEFAULT_FONT          &GUI_Font6x8
N
N/*********************************************************************
N*
N*         Configuration of available packages
N*/
N#define GUI_SUPPORT_MOUSE    1    // Mouse support
N#define GUI_WINSUPPORT       1    // Use Window Manager
N#define GUI_SUPPORT_MEMDEV   1    // Use Memory Devices
N#define GUI_SUPPORT_DEVICES  1    // Enable use of device pointers
N
N#endif  // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 52 "..\..\..\ThirdParty\emWin\Include\GUI_ConfDefaults.h" 2
N
N#ifndef   GUI_USE_MIXCOLORS
N  #define GUI_USE_MIXCOLORS 1
N#endif
N
N#ifndef   GUI_USE_BIDI2
N  #define GUI_USE_BIDI2 1
N#endif
N
N#ifndef   LCD_MAX_LOG_COLORS
N  #define LCD_MAX_LOG_COLORS 256
N#else
S  #if (LCD_MAX_LOG_COLORS > 256)
S    #error The value of LCD_MAX_LOG_COLORS must be <= 256!
S  #endif
N#endif
N
N#define LCD_PIXELINDEX U32
N
N#ifndef LCD_YMAG
N  #define LCD_YMAG 1
N#endif
N#ifndef LCD_XMAG
N  #define LCD_XMAG 1
N#endif
N
N/**********************************************************************
N*
N*       Defaults for config switches
N*
N***********************************************************************
N*/
N
N/* ATTENTION: This define swaps the meaning of a logical color from
N   ABGR to ARGB.
N   
N   It further swaps the meaning of a transparent pixel:
N   ABGR: 0x00 means opaque, 0xFF means transparent
N   ARGB: 0x00 means transparent, 0xFF means opaque (default)
N*/
N#ifndef GUI_USE_ARGB
N  #define GUI_USE_ARGB 1
N#endif
N
N/* Define "universal pointer". Normally, this is not needed (define will expand to nothing)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __generic),
N   since a default pointer can access RAM only, not the built-in Flash
N*/
N#ifndef GUI_UNI_PTR
N  #define GUI_UNI_PTR /* Remains only for compatibility purpose, no longer used in emWin */
N#endif
N
N/* Define const storage. Normally, this is not needed (define will expand to const)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __flash const),
N   since otherwise constants are copied into RAM
N*/
N#ifndef GUI_CONST_STORAGE
N  #define GUI_CONST_STORAGE const
N#endif
N
N#ifndef GUI_USE_MEMDEV_1BPP_FOR_SCREEN
N  #define GUI_USE_MEMDEV_1BPP_FOR_SCREEN 1
N#endif
N
N#ifndef GUI_BIDI_MAX_CHARS_PER_LINE
N  #if GUI_USE_BIDI2
X  #if 1
N    #define GUI_BIDI_MAX_CHARS_PER_LINE 200
N  #else
S    #define GUI_BIDI_MAX_CHARS_PER_LINE  80
N  #endif
N#endif
N
N#ifndef GUI_SUPPORT_TOUCH
S  #define GUI_SUPPORT_TOUCH   0
N#endif
N
N#ifndef GUI_SUPPORT_MOUSE
S  #define GUI_SUPPORT_MOUSE   0
N#endif
N
N#ifndef GUI_SUPPORT_MEMDEV
S  #define GUI_SUPPORT_MEMDEV  0
N#endif
N
N#ifndef GUI_OS
S  #define GUI_OS              0
N#endif
N
N#ifndef GUI_NUM_LAYERS
S  #define GUI_NUM_LAYERS      4
N#endif
N
N#ifndef GUI_SUPPORT_CURSOR
N  #define GUI_SUPPORT_CURSOR  (GUI_SUPPORT_MOUSE | GUI_SUPPORT_TOUCH)
N#endif
N
N#ifndef   GUI_CURSOR_LAYER
N  #define GUI_CURSOR_LAYER 0
N#endif
N
N#ifndef GUI_SUPPORT_ROTATION
N  #define GUI_SUPPORT_ROTATION 1
N#endif
N
N/* In order to avoid warnings for undefined parameters */
N#ifndef GUI_USE_PARA
N  #if defined (__BORLANDC__) || defined(NC30) || defined(NC308)
X  #if 0L || 0L || 0L
S    #define GUI_USE_PARA(para)
N  #else
N    #define GUI_USE_PARA(para) (void)para
N  #endif
N#endif
N
N/* Default for types */
N#ifndef GUI_TIMER_TIME
N  #define GUI_TIMER_TIME int  /* default is to use 16 bits for 16 bit CPUs,
N	                           32 bits on 32 bit CPUs for timing */
N#endif
N
N/* Types used for memory allocation */
N#define GUI_ALLOC_DATATYPE   I32
N#define GUI_ALLOC_DATATYPE_U U32
N
N#ifndef   GUI_MAX_XBF_BYTES
N  #define GUI_MAX_XBF_BYTES 200
N#endif
N
N#ifndef   GUI_MEMSET
N  #define GUI_MEMSET memset
N#endif
N
N#ifndef GUI_MEMCPY
N  #define GUI_MEMCPY memcpy
N#endif
N
N/* Optional custom drawing of memory devices */
N#ifndef   GUI_MEMDEV_SUPPORT_CUSTOMDRAW
N  #define GUI_MEMDEV_SUPPORT_CUSTOMDRAW 0
N#endif
N
N/* Clip static memory devices to parent borders */
N#ifndef   GUI_MEMDEV_CLIP_AT_PARENT
N  #define GUI_MEMDEV_CLIP_AT_PARENT 0
N#endif
N
N#endif   /* ifdef GUI_CONFDEFAULTS_H */
N
N/*************************** End of file ****************************/
L 49 "..\..\..\ThirdParty\emWin\Include\WM.h" 2
N#include "GUI_Type.h"      /* Needed because of typedefs only */
L 1 "..\..\..\ThirdParty\emWin\Include\GUI_Type.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_Type.h
NPurpose     : Include file define the types used for GUI
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUITYPE_H_INCLUDED
N#define  GUITYPE_H_INCLUDED
N
N#include "LCD.h"
L 1 "..\..\..\ThirdParty\emWin\Include\LCD.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : LCD.h
NPurpose     : Declares LCD interface functions
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_H
N#define LCD_H
N
N#include "GUI_ConfDefaults.h" /* Used for GUI_CONST_STORAGE */
N#include "Global.h"
L 1 "..\..\..\ThirdParty\emWin\Include\Global.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile    : Global.h
NPurpose : Global types
N          In case your application already has a Global.h, you should
N          merge the files. In order to use Segger code, the types
N          U8, U16, U32, I8, I16, I32 need to be defined in Global.h;
N          additional definitions do not hurt.
NRevision: $Rev: 9374 $
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef GLOBAL_H            // Guard against multiple inclusion
N#define GLOBAL_H
N
N#define U8    unsigned char
N#define I8    signed char
N#define U16   unsigned short
N#define I16   signed short
N#ifdef __x86_64__
S#define U32   unsigned
S#define I32   int
N#else
N#define U32   unsigned long
N#define I32   signed long
N#endif
N
N#if defined(_WIN32) && !defined(__clang__) && !defined(__MINGW32__)
X#if 0L && !0L && !0L
S  //
S  // Microsoft VC6 compiler related
S  //
S  #define U64   unsigned __int64
S  #define U128  unsigned __int128
S  #define I64   __int64
S  #define I128  __int128
S  #if _MSC_VER <= 1200
S    #define U64_C(x) x##UI64
S  #else
S    #define U64_C(x) x##ULL
S  #endif
N#else
N  //
N  // C99 compliant compiler
N  //
N  #define U64   unsigned long long
N  #define I64   signed long long
N  #define U64_C(x) x##ULL
N#endif
N
N#ifndef PTR_ADDR
N  #if (defined(_WIN64) || defined(__LP64__))  // 64-bit symbols used by Visual Studio and GCC, maybe others as well.
X  #if (0L || 0L)  
S    #define PTR_ADDR  U64
N  #else
N    #define PTR_ADDR  U32
N  #endif
N#endif
N
N#endif                      // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 49 "..\..\..\ThirdParty\emWin\Include\LCD.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Basic type defines
N*
N* The follwing are defines for types used in the LCD-driver and the
N* GUI layers on top of that. Since "C" does not provide data types of
N* fixed length which are identical on all platforms, this is done here.
N* For most 16/32 controllers, the settings will work fine. However, if
N* you have similar defines in other sections of your program, you might
N* want to change or relocate these defines, e.g. in a TYPE.h file.
N*/
N#define I16P I16              /*   signed 16 bits OR MORE ! */
N#define U16P U16              /* unsigned 16 bits OR MORE ! */
N
N/*********************************************************************
N*
N*       Settings for windows simulation
N*
N* Some settings in the configuration may conflict with the values required
N* in the Simulation. This is why we ignore the target settings for data
N* types and use the correct settings for the simulation.
N* (U32 could be defined as long, which would yield a 64 bit type on
N* the PC)
N*/
N#ifdef WIN32
S  #pragma warning( disable : 4244 )  // Disable warning messages in simulation
S  #pragma warning( disable : 4761 )  // Disable warning "integral size mismatch in argument; conversion supplied"
N#endif
N
N/*********************************************************************
N*
N*       Constants
N*/
N#define LCD_ERR0 (0x10)
N#define LCD_ERR_CONTROLLER_NOT_FOUND (LCD_ERR0+1)
N#define LCD_ERR_MEMORY               (LCD_ERR0+2)
N
N/*********************************************************************
N*
N*       Drawing modes
N*/
N#define LCD_DRAWMODE_NORMAL (0)
N#define LCD_DRAWMODE_XOR    (1<<0)
N#define LCD_DRAWMODE_TRANS  (1<<1)
N#define LCD_DRAWMODE_REV    (1<<2)
N
N/*********************************************************************
N*
N*       Typedefs
N*/
Ntypedef int LCD_DRAWMODE;
Ntypedef U32 LCD_COLOR;
Xtypedef unsigned long LCD_COLOR;
N
N/*********************************************************************
N*
N*       Data structures
N*/
Ntypedef struct { I16P x,y; } GUI_POINT;
Xtypedef struct { signed short x,y; } GUI_POINT;
Ntypedef struct { I16 x0,y0,x1,y1; } LCD_RECT;
Xtypedef struct { signed short x0,y0,x1,y1; } LCD_RECT;
N
Ntypedef struct {
N  int              NumEntries;
N  char             HasTrans;
N  const LCD_COLOR * pPalEntries;
N} LCD_LOGPALETTE;
N
N/* This is used for the simulation only ! */
Ntypedef struct {
N  int x,y;
N  unsigned char KeyStat;
N} LCD_tMouseState;
N
Ntypedef struct {
N  int               NumEntries;
N  const LCD_COLOR * pPalEntries;
N} LCD_PHYSPALETTE;
N
N/*********************************************************************
N*
N*       LCD_L0_... color conversion
N*/
Ntypedef LCD_COLOR      tLCDDEV_Index2Color  (LCD_PIXELINDEX Index);
Xtypedef LCD_COLOR      tLCDDEV_Index2Color  (unsigned long Index);
Ntypedef LCD_PIXELINDEX tLCDDEV_Color2Index  (LCD_COLOR Color);
Xtypedef unsigned long tLCDDEV_Color2Index  (LCD_COLOR Color);
Ntypedef LCD_PIXELINDEX tLCDDEV_GetIndexMask (void);
Xtypedef unsigned long tLCDDEV_GetIndexMask (void);
N
Ntypedef void tLCDDEV_Index2ColorBulk(void * pIndex, LCD_COLOR * pColor, U32 NumItems, U8 SizeOfIndex);
Xtypedef void tLCDDEV_Index2ColorBulk(void * pIndex, LCD_COLOR * pColor, unsigned long NumItems, unsigned char SizeOfIndex);
Ntypedef void tLCDDEV_Color2IndexBulk(LCD_COLOR * pColor, void * pIndex, U32 NumItems, U8 SizeOfIndex);
Xtypedef void tLCDDEV_Color2IndexBulk(LCD_COLOR * pColor, void * pIndex, unsigned long NumItems, unsigned char SizeOfIndex);
N
N/*********************************************************************
N*
N*       Color conversion API tables
N*/
Ntypedef struct {
N  tLCDDEV_Color2Index  * pfColor2Index;
N  tLCDDEV_Index2Color  * pfIndex2Color;
N  tLCDDEV_GetIndexMask * pfGetIndexMask;
N  int NoAlpha;
N  tLCDDEV_Color2IndexBulk * pfColor2IndexBulk;
N  tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk;
N} LCD_API_COLOR_CONV;
N
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_0;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_2;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_4;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_5;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_8;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_24;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_2;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_4;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_5;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_6;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1616I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_111;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_222;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_233;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_323;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_332;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_12;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_12_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_555;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_556;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_655;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_666_9;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_822216;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_84444;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8666_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_88666I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M111;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M1555I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M222;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M233;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M323;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M332;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M4444I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_12;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_12_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M555;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M556;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M655;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M666_9;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8888I;
N
N#define GUICC_0         &LCD_API_ColorConv_0
N#define GUICC_1         &LCD_API_ColorConv_1
N#define GUICC_1_2       &LCD_API_ColorConv_1_2
N#define GUICC_1_4       &LCD_API_ColorConv_1_4
N#define GUICC_1_5       &LCD_API_ColorConv_1_5
N#define GUICC_1_8       &LCD_API_ColorConv_1_8
N#define GUICC_1_16      &LCD_API_ColorConv_1_16
N#define GUICC_1_24      &LCD_API_ColorConv_1_24
N#define GUICC_2         &LCD_API_ColorConv_2
N#define GUICC_4         &LCD_API_ColorConv_4
N#define GUICC_5         &LCD_API_ColorConv_5
N#define GUICC_6         &LCD_API_ColorConv_6
N#define GUICC_8         &LCD_API_ColorConv_8
N#define GUICC_16        &LCD_API_ColorConv_16
N#define GUICC_1616I     &LCD_API_ColorConv_1616I
N#define GUICC_111       &LCD_API_ColorConv_111
N#define GUICC_222       &LCD_API_ColorConv_222
N#define GUICC_233       &LCD_API_ColorConv_233
N#define GUICC_323       &LCD_API_ColorConv_323
N#define GUICC_332       &LCD_API_ColorConv_332
N#define GUICC_M4444I    &LCD_API_ColorConv_M4444I
N#define GUICC_444_12    &LCD_API_ColorConv_444_12
N#define GUICC_444_12_1  &LCD_API_ColorConv_444_12_1
N#define GUICC_444_16    &LCD_API_ColorConv_444_16
N#define GUICC_555       &LCD_API_ColorConv_555
N#define GUICC_565       &LCD_API_ColorConv_565
N#define GUICC_556       &LCD_API_ColorConv_556
N#define GUICC_655       &LCD_API_ColorConv_655
N#define GUICC_666       &LCD_API_ColorConv_666
N#define GUICC_666_9     &LCD_API_ColorConv_666_9
N#define GUICC_822216    &LCD_API_ColorConv_822216
N#define GUICC_84444     &LCD_API_ColorConv_84444
N#define GUICC_8666      &LCD_API_ColorConv_8666
N#define GUICC_8666_1    &LCD_API_ColorConv_8666_1
N#define GUICC_88666I    &LCD_API_ColorConv_88666I
N#define GUICC_888       &LCD_API_ColorConv_888
N#define GUICC_8888      &LCD_API_ColorConv_8888
N#define GUICC_M111      &LCD_API_ColorConv_M111
N#define GUICC_M1555I    &LCD_API_ColorConv_M1555I
N#define GUICC_M222      &LCD_API_ColorConv_M222
N#define GUICC_M233      &LCD_API_ColorConv_M233
N#define GUICC_M323      &LCD_API_ColorConv_M323
N#define GUICC_M332      &LCD_API_ColorConv_M332
N#define GUICC_M444_12   &LCD_API_ColorConv_M444_12
N#define GUICC_M444_12_1 &LCD_API_ColorConv_M444_12_1
N#define GUICC_M444_16   &LCD_API_ColorConv_M444_16
N#define GUICC_M555      &LCD_API_ColorConv_M555
N#define GUICC_M565      &LCD_API_ColorConv_M565
N#define GUICC_M556      &LCD_API_ColorConv_M556
N#define GUICC_M655      &LCD_API_ColorConv_M655
N#define GUICC_M666      &LCD_API_ColorConv_M666
N#define GUICC_M666_9    &LCD_API_ColorConv_M666_9
N#define GUICC_M8565     &LCD_API_ColorConv_M8565
N#define GUICC_M888      &LCD_API_ColorConv_M888
N#define GUICC_M8888     &LCD_API_ColorConv_M8888
N#define GUICC_M8888I    &LCD_API_ColorConv_M8888I
N
Nvoid GUICC_M1555I_SetCustColorConv(tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M565_SetCustColorConv  (tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M4444I_SetCustColorConv(tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M888_SetCustColorConv  (tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M8888I_SetCustColorConv(tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
N
N/*********************************************************************
N*
N*       Compatibility defines for older versions
N*/
N#define GUI_COLOR_CONV_1    GUICC_1
N#define GUI_COLOR_CONV_2    GUICC_2
N#define GUI_COLOR_CONV_4    GUICC_4
N#define GUI_COLOR_CONV_8666 GUICC_8666
N#define GUI_COLOR_CONV_888  GUICC_888
N#define GUI_COLOR_CONV_8888 GUICC_8888
N#define GUI_COLOR_CONV_565  GUICC_565
N#define GUI_COLOR_CONV_M565 GUICC_M565
N
N/*********************************************************************
N*
N*       LCDDEV function table
N*
N*  Below the routines which need to in an LCDDEV routine table are
N*  defined. All of these routines have to be in the low-level driver
N*  (LCD_L0) or in the memory device which can be used to replace the
N*  driver.
N*  The one exception to this is the SetClipRect routine, which would
N*  be identical for all drivers and is therefor contained in the
N*  level above (LCD).
N*/
Ntypedef void         tLCDDEV_DrawPixel    (int x, int y);
Ntypedef void         tLCDDEV_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void         tLCDDEV_DrawVLine    (int x , int y0,  int y1);
Ntypedef void         tLCDDEV_FillRect     (int x0, int y0, int x1, int y1);
Ntypedef unsigned int tLCDDEV_GetPixelIndex(int x, int y);
Ntypedef void         tLCDDEV_SetPixelIndex(int x, int y, int ColorIndex);
Ntypedef void         tLCDDEV_XorPixel     (int x, int y);
Ntypedef void         tLCDDEV_FillPolygon  (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_FillPolygonAA(const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_GetRect      (LCD_RECT * pRect);
Ntypedef int          tLCDDEV_Init         (void);
Ntypedef void         tLCDDEV_On           (void);
Ntypedef void         tLCDDEV_Off          (void);
Ntypedef void         tLCDDEV_SetLUTEntry  (U8 Pos, LCD_COLOR color);
Xtypedef void         tLCDDEV_SetLUTEntry  (unsigned char Pos, LCD_COLOR color);
Ntypedef void *       tLCDDEV_GetDevFunc   (int Index);
Ntypedef I32          tLCDDEV_GetDevProp   (int Index);
Xtypedef signed long          tLCDDEV_GetDevProp   (int Index);
Ntypedef void         tLCDDEV_SetOrg       (int x, int y);
N
N/*********************************************************************
N*
N*       Memory device API tables
N*/
Ntypedef struct GUI_DEVICE     GUI_DEVICE;
Ntypedef struct GUI_DEVICE_API GUI_DEVICE_API;
N
Ntypedef void tLCDDEV_DrawBitmap   (int x0, int y0, int xsize, int ysize,
N                       int BitsPerPixel, int BytesPerLine,
N                       const U8 * pData, int Diff,
X                       const unsigned char * pData, int Diff,
N                       const void * pTrans);   /* Really LCD_PIXELINDEX, but is void to avoid compiler warnings */
N#define GUI_MEMDEV_APILIST_1  &GUI_MEMDEV_DEVICE_1
N#define GUI_MEMDEV_APILIST_8  &GUI_MEMDEV_DEVICE_8
N#define GUI_MEMDEV_APILIST_16 &GUI_MEMDEV_DEVICE_16
N#define GUI_MEMDEV_APILIST_32 &GUI_MEMDEV_DEVICE_32
N
N/*********************************************************************
N*
N*       Defines for device capabilities
N*
N* The following is the list of device capabilities which can, but do
N* not have to be implemented in the driver. This way the driver can be
N* enhanced in the future without affecting the driver interface,
N* keeping older drivers compatible.
N* More DevCaps can always be added in the future, as older drivers
N* are guaranteed to return 0 for all unimplemented features or queries.
N*
N* The values below define the legal parameters to the LCD_GetDeviceCaps
N* and the LCD_GetpCapFunc routines.
N*/
N
N#define LCD_DEVCAP_XSIZE             0x01    /* Quest horiz. res. of display */
N#define LCD_DEVCAP_YSIZE             0x02    /* Quest vert. res. of display */
N#define LCD_DEVCAP_VXSIZE            0x03    /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_VYSIZE            0x04    /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_XORG              0x05    /* X-origin ... usually 0 */
N#define LCD_DEVCAP_YORG              0x06    /* Y-origin ... usually 0 */
N#define LCD_DEVCAP_CONTROLLER        0x07    /* LCD Controller (Numerical) */
N#define LCD_DEVCAP_BITSPERPIXEL      0x08    /* Bits per pixel ... 1/2/4/8 */
N#define LCD_DEVCAP_NUMCOLORS         0x09    /* Quest number of colors */
N#define LCD_DEVCAP_XMAG              0x0A
N#define LCD_DEVCAP_YMAG              0x0B
N#define LCD_DEVCAP_MIRROR_X          0x0C
N#define LCD_DEVCAP_MIRROR_Y          0x0D
N#define LCD_DEVCAP_SWAP_XY           0x0E
N#define LCD_DEVCAP_SWAP_RB           0x0F
N
Nint LCD_GetXSizeMax(void);
Nint LCD_GetYSizeMax(void);
Nint LCD_GetVXSizeMax(void);
Nint LCD_GetVYSizeMax(void);
Nint LCD_GetBitsPerPixelMax(void);
Nvoid LCD_SetDisplaySize(int xSizeDisplay, int ySizeDisplay);
Nint LCD_GetXSizeDisplay(void);
Nint LCD_GetYSizeDisplay(void);
N
Nint LCD_GetXSizeEx          (int LayerIndex);
Nint LCD_GetYSizeEx          (int LayerIndex);
Nint LCD_GetVXSizeEx         (int LayerIndex);
Nint LCD_GetVYSizeEx         (int LayerIndex);
Nint LCD_GetBitsPerPixelEx   (int LayerIndex);
NU32 LCD_GetNumColorsEx      (int LayerIndex);
Xunsigned long LCD_GetNumColorsEx      (int LayerIndex);
Nint LCD_GetXMagEx           (int LayerIndex);
Nint LCD_GetYMagEx           (int LayerIndex);
Nint LCD_GetMirrorXEx        (int LayerIndex);
Nint LCD_GetMirrorYEx        (int LayerIndex);
Nint LCD_GetSwapXYEx         (int LayerIndex);
Nint LCD_GetReversLUTEx      (int LayerIndex);
Nint LCD_GetPhysColorsInRAMEx(int LayerIndex);
N
Nint LCD_GetXSize            (void);
Nint LCD_GetYSize            (void);
Nint LCD_GetVXSize           (void);
Nint LCD_GetVYSize           (void);
Nint LCD_GetBitsPerPixel     (void);
NU32 LCD_GetNumColors        (void);
Xunsigned long LCD_GetNumColors        (void);
Nint LCD_GetXMag             (void);
Nint LCD_GetYMag             (void);
Nint LCD_GetMirrorX          (void);
Nint LCD_GetMirrorY          (void);
Nint LCD_GetSwapXY           (void);
Nint LCD_GetReversLUT        (void);
Nint LCD_GetPhysColorsInRAM  (void);
N
NI32 LCD__GetBPP      (U32 IndexMask);
Xsigned long LCD__GetBPP      (unsigned long IndexMask);
NI32 LCD__GetBPPDevice(U32 IndexMask);
Xsigned long LCD__GetBPPDevice(unsigned long IndexMask);
N
NtLCDDEV_Index2Color * LCD_GetpfIndex2ColorEx(int LayerIndex);
NtLCDDEV_Color2Index * LCD_GetpfColor2IndexEx(int LayerIndex);
N
NtLCDDEV_Color2Index * LCD_GetpfColor2Index(void);
N
Nint LCD_GetNumLayers(void);
N
NLCD_COLOR * LCD_GetPalette   (void);
NLCD_COLOR * LCD_GetPaletteEx (int LayerIndex);
Nvoid      * LCD_GetVRAMAddr  (void);
Nvoid      * LCD_GetVRAMAddrEx(int LayerIndex);
N
Nvoid (* LCD_GetDevFunc(int LayerIndex, int Item))(void);
N
N/*********************************************************************
N*
N*       Runtime rotation of drivers
N*/
Nint LCD_ROTATE_AddDriver  (const GUI_DEVICE_API * pDriver);
Nint LCD_ROTATE_AddDriverEx(const GUI_DEVICE_API * pDeviceAPI, int LayerIndex);
Nint LCD_ROTATE_DecSel     (void);
Nint LCD_ROTATE_DecSelEx   (int LayerIndex);
Nint LCD_ROTATE_IncSel     (void);
Nint LCD_ROTATE_IncSelEx   (int LayerIndex);
Nint LCD_ROTATE_SetCallback(void (* pCbOnConfig)(GUI_DEVICE *, int, int), int LayerIndex);
Nint LCD_ROTATE_SetSel     (int Index);
Nint LCD_ROTATE_SetSelEx   (int Index, int LayerIndex);
N
N/*********************************************************************
N*
N*       Values for requesting and setting function pointers (display driver)
N*/
N                                       /* Request of a function pointer for... */
N#define LCD_DEVFUNC_READRECT      0x01 /* ...reading a rectangular display area */
N#define LCD_DEVFUNC_SETALPHA      0x02 /* ...setting the alpha blending factor */
N#define LCD_DEVFUNC_SETPOS        0x03 /* ...setting the layer position */
N#define LCD_DEVFUNC_GETPOS        0x04 /* ...getting the layer position */
N#define LCD_DEVFUNC_SETSIZE       0x05 /* ...setting the layer size */
N#define LCD_DEVFUNC_SETVIS        0x06 /* ...setting the visibility of a layer */
N#define LCD_DEVFUNC_24BPP         0x07 /* ...drawing 24bpp bitmaps */
N#define LCD_DEVFUNC_NEXT_PIXEL    0x08 /* ...drawing a bitmap pixel by pixel */
N#define LCD_DEVFUNC_SET_VRAM_ADDR 0x09 /* ...setting the VRAM address */
N#define LCD_DEVFUNC_SET_VSIZE     0x0A /* ...setting the VRAM size */
N#define LCD_DEVFUNC_SET_SIZE      0x0B /* ...setting the display size */
N#define LCD_DEVFUNC_INIT          0x0C /* ...initializing the display controller */
N#define LCD_DEVFUNC_CONTROLCACHE  0x0D /* ...controlling the cache */
N#define LCD_DEVFUNC_ON            0x0E /* ...switching the display on */
N#define LCD_DEVFUNC_OFF           0x0F /* ...switching the display off */
N#define LCD_DEVFUNC_SETLUTENTRY   0x10 /* ...setting a LUT entry */
N#define LCD_DEVFUNC_FILLPOLY      0x11 /* ...filling a polygon */
N#define LCD_DEVFUNC_FILLPOLYAA    0x12 /* ...filling an antialiased polygon */
N#define LCD_DEVFUNC_ALPHAMODE     0x13 /* ...setting the alpha blending mode */
N#define LCD_DEVFUNC_CHROMAMODE    0x14 /* ...setting the chroma blending mode */
N#define LCD_DEVFUNC_CHROMA        0x15 /* ...setting the chroma values */
N#define LCD_DEVFUNC_SETFUNC       0x16 /* ...setting a function pointer */
N#define LCD_DEVFUNC_REFRESH       0x17 /* ...refreshing the display */
N#define LCD_DEVFUNC_SETRECT       0x18 /* ...setting the drawing rectangle */
N                                       /* Setting a function pointer for... */
N#define LCD_DEVFUNC_FILLRECT      0x19 /* ...filling a rectangular area */
N#define LCD_DEVFUNC_DRAWBMP_1BPP  0x20 /* ...drawing a 1bpp bitmap */
N#define LCD_DEVFUNC_COPYBUFFER    0x21 /* ...copying complete frame buffers */
N#define LCD_DEVFUNC_SHOWBUFFER    0x22 /* ...shows the given buffer */
N#define LCD_DEVFUNC_COPYRECT      0x23 /* ...filling a rectangular area */
N#define LCD_DEVFUNC_DRAWBMP_16BPP 0x24 /* ...drawing a 16bpp bitmap */
N#define LCD_DEVFUNC_DRAWBMP_8BPP  0x25 /* ...drawing a 8bpp bitmap */
N#define LCD_DEVFUNC_READPIXEL     0x26 /* ...reading a pixel index */
N#define LCD_DEVFUNC_READMPIXELS   0x27 /* ...reading multiple pixel indices */
N#define LCD_DEVFUNC_DRAWBMP_32BPP 0x28 /* ...drawing a 32bpp bitmap */
N#define LCD_DEVFUNC_SET_BUFFERPTR 0x29 /* ...setting an array of buffer pointers */
N#define LCD_DEVFUNC_EXIT          0x30 /* ...free memory and shut down controller */
N
N/*********************************************************************
N*
N*       Values for requesting function pointers (memory devices)
N*/
N                                          /* Request of a function pointer for... */
N#define MEMDEV_DEVFUNC_WRITETOACTIVE 0x16 /* ...writing the memory device */
N
N/*********************************************************************
N*
N*       Values for requesting data
N*/
N                                       /* Request pointer to... */
N#define LCD_DEVDATA_MEMDEV        0x01 /* ...default memory device API */
N#define LCD_DEVDATA_PHYSPAL       0x02 /* ...physical palette */
N#define LCD_DEVDATA_VRAMADDR      0x03 /* ...VRAM address */
N
N/*********************************************************************
N*
N*       Structures for passing data to LCD_X_DisplayDriver()
N*/
Ntypedef struct {
N  void * pVRAM;
N} LCD_X_SETVRAMADDR_INFO;
N
Ntypedef struct {
N  int xPos, yPos;
N} LCD_X_SETORG_INFO;
N
Ntypedef struct {
N  LCD_COLOR Color;
N  U8 Pos;
X  unsigned char Pos;
N} LCD_X_SETLUTENTRY_INFO;
N
Ntypedef struct {
N  int xSize, ySize;
N} LCD_X_SETSIZE_INFO;
N
Ntypedef struct {
N  int xPos, yPos;
N  int xLen, yLen;
N  int BytesPerPixel;
N  U32 Off;
X  unsigned long Off;
N} LCD_X_SETPOS_INFO;
N
Ntypedef struct {
N  int Alpha;
N} LCD_X_SETALPHA_INFO;
N
Ntypedef struct {
N  int OnOff;
N} LCD_X_SETVIS_INFO;
N
Ntypedef struct {
N  int AlphaMode;
N} LCD_X_SETALPHAMODE_INFO;
N
Ntypedef struct {
N  int ChromaMode;
N} LCD_X_SETCHROMAMODE_INFO;
N
Ntypedef struct {
N  LCD_COLOR ChromaMin;
N  LCD_COLOR ChromaMax;
N} LCD_X_SETCHROMA_INFO;
N
Ntypedef struct {
N  int Index;
N} LCD_X_SHOWBUFFER_INFO;
N
N/*********************************************************************
N*
N*       Commands for LCD_X_DisplayDriver()
N*/
N#define LCD_X_INITCONTROLLER 0x01 /* Initializing the display controller */
N#define LCD_X_SETVRAMADDR    0x02 /* Setting the video RAM address */
N#define LCD_X_SETORG         0x03 /* Setting the origin within a layer */
N#define LCD_X_SETLUTENTRY    0x04 /* Setting an entry of the LUT */
N#define LCD_X_ON             0x05 /* Switching the display on */
N#define LCD_X_OFF            0x06 /* Switching the display off */
N#define LCD_X_SETSIZE        0x07 /* Setting the layer size */
N#define LCD_X_SETPOS         0x08 /* Setting the layer position */
N#define LCD_X_SETVIS         0x09 /* Setting the visibility of a layer */
N#define LCD_X_SETALPHA       0x0A /* Setting the alpha value of the layer */
N#define LCD_X_SETALPHAMODE   0x0B /* Setting the alpha blending mode */
N#define LCD_X_SETCHROMAMODE  0x0C /* Setting the chroma blending mode */
N#define LCD_X_SETCHROMA      0x0D /* Setting the chroma values */
N#define LCD_X_SHOWBUFFER     0x0E /* Switching to the given buffer */
N
Nint  LCD_X_DisplayDriver(unsigned LayerIndex, unsigned Cmd, void * pData);
Nvoid LCD_X_Config(void);
N
N/*********************************************************************
N*
N*       Get/Set layer properties
N*/
Nint  LCD_GetPosEx       (int LayerIndex, int * pxPos, int * pyPos);
Nint  LCD_OffEx          (int LayerIndex);
Nint  LCD_OnEx           (int LayerIndex);
Nint  LCD_RefreshEx      (int LayerIndex);
Nint  LCD_SetAlphaEx     (int LayerIndex, int Alpha);
Nint  LCD_SetAlphaModeEx (int LayerIndex, int AlphaMode);
Nint  LCD_SetBufferPtrEx (int LayerIndex, void ** pBufferPTR);
Nint  LCD_SetChromaEx    (int LayerIndex, LCD_COLOR ChromaMin, LCD_COLOR ChromaMax);
Nint  LCD_SetChromaModeEx(int LayerIndex, int ChromaMode);
Nint  LCD_SetDevFunc     (int LayerIndex, int IdFunc, void (* pDriverFunc)(void));
Nint  LCD_SetLUTEntryEx  (int LayerIndex, U8 Pos, LCD_COLOR Color);
Xint  LCD_SetLUTEntryEx  (int LayerIndex, unsigned char Pos, LCD_COLOR Color);
Nint  LCD_SetPosEx       (int LayerIndex, int xPos, int yPos);
Nint  LCD_SetSizeEx      (int LayerIndex, int xSize, int ySize);
Nint  LCD_SetVisEx       (int LayerIndex, int OnOff);
Nint  LCD_SetVRAMAddrEx  (int LayerIndex, void * pVRAM);
Nint  LCD_SetVSizeEx     (int LayerIndex, int xSize, int ySize);
N
Nint  LCD_GetPos         (int * pxPos, int * pyPos);
Nint  LCD_Off            (void);
Nint  LCD_On             (void);
Nint  LCD_Refresh        (void);
Nint  LCD_SetAlpha       (int Alpha);
Nint  LCD_SetAlphaMode   (int AlphaMode);
Nint  LCD_SetBufferPtr   (void ** pBufferPTR);
Nint  LCD_SetChroma      (LCD_COLOR ChromaMin, LCD_COLOR ChromaMax);
Nint  LCD_SetChromaMode  (int ChromaMode);
Nint  LCD_SetLUTEntry    (U8 Pos, LCD_COLOR Color);
Xint  LCD_SetLUTEntry    (unsigned char Pos, LCD_COLOR Color);
Nvoid LCD_SetOrg         (int xOrg, int yOrg);
Nint  LCD_SetPos         (int xPos, int yPos);
Nint  LCD_SetSize        (int xSize, int ySize);
Nint  LCD_SetVis         (int OnOff);
Nint  LCD_SetVRAMAddr    (void * pVRAM);
Nint  LCD_SetVSize       (int xSize, int ySize);
N
N/*********************************************************************
N*
N*       NEXT_PIXEL API support
N*/
Ntypedef struct {
N  int  (* pfStart)   (int x0, int y0, int x1, int y1);
N  void (* pfSetPixel)(LCD_PIXELINDEX PixelIndex);
X  void (* pfSetPixel)(unsigned long PixelIndex);
N  void (* pfNextLine)(void);
N  void (* pfEnd)     (void);
N} LCD_API_NEXT_PIXEL;
N
NLCD_API_NEXT_PIXEL * LCD_GetNextPixelAPI(void);
N
N/*********************************************************************
N*
N*      LCD_CLIP function table
N*/
Ntypedef void tLCD_HL_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void tLCD_HL_DrawPixel    (int x0, int y0);
N
Ntypedef struct {
N  tLCD_HL_DrawHLine * pfDrawHLine;
N  tLCD_HL_DrawPixel * pfDrawPixel;
N} tLCD_HL_APIList;
N
Nvoid LCD_DrawHLine(int x0, int y0,  int x1);
Nvoid LCD_DrawPixel(int x0, int y0);
Nvoid LCD_DrawVLine(int x,  int y0,  int y1);
N
N
N/*********************************************************************
N*
N*       Declarations for LCD_
N*/
Nvoid LCD_SetClipRectEx(const LCD_RECT * pRect);
Nvoid LCD_SetClipRectMax(void);
N
N/* Get device capabilities (0 if not supported) */
NI32  LCD_GetDevCap  (int Index);
Xsigned long  LCD_GetDevCap  (int Index);
NI32  LCD_GetDevCapEx(int LayerIndex, int Index);
Xsigned long  LCD_GetDevCapEx(int LayerIndex, int Index);
N
N/* Initialize LCD using config-parameters */
Nint LCD_Init(void);
Nint LCD_InitColors(void);
Nint LCD_InitEx(GUI_DEVICE * pDevice, int ClearScreen);
Nint LCD_ExitEx(int LayerIndex);
N
Nvoid LCD_SetBkColor   (LCD_COLOR Color); /* Set background color */
Nvoid LCD_SetColor     (LCD_COLOR Color); /* Set foreground color */
Nvoid LCD_SetPixelIndex(int x, int y, int ColorIndex);
N
N/* Palette routines (Not available on all drivers) */
Nvoid LCD_InitLUT(void);
Nvoid LCD_SetLUTEx(int LayerIndex, const LCD_PHYSPALETTE * pPalette);
Nvoid LCD_SetLUT  (const LCD_PHYSPALETTE * pPalette);
N
NLCD_DRAWMODE LCD_SetDrawMode  (LCD_DRAWMODE dm);
Nvoid LCD_SetColorIndex(unsigned PixelIndex);
Nvoid LCD_SetBkColorIndex(unsigned PixelIndex);
Nvoid LCD_FillRect(int x0, int y0, int x1, int y1);
Ntypedef void tLCD_SetPixelAA(int x, int y, U8 Intens);
Xtypedef void tLCD_SetPixelAA(int x, int y, unsigned char Intens);
N
Nvoid LCD_SetPixelAA4_Trans  (int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA4_Trans  (int x, int y, unsigned char Intens);
Nvoid LCD_SetPixelAA4_NoTrans(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA4_NoTrans(int x, int y, unsigned char Intens);
N
Nvoid LCD_SetPixelAA8_Trans  (int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA8_Trans  (int x, int y, unsigned char Intens);
Nvoid LCD_SetPixelAA8_NoTrans(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA8_NoTrans(int x, int y, unsigned char Intens);
N
Nvoid LCD_AA_EnableGamma(int OnOff);
Nvoid LCD_AA_SetGamma   (U8 * pGamma);
Xvoid LCD_AA_SetGamma   (unsigned char * pGamma);
Nvoid LCD_AA_GetGamma   (U8 * pGamma);
Xvoid LCD_AA_GetGamma   (unsigned char * pGamma);
N
NLCD_COLOR    LCD_AA_MixColors16 (LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR    LCD_AA_MixColors16 (LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
NLCD_COLOR    LCD_AA_MixColors256(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR    LCD_AA_MixColors256(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
NLCD_COLOR    LCD_MixColors256   (LCD_COLOR Color, LCD_COLOR BkColor, unsigned Intens);
NLCD_COLOR    LCD_GetPixelColor(int x, int y);     /* Get RGB color of pixel */
Nunsigned int LCD_GetPixelIndex(int x, int y);
Nint          LCD_GetBkColorIndex (void);
Nint          LCD_GetColorIndex (void);
N#if (GUI_USE_ARGB)
X#if (1)
NU32          LCD_AA_SetOrMask(U32 OrMask);
Xunsigned long          LCD_AA_SetOrMask(unsigned long OrMask);
N#else
SU32          LCD_AA_SetAndMask(U32 AndMask);
N#endif
N
N/* Configuration */
Nint  LCD_SetMaxNumColors(unsigned MaxNumColors);
Nint  LCD_GetMaxNumColors(void);
Nvoid LCD__SetPaletteConversionHook(void (* pfPaletteConversionHook)(const LCD_LOGPALETTE * pLogPal));
N
N/*********************************************************************
N*
N*       Optional support for rotation
N*/
N#if GUI_SUPPORT_ROTATION
X#if 1
N
Ntypedef void tLCD_DrawBitmap(int x0, int y0, int xsize, int ysize,
N                             int xMul, int yMul, int BitsPerPixel, int BytesPerLine,
N                             const U8 * pPixel, const void * pTrans);
X                             const unsigned char * pPixel, const void * pTrans);
Ntypedef void tRect2TextRect (LCD_RECT * pRect);
N
Nstruct tLCD_APIList_struct {
N  tLCD_DrawBitmap   * pfDrawBitmap;
N  tRect2TextRect    * pfRect2TextRect;
N  tRect2TextRect    * pfTransformRect;
N};
N
Ntypedef struct tLCD_APIList_struct tLCD_APIList;
N
Nextern tLCD_APIList LCD_APIListCCW;
Nextern tLCD_APIList LCD_APIListCW;
Nextern tLCD_APIList LCD_APIList180;
N
N#define GUI_ROTATION   tLCD_APIList
N#define GUI_ROTATE_CCW &LCD_APIListCCW
N#define GUI_ROTATE_CW  &LCD_APIListCW
N#define GUI_ROTATE_180 &LCD_APIList180
N#define GUI_ROTATE_0   0
N
NtLCD_SetPixelAA * LCD__GetPfSetPixel(int BitsPerPixel);
N
N#endif
N
N/*********************************************************************
N*
N*       Physical color access, internally used only
N*/
Nvoid LCD__SetPhysColor(U8 Pos, LCD_COLOR Color);
Xvoid LCD__SetPhysColor(unsigned char Pos, LCD_COLOR Color);
N
N/*********************************************************************
N*
N*       Cache control
N*/
N#define LCD_CC_UNLOCK (0)    /* Default mode: Cache is transparent */
N#define LCD_CC_LOCK   (1)    /* Cache is locked, no write operations */
N#define LCD_CC_FLUSH  (2)    /* Flush cache, do not change mode */
N
Nint LCD_ControlCache  (int Cmd);
Nint LCD_ControlCacheEx(int LayerIndex, int Cmd);
N
N/*********************************************************************
N*
N*       Color conversion
N*/
NLCD_PIXELINDEX   LCD_Color2Index     (LCD_COLOR Color);
Xunsigned long   LCD_Color2Index     (LCD_COLOR Color);
NLCD_COLOR        LCD_Index2Color     (int Index);
NLCD_COLOR        LCD_Index2ColorEx   (int i, unsigned LayerIndex);
N
N/*********************************************************************
N*
N*       LCD_X_...
N*/
Nunsigned char LCD_X_Read00(void);
Nunsigned char LCD_X_Read01(void);
Nvoid LCD_X_Write00 (unsigned char c);
Nvoid LCD_X_Write01 (unsigned char c);
Nvoid LCD_X_WriteM01(unsigned char * pData, int NumBytes);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif /* LCD_H */
N
N/*************************** End of file ****************************/
L 52 "..\..\..\ThirdParty\emWin\Include\GUI_Type.h" 2
N#include "GUIConf.h"
N
N/*********************************************************************
N*
N*       Common types
N*/
Ntypedef const char *  GUI_ConstString;
N
Ntypedef LCD_COLOR       GUI_COLOR;
Ntypedef LCD_LOGPALETTE  GUI_LOGPALETTE;
Ntypedef LCD_DRAWMODE    GUI_DRAWMODE;
Ntypedef LCD_RECT        GUI_RECT;
N
Ntypedef struct {
N  void      (* pfDraw)  (int x0,
N                         int y0,
N                         int xsize, 
N                         int ysize, 
N                         const U8 * pPixel, 
X                         const unsigned char * pPixel, 
N                         const LCD_LOGPALETTE * pLogPal, 
N                         int xMag, 
N                         int yMag);
N  GUI_COLOR (* pfIndex2Color)(LCD_PIXELINDEX Index);
X  GUI_COLOR (* pfIndex2Color)(unsigned long Index);
N  void      (* pfDrawHW)(int x0,
N                         int y0,
N                         int xsize, 
N                         int ysize, 
N                         const U8 * pPixel, 
X                         const unsigned char * pPixel, 
N                         const LCD_LOGPALETTE * pLogPal, 
N                         int xMag, 
N                         int yMag);
N  const LCD_API_COLOR_CONV * pColorConvAPI;
N} GUI_BITMAP_METHODS;
N
Ntypedef struct {
N  U16P XSize;
X  unsigned short XSize;
N  U16P YSize;
X  unsigned short YSize;
N  U16P BytesPerLine;
X  unsigned short BytesPerLine;
N  U16P BitsPerPixel;
X  unsigned short BitsPerPixel;
N  const U8 * pData;
X  const unsigned char * pData;
N  const GUI_LOGPALETTE * pPal;
N  const GUI_BITMAP_METHODS * pMethods;
N} GUI_BITMAP;
N
N/* This structure may not be changed because the data that it
N   expects is read in binary form (via any kind of interface,
N   at runtime).
N   This structure should therefor not be changed.
N*/
Ntypedef struct {
N  U16 ID;
X  unsigned short ID;
N  U16 Format;
X  unsigned short Format;
N  U16 XSize;
X  unsigned short XSize;
N  U16 YSize;
X  unsigned short YSize;
N  U16 BytesPerLine;
X  unsigned short BytesPerLine;
N  U16 BitsPerPixel;
X  unsigned short BitsPerPixel;
N  U16 NumColors;
X  unsigned short NumColors;
N  U16 HasTrans;
X  unsigned short HasTrans;
N} GUI_BITMAP_STREAM;
N
Ntypedef struct {
N  int    Cmd;
N  U32    v;
X  unsigned long    v;
N  void * p;
N} GUI_BITMAPSTREAM_PARAM;
N
Ntypedef struct {
N  int XSize;
N  int YSize;
N  int BitsPerPixel;
N  int NumColors;
N  int HasTrans;
N} GUI_BITMAPSTREAM_INFO;
N
Ntypedef void * (* GUI_BITMAPSTREAM_CALLBACK)(GUI_BITMAPSTREAM_PARAM * pParam);
N
Ntypedef struct {
N  int x,y;
N  U8  Pressed;
X  unsigned char  Pressed;
N  U8  Layer;
X  unsigned char  Layer;
N} GUI_PID_STATE;
N
Ntypedef struct {
N  int Key;
N  int Pressed;
N} GUI_KEY_STATE;
N
Ntypedef struct {
N  int xPos;
N  int yPos;
N  int xSize;
N  int ySize;
N  int Delay;
N} GUI_GIF_IMAGE_INFO;
N
Ntypedef struct {
N  int xSize;
N  int ySize;
N  int NumImages;
N} GUI_GIF_INFO;
N
N#define GUI_REGISTER_INIT GUI_REGISTER_HOOK
N#define GUI_REGISTER_EXIT GUI_REGISTER_HOOK
N
Ntypedef struct GUI_REGISTER_HOOK GUI_REGISTER_HOOK;
N
Nstruct GUI_REGISTER_HOOK {
N  void (* pfVoid)(void);
N  GUI_REGISTER_HOOK * pNext;
N};
N
Ntypedef struct {
N  void (* cbBegin)(void);
N  void (* cbEnd)  (void);
N} GUI_MULTIBUF_API;
N
Ntypedef struct {
N  void (* cbBeginEx)(int LayerIndex);
N  void (* cbEndEx)  (int LayerIndex);
N} GUI_MULTIBUF_API_EX;
N
N/*********************************************************************
N*
N*       FONT structures
N*/
N
N/* Translation list. Translates a character code into up to 2
N   indices of images to display on top of each other;
N   '' -> index('a'), index('') */
Ntypedef struct {
N  I16P c0;
X  signed short c0;
N  I16P c1;
X  signed short c1;
N} GUI_FONT_TRANSLIST;
N
Ntypedef struct {
N  U16P FirstChar;
X  unsigned short FirstChar;
N  U16P LastChar;
X  unsigned short LastChar;
N  const GUI_FONT_TRANSLIST * pList;
N} GUI_FONT_TRANSINFO;
N
Ntypedef struct {
N  U8 XSize;
X  unsigned char XSize;
N  U8 XDist;
X  unsigned char XDist;
N  U8 BytesPerLine;
X  unsigned char BytesPerLine;
N  const unsigned char * pData;
N} GUI_CHARINFO;
N
Ntypedef struct {
N  U8 XSize;
X  unsigned char XSize;
N  U8 YSize;
X  unsigned char YSize;
N  I8 XPos;
X  signed char XPos;
N  I8 YPos;
X  signed char YPos;
N  U8 XDist;
X  unsigned char XDist;
N  const unsigned char * pData;
N} GUI_CHARINFO_EXT;
N
Ntypedef struct GUI_FONT_PROP {
N  U16P First;                                  /* First character               */
X  unsigned short First;                                   
N  U16P Last;                                   /* Last character                */
X  unsigned short Last;                                    
N  const GUI_CHARINFO         * paCharInfo;     /* Address of first character    */
N  const struct GUI_FONT_PROP * pNext;          /* Pointer to next               */
N} GUI_FONT_PROP;
N
Ntypedef struct GUI_FONT_PROP_EXT {
N  U16P First;                                  /* First character               */
X  unsigned short First;                                   
N  U16P Last;                                   /* Last character                */
X  unsigned short Last;                                    
N  const GUI_CHARINFO_EXT         * paCharInfo; /* Address of first character    */
N  const struct GUI_FONT_PROP_EXT * pNext;      /* Pointer to next               */
N} GUI_FONT_PROP_EXT;
N
Ntypedef struct {
N  const unsigned char      * pData;
N  const U8                 * pTransData;
X  const unsigned char                 * pTransData;
N  const GUI_FONT_TRANSINFO * pTrans;
N  U16P                       FirstChar;
X  unsigned short                       FirstChar;
N  U16P                       LastChar;
X  unsigned short                       LastChar;
N  U8                         XSize;
X  unsigned char                         XSize;
N  U8                         XDist;
X  unsigned char                         XDist;
N  U8                         BytesPerLine;
X  unsigned char                         BytesPerLine;
N} GUI_FONT_MONO;
N
N/*********************************************************************
N*
N*       FONT structures
N*
N* This structure is used when retrieving information about a font.
N* It is designed for future expansion without incompatibilities.
N*/
Ntypedef struct {
N  U16 Flags;
X  unsigned short Flags;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N} GUI_FONTINFO;
N
N#define GUI_FONTINFO_FLAG_PROP    (1 << 0)    /* Is proportional */
N#define GUI_FONTINFO_FLAG_MONO    (1 << 1)    /* Is monospaced */
N#define GUI_FONTINFO_FLAG_AA      (1 << 2)    /* Is an antialiased font */
N#define GUI_FONTINFO_FLAG_AA2     (1 << 3)    /* Is an antialiased font, 2bpp */
N#define GUI_FONTINFO_FLAG_AA4     (1 << 4)    /* Is an antialiased font, 4bpp */
N#define GUI_FONTINFO_FLAG_PROPFRM (1 << 5)    /* Is proportional, framed */
N
N/*********************************************************************
N*
N*       UNICODE Encoding
N*/
Ntypedef U16  tGUI_GetCharCode   (const char * s);
Xtypedef unsigned short  tGUI_GetCharCode   (const char * s);
Ntypedef int  tGUI_GetCharSize   (const char * s);
Ntypedef int  tGUI_CalcSizeOfChar(U16 Char);
Xtypedef int  tGUI_CalcSizeOfChar(unsigned short Char);
Ntypedef int  tGUI_Encode        (char * s, U16 Char);
Xtypedef int  tGUI_Encode        (char * s, unsigned short Char);
N
Ntypedef struct {
N  tGUI_GetCharCode    * pfGetCharCode;
N  tGUI_GetCharSize    * pfGetCharSize;
N  tGUI_CalcSizeOfChar * pfCalcSizeOfChar;
N  tGUI_Encode         * pfEncode;
N} GUI_UC_ENC_APILIST;
N
N/*********************************************************************
N*
N*       FONT Encoding
N*/
Ntypedef int  tGUI_GetLineDistX(const char * s, int Len);
Ntypedef int  tGUI_GetLineLen  (const char * s, int MaxLen);
Ntypedef void tGL_DispLine     (const char * s, int Len);
N
Ntypedef struct {
N  tGUI_GetLineDistX * pfGetLineDistX;
N  tGUI_GetLineLen   * pfGetLineLen;
N  tGL_DispLine      * pfDispLine;
N} tGUI_ENC_APIList;
N
Nextern const tGUI_ENC_APIList GUI_ENC_APIList_SJIS;
Nextern const tGUI_ENC_APIList GUI_ENC_APIList_EXT;
N
N/*********************************************************************
N*
N*       FONT methods
N*/
Ntypedef struct GUI_FONT GUI_FONT;
N
Ntypedef void GUI_DISPCHAR    (U16 c);
Xtypedef void GUI_DISPCHAR    (unsigned short c);
Ntypedef int  GUI_GETCHARDISTX(U16P c, int * pSizeX);
Xtypedef int  GUI_GETCHARDISTX(unsigned short c, int * pSizeX);
Ntypedef void GUI_GETFONTINFO (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Ntypedef char GUI_ISINFONT    (const GUI_FONT * pFont, U16 c);
Xtypedef char GUI_ISINFONT    (const GUI_FONT * pFont, unsigned short c);
Ntypedef int  GUI_GETCHARINFO (U16P c, GUI_CHARINFO_EXT * pInfo);
Xtypedef int  GUI_GETCHARINFO (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N
N#define DECLARE_FONT(Type)                                     \
Nvoid GUI##Type##_DispChar    (U16P c);                         \
Nint  GUI##Type##_GetCharDistX(U16P c, int * pSizeX);                         \
Nvoid GUI##Type##_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); \
Nchar GUI##Type##_IsInFont    (const GUI_FONT * pFont, U16 c); \
Nint  GUI##Type##_GetCharInfo (U16P c, GUI_CHARINFO_EXT * pInfo)
X#define DECLARE_FONT(Type)                                     void GUI##Type##_DispChar    (U16P c);                         int  GUI##Type##_GetCharDistX(U16P c, int * pSizeX);                         void GUI##Type##_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUI##Type##_IsInFont    (const GUI_FONT * pFont, U16 c); int  GUI##Type##_GetCharInfo (U16P c, GUI_CHARINFO_EXT * pInfo)
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
NDECLARE_FONT(MONO);
Xvoid GUIMONO_DispChar (unsigned short c); int GUIMONO_GetCharDistX(unsigned short c, int * pSizeX); void GUIMONO_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIMONO_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIMONO_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP);
Xvoid GUIPROP_DispChar (unsigned short c); int GUIPROP_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_EXT);
Xvoid GUIPROP_EXT_DispChar (unsigned short c); int GUIPROP_EXT_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_EXT_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_EXT_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_FRM);
Xvoid GUIPROP_FRM_DispChar (unsigned short c); int GUIPROP_FRM_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_FRM_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_FRM_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_FRM_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROPAA);
Xvoid GUIPROPAA_DispChar (unsigned short c); int GUIPROPAA_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROPAA_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROPAA_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROPAA_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA2);
Xvoid GUIPROP_AA2_DispChar (unsigned short c); int GUIPROP_AA2_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA2_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA2_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA2_EXT);
Xvoid GUIPROP_AA2_EXT_DispChar (unsigned short c); int GUIPROP_AA2_EXT_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA2_EXT_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_EXT_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA2_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA4);
Xvoid GUIPROP_AA4_DispChar (unsigned short c); int GUIPROP_AA4_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA4_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA4_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA4_EXT);
Xvoid GUIPROP_AA4_EXT_DispChar (unsigned short c); int GUIPROP_AA4_EXT_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA4_EXT_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_EXT_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA4_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N
N/* MONO: Monospaced fonts */
N#define GUI_FONTTYPE_MONO       \
N  GUIMONO_DispChar,             \
N  GUIMONO_GetCharDistX,         \
N  GUIMONO_GetFontInfo,          \
N  GUIMONO_IsInFont,             \
N  (GUI_GETCHARINFO *)0,         \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_MONO         GUIMONO_DispChar,               GUIMONO_GetCharDistX,           GUIMONO_GetFontInfo,            GUIMONO_IsInFont,               (GUI_GETCHARINFO *)0,           (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts */
N#define GUI_FONTTYPE_PROP       \
N  GUIPROP_DispChar,             \
N  GUIPROP_GetCharDistX,         \
N  GUIPROP_GetFontInfo,          \
N  GUIPROP_IsInFont,             \
N  (GUI_GETCHARINFO *)0,         \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP         GUIPROP_DispChar,               GUIPROP_GetCharDistX,           GUIPROP_GetFontInfo,            GUIPROP_IsInFont,               (GUI_GETCHARINFO *)0,           (tGUI_ENC_APIList*)0
N
N/* PROP_EXT: Extended proportional fonts */
N#define GUI_FONTTYPE_PROP_EXT       \
N  GUIPROP_EXT_DispChar,             \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_EXT         GUIPROP_EXT_DispChar,               GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_FRM: Extended proportional fonts, framed */
N#define GUI_FONTTYPE_PROP_FRM       \
N  GUIPROP_FRM_DispChar,             \
N  GUIPROP_FRM_GetCharDistX,         \
N  GUIPROP_FRM_GetFontInfo,          \
N  GUIPROP_FRM_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_FRM         GUIPROP_FRM_DispChar,               GUIPROP_FRM_GetCharDistX,           GUIPROP_FRM_GetFontInfo,            GUIPROP_FRM_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts SJIS */
N#define GUI_FONTTYPE_PROP_SJIS  \
N  GUIPROP_DispChar,             \
N  GUIPROP_GetCharDistX,         \
N  GUIPROP_GetFontInfo,          \
N  GUIPROP_IsInFont,             \
N  (GUI_GETCHARINFO *)0,         \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_SJIS    GUIPROP_DispChar,               GUIPROP_GetCharDistX,           GUIPROP_GetFontInfo,            GUIPROP_IsInFont,               (GUI_GETCHARINFO *)0,           &GUI_ENC_APIList_SJIS
N
N/* PROPAA: Proportional, antialiased fonts */
N#define GUI_FONTTYPE_PROPAA       \
N  GUIPROPAA_DispChar,             \
N  GUIPROPAA_GetCharDistX,         \
N  GUIPROPAA_GetFontInfo,          \
N  GUIPROPAA_IsInFont,             \
N  (GUI_GETCHARINFO *)0,           \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROPAA         GUIPROPAA_DispChar,               GUIPROPAA_GetCharDistX,           GUIPROPAA_GetFontInfo,            GUIPROPAA_IsInFont,               (GUI_GETCHARINFO *)0,             (tGUI_ENC_APIList*)0
N
N/* PROP_AA2: Proportional, antialiased fonts, 2bpp */
N#define GUI_FONTTYPE_PROP_AA2       \
N  GUIPROP_AA2_DispChar,             \
N  GUIPROP_AA2_GetCharDistX,         \
N  GUIPROP_AA2_GetFontInfo,          \
N  GUIPROP_AA2_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA2         GUIPROP_AA2_DispChar,               GUIPROP_AA2_GetCharDistX,           GUIPROP_AA2_GetFontInfo,            GUIPROP_AA2_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP_AA2_EXT: Proportional, antialiased fonts, 2bpp, extended font information */
N#define GUI_FONTTYPE_PROP_AA2_EXT   \
N  GUIPROP_AA2_EXT_DispChar,         \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_AA2_EXT     GUIPROP_AA2_EXT_DispChar,           GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_AA2: Proportional, antialiased fonts, 2bpp, SJIS encoding */
N#define GUI_FONTTYPE_PROP_AA2_SJIS  \
N  GUIPROP_AA2_DispChar,             \
N  GUIPROP_AA2_GetCharDistX,         \
N  GUIPROP_AA2_GetFontInfo,          \
N  GUIPROP_AA2_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_AA2_SJIS    GUIPROP_AA2_DispChar,               GUIPROP_AA2_GetCharDistX,           GUIPROP_AA2_GetFontInfo,            GUIPROP_AA2_IsInFont,               (GUI_GETCHARINFO *)0,               &GUI_ENC_APIList_SJIS
N
N/* PROP_AA4: Proportional, antialiased fonts, 4bpp */
N#define GUI_FONTTYPE_PROP_AA4       \
N  GUIPROP_AA4_DispChar,             \
N  GUIPROP_AA4_GetCharDistX,         \
N  GUIPROP_AA4_GetFontInfo,          \
N  GUIPROP_AA4_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA4         GUIPROP_AA4_DispChar,               GUIPROP_AA4_GetCharDistX,           GUIPROP_AA4_GetFontInfo,            GUIPROP_AA4_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP_AA4_EXT: Proportional, antialiased fonts, 4bpp, extended font information */
N#define GUI_FONTTYPE_PROP_AA4_EXT   \
N  GUIPROP_AA4_EXT_DispChar,         \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_AA4_EXT     GUIPROP_AA4_EXT_DispChar,           GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_AA4: Proportional, antialiased fonts, 4bpp, SJIS encoding */
N#define GUI_FONTTYPE_PROP_AA4_SJIS  \
N  GUIPROP_AA4_DispChar,             \
N  GUIPROP_AA4_GetCharDistX,         \
N  GUIPROP_AA4_GetFontInfo,          \
N  GUIPROP_AA4_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_AA4_SJIS    GUIPROP_AA4_DispChar,               GUIPROP_AA4_GetCharDistX,           GUIPROP_AA4_GetFontInfo,            GUIPROP_AA4_IsInFont,               (GUI_GETCHARINFO *)0,               &GUI_ENC_APIList_SJIS
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
Nstruct GUI_FONT {
N  GUI_DISPCHAR     * pfDispChar; 
N  GUI_GETCHARDISTX * pfGetCharDistX; 
N  GUI_GETFONTINFO  * pfGetFontInfo; 
N  GUI_ISINFONT     * pfIsInFont;
N  GUI_GETCHARINFO  * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N  U8 YSize;
X  unsigned char YSize;
N  U8 YDist;
X  unsigned char YDist;
N  U8 XMag;
X  unsigned char XMag;
N  U8 YMag;
X  unsigned char YMag;
N  union {
N    const void              * pFontData;
N    const GUI_FONT_MONO     * pMono;
N    const GUI_FONT_PROP     * pProp;
N    const GUI_FONT_PROP_EXT * pPropExt;
N  } p;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* Height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* Height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N};
N
N/*********************************************************************
N*
N*       Bitmap serialization (BMP)
N*/
Ntypedef void GUI_CALLBACK_VOID_U8_P(U8 Data, void * p);
Xtypedef void GUI_CALLBACK_VOID_U8_P(unsigned char Data, void * p);
N
N/*********************************************************************
N*
N*       System independent font structures (SIF)
N*/
Ntypedef struct {
N  U32 ID;           /* Font file ID */
X  unsigned long ID;            
N  U16 YSize;        /* Height of font */
X  unsigned short YSize;         
N  U16 YDist;        /* Space of font Y */
X  unsigned short YDist;         
N  U16 Baseline;     /* Index of baseline */
X  unsigned short Baseline;      
N  U16 LHeight;      /* Height of a small lower case character (a) */
X  unsigned short LHeight;       
N  U16 CHeight;      /* Height of a upper case character (A) */
X  unsigned short CHeight;       
N  U16 NumAreas;     /* Number of character areas */
X  unsigned short NumAreas;      
N} GUI_SI_FONT;
N
Ntypedef struct {
N  U16 First;        /* Index of first character */
X  unsigned short First;         
N  U16 Last;         /* Index of last character */
X  unsigned short Last;          
N} GUI_SIF_CHAR_AREA;
N
Ntypedef struct {
N  U16 XSize;        /* Size of bitmap data in X */
X  unsigned short XSize;         
N  U16 XDist;        /* Number of pixels for increment cursor in X */
X  unsigned short XDist;         
N  U16 BytesPerLine; /* Number of bytes per line */
X  unsigned short BytesPerLine;  
N  U16 Dummy;
X  unsigned short Dummy;
N  U32 OffData;      /* Offset of pixel data */
X  unsigned long OffData;       
N} GUI_SIF_CHARINFO;
N
Ntypedef struct {
N  U16 XSize;        /* Size of bitmap data in X */
X  unsigned short XSize;         
N  U16 YSize;        /* Size of bitmap data in X */
X  unsigned short YSize;         
N  I16 XOff;         /* Display offset of bitmap data in X */
X  signed short XOff;          
N  I16 YOff;         /* Display offset of bitmap data in Y */
X  signed short YOff;          
N  U16 XDist;        /* Number of pixels for increment cursor in X */
X  unsigned short XDist;         
N  U16 Dummy;
X  unsigned short Dummy;
N  U32 OffData;      /* Offset of pixel data */
X  unsigned long OffData;       
N} GUI_SIF_CHARINFO_EXT;
N
Ntypedef struct tGUI_SIF_APIList_struct {
N  GUI_DISPCHAR          * pfDispChar;
N  GUI_GETCHARDISTX      * pfGetCharDistX;
N  GUI_GETFONTINFO       * pfGetFontInfo;
N  GUI_ISINFONT          * pfIsInFont;
N  GUI_GETCHARINFO       * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N} tGUI_SIF_APIList;
N
N#define GUI_SIF_TYPE              tGUI_SIF_APIList
N#define GUI_SIF_TYPE_PROP         &GUI_SIF_APIList_Prop
N#define GUI_SIF_TYPE_PROP_EXT     &GUI_SIF_APIList_Prop_Ext
N#define GUI_SIF_TYPE_PROP_FRM     &GUI_SIF_APIList_Prop_Frm
N#define GUI_SIF_TYPE_PROP_AA2     &GUI_SIF_APIList_Prop_AA2
N#define GUI_SIF_TYPE_PROP_AA4     &GUI_SIF_APIList_Prop_AA4
N#define GUI_SIF_TYPE_PROP_AA2_EXT &GUI_SIF_APIList_Prop_AA2_EXT
N#define GUI_SIF_TYPE_PROP_AA4_EXT &GUI_SIF_APIList_Prop_AA4_EXT
N
N/*********************************************************************
N*
N*       External binary font structures (XBF)
N*/
Ntypedef int GUI_XBF_GET_DATA_FUNC(U32 Off, U16 NumBytes, void * pVoid, void * pBuffer);
Xtypedef int GUI_XBF_GET_DATA_FUNC(unsigned long Off, unsigned short NumBytes, void * pVoid, void * pBuffer);
N
Ntypedef struct {
N  U16 First;                         /* First character of font */
X  unsigned short First;                          
N  U16 Last;                          /* Last character of font */
X  unsigned short Last;                           
N  void * pVoid;                      /* Void pointer passed to GetData-function */
N  GUI_XBF_GET_DATA_FUNC * pfGetData; /* Pointer to callback function */
N} GUI_XBF_DATA;
N
Ntypedef struct tGUI_XBF_APIList_struct {
N  GUI_DISPCHAR          * pfDispChar;
N  GUI_GETCHARDISTX      * pfGetCharDistX;
N  GUI_GETFONTINFO       * pfGetFontInfo;
N  GUI_ISINFONT          * pfIsInFont;
N  GUI_GETCHARINFO       * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N} tGUI_XBF_APIList;
N
N#define GUI_XBF_TYPE              tGUI_XBF_APIList
N#define GUI_XBF_TYPE_PROP         &GUI_XBF_APIList_Prop
N#define GUI_XBF_TYPE_PROP_EXT     &GUI_XBF_APIList_Prop_Ext
N#define GUI_XBF_TYPE_PROP_FRM     &GUI_XBF_APIList_Prop_Frm
N#define GUI_XBF_TYPE_PROP_AA2_EXT &GUI_XBF_APIList_Prop_AA2_Ext
N#define GUI_XBF_TYPE_PROP_AA4_EXT &GUI_XBF_APIList_Prop_AA4_Ext
N
N/*********************************************************************
N*
N*       TrueType support (TTF)
N*/
Ntypedef struct {
N  const void * pData;      /* Pointer to TTF font file in addressable memory area */
N  U32 NumBytes;            /* Size of file in bytes */
X  unsigned long NumBytes;             
N} GUI_TTF_DATA;
N
Ntypedef struct {
N  GUI_TTF_DATA * pTTF;     /* Pointer to GUI_TTF_DATA structure which contains location and size of font file */
N  U32 aImageTypeBuffer[4]; /* Buffer for image type structure */
X  unsigned long aImageTypeBuffer[4];  
N  int PixelHeight;         /* Pixel height of new font. It means the height of the surrounding rectangle
N                            * between the glyphs 'g' anf 'f'. Please notice that it is not the distance
N                            * between two lines of text. With other words the value returned byGUI_GetFontSizeY()
N                            * is not identically with this value. */
N  int FaceIndex;           /* Some font files can contain more than one font face. In case of more than one face
N                            * this index specifies the zero based face index to be used to create the font. 
N                            * Usually 0. */
N} GUI_TTF_CS;
N
N/*********************************************************************
N*
N*       Task synchronization
N*/
Ntypedef void (* GUI_SIGNAL_EVENT_FUNC)    (void);
Ntypedef void (* GUI_WAIT_EVENT_FUNC)      (void);
Ntypedef void (* GUI_WAIT_EVENT_TIMED_FUNC)(int Period);
N
N/*********************************************************************
N*
N*       Memory management
N*/
N#ifndef     GUI_HMEM
N  #define     GUI_HMEM        I32
N#endif
N#define     GUI_HMEM_NULL     (0)
Ntypedef     GUI_HMEM      GUI_HWIN;
Xtypedef     signed long      GUI_HWIN;
Ntypedef     GUI_HMEM      GUI_HSPRITE;
Xtypedef     signed long      GUI_HSPRITE;
N
N/*********************************************************************
N*
N*       Multi touch input
N*/
N#ifndef   GUI_MTOUCH_MAX_NUM_POINTS
N  #define GUI_MTOUCH_MAX_NUM_POINTS 10
N#endif
N
Ntypedef struct {
N  I32 x;
X  signed long x;
N  I32 y;
X  signed long y;
N  U32 Id;
X  unsigned long Id;
N  U16 Flags;
X  unsigned short Flags;
N} GUI_MTOUCH_INPUT;
N
Ntypedef struct {
N  int            LayerIndex;
N  unsigned       NumPoints;
N  GUI_TIMER_TIME TimeStamp;
X  int TimeStamp;
N  PTR_ADDR       hInput;
X  unsigned long       hInput;
N} GUI_MTOUCH_EVENT;
N
N//
N// Used for emWinSPY with reduced data types and array sizes
N//
Ntypedef struct {
N  U8  Layer;
X  unsigned char  Layer;
N  U8  NumPoints;
X  unsigned char  NumPoints;
N  I16 ax[5];
X  signed short ax[5];
N  I16 ay[5];
X  signed short ay[5];
N  U16 aId[5];
X  unsigned short aId[5];
N  U8  aFlags[5];
X  unsigned char  aFlags[5];
N} GUI_MTOUCH_STATE;
N
Ntypedef void (* T_GUI_MTOUCH_STOREEVENT)(GUI_MTOUCH_EVENT *, GUI_MTOUCH_INPUT * pInput);
N
N/*********************************************************************
N*
N*       Hardware routines
N*/
Ntypedef struct {
N  //
N  // 8 Bit access
N  //
N  void (* pfWrite8_A0)  (U8 Data);
X  void (* pfWrite8_A0)  (unsigned char Data);
N  void (* pfWrite8_A1)  (U8 Data);
X  void (* pfWrite8_A1)  (unsigned char Data);
N  void (* pfWriteM8_A0) (U8 * pData, int NumItems);
X  void (* pfWriteM8_A0) (unsigned char * pData, int NumItems);
N  void (* pfWriteM8_A1) (U8 * pData, int NumItems);
X  void (* pfWriteM8_A1) (unsigned char * pData, int NumItems);
N  U8   (* pfRead8_A0)   (void);
X  unsigned char   (* pfRead8_A0)   (void);
N  U8   (* pfRead8_A1)   (void);
X  unsigned char   (* pfRead8_A1)   (void);
N  void (* pfReadM8_A0)  (U8 * pData, int NumItems);
X  void (* pfReadM8_A0)  (unsigned char * pData, int NumItems);
N  void (* pfReadM8_A1)  (U8 * pData, int NumItems);
X  void (* pfReadM8_A1)  (unsigned char * pData, int NumItems);
N  //
N  // 16 Bit access
N  //
N  void (* pfWrite16_A0) (U16 Data);
X  void (* pfWrite16_A0) (unsigned short Data);
N  void (* pfWrite16_A1) (U16 Data);
X  void (* pfWrite16_A1) (unsigned short Data);
N  void (* pfWriteM16_A0)(U16 * pData, int NumItems);
X  void (* pfWriteM16_A0)(unsigned short * pData, int NumItems);
N  void (* pfWriteM16_A1)(U16 * pData, int NumItems);
X  void (* pfWriteM16_A1)(unsigned short * pData, int NumItems);
N  U16  (* pfRead16_A0)  (void);
X  unsigned short  (* pfRead16_A0)  (void);
N  U16  (* pfRead16_A1)  (void);
X  unsigned short  (* pfRead16_A1)  (void);
N  void (* pfReadM16_A0) (U16 * pData, int NumItems);
X  void (* pfReadM16_A0) (unsigned short * pData, int NumItems);
N  void (* pfReadM16_A1) (U16 * pData, int NumItems);
X  void (* pfReadM16_A1) (unsigned short * pData, int NumItems);
N  //
N  // 32 Bit access
N  //
N  void (* pfWrite32_A0) (U32 Data);
X  void (* pfWrite32_A0) (unsigned long Data);
N  void (* pfWrite32_A1) (U32 Data);
X  void (* pfWrite32_A1) (unsigned long Data);
N  void (* pfWriteM32_A0)(U32 * pData, int NumItems);
X  void (* pfWriteM32_A0)(unsigned long * pData, int NumItems);
N  void (* pfWriteM32_A1)(U32 * pData, int NumItems);
X  void (* pfWriteM32_A1)(unsigned long * pData, int NumItems);
N  U32  (* pfRead32_A0)  (void);
X  unsigned long  (* pfRead32_A0)  (void);
N  U32  (* pfRead32_A1)  (void);
X  unsigned long  (* pfRead32_A1)  (void);
N  void (* pfReadM32_A0) (U32 * pData, int NumItems);
X  void (* pfReadM32_A0) (unsigned long * pData, int NumItems);
N  void (* pfReadM32_A1) (U32 * pData, int NumItems);
X  void (* pfReadM32_A1) (unsigned long * pData, int NumItems);
N  //
N  // SPI access
N  //
N  void (* pfSetCS)      (U8 NotActive);
X  void (* pfSetCS)      (unsigned char NotActive);
N  //
N  // Common routines
N  //
N  void (* pfFlushBuffer)(void);
N} GUI_PORT_API;
N
N/*********************************************************************
N*
N*       Send/Receive function for VNC and/or emWinSPY
N*/
Ntypedef int    (* GUI_tSend)  (const U8 * pData, int len, void * p);
Xtypedef int    (* GUI_tSend)  (const unsigned char * pData, int len, void * p);
Ntypedef int    (* GUI_tRecv)  (      U8 * pData, int len, void * p);
Xtypedef int    (* GUI_tRecv)  (      unsigned char * pData, int len, void * p);
N
N/*********************************************************************
N*
N*       Memory allocation replacement for emWinSPY
N*/
Ntypedef void * (* GUI_tMalloc)(unsigned int);
Ntypedef void   (* GUI_tFree)  (void *);
N
N#endif  /* GUITYPE_H_INCLUDED */
N
N/*************************** End of file ****************************/
L 50 "..\..\..\ThirdParty\emWin\Include\WM.h" 2
N#include "WM_GUI.h"       /* Some functions needed by GUI routines */
L 1 "..\..\..\ThirdParty\emWin\Include\WM_GUI.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WM_GUI.h
NPurpose     : Windows manager include for low level GUI routines
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_GUI_H            /* Make sure we only include it once */
N#define WM_GUI_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
Nint       WM__InitIVRSearch(const GUI_RECT* pMaxRect);
Nint       WM__GetNextIVR   (void);
Nint       WM__GetOrgX_AA(void);
Nint       WM__GetOrgY_AA(void);
N
N#define WM_ITERATE_START(pRect)                   \
N  {                                               \
N    if (WM__InitIVRSearch(pRect))                 \
N      do {
X#define WM_ITERATE_START(pRect)                     {                                                   if (WM__InitIVRSearch(pRect))                       do {
N
N#define WM_ITERATE_END()                          \
N    } while (WM__GetNextIVR());                   \
N  }
X#define WM_ITERATE_END()                              } while (WM__GetNextIVR());                     }
N
N#define WM_ADDORGX(x)       (x += GUI_pContext->xOff)
N#define WM_ADDORGY(y)       (y += GUI_pContext->yOff)
N#define WM_ADDORG(x0,y0)    WM_ADDORGX(x0); WM_ADDORGY(y0)
N#define WM_ADDORGX_AA(x)    (x += WM__GetOrgX_AA())
N#define WM_ADDORGY_AA(y)    (y += WM__GetOrgY_AA())
N#define WM_ADDORG_AA(x0,y0) WM_ADDORGX_AA(x0); WM_ADDORGY_AA(y0)
N#define WM_SUBORGX(x)       (x -= GUI_pContext->xOff)
N#define WM_SUBORGY(y)       (y -= GUI_pContext->yOff)
N#define WM_SUBORG(x0,y0)    WM_SUBORGX(x0); WM_SUBORGY(y0)
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 51 "..\..\..\ThirdParty\emWin\Include\WM.h" 2
N#include "GUI.h"
L 1 "..\..\..\ThirdParty\emWin\Include\GUI.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI.h
NPurpose     : GUI API include file
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef  GUI_H
N#define  GUI_H
N
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199409L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 48 "..\..\..\ThirdParty\emWin\Include\GUI.h" 2
N
N#include "GUI_ConfDefaults.h"
N#include "GUI_Type.h"
N#include "GUI_Version.h"
L 1 "..\..\..\ThirdParty\emWin\Include\GUI_Version.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_Version.h
NPurpose     : Include file defining current GUI version
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef  GUI_VERSION_H
N#define  GUI_VERSION_H
N
N#define GUI_VERSION 548112
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 52 "..\..\..\ThirdParty\emWin\Include\GUI.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Disable string function warning with newer MSVC versions
N*/
N#if defined (_MSC_VER)
X#if 0L
S  #if (_MSC_VER > 1200)
S    #pragma warning( disable : 4996)
S  #endif
N#endif
N
N/*********************************************************************
N*
N*       Macros, function replacement
N*/
N#define GUI_COUNTOF(a)          (sizeof(a) / sizeof(a[0]))
N#define GUI_MIN(a,b)            (((a) < (b)) ? (a) : (b))
N#define GUI_MAX(a,b)            (((a) > (b)) ? (a) : (b))
N#define GUI_ZEROFILL(p, Size)   (memset(p, 0, Size)) /**/
N
N/*********************************************************************
N*
N*       Support for multitasking systems (locking)
N*/
Ntypedef struct GUI_CONTEXT GUI_CONTEXT;
N
N#if !GUI_OS
X#if !(1)
S  #define GUI_LOCK()
S  #define GUI_UNLOCK()
S  #define GUITASK_INIT()
S  #define GUITASK_COPY_CONTEXT()
N#else
N  void GUI_Lock(void);
N  void GUI_Unlock(void);
N  void GUITASK_Init(void);
N  void GUITASK_CopyContext(void);
N  void GUITASK_SetMaxTask(int MaxTask);
N  int  GUITASK_GetMaxTask(void);
N  GUI_CONTEXT * GUITASK_GetpContext(int Index);
N  #define GUI_LOCK()             GUI_Lock()
N  #define GUI_UNLOCK()           GUI_Unlock()
N  #define GUITASK_INIT()         GUITASK_Init()
N  #define GUITASK_COPY_CONTEXT() GUITASK_CopyContext()
N#endif
N
N/*********************************************************************
N*
N*       API table of a display driver
N*/
Nstruct GUI_DEVICE_API {
N  //
N  // Data
N  //
N  int DeviceClassIndex;
N  //
N  // Drawing functions
N  //
N  void           (* pfDrawBitmap   )(GUI_DEVICE *  pDevice,  int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const U8 * pData, int Diff, const LCD_PIXELINDEX * pTrans);
X  void           (* pfDrawBitmap   )(GUI_DEVICE *  pDevice,  int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const unsigned char * pData, int Diff, const unsigned long * pTrans);
N  void           (* pfDrawHLine    )(GUI_DEVICE *  pDevice,  int x0, int y0,  int x1);
N  void           (* pfDrawVLine    )(GUI_DEVICE *  pDevice,  int x , int y0,  int y1);
N  void           (* pfFillRect     )(GUI_DEVICE *  pDevice,  int x0, int y0, int x1, int y1);
N  LCD_PIXELINDEX (* pfGetPixelIndex)(GUI_DEVICE *  pDevice,  int x, int y);
X  unsigned long (* pfGetPixelIndex)(GUI_DEVICE *  pDevice,  int x, int y);
N  void           (* pfSetPixelIndex)(GUI_DEVICE *  pDevice,  int x, int y, LCD_PIXELINDEX ColorIndex);
X  void           (* pfSetPixelIndex)(GUI_DEVICE *  pDevice,  int x, int y, unsigned long ColorIndex);
N  void           (* pfXorPixel     )(GUI_DEVICE *  pDevice,  int x, int y);
N  //
N  // Set origin
N  //
N  void           (* pfSetOrg       )(GUI_DEVICE *  pDevice,  int x, int y);
N  //
N  // Request information
N  //
N  void         (*(* pfGetDevFunc)   (GUI_DEVICE ** ppDevice, int Index))(void);
N  I32            (* pfGetDevProp   )(GUI_DEVICE *  pDevice,  int Index);
X  signed long            (* pfGetDevProp   )(GUI_DEVICE *  pDevice,  int Index);
N  void          *(* pfGetDevData   )(GUI_DEVICE *  pDevice,  int Index);
N  void           (* pfGetRect      )(GUI_DEVICE *  pDevice,  LCD_RECT * pRect);
N};
N
N/*********************************************************************
N*
N*       Device classes
N*/
Ntypedef enum {
N  DEVICE_CLASS_DRIVER = 0,
N  DEVICE_CLASS_DRIVER_MODIFIER,   // Zoom or delta-pixel modifier
N  DEVICE_CLASS_VNC,
N  DEVICE_CLASS_SPRITE,
N  DEVICE_CLASS_MEMDEV,
N  DEVICE_CLASS_ALPHA,
N  DEVICE_CLASS_AUTOALPHA,
N  DEVICE_CLASS_MEASDEV
N} DEVICE_CLASS;
N
N#define GUI_DEVICE_STAYONTOP 1
N
N/*********************************************************************
N*
N*       Display drivers
N*/
N//
N// Addresses
N//
Nextern const GUI_DEVICE_API GUIDRV_Win_API;
Nextern const GUI_DEVICE_API GUIDRV_Template_API;
N
N//
N// Macros to be used in configuration files
N//
N#define GUIDRV_WIN32       &GUIDRV_Win_API
N
N#if defined(WIN32) && !defined(LCD_SIMCONTROLLER)
X#if 0L && !0L
S  #define GUIDRV_TEMPLATE         &GUIDRV_Win_API
N#else
N  #define GUIDRV_TEMPLATE         &GUIDRV_Template_API
N#endif
N
N/*********************************************************************
N*
N*       Definition of GUI_DEVICE structure
N*/
Nstruct GUI_DEVICE {
N  //
N  // Linking
N  //
N  GUI_DEVICE * pNext;
N  GUI_DEVICE * pPrev;
N  //
N  // Data
N  //
N  union {
N    GUI_HMEM hContext; // Handle of payload data like sprite- or memory device context
X    signed long hContext; 
N    void   * pContext; // Pointer for context data in a fixed block
N  } u;
N  //
N  // API pointers
N  //
N  const GUI_DEVICE_API     * pDeviceAPI;
N  const LCD_API_COLOR_CONV * pColorConvAPI;
N  U16 Flags;
X  unsigned short Flags;
N  int LayerIndex;
N};
N
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_1;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_8;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_16;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_32;
N
N/*********************************************************************
N*
N*       GUI_CONTEXT
N*
N*  This structure is public for one reason only:
N*  To allow the application to save and restore the context.
N*/
Ntypedef union {
N  U8  aColorIndex8[2];
X  unsigned char  aColorIndex8[2];
N  U16 aColorIndex16[2];
X  unsigned short aColorIndex16[2];
N  U32 aColorIndex32[2];
X  unsigned long aColorIndex32[2];
N} LCD_COLORINDEX_UNION;
N
Nstruct GUI_CONTEXT {
N  //
N  // Variables in LCD module
N  //
N  LCD_COLORINDEX_UNION uLCD;
N  LCD_RECT       ClipRect;
N  U8             DrawMode;
X  unsigned char             DrawMode;
N  U8             SelLayer;
X  unsigned char             SelLayer;
N  U8             TextStyle;
X  unsigned char             TextStyle;
N  //
N  // Variables in GL module
N  //
N  GUI_RECT * pClipRect_HL;                 // High level clip rectangle ... Speed optimization so drawing routines can optimize
N  U8         PenSize;
X  unsigned char         PenSize;
N  U8         PenShape;
X  unsigned char         PenShape;
N  U8         LineStyle;
X  unsigned char         LineStyle;
N  U8         StrikeWidth;
X  unsigned char         StrikeWidth;
N  //
N  // Variables in GUICHAR module
N  //
N  const GUI_FONT * pAFont;
N  I16P LBorder;
X  signed short LBorder;
N  I16P DispPosX, DispPosY;
X  signed short DispPosX, DispPosY;
N  I16P DrawPosX, DrawPosY;
X  signed short DrawPosX, DrawPosY;
N  I16P TextMode, TextAlign;
X  signed short TextMode, TextAlign;
N  GUI_COLOR Color, BkColor;                // Required only when changing devices and for speed opt (caching)
N  //
N  // Pointer to  color indices
N  //
N  LCD_PIXELINDEX * LCD_pBkColorIndex;
X  unsigned long * LCD_pBkColorIndex;
N  LCD_PIXELINDEX * LCD_pColorIndex;
X  unsigned long * LCD_pColorIndex;
N  //
N  // Variables in WM module
N  //
N  #if GUI_WINSUPPORT
X  #if 1
N    const GUI_RECT * WM__pUserClipRect;
N    GUI_HWIN hAWin;
N    int xOff, yOff;
N    U8 WM_IsActive;
X    unsigned char WM_IsActive;
N  #endif
N  //
N  // Array of pointers to device chains
N  //
N  GUI_DEVICE * apDriver[GUI_NUM_LAYERS];
X  GUI_DEVICE * apDriver[1];
N  //
N  // Variables in MEMDEV module (with memory devices only)
N  //
N  GUI_HMEM    hDevData;
X  signed long    hDevData;
N  //
N  // Variables in Anitaliasing module
N  //
N  const tLCD_HL_APIList * pLCD_HL;       // Required to reroute drawing (HLine & Pixel) to the AA module
N  U8 AA_Factor;
X  unsigned char AA_Factor;
N  U8 AA_HiResEnable;
X  unsigned char AA_HiResEnable;
N  void (* AA_pfSetPixelAA)(int x, int y, U8 Intens); // Function to be used for drawing a single pixel
X  void (* AA_pfSetPixelAA)(int x, int y, unsigned char Intens); 
N  //
N  // Used to reference and link in the copyright string for libraries.
N  //
N  const char * sCopyright;
N};
N
N/* Rename GUI_SaveContext in order to avoid crashes if wrong GUIConf is used */
N#if (GUI_WINSUPPORT == 1)
X#if (1 == 1)
N  #define GUI_SaveContext GUI_SaveContext_W
N#else
S  #define GUI_SaveContext GUI_SaveContext_
N#endif
N
N/*********************************************************************
N*
N*       Device management
N*/
NGUI_DEVICE * GUI_DEVICE_Create       (const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, U16 Flags, int LayerIndex);
XGUI_DEVICE * GUI_DEVICE_Create       (const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, unsigned short Flags, int LayerIndex);
NGUI_DEVICE * GUI_DEVICE_CreateAndLink(const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, U16 Flags, int LayerIndex);
XGUI_DEVICE * GUI_DEVICE_CreateAndLink(const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, unsigned short Flags, int LayerIndex);
Nvoid         GUI_DEVICE_Delete       (GUI_DEVICE * pDevice);
Nint          GUI_DEVICE_Link         (GUI_DEVICE * pDevice);
Nvoid         GUI_DEVICE_Unlink       (GUI_DEVICE * pDevice);
NGUI_DEVICE * GUI_DEVICE__GetpDriver  (int LayerIndex);
NGUI_DEVICE * GUI_DEVICE__GetpDevice  (int LayerIndex, int DeviceClass);
N
NGUI_DEVICE * GUI_DEVICE_UnlinkTaskDevices(void);
Nvoid         GUI_DEVICE_LinkDevices      (GUI_DEVICE * pDevice);
N
N/*********************************************************************
N*
N*       GUI_DIRTYDEVICE
N*/
Ntypedef struct {
N  void * pData;         // Pointer to first pixel
N  int    x0, y0;        // Coordinates of the upper left pixel
N  int    xSize, ySize;  // Size of dirty rectangle
N  int    LineOff;       // Virtual xSize in pixels
N  int    BytesPerPixel; // Number of bytes required per pixel
N  int    IsDirty;       // Indicates if dirty pixels exist
N} GUI_DIRTYDEVICE_INFO;
N
Nint GUI_DIRTYDEVICE_Create      (void);
Nint GUI_DIRTYDEVICE_CreateEx    (int LayerIndex);
Nint GUI_DIRTYDEVICE_CreateExInfo(GUI_DIRTYDEVICE_INFO * pInfo, int LayerIndex);
Nint GUI_DIRTYDEVICE_Delete      (void);
Nint GUI_DIRTYDEVICE_DeleteEx    (int LayerIndex);
Nint GUI_DIRTYDEVICE_Fetch       (GUI_DIRTYDEVICE_INFO * pInfo);
Nint GUI_DIRTYDEVICE_FetchEx     (GUI_DIRTYDEVICE_INFO * pInfo, int LayerIndex);
N
N/*********************************************************************
N*
N*       GUI_GCACHE
N*/
Nint GUI_GCACHE_4_Create(const LCD_API_COLOR_CONV * pColorConvAPI);
Nint GUI_GCACHE_4_CreateEx(int LayerIndex, const LCD_API_COLOR_CONV * pColorConvAPI);
N
N/*********************************************************************
N*
N*       GUI_DCACHE
N*/
Nvoid GUI_DCACHE_SetClearCacheHook(void (* pFunc)(U32 LayerMask));
Xvoid GUI_DCACHE_SetClearCacheHook(void (* pFunc)(unsigned long LayerMask));
Nvoid GUI_DCACHE_Clear            (U32 LayerMask);
Xvoid GUI_DCACHE_Clear            (unsigned long LayerMask);
N
Nextern void (* GUI_DCACHE__pfClearCacheHook)(U32 LayerMask);
Xextern void (* GUI_DCACHE__pfClearCacheHook)(unsigned long LayerMask);
N
N/*********************************************************************
N*
N*       GUI_SOFTLAYER
N*/
Ntypedef struct {
N  int xPos;
N  int yPos;
N  int xSize;
N  int ySize;
N  int Visible;
N} GUI_SOFTLAYER_CONFIG;
N
Nint  GUI_SOFTLAYER_Enable           (GUI_SOFTLAYER_CONFIG * pConfig, int NumLayers, GUI_COLOR CompositeColor);
Nint  GUI_SOFTLAYER_Refresh          (void);
Nvoid GUI_SOFTLAYER_SetCompositeColor(U32 Color);
Xvoid GUI_SOFTLAYER_SetCompositeColor(unsigned long Color);
Nint  GUI_SOFTLAYER_MULTIBUF_Enable  (int OnOff);
N
N/*********************************************************************
N*
N*       General routines
N*/
Nvoid             GUI_Exit                 (void);
NGUI_COLOR        GUI_GetDefaultBkColor    (void);
NGUI_COLOR        GUI_GetDefaultColor      (void);
Nconst GUI_FONT * GUI_GetDefaultFont       (void);
Nint              GUI_GetScreenSizeX       (void);
Nint              GUI_GetScreenSizeY       (void);
Nconst char *     GUI_GetVersionString     (void);
Nint              GUI_Init                 (void);
Nint              GUI_IsInitialized        (void);
Nvoid             GUI_SetAfterInitHook     (void (* pFunc)(void));
Nvoid             GUI_RegisterAfterInitHook(void (* pFunc)(void), GUI_REGISTER_INIT * pRegisterInit);
Xvoid             GUI_RegisterAfterInitHook(void (* pFunc)(void), GUI_REGISTER_HOOK * pRegisterInit);
Nvoid             GUI_RestoreContext       (const GUI_CONTEXT * pContext);
Nvoid             GUI_SaveContext          (GUI_CONTEXT * pContext);
Xvoid             GUI_SaveContext_W          (GUI_CONTEXT * pContext);
Nconst GUI_RECT * GUI_SetClipRect          (const GUI_RECT * pRect);
Nvoid             GUI_SetControlHook       (void (* pFunc)(int LayerIndex, int Cmd));
Nvoid             GUI_SetDefault           (void);
Nvoid             GUI_SetDefaultBkColor    (GUI_COLOR Color);
Nvoid             GUI_SetDefaultColor      (GUI_COLOR Color);
Nvoid             GUI_SetDefaultFont       (const GUI_FONT * pFont);
NGUI_DRAWMODE     GUI_SetDrawMode          (GUI_DRAWMODE dm);
Nvoid             GUI_SetScreenSizeX       (int xSize);
Nvoid             GUI_SetScreenSizeY       (int ySize);
Nvoid             GUI_SetRefreshHook       (void (* pFunc)(void));
Nvoid             MainTask                 (void);
N
N#define GUI_PID_SetInitFunc(x) GUI_SetAfterInitHook(x)  // Compatibility
N
N/*********************************************************************
N*
N*       Function replacement
N*/
Nvoid GUI_SetpfMemset(void * (* pFunc)(void * pDest, int c, size_t Cnt));
Nvoid GUI_SetpfMemcpy(void * (* pFunc)(void * pDest, const void * pSrc, size_t Cnt));
Nvoid GUI_SetpfStrcmp(int    (* pFunc)(const char *, const char *));
Nvoid GUI_SetpfStrlen(size_t (* pFunc)(const char *));
Nvoid GUI_SetpfStrcpy(char * (* pFunc)(char *, const char *));
N
N/*********************************************************************
N*
N*       Rectangle helper functions
N*/
Nvoid GUI_AddRect        (GUI_RECT * pDest, const GUI_RECT * pRect, int Dist);
Nint  GUI_RectsIntersect(const GUI_RECT * pr0, const GUI_RECT * pr1);
Nvoid GUI_MoveRect       (GUI_RECT * pRect, int x, int y);
Nvoid GUI_MergeRect      (GUI_RECT * pDest, const GUI_RECT * pr0, const GUI_RECT * pr1);
Nint  GUI__IntersectRects(GUI_RECT * pDest, const GUI_RECT * pr0, const GUI_RECT * pr1);
Nvoid GUI__IntersectRect (GUI_RECT * pDest, const GUI_RECT * pr0);
Nvoid GUI__ReduceRect    (GUI_RECT * pDest, const GUI_RECT * pRect, int Dist);
N
N/*********************************************************************
N*
N*       Misc helper functions
N*/
NI32  GUI__ATan2(I32 x, I32 y, I32 * ph);
Xsigned long  GUI__ATan2(signed long x, signed long y, signed long * ph);
NI32  GUI__ASinHQ(I32 SinHQ);
Xsigned long  GUI__ASinHQ(signed long SinHQ);
Nint  GUI__CompactPixelIndices  (LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel);
Xint  GUI__CompactPixelIndices  (unsigned long * pBuffer, int NumPixels, int BitsPerPixel);
Nint  GUI__CompactPixelIndicesEx(LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI);
Xint  GUI__CompactPixelIndicesEx(unsigned long * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI);
Nint  GUI__ConvertColor2Index   (LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI, void * pResult);
Xint  GUI__ConvertColor2Index   (unsigned long * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI, void * pResult);
Nvoid GUI__Config(void);
NI32  GUI__CosHQ(I32 Ang1000);
Xsigned long  GUI__CosHQ(signed long Ang1000);
Nint  GUI__DivideRound     (int a, int b);
NI32  GUI__DivideRound32   (I32 a, I32 b);
Xsigned long  GUI__DivideRound32   (signed long a, signed long b);
Nvoid GUI__ExpandPixelIndices   (void * pBuffer, int NumPixels, int BitsPerPixel);
Nvoid GUI__ExpandPixelIndicesEx (void * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI);
Nint  GUI__SetText(GUI_HMEM * phText, const char * s);
Xint  GUI__SetText(signed long * phText, const char * s);
NI32  GUI__SinHQ(I32 Ang1000);
Xsigned long  GUI__SinHQ(signed long Ang1000);
NI32  GUI__sqrt32(I32 Square);
Xsigned long  GUI__sqrt32(signed long Square);
Nvoid GUI__DrawTwinArc2(int xl, int xr, int y0,         int r, GUI_COLOR ColorR0, GUI_COLOR ColorR1, GUI_COLOR ColorFill);
Nvoid GUI__DrawTwinArc4(int x0, int y0, int x1, int y1, int r, GUI_COLOR ColorR0, GUI_COLOR ColorR1, GUI_COLOR ColorFill);
Nvoid GUI__FillTrippleArc(int x0, int y0, int Size, GUI_COLOR ColorR0, GUI_COLOR ColorR1, GUI_COLOR ColorR2, GUI_COLOR ColorFill);
Nvoid GUI__RegisterExit(GUI_REGISTER_EXIT * pRegisterExit);
Xvoid GUI__RegisterExit(GUI_REGISTER_HOOK * pRegisterExit);
Nvoid GUI__RegisterInit(GUI_REGISTER_INIT * pRegisterInit);
Xvoid GUI__RegisterInit(GUI_REGISTER_HOOK * pRegisterInit);
N
N/*********************************************************************
N*
N*       Optional function replacement
N*/
Nvoid * GUI__memcpy(void * pDest, const void * pSrc, size_t NumBytes);
Nvoid * GUI__memset(void * pDest, int c, size_t Cnt);
N
N/*********************************************************************
N*
N*       Get / Set Attributes
N*/
NGUI_COLOR GUI_GetBkColor     (void);
Nint       GUI_GetBkColorIndex(void);
NGUI_COLOR GUI_GetColor       (void);
Nint       GUI_GetColorIndex  (void);
NU8        GUI_GetLineStyle   (void);
Xunsigned char        GUI_GetLineStyle   (void);
NU8        GUI_GetPenSize     (void);
Xunsigned char        GUI_GetPenSize     (void);
NU8        GUI_GetPenShape    (void);
Xunsigned char        GUI_GetPenShape    (void);
Nunsigned  GUI_GetPixelIndex  (int x, int y);
N
Nvoid      GUI_SetBkColor   (GUI_COLOR);
Nvoid      GUI_SetColor     (GUI_COLOR);
Nvoid      GUI_SetBkColorIndex(int Index);
Nvoid      GUI_SetColorIndex(int Index);
N
NU8        GUI_SetPenSize   (U8 Size);
Xunsigned char        GUI_SetPenSize   (unsigned char Size);
NU8        GUI_SetPenShape  (U8 Shape);
Xunsigned char        GUI_SetPenShape  (unsigned char Shape);
NU8        GUI_SetLineStyle (U8 Style);
Xunsigned char        GUI_SetLineStyle (unsigned char Style);
N
N/* Get/Set Character used as decimal point (usually '.' or ',') */
Nchar      GUI_GetDecChar(void);
Nchar      GUI_SetDecChar(char c);
N
N/*********************************************************************
N*
N*       Color / Index related functions
N*/
Nint       GUI_Color2Index(GUI_COLOR color);
NGUI_COLOR GUI_Color2VisColor(GUI_COLOR color);
Nchar      GUI_ColorIsAvailable(GUI_COLOR color);
NGUI_COLOR GUI_Index2Color(int Index);
NU32       GUI_CalcColorDist (GUI_COLOR Color0, GUI_COLOR  Color1);
Xunsigned long       GUI_CalcColorDist (GUI_COLOR Color0, GUI_COLOR  Color1);
NU32       GUI_CalcVisColorError(GUI_COLOR color);
Xunsigned long       GUI_CalcVisColorError(GUI_COLOR color);
N
N/*********************************************************************
N*
N*       Error handler
N*/
Nvoid GUI_SetOnErrorFunc(void (* pFunc)(const char * s));
N
N/*********************************************************************
N*
N*       Logging (for debugging primarily)
N*/
Nvoid GUI_Log      (const char * s);
Nvoid GUI_Log1     (const char * s, I32 p0);
Xvoid GUI_Log1     (const char * s, signed long p0);
Nvoid GUI_Log2     (const char * s, I32 p0, I32 p1);
Xvoid GUI_Log2     (const char * s, signed long p0, signed long p1);
Nvoid GUI_Log3     (const char * s, I32 p0, I32 p1, I32 p2);
Xvoid GUI_Log3     (const char * s, signed long p0, signed long p1, signed long p2);
Nvoid GUI_Log4     (const char * s, I32 p0, I32 p1, I32 p2,I32 p3);
Xvoid GUI_Log4     (const char * s, signed long p0, signed long p1, signed long p2,signed long p3);
Nvoid GUI_Warn     (const char * s);
Nvoid GUI_Warn1    (const char * s, I32 p0);
Xvoid GUI_Warn1    (const char * s, signed long p0);
Nvoid GUI_Warn2    (const char * s, I32 p0, I32 p1);
Xvoid GUI_Warn2    (const char * s, signed long p0, signed long p1);
Nvoid GUI_Warn3    (const char * s, I32 p0, I32 p1, I32 p2);
Xvoid GUI_Warn3    (const char * s, signed long p0, signed long p1, signed long p2);
Nvoid GUI_Warn4    (const char * s, I32 p0, I32 p1, I32 p2, I32 p3);
Xvoid GUI_Warn4    (const char * s, signed long p0, signed long p1, signed long p2, signed long p3);
Nvoid GUI_ErrorOut (const char * s);
Nvoid GUI_ErrorOut1(const char * s, I32 p0);
Xvoid GUI_ErrorOut1(const char * s, signed long p0);
Nvoid GUI_ErrorOut2(const char * s, I32 p0, I32 p1);
Xvoid GUI_ErrorOut2(const char * s, signed long p0, signed long p1);
Nvoid GUI_ErrorOut3(const char * s, I32 p0, I32 p1, I32 p2);
Xvoid GUI_ErrorOut3(const char * s, signed long p0, signed long p1, signed long p2);
Nvoid GUI_ErrorOut4(const char * s, I32 p0, I32 p1, I32 p2, I32 p3);
Xvoid GUI_ErrorOut4(const char * s, signed long p0, signed long p1, signed long p2, signed long p3);
N
N/*********************************************************************
N*
N*       2d - GL
N*/
Nvoid GUI_Clear            (void);
Nvoid GUI_ClearRect        (int x0, int y0, int x1, int y1);
Nvoid GUI_ClearRectEx      (const GUI_RECT * pRect);
Nvoid GUI_CopyRect         (int x0, int y0, int x1, int y1, int dx, int dy);
Nvoid GUI_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_DrawBitmap       (const GUI_BITMAP * pBM, int x0, int y0);
Nvoid GUI_DrawBitmapMag    (const GUI_BITMAP * pBM, int x0, int y0, int XMul, int YMul);
Nvoid GUI_DrawBitmapEx     (const GUI_BITMAP * pBM, int x0, int y0, int xCenter, int yCenter, int xMag, int yMag);
Nvoid GUI_DrawBitmapExp    (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const U8 * pData, const GUI_LOGPALETTE * pPal);
Xvoid GUI_DrawBitmapExp    (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const unsigned char * pData, const GUI_LOGPALETTE * pPal);
Nvoid GUI_DrawBitmapHWAlpha(const GUI_BITMAP * pBM, int x0, int y0);
Nvoid GUI_DrawCircle       (int x0, int y0, int r);
Nvoid GUI_DrawEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_DrawGradientH    (int x0, int y0, int x1, int y1, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientV    (int x0, int y0, int x1, int y1, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientRoundedH(int x0, int y0, int x1, int y1, int rd, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientRoundedV(int x0, int y0, int x1, int y1, int rd, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGraph        (I16 * pay, int NumPoints, int x0, int y0);
Xvoid GUI_DrawGraph        (signed short * pay, int NumPoints, int x0, int y0);
Nvoid GUI_DrawGraphEx      (I16 * pay, int NumPoints, int x0, int y0, int Numerator, int Denominator, int MirrorX);
Xvoid GUI_DrawGraphEx      (signed short * pay, int NumPoints, int x0, int y0, int Numerator, int Denominator, int MirrorX);
Nvoid GUI_DrawHLine        (int y0, int x0, int x1);
Nvoid GUI_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawLineRel      (int dx, int dy);
Nvoid GUI_DrawLineTo       (int x, int y);
Nvoid GUI_DrawPie          (int x0, int y0, int r, int a0, int a1, int Type);
Nvoid GUI_DrawPixel        (int x, int y);
Nvoid GUI_DrawPoint        (int x, int y);
Nvoid GUI_DrawPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawPolyLine     (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawFocusRect    (const GUI_RECT  * pRect, int Dist);
Nvoid GUI_DrawRect         (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawRectEx       (const GUI_RECT * pRect);
Nvoid GUI_DrawRoundedFrame (int x0, int y0, int x1, int y1, int r, int w);
Nvoid GUI_DrawRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_DrawVLine        (int x0, int y0, int y1);
Nvoid GUI_FillCircle       (int x0, int y0, int r);
Nvoid GUI_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_FillPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_FillRect         (int x0, int y0, int x1, int y1);
Nvoid GUI_FillRectEx       (const GUI_RECT * pRect);
Nvoid GUI_FillRoundedFrame (int x0, int y0, int x1, int y1, int r, int w);
Nvoid GUI_FillRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_FillRoundedRectB (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_FillRoundedRectT (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_GetClientRect    (GUI_RECT * pRect);
Nvoid GUI_InvertRect       (int x0, int y0, int x1, int y1);
Nvoid GUI_MoveRel          (int dx, int dy);
Nvoid GUI_MoveTo           (int x, int y);
Nvoid GUI_SetAlphaMask8888 (U32 OrMask, U32 AndMask);
Xvoid GUI_SetAlphaMask8888 (unsigned long OrMask, unsigned long AndMask);
N
N/*********************************************************************
N*
N*       IMAGE file support
N*/
Ntypedef int GUI_GET_DATA_FUNC(void * p, const U8 ** ppData, unsigned NumBytes, U32 Off);
Xtypedef int GUI_GET_DATA_FUNC(void * p, const unsigned char ** ppData, unsigned NumBytes, unsigned long Off);
N
N/*********************************************************************
N*
N*       GIF file support
N*/
Nint GUI_GIF_Draw           (const void * pGIF, U32 NumBytes,         int x0, int y0);
Xint GUI_GIF_Draw           (const void * pGIF, unsigned long NumBytes,         int x0, int y0);
Nint GUI_GIF_DrawEx         (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_GIF_DrawSub        (const void * pGIF, U32 NumBytes,         int x0, int y0, int Index);
Xint GUI_GIF_DrawSub        (const void * pGIF, unsigned long NumBytes,         int x0, int y0, int Index);
Nint GUI_GIF_DrawSubEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Index);
Nint GUI_GIF_DrawSubScaled  (const void * pGIF, U32 NumBytes,         int x0, int y0, int Index, int Num, int Denom);
Xint GUI_GIF_DrawSubScaled  (const void * pGIF, unsigned long NumBytes,         int x0, int y0, int Index, int Num, int Denom);
Nint GUI_GIF_DrawSubScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Index, int Num, int Denom);
Nint GUI_GIF_GetComment     (const void * pGIF, U32 NumBytes,         U8 * pBuffer, int MaxSize, int Index);
Xint GUI_GIF_GetComment     (const void * pGIF, unsigned long NumBytes,         unsigned char * pBuffer, int MaxSize, int Index);
Nint GUI_GIF_GetCommentEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, U8 * pBuffer, int MaxSize, int Index);
Xint GUI_GIF_GetCommentEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, unsigned char * pBuffer, int MaxSize, int Index);
Nint GUI_GIF_GetImageInfo   (const void * pGIF, U32 NumBytes,         GUI_GIF_IMAGE_INFO * pInfo, int Index);
Xint GUI_GIF_GetImageInfo   (const void * pGIF, unsigned long NumBytes,         GUI_GIF_IMAGE_INFO * pInfo, int Index);
Nint GUI_GIF_GetImageInfoEx (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_GIF_IMAGE_INFO * pInfo, int Index);
Nint GUI_GIF_GetInfo        (const void * pGIF, U32 NumBytes,         GUI_GIF_INFO * pInfo);
Xint GUI_GIF_GetInfo        (const void * pGIF, unsigned long NumBytes,         GUI_GIF_INFO * pInfo);
Nint GUI_GIF_GetInfoEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_GIF_INFO * pInfo);
Nint GUI_GIF_GetXSize       (const void * pGIF);
Nint GUI_GIF_GetXSizeEx     (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_GIF_GetYSize       (const void * pGIF);
Nint GUI_GIF_GetYSizeEx     (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_GIF_SetFillTrans   (int OnOff);
N
N/*********************************************************************
N*
N*       BMP file support
N*/
Nint  GUI_BMP_Draw        (const void * pFileData,                  int x0, int y0);
Nint  GUI_BMP_DrawEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint  GUI_BMP_DrawScaled  (const void * pFileData,                  int x0, int y0, int Num, int Denom);
Nint  GUI_BMP_DrawScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Num, int Denom);
Nint  GUI_BMP_GetXSize    (const void * pFileData);
Nint  GUI_BMP_GetXSizeEx  (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint  GUI_BMP_GetYSize    (const void * pFileData);
Nint  GUI_BMP_GetYSizeEx  (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nvoid GUI_BMP_EnableAlpha (void);
Nvoid GUI_BMP_DisableAlpha(void);
N
N/*********************************************************************
N*
N*       PNG file support
N*/
Nint GUI_PNG_Draw      (const void * pFileData, int DataSize, int x0, int y0);
Nint GUI_PNG_DrawEx    (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_PNG_GetXSize  (const void * pFileData, int FileSize);
Nint GUI_PNG_GetXSizeEx(GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_PNG_GetYSize  (const void * pFileData, int FileSize);
Nint GUI_PNG_GetYSizeEx(GUI_GET_DATA_FUNC * pfGetData, void * p);
N
N/*********************************************************************
N*
N*       JPEG file support
N*/
Ntypedef struct {
N  int XSize;
N  int YSize;
N} GUI_JPEG_INFO;
N
Nint GUI_JPEG_Draw        (const void * pFileData, int DataSize,    int x0, int y0);
Nint GUI_JPEG_DrawEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_JPEG_DrawScaled  (const void * pFileData, int DataSize,    int x0, int y0, int Num, int Denom);
Nint GUI_JPEG_DrawScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Num, int Denom);
Nint GUI_JPEG_GetInfo     (const void * pFileData, int DataSize,    GUI_JPEG_INFO * pInfo);
Nint GUI_JPEG_GetInfoEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_JPEG_INFO * pInfo);
N
Nvoid GUI_JPEG_SetpfDrawEx(int (* pfDrawEx)(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0));
N
N/*********************************************************************
N*
N*       MOVIE file support
N*/
N#define GUI_MOVIE_NOTIFICATION_PREDRAW  0 // Immediately before frame is drawn
N#define GUI_MOVIE_NOTIFICATION_POSTDRAW 1 // Immediately after a frame is drawn
N#define GUI_MOVIE_NOTIFICATION_START    2 // Send when start playing a movie
N#define GUI_MOVIE_NOTIFICATION_STOP     3 // Movie has stopped
N#define GUI_MOVIE_NOTIFICATION_DELETE   4 // Movie has been deleted
N
Ntypedef GUI_HMEM GUI_MOVIE_HANDLE;
Xtypedef signed long GUI_MOVIE_HANDLE;
N
Ntypedef void GUI_MOVIE_FUNC(GUI_MOVIE_HANDLE hMovie, int Notification, U32 CurrentFrame);
Xtypedef void GUI_MOVIE_FUNC(GUI_MOVIE_HANDLE hMovie, int Notification, unsigned long CurrentFrame);
N
Ntypedef struct {
N  int xSize;         // X-size of images
N  int ySize;         // Y-size of images
N  int msPerFrame;    // Default duration of 1 frame
N  U32 NumFrames;     // Number of frames
X  unsigned long NumFrames;     
N} GUI_MOVIE_INFO;
N
NGUI_MOVIE_HANDLE GUI_MOVIE_Create       (const void * pFileData, U32 FileSize, GUI_MOVIE_FUNC * pfNotify);
XGUI_MOVIE_HANDLE GUI_MOVIE_Create       (const void * pFileData, unsigned long FileSize, GUI_MOVIE_FUNC * pfNotify);
NGUI_MOVIE_HANDLE GUI_MOVIE_CreateEx     (GUI_GET_DATA_FUNC * pfGetData, void * pParam, GUI_MOVIE_FUNC * pfNotify);
Nint              GUI_MOVIE_Delete       (GUI_MOVIE_HANDLE hMovie);
Nvoid             GUI_MOVIE_DrawFrame    (GUI_MOVIE_HANDLE hMovie, int Index, int x, int y);
NU32              GUI_MOVIE_GetFrameIndex(GUI_MOVIE_HANDLE hMovie);
Xunsigned long              GUI_MOVIE_GetFrameIndex(GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_GetInfo      (const void * pFileData, U32 FileSize, GUI_MOVIE_INFO * pInfo);
Xint              GUI_MOVIE_GetInfo      (const void * pFileData, unsigned long FileSize, GUI_MOVIE_INFO * pInfo);
Nint              GUI_MOVIE_GetInfoEx    (GUI_GET_DATA_FUNC * pfGetData, void * pParam, GUI_MOVIE_INFO * pInfo);
Nint              GUI_MOVIE_GetNumFrames (GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_GetPos       (GUI_MOVIE_HANDLE hMovie, int * pxPos, int * pyPos, int * pxSize, int * pySize);
Nint              GUI_MOVIE_GotoFrame    (GUI_MOVIE_HANDLE hMovie, U32 Frame);
Xint              GUI_MOVIE_GotoFrame    (GUI_MOVIE_HANDLE hMovie, unsigned long Frame);
Nint              GUI_MOVIE_Pause        (GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_Play         (GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_SetPeriod    (GUI_MOVIE_HANDLE hMovie, unsigned Period);
Nvoid             GUI_MOVIE_SetpfNotify  (GUI_MOVIE_FUNC * pfNotify);
Nint              GUI_MOVIE_SetPos       (GUI_MOVIE_HANDLE hMovie, int xPos, int yPos);
Nint              GUI_MOVIE_Show         (GUI_MOVIE_HANDLE hMovie, int xPos, int yPos, int DoLoop);
N
N/*********************************************************************
N*
N*       Splines
N*/
NGUI_HMEM GUI_SPLINE_Create  (const int * px, const int * py, unsigned NumPoints);
Xsigned long GUI_SPLINE_Create  (const int * px, const int * py, unsigned NumPoints);
Nvoid     GUI_SPLINE_Draw    (GUI_HMEM hSpline, int x, int y);
Xvoid     GUI_SPLINE_Draw    (signed long hSpline, int x, int y);
Nvoid     GUI_SPLINE_Delete  (GUI_HMEM hSpline);
Xvoid     GUI_SPLINE_Delete  (signed long hSpline);
NI16      GUI_SPLINE_GetY    (GUI_HMEM hSpline, unsigned Index, float * py);
Xsigned short      GUI_SPLINE_GetY    (signed long hSpline, unsigned Index, float * py);
Nunsigned GUI_SPLINE_GetXSize(GUI_HMEM hSpline);
Xunsigned GUI_SPLINE_GetXSize(signed long hSpline);
Nvoid     GUI_SPLINE_DrawAA  (GUI_HMEM hSpline, int x, int y, unsigned Width);
Xvoid     GUI_SPLINE_DrawAA  (signed long hSpline, int x, int y, unsigned Width);
N
N/*********************************************************************
N*
N*       Cursor routines
N*/
N#define GUI_CURSOR_SHOW 0
N#define GUI_CURSOR_HIDE 1
N
Ntypedef struct {
N  const GUI_BITMAP  * pBitmap;
N  int                 xHot;
N  int                 yHot;
N} GUI_CURSOR;
N
Ntypedef struct {
N  const GUI_BITMAP ** ppBm;
N  int                 xHot;
N  int                 yHot;
N  unsigned            Period;
N  const unsigned    * pPeriod;
N  int                 NumItems;
N} GUI_CURSOR_ANIM;
N
N#if GUI_SUPPORT_CURSOR
X#if (1 | (1))
N  int                GUI_CURSOR_GetState     (void);
N  int                GUI_CURSOR_GetStateEx   (int Layer);
N  void               GUI_CURSOR_Hide         (void);
N  void               GUI_CURSOR_HideEx       (int Layer);
N  const GUI_CURSOR * GUI_CURSOR_Select       (const GUI_CURSOR * pCursor);
N  const GUI_CURSOR * GUI_CURSOR_SelectEx     (const GUI_CURSOR * pCursor, int Layer);
N  int                GUI_CURSOR_SelectAnim   (const GUI_CURSOR_ANIM * pCursorAnim);
N  int                GUI_CURSOR_SelectAnimEx (const GUI_CURSOR_ANIM * pCursorAnim, int LayerIndex);
N  int                GUI_CURSOR_SetBitmap    (const GUI_BITMAP * pBM);
N  int                GUI_CURSOR_SetBitmapEx  (const GUI_BITMAP * pBM, int Layer);
N  void               GUI_CURSOR_SetPosition  (int x, int y);
N  void               GUI_CURSOR_SetPositionEx(int xNewPos, int yNewPos, int Layer);
N  void               GUI_CURSOR_Show         (void);
N  void               GUI_CURSOR_ShowEx       (int Layer);
N  GUI_HSPRITE        GUI_CURSOR__GetSpriteEx (int LayerIndex, int * pxPos, int * pyPos);
N  void               GUI_CURSOR__SetSpriteEx (GUI_HSPRITE hSprite, const GUI_CURSOR * pCursor, int LayerIndex);
N#else
S  #define GUI_CURSOR_Show();
S  #define GUI_CURSOR_Clear();
N#endif
N
N/*********************************************************************
N*
N*       Sprite support
N*/
N#define GUI_SPRITE_CF_STAYONTOP (1 << 0)
N#define GUI_SPRITE_CF_SHOW      (1 << 1)
N
N#define GUI_SPRITE_SHOW 0
N#define GUI_SPRITE_HIDE 1
N
NGUI_HSPRITE GUI_SPRITE__CreateEx           (const GUI_BITMAP * pBM, int x, int y, int Layer, U16 Flags); /* Not to be documented, only used by cursor modul */
XGUI_HSPRITE GUI_SPRITE__CreateEx           (const GUI_BITMAP * pBM, int x, int y, int Layer, unsigned short Flags);  
Nvoid        GUI_SPRITE__SetCallback        (GUI_HSPRITE hSprite, GUI_HMEM hContext, void (* pCB)(GUI_HSPRITE, int));
Xvoid        GUI_SPRITE__SetCallback        (GUI_HSPRITE hSprite, signed long hContext, void (* pCB)(GUI_HSPRITE, int));
NGUI_HSPRITE GUI_SPRITE_Create              (const GUI_BITMAP * pBM, int x, int y);
NGUI_HSPRITE GUI_SPRITE_CreateAnim          (const GUI_BITMAP ** ppBm, int x, int y, unsigned Period, const unsigned * pPeriod, int NumItems);
NGUI_HSPRITE GUI_SPRITE_CreateEx            (const GUI_BITMAP * pBM, int x, int y, int Layer);
NGUI_HSPRITE GUI_SPRITE_CreateExAnim        (const GUI_BITMAP ** ppBm, int x, int y, unsigned Period, const unsigned * pPeriod, int NumItems, int LayerIndex);
NGUI_HSPRITE GUI_SPRITE_CreateHidden        (const GUI_BITMAP * pBM, int x, int y);
NGUI_HSPRITE GUI_SPRITE_CreateHiddenEx      (const GUI_BITMAP * pBM, int x, int y, int Layer);
Nvoid        GUI_SPRITE_Delete              (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_GetState            (GUI_HSPRITE hSprite);
Nvoid        GUI_SPRITE_Hide                (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_SetBitmap           (GUI_HSPRITE hSprite, const GUI_BITMAP * pBM);
Nint         GUI_SPRITE_SetBitmapAndPosition(GUI_HSPRITE hSprite, const GUI_BITMAP * pBM, int x, int y);
Nint         GUI_SPRITE_SetLoop             (GUI_HSPRITE hSprite, int OnOff);
Nvoid        GUI_SPRITE_SetPosition         (GUI_HSPRITE hSprite, int x, int y);
Nint         GUI_SPRITE_StartAnim           (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_StopAnim            (GUI_HSPRITE hSprite);
Nvoid        GUI_SPRITE_Show                (GUI_HSPRITE hSprite);
N
N/*********************************************************************
N*
N*       Cursors and their bitmaps
N*/
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Xextern const GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Xextern const GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Xextern const GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Xextern const GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Xextern const GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Xextern const GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
Xextern const GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR_ANIM GUI_CursorAnimHourglassM;
Xextern const GUI_CURSOR_ANIM GUI_CursorAnimHourglassM;
N
N/*********************************************************************
N*
N*       Wrap modes
N*/
Ntypedef enum { GUI_WRAPMODE_NONE, GUI_WRAPMODE_WORD, GUI_WRAPMODE_CHAR } GUI_WRAPMODE;
N
N/*********************************************************************
N*
N*       Text related routines
N*/
Nvoid  GUI_DispCEOL              (void);
Nvoid  GUI_DispChar              (U16 c);
Xvoid  GUI_DispChar              (unsigned short c);
Nvoid  GUI_DispCharAt            (U16 c, I16P x, I16P y);
Xvoid  GUI_DispCharAt            (unsigned short c, signed short x, signed short y);
Nvoid  GUI_DispChars             (U16 c, int Cnt);
Xvoid  GUI_DispChars             (unsigned short c, int Cnt);
Nvoid  GUI_DispNextLine          (void);
Nvoid  GUI_DispString            (const char * s);
Nvoid  GUI_DispStringAt          (const char * s, int x, int y);
Nvoid  GUI_DispStringAtCEOL      (const char * s, int x, int y);
Nvoid  GUI_DispStringHCenterAt   (const char * s, int x, int y);
Nvoid  GUI__DispStringInRect     (const char * s, GUI_RECT * pRect, int TextAlign, int MaxNumChars);
Nvoid  GUI_DispStringInRect      (const char * s, GUI_RECT * pRect, int TextAlign);
N#if GUI_SUPPORT_ROTATION
X#if 1
Nvoid  GUI_DispStringInRectEx    (const char * s, GUI_RECT * pRect, int TextAlign, int MaxLen, const GUI_ROTATION * pLCD_Api);
Xvoid  GUI_DispStringInRectEx    (const char * s, GUI_RECT * pRect, int TextAlign, int MaxLen, const tLCD_APIList * pLCD_Api);
N#endif
Nvoid  GUI_DispStringInRectMax   (const char * s, GUI_RECT * pRect, int TextAlign, int MaxLen); /* Not to be doc. */
Nvoid  GUI_DispStringInRectWrap  (const char * s, GUI_RECT * pRect, int TextAlign, GUI_WRAPMODE WrapMode); /* Not to be doc. */
N#if GUI_SUPPORT_ROTATION
X#if 1
Nvoid  GUI_DispStringInRectWrapEx(const char * s, GUI_RECT * pRect, int TextAlign, GUI_WRAPMODE WrapMode, const GUI_ROTATION * pLCD_Api);
Xvoid  GUI_DispStringInRectWrapEx(const char * s, GUI_RECT * pRect, int TextAlign, GUI_WRAPMODE WrapMode, const tLCD_APIList * pLCD_Api);
N#endif
Nvoid  GUI_DispStringLen         (const char * s, int Len);
Nvoid  GUI_GetTextExtend         (GUI_RECT* pRect, const char * s, int Len);
Nint   GUI_GetYAdjust            (void);
Nint   GUI_GetDispPosX           (void);
Nint   GUI_GetDispPosY           (void);
Nconst GUI_FONT * GUI_GetFont    (void);
Nint   GUI_GetCharDistX          (U16 c);
Xint   GUI_GetCharDistX          (unsigned short c);
Nint   GUI_GetCharDistXEx        (U16 c, int * pSizeX);
Xint   GUI_GetCharDistXEx        (unsigned short c, int * pSizeX);
Nint   GUI_GetStringDistX        (const char * s);
NGUI_DRAWMODE GUI_GetDrawMode    (void);
Nint   GUI_GetFontDistY          (void);
Nint   GUI_GetFontSizeY          (void);
Nvoid  GUI_GetFontInfo           (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Nvoid  GUI_GetOrg                (int * px, int * py);
Nint   GUI_GetYSizeOfFont        (const GUI_FONT * pFont);
Nint   GUI_GetYDistOfFont        (const GUI_FONT * pFont);
Nint   GUI_GetTextAlign          (void);
Nint   GUI_GetTextMode           (void);
Nchar  GUI_IsInFont              (const GUI_FONT * pFont, U16 c);
Xchar  GUI_IsInFont              (const GUI_FONT * pFont, unsigned short c);
NU8    GUI_SetClearTextRectMode  (unsigned OnOff);
Xunsigned char    GUI_SetClearTextRectMode  (unsigned OnOff);
Nint   GUI_SetTextAlign          (int Align);
Nint   GUI_SetTextMode           (int Mode);
Nchar  GUI_SetTextStyle          (char Style);
Nint   GUI_SetLBorder            (int x);
NU8    GUI_SetStrikeWidth        (U8 StrikeWidth);
Xunsigned char    GUI_SetStrikeWidth        (unsigned char StrikeWidth);
Nconst GUI_FONT * GUI_SetFont    (const GUI_FONT * pNewFont);
Nchar  GUI_GotoXY                (int x, int y);
Nchar  GUI_GotoX                 (int x);
Nchar  GUI_GotoY                 (int y);
Nint   GUI_WrapGetNumLines       (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint   GUI_WrapGetPositions      (const char * pText, int xSize, GUI_WRAPMODE WrapMode, int * aPos, int NumItems);
Nvoid  GUI_WrapSetSeparators     (const U16 * pSep, int NumSeps);
Xvoid  GUI_WrapSetSeparators     (const unsigned short * pSep, int NumSeps);
N
Nint   GUI_GetLeadingBlankCols (U16 c);
Xint   GUI_GetLeadingBlankCols (unsigned short c);
Nint   GUI_GetTrailingBlankCols(U16 c);
Xint   GUI_GetTrailingBlankCols(unsigned short c);
N
N
N/*********************************************************************
N*
N*       System independent fonts (SIF)
N*/
Nvoid GUI_SIF_CreateFont(const void * pFontData, GUI_FONT * pFont, const GUI_SIF_TYPE * pFontType);
Xvoid GUI_SIF_CreateFont(const void * pFontData, GUI_FONT * pFont, const tGUI_SIF_APIList * pFontType);
Nvoid GUI_SIF_DeleteFont(GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*       External binary fonts (XBF)
N*/
Nint  GUI_XBF_CreateFont(GUI_FONT * pFont, GUI_XBF_DATA * pXBF, const GUI_XBF_TYPE * pFontType, GUI_XBF_GET_DATA_FUNC * pfGetData, void * pVoid);
Xint  GUI_XBF_CreateFont(GUI_FONT * pFont, GUI_XBF_DATA * pXBF, const tGUI_XBF_APIList * pFontType, GUI_XBF_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid GUI_XBF_DeleteFont(GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*       TrueType support (TTF)
N*/
Nint  GUI_TTF_CreateFont   (GUI_FONT * pFont, GUI_TTF_CS * pCS);
Nint  GUI_TTF_CreateFontAA (GUI_FONT * pFont, GUI_TTF_CS * pCS);
Nvoid GUI_TTF_DestroyCache (void);
Nvoid GUI_TTF_Done         (void);
Nint  GUI_TTF_GetFamilyName(GUI_FONT * pFont, char * pBuffer, int NumBytes);
Nint  GUI_TTF_GetStyleName (GUI_FONT * pFont, char * pBuffer, int NumBytes);
Nvoid GUI_TTF_SetCacheSize (unsigned MaxFaces, unsigned MaxSizes, U32 MaxBytes);
Xvoid GUI_TTF_SetCacheSize (unsigned MaxFaces, unsigned MaxSizes, unsigned long MaxBytes);
N
N/*********************************************************************
N*
N*       Resource file support
N*/
Nint          GUI_LANG_GetLang          (void);
Nint          GUI_LANG_GetNumItems      (int IndexLang);
Nconst char * GUI_LANG_GetText          (int IndexText);
Nint          GUI_LANG_GetTextBuffered  (int IndexText, char * pBuffer, int SizeOfBuffer);
Nint          GUI_LANG_GetTextBufferedEx(int IndexText, int IndexLang, char * pBuffer, int SizeOfBuffer);
Nconst char * GUI_LANG_GetTextEx        (int IndexText, int IndexLang);
Nint          GUI_LANG_LoadCSV          (U8 * pFileData, U32 FileSize);
Xint          GUI_LANG_LoadCSV          (unsigned char * pFileData, unsigned long FileSize);
Nint          GUI_LANG_LoadCSVEx        (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint          GUI_LANG_LoadText         (U8 * pFileData, U32 FileSize, int IndexLang);
Xint          GUI_LANG_LoadText         (unsigned char * pFileData, unsigned long FileSize, int IndexLang);
Nint          GUI_LANG_LoadTextEx       (GUI_GET_DATA_FUNC * pfGetData, void * p, int IndexLang);
Nint          GUI_LANG_SetLang          (int IndexLang);
Nunsigned     GUI_LANG_SetMaxNumLang    (unsigned MaxNumLang);
NU16          GUI_LANG_SetSep           (U16 Sep);
Xunsigned short          GUI_LANG_SetSep           (unsigned short Sep);
N
N/*********************************************************************
N*
N*       Unicode support
N*/
Nint  GUI_UC_ConvertUC2UTF8(const U16 * s, int Len, char * pBuffer, int BufferSize);
Xint  GUI_UC_ConvertUC2UTF8(const unsigned short * s, int Len, char * pBuffer, int BufferSize);
Nint  GUI_UC_ConvertUTF82UC(const char * s, int Len, U16 * pBuffer, int BufferSize);
Xint  GUI_UC_ConvertUTF82UC(const char * s, int Len, unsigned short * pBuffer, int BufferSize);
Nint  GUI_UC_EnableBIDI    (int OnOff);
Nint  GUI_UC_Encode        (char * s, U16 Char);
Xint  GUI_UC_Encode        (char * s, unsigned short Char);
Nint  GUI_UC_GetCharSize   (const char * s);
NU16  GUI_UC_GetCharCode   (const char * s);
Xunsigned short  GUI_UC_GetCharCode   (const char * s);
Nvoid GUI_UC_SetEncodeNone (void);
Nvoid GUI_UC_SetEncodeSJIS (void);
Nvoid GUI_UC_SetEncodeUTF8 (void);
Nvoid GUI_UC_SetBaseDir    (int Dir);  // Only available with new version of BIDI algorithm (GUI_USE_BIDI2 == 1)
Nint  GUI_UC_GetBaseDir    (void);     // Only available with new version of BIDI algorithm (GUI_USE_BIDI2 == 1)
N
Nvoid GUI_UC_DispString(const U16 * s);
Xvoid GUI_UC_DispString(const unsigned short * s);
Nvoid GUI_UC2DB (U16 Code, U8 * pOut);
Xvoid GUI_UC2DB (unsigned short Code, unsigned char * pOut);
NU16  GUI_DB2UC (U8 Byte0, U8 Byte1);
Xunsigned short  GUI_DB2UC (unsigned char Byte0, unsigned char Byte1);
N
N/*********************************************************************
N*
N*       Bidi support
N*/
N#define GUI_BIDI_BASEDIR_LTR  0
N#define GUI_BIDI_BASEDIR_RTL  1
N#define GUI_BIDI_BASEDIR_AUTO 2
N
N#define GUI_BIDI_LOG2VIS_CALC     0
N#define GUI_BIDI_LOG2VIS_GETCACHE 1
N
N/*********************************************************************
N*
N*       Drawing of binary, decimal and hexadecimal values
N*/
Nvoid GUI_DispBin  (U32  v, U8 Len);
Xvoid GUI_DispBin  (unsigned long  v, unsigned char Len);
Nvoid GUI_DispBinAt(U32  v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispBinAt(unsigned long  v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDec  (I32 v, U8 Len);
Xvoid GUI_DispDec  (signed long v, unsigned char Len);
Nvoid GUI_DispDecAt (I32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispDecAt (signed long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDecMin(I32 v);
Xvoid GUI_DispDecMin(signed long v);
Nvoid GUI_DispDecShift(I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispDecShift(signed long v, unsigned char Len, unsigned char Shift);
Nvoid GUI_DispDecSpace(I32 v, U8 MaxDigits);
Xvoid GUI_DispDecSpace(signed long v, unsigned char MaxDigits);
Nvoid GUI_DispHex  (U32 v, U8 Len);
Xvoid GUI_DispHex  (unsigned long v, unsigned char Len);
Nvoid GUI_DispHexAt(U32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispHexAt(unsigned long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispSDec(I32 v, U8 Len);
Xvoid GUI_DispSDec(signed long v, unsigned char Len);
Nvoid GUI_DispSDecShift(I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispSDecShift(signed long v, unsigned char Len, unsigned char Shift);
N
N/*********************************************************************
N*
N*       Drawing of floating point values
N*/
Nvoid GUI_DispFloat    (float v, char Len);
Nvoid GUI_DispFloatFix (float v, char Len, char Fract);
Nvoid GUI_DispFloatMin (float v, char Fract);
Nvoid GUI_DispSFloatFix(float v, char Len, char Fract);
Nvoid GUI_DispSFloatMin(float v, char Fract);
N
N/*********************************************************************
N*
N*       Dynamic memory management
N*/
Ntypedef struct {
N  U32 TotalBytes;
X  unsigned long TotalBytes;
N  U32 FreeBytes;
X  unsigned long FreeBytes;
N  U32 UsedBytes;
X  unsigned long UsedBytes;
N  U32 AllocSize;
X  unsigned long AllocSize;
N  U32 NumFixedBytes;
X  unsigned long NumFixedBytes;
N  U32 MaxUsedBytes;
X  unsigned long MaxUsedBytes;
N} GUI_ALLOC_INFO;
N
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBlocks(void);
Xsigned long GUI_ALLOC_GetNumFreeBlocks(void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes (void);
Xsigned long GUI_ALLOC_GetNumFreeBytes (void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBlocks(void);
Xsigned long GUI_ALLOC_GetNumUsedBlocks(void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBytes (void);
Xsigned long GUI_ALLOC_GetNumUsedBytes (void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxUsedBytes (void);
Xsigned long GUI_ALLOC_GetMaxUsedBytes (void);
N
Nvoid GUI_ALLOC_GetMemInfo  (GUI_ALLOC_INFO * pInfo);
Nvoid GUI_ALLOC_SuppressPeak(int OnOff);
N
NGUI_HMEM           GUI_ALLOC_AllocInit       (const void * pInitData, GUI_ALLOC_DATATYPE Size);
Xsigned long           GUI_ALLOC_AllocInit       (const void * pInitData, signed long Size);
NGUI_HMEM           GUI_ALLOC_AllocNoInit     (GUI_ALLOC_DATATYPE size);
Xsigned long           GUI_ALLOC_AllocNoInit     (signed long size);
NGUI_HMEM           GUI_ALLOC_AllocZero       (GUI_ALLOC_DATATYPE size);
Xsigned long           GUI_ALLOC_AllocZero       (signed long size);
Nvoid               GUI_ALLOC_AssignMemory    (void * p, U32 NumBytes);
Xvoid               GUI_ALLOC_AssignMemory    (void * p, unsigned long NumBytes);
Nvoid               GUI_ALLOC_Free            (GUI_HMEM  hMem);
Xvoid               GUI_ALLOC_Free            (signed long  hMem);
Nvoid               GUI_ALLOC_FreeFixedBlock  (void * p);
Nvoid               GUI_ALLOC_FreePtrArray    (GUI_HMEM * pArray, int NumElems);
Xvoid               GUI_ALLOC_FreePtrArray    (signed long * pArray, int NumElems);
Nvoid               GUI_ALLOC_FreePtr         (GUI_HMEM * phMem);
Xvoid               GUI_ALLOC_FreePtr         (signed long * phMem);
Nvoid *             GUI_ALLOC_GetFixedBlock   (GUI_ALLOC_DATATYPE Size);
Xvoid *             GUI_ALLOC_GetFixedBlock   (signed long Size);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize      (void);
Xsigned long GUI_ALLOC_GetMaxSize      (void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetSize         (GUI_HMEM  hMem);
Xsigned long GUI_ALLOC_GetSize         (signed long  hMem);
Nvoid *             GUI_ALLOC_h2p             (GUI_HMEM  hMem);
Xvoid *             GUI_ALLOC_h2p             (signed long  hMem);
NGUI_HMEM           GUI_ALLOC_p2h             (void * p);
Xsigned long           GUI_ALLOC_p2h             (void * p);
Nvoid               GUI_ALLOC_Init            (void);
Nvoid               GUI_ALLOC_Lock            (void);
Nvoid *             GUI_ALLOC_LockH           (GUI_HMEM  hMem);
Xvoid *             GUI_ALLOC_LockH           (signed long  hMem);
NGUI_HMEM           GUI_ALLOC_Realloc         (GUI_HMEM hOld, int NewSize);
Xsigned long           GUI_ALLOC_Realloc         (signed long hOld, int NewSize);
NGUI_ALLOC_DATATYPE GUI_ALLOC_RequestSize     (void);
Xsigned long GUI_ALLOC_RequestSize     (void);
Nvoid               GUI_ALLOC_SetAvBlockSize  (U32 BlockSize);
Xvoid               GUI_ALLOC_SetAvBlockSize  (unsigned long BlockSize);
Nvoid               GUI_ALLOC_Unlock          (void);
Nvoid *             GUI_ALLOC_UnlockH         (void ** pp);
Nint                GUI_ALLOC_SetMaxPercentage(int MaxPercentage);
Nvoid               GUI_ALLOC_Exit            (void);
N
N/*********************************************************************
N*
N*       Memory devices: GUI_MEMDEV
N*/
N#define GUI_MEMDEV_HASTRANS       0
N#define GUI_MEMDEV_NOTRANS  (1 << 0)
N
Ntypedef GUI_HMEM GUI_MEMDEV_Handle;
Xtypedef signed long GUI_MEMDEV_Handle;
Ntypedef void     GUI_CALLBACK_VOID_P        (void * p);
Ntypedef int      GUI_ANIMATION_CALLBACK_FUNC(int TimeRem, void * pVoid);
Ntypedef void     GUI_DRAWMEMDEV_16BPP_FUNC  (void * pDst, const void * pSrc, int xSize, int ySize, int BytesPerLineDst, int BytesPerLineSrc);
N
N#define GUI_DRAWMEMDEV_FUNC GUI_DRAWMEMDEV_16BPP_FUNC
N
Ntypedef void GUI_DRAWBITMAP_FUNC (int LayerIndex, int x, int y, const void * p, int xSize, int ySize, int BytesPerLine);
N
Nint GUI_SetFuncDrawAlpha(GUI_DRAWMEMDEV_FUNC * pfDrawMemdevFunc, GUI_DRAWBITMAP_FUNC * pfDrawBitmapFunc);
Xint GUI_SetFuncDrawAlpha(GUI_DRAWMEMDEV_16BPP_FUNC * pfDrawMemdevFunc, GUI_DRAWBITMAP_FUNC * pfDrawBitmapFunc);
Nint GUI_SetFuncDrawM565 (GUI_DRAWMEMDEV_FUNC * pfDrawMemdevFunc, GUI_DRAWBITMAP_FUNC * pfDrawBitmapFunc);
Xint GUI_SetFuncDrawM565 (GUI_DRAWMEMDEV_16BPP_FUNC * pfDrawMemdevFunc, GUI_DRAWBITMAP_FUNC * pfDrawBitmapFunc);
N
Nextern GUI_ANIMATION_CALLBACK_FUNC * GUI_MEMDEV__pCbAnimation;
Nextern void                        * GUI_MEMDEV__pVoid;
N
Nextern void (* GUI_MEMDEV__pfMEMDEV_Write)    (GUI_MEMDEV_Handle hMem);
Nextern void (* GUI_MEMDEV__pfMEMDEV_CopyToLCD)(GUI_MEMDEV_Handle hMem);
N
Ntypedef struct {
N  GUI_RECT rView, rPrev;
N  char FirstCall;
N} GUI_AUTODEV;
N
Ntypedef struct {
N  char DrawFixed;
N  char IsMeasurement;
N} GUI_AUTODEV_INFO;
N
Nint  GUI_MEMDEV_CreateAuto(GUI_AUTODEV * pAutoDev);
Nvoid GUI_MEMDEV_DeleteAuto(GUI_AUTODEV * pAutoDev);
Nint  GUI_MEMDEV_DrawAuto  (GUI_AUTODEV * pAutoDev, GUI_AUTODEV_INFO * pAutoDevInfo, GUI_CALLBACK_VOID_P * pfDraw, void * pData);
N
N/* Create a memory device which is compatible to the selected LCD */
NGUI_MEMDEV_Handle GUI_MEMDEV_Create       (int x0, int y0, int xSize, int ySize);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateEx     (int x0, int y0, int xSize, int ySize, int Flags);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateFixed  (int x0, int y0, int xSize, int ySize, int Flags,
N                                           const GUI_DEVICE_API     * pDeviceAPI,
N                                           const LCD_API_COLOR_CONV * pColorConvAPI);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateFixed32(int x0, int y0, int xSize, int ySize);
N
Nvoid GUI_MEMDEV_Clear                (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_ClearAlpha           (GUI_MEMDEV_Handle hMemData, GUI_MEMDEV_Handle hMemMask);
Nvoid GUI_MEMDEV_CopyFromLCD          (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyFromLCDAA        (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyToLCD            (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyToLCDAA          (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyToLCDAt          (GUI_MEMDEV_Handle hMem, int x, int y);
Nint  GUI_MEMDEV_CompareWithLCD       (GUI_MEMDEV_Handle hMem, int * px, int * py, int * pExp, int * pAct);
Nvoid GUI_MEMDEV_Delete               (GUI_MEMDEV_Handle MemDev);
Nvoid GUI_MEMDEV_DrawPerspectiveX     (GUI_MEMDEV_Handle hMem, int x, int y, int h0, int h1, int dx, int dy);
Nint  GUI_MEMDEV_GetXPos              (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_GetXSize             (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_GetYPos              (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_GetYSize             (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_MarkDirty            (GUI_MEMDEV_Handle hMem, int x0, int y0, int x1, int y1);
Nvoid GUI_MEMDEV_ReduceYSize          (GUI_MEMDEV_Handle hMem, int YSize);
Nvoid GUI_MEMDEV_Rotate               (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
Nvoid GUI_MEMDEV_RotateAlpha          (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, U8 Alpha);
Xvoid GUI_MEMDEV_RotateAlpha          (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, unsigned char Alpha);
Nvoid GUI_MEMDEV_RotateHR             (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, I32 dx, I32 dy, int a, int Mag);
Xvoid GUI_MEMDEV_RotateHR             (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, signed long dx, signed long dy, int a, int Mag);
Nvoid GUI_MEMDEV__Rotate              (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, U32 Mask);
Xvoid GUI_MEMDEV__Rotate              (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, unsigned long Mask);
Nvoid GUI_MEMDEV__RotateHR            (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, I32 dx, I32 dy, int a, int Mag, U32 Mask);
Xvoid GUI_MEMDEV__RotateHR            (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, signed long dx, signed long dy, int a, int Mag, unsigned long Mask);
Nvoid GUI_MEMDEV_RotateHQ             (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
Nvoid GUI_MEMDEV_RotateHQAlpha        (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, U8 Alpha);
Xvoid GUI_MEMDEV_RotateHQAlpha        (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, unsigned char Alpha);
Nvoid GUI_MEMDEV_RotateHQHR           (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, I32 dx, I32 dy, int a, int Mag);
Xvoid GUI_MEMDEV_RotateHQHR           (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, signed long dx, signed long dy, int a, int Mag);
Nvoid GUI_MEMDEV_RotateHQT            (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
Nvoid GUI_MEMDEV_RotateHQTI           (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
NGUI_MEMDEV_Handle GUI_MEMDEV_Select  (GUI_MEMDEV_Handle hMem);  /* Select (activate) a particular memory device. */
Nvoid  GUI_MEMDEV_SetOrg              (GUI_MEMDEV_Handle hMem, int x0, int y0);
Nvoid  GUI_MEMDEV_WriteAt             (GUI_MEMDEV_Handle hMem, int x, int y);
Nvoid  GUI_MEMDEV_Write               (GUI_MEMDEV_Handle hMem);
Nvoid  GUI_MEMDEV_WriteAlphaAt        (GUI_MEMDEV_Handle hMem, int Alpha, int x, int y);
Nvoid  GUI_MEMDEV_WriteAlpha          (GUI_MEMDEV_Handle hMem, int Alpha);
Nvoid  GUI_MEMDEV_WriteExAt           (GUI_MEMDEV_Handle hMem, int x, int y, int xMag, int yMag, int Alpha);
Nvoid  GUI_MEMDEV_WriteEx             (GUI_MEMDEV_Handle hMem, int xMag, int yMag, int Alpha);
Nvoid  GUI_MEMDEV_WriteOpaque         (GUI_MEMDEV_Handle hMem);
Nvoid  GUI_MEMDEV_WriteOpaqueAt       (GUI_MEMDEV_Handle hMem, int x, int y);
Nint   GUI_MEMDEV_Draw                (GUI_RECT * pRect, GUI_CALLBACK_VOID_P * pfDraw, void * pData, int NumLines, int Flags);
Nvoid* GUI_MEMDEV_GetDataPtr          (GUI_MEMDEV_Handle hMem);
Nvoid  GUI_MEMDEV_SetColorConv        (GUI_MEMDEV_Handle hMem, const LCD_API_COLOR_CONV * pColorConvAPI);
Nconst LCD_API_COLOR_CONV * GUI_MEMDEV_GetColorConv(GUI_MEMDEV_Handle hMemDev);
Nint   GUI_MEMDEV_GetBitsPerPixel     (GUI_MEMDEV_Handle hMemDev);
Nint   GUI_MEMDEV_FadeInDevices       (GUI_MEMDEV_Handle hMem0, GUI_MEMDEV_Handle hMem1, int Period);
Nint   GUI_MEMDEV_FadeOutDevices      (GUI_MEMDEV_Handle hMem0, GUI_MEMDEV_Handle hMem1, int Period);
Nvoid  GUI_MEMDEV_SerializeBMP        (GUI_MEMDEV_Handle hDev, GUI_CALLBACK_VOID_U8_P * pfSerialize, void * p);
Nvoid  GUI_MEMDEV_SetAnimationCallback(GUI_ANIMATION_CALLBACK_FUNC * pCbAnimation, void * pVoid);
Nvoid  GUI_MEMDEV__FadeDevice         (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, U8 Intens);
Xvoid  GUI_MEMDEV__FadeDevice         (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, unsigned char Intens);
Nvoid  GUI_MEMDEV__FadeDeviceEx       (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, U8 Intens, int xPosWin, int yPosWin);
Xvoid  GUI_MEMDEV__FadeDeviceEx       (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, unsigned char Intens, int xPosWin, int yPosWin);
Nint   GUI_MEMDEV_PunchOutDevice      (GUI_MEMDEV_Handle hMemData, GUI_MEMDEV_Handle hMemMask);
Nvoid  GUI_MEMDEV_SetTimePerFrame     (unsigned TimePerFrame);
Nint   GUI_MEMDEV_MULTIBUF_Enable     (int OnOff);
N
Nvoid  GUI_SelectLCD(void);
N
N/* Blurring, dithering and blending */
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32  (GUI_MEMDEV_Handle hMem, U8 Depth);
XGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32  (GUI_MEMDEV_Handle hMem, unsigned char Depth);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32HQ(GUI_MEMDEV_Handle hMem, U8 Depth);
XGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32HQ(GUI_MEMDEV_Handle hMem, unsigned char Depth);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32LQ(GUI_MEMDEV_Handle hMem, U8 Depth);
XGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32LQ(GUI_MEMDEV_Handle hMem, unsigned char Depth);
Nvoid              GUI_MEMDEV_SetBlurHQ              (void);
Nvoid              GUI_MEMDEV_SetBlurLQ              (void);
Nint               GUI_MEMDEV_BlendColor32           (GUI_MEMDEV_Handle hMem, U32 BlendColor, U8 BlendIntens);
Xint               GUI_MEMDEV_BlendColor32           (GUI_MEMDEV_Handle hMem, unsigned long BlendColor, unsigned char BlendIntens);
Nint               GUI_MEMDEV_Dither32               (GUI_MEMDEV_Handle hMem, const LCD_API_COLOR_CONV * pColorConvAPI);
N
N/* Optional custom drawing of 16bpp memory devices */
Nvoid GUI_MEMDEV_SetDrawMemdev16bppFunc(GUI_DRAWMEMDEV_16BPP_FUNC * pfDrawMemdev16bppFunc);
N
N/*********************************************************************
N*
N*       Alpha blending
N*/
Ntypedef struct {
N  U32 UserAlpha;
X  unsigned long UserAlpha;
N} GUI_ALPHA_STATE;
N
N#define GUI_MAKE_ALPHA(Alpha, Color) ((U32)(((U32)Alpha << 24) | (Color & 0xFFFFFF)))
N
Nunsigned     GUI_EnableAlpha         (unsigned OnOff);
NU32          GUI_RestoreUserAlpha    (GUI_ALPHA_STATE * pAlphaState);
Xunsigned long          GUI_RestoreUserAlpha    (GUI_ALPHA_STATE * pAlphaState);
Nunsigned     GUI_SetAlpha            (U8 Alpha);
Xunsigned     GUI_SetAlpha            (unsigned char Alpha);
NU32          GUI_SetUserAlpha        (GUI_ALPHA_STATE * pAlphaState, U32 UserAlpha);
Xunsigned long          GUI_SetUserAlpha        (GUI_ALPHA_STATE * pAlphaState, unsigned long UserAlpha);
Nvoid      (* GUI_SetFuncAlphaBlending(void (* pfAlphaBlending)(LCD_COLOR *, LCD_COLOR *, LCD_COLOR *, U32)))
Xvoid      (* GUI_SetFuncAlphaBlending(void (* pfAlphaBlending)(LCD_COLOR *, LCD_COLOR *, LCD_COLOR *, unsigned long)))
N                                                              (LCD_COLOR *, LCD_COLOR *, LCD_COLOR *, U32);
X                                                              (LCD_COLOR *, LCD_COLOR *, LCD_COLOR *, unsigned long);
NLCD_COLOR (* GUI_SetFuncMixColors    (LCD_COLOR (* pFunc)(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens)))
XLCD_COLOR (* GUI_SetFuncMixColors    (LCD_COLOR (* pFunc)(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens)))
N                                                         (LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
X                                                         (LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
Nvoid      (* GUI_SetFuncMixColorsBulk(void (* pFunc)(U32 * pFG, U32 * pBG, U32 * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, U8 Intens)))
Xvoid      (* GUI_SetFuncMixColorsBulk(void (* pFunc)(unsigned long * pFG, unsigned long * pBG, unsigned long * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, unsigned char Intens)))
N                                                    (U32 * pFG, U32 * pBG, U32 * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, U8 Intens);
X                                                    (unsigned long * pFG, unsigned long * pBG, unsigned long * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, unsigned char Intens);
Nunsigned     GUI_PreserveTrans       (unsigned OnOff);
N
N/*********************************************************************
N*
N*       Multi layer support
N*/
Nunsigned GUI_SelectLayer(unsigned Index);
Nunsigned GUI_GetSelLayer(void);
N
Nint  GUI_SetLayerPosEx  (unsigned Index, int xPos, int yPos);
Nint  GUI_SetLayerSizeEx (unsigned Index, int xSize, int ySize);
Nint  GUI_SetLayerVisEx  (unsigned Index, int OnOff);
Nint  GUI_SetLayerAlphaEx(unsigned Index, int Alpha);
Nint  GUI_GetLayerPosEx  (unsigned Index, int * pxPos, int * pyPos);
N
Nvoid     GUI_AssignCursorLayer(unsigned Index, unsigned CursorLayer);
Nunsigned GUI_GetCursorLayer   (unsigned Index);
N
N/*********************************************************************
N*
N*       Multiple buffers and display origin
N*/
Nvoid GUI_SetOrg(int x, int y);
N
Nvoid GUI_MULTIBUF_Begin          (void);
Nvoid GUI_MULTIBUF_BeginEx        (int LayerIndex);
Nvoid GUI_MULTIBUF_End            (void);
Nvoid GUI_MULTIBUF_EndEx          (int LayerIndex);
Nvoid GUI_MULTIBUF_Config         (int NumBuffers);
Nvoid GUI_MULTIBUF_ConfigEx       (int LayerIndex, int NumBuffers);
Nvoid GUI_MULTIBUF_Confirm        (int Index);
Nvoid GUI_MULTIBUF_ConfirmEx      (int LayerIndex, int BufferIndex);
Nint  GUI_MULTIBUF_GetNumBuffers  (void);
Nint  GUI_MULTIBUF_GetNumBuffersEx(int LayerIndex);
Nvoid GUI_MULTIBUF_SetLayerMask   (U32 LayerMask);
Xvoid GUI_MULTIBUF_SetLayerMask   (unsigned long LayerMask);
Nvoid GUI_MULTIBUF_UseSingleBuffer(void);
N
N/*********************************************************************
N*
N*       emWinSPY
N*/
Nint  GUI_SPY_Process      (GUI_tSend pfSend, GUI_tRecv pfRecv, void * pConnectInfo);
Nvoid GUI_SPY_SetMemHandler(GUI_tMalloc pMalloc, GUI_tFree pFree);
Nint  GUI_SPY_StartServer  (void);
Nint  GUI_SPY_StartServerEx(int (* pGUI_SPY_X_StartServer)(void));
Nint  GUI_SPY_X_StartServer(void);
N
N/*********************************************************************
N*
N*       QR-Codes
N*/
N#define GUI_QR_ECLEVEL_L 0
N#define GUI_QR_ECLEVEL_M 1
N#define GUI_QR_ECLEVEL_Q 2
N#define GUI_QR_ECLEVEL_H 3
N
Ntypedef struct {
N  int Version;  // Version according to QR code documentation
N  int Width;    // Number of 'Modules'
N  int Size;     // Size of bitmap in pixels
N} GUI_QR_INFO;
N
NGUI_HMEM GUI_QR_Create (const char * pText, int PixelSize, int EccLevel, int Version);
Xsigned long GUI_QR_Create (const char * pText, int PixelSize, int EccLevel, int Version);
Nvoid     GUI_QR_Draw   (GUI_HMEM hQR, int xPos, int yPos);
Xvoid     GUI_QR_Draw   (signed long hQR, int xPos, int yPos);
Nvoid     GUI_QR_GetInfo(GUI_HMEM hQR, GUI_QR_INFO * pInfo);
Xvoid     GUI_QR_GetInfo(signed long hQR, GUI_QR_INFO * pInfo);
Nvoid     GUI_QR_Delete (GUI_HMEM hQR);
Xvoid     GUI_QR_Delete (signed long hQR);
N
N/*********************************************************************
N*
N*       Basics for animations
N*/
N#define ANIM_LINEAR     GUI_ANIM__Linear
N#define ANIM_ACCEL      GUI_ANIM__Accel
N#define ANIM_DECEL      GUI_ANIM__Decel
N#define ANIM_ACCELDECEL GUI_ANIM__AccelDecel
N
N#define GUI_ANIM_START   0
N#define GUI_ANIM_RUNNING 1
N#define GUI_ANIM_END     2
N
N#ifndef   GUI_ANIM_RANGE
N  #define GUI_ANIM_RANGE 32767L
N#endif
N
Ntypedef GUI_HMEM GUI_ANIM_HANDLE;
Xtypedef signed long GUI_ANIM_HANDLE;
N
Ntypedef I32 (* GUI_ANIM_GETPOS_FUNC)(GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xtypedef signed long (* GUI_ANIM_GETPOS_FUNC)(int ts, int te, int tNow);
N
Ntypedef struct {
N  int Pos;
N  int State;
N  GUI_ANIM_HANDLE hAnim;
N  GUI_TIMER_TIME Period;
X  int Period;
N} GUI_ANIM_INFO;
N
Ntypedef void GUI_ANIMATION_FUNC(GUI_ANIM_INFO * pInfo, void * pVoid);
N
NI32 GUI_ANIM__Linear    (GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__Linear    (int ts, int te, int tNow);
NI32 GUI_ANIM__Decel     (GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__Decel     (int ts, int te, int tNow);
NI32 GUI_ANIM__Accel     (GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__Accel     (int ts, int te, int tNow);
NI32 GUI_ANIM__AccelDecel(GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__AccelDecel(int ts, int te, int tNow);
N
Nint             GUI_ANIM_AddItem(GUI_ANIM_HANDLE hAnim, GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_ANIM_GETPOS_FUNC pfGetPos, void * pVoid, GUI_ANIMATION_FUNC * pfAnim);
Xint             GUI_ANIM_AddItem(GUI_ANIM_HANDLE hAnim, int ts, int te, GUI_ANIM_GETPOS_FUNC pfGetPos, void * pVoid, GUI_ANIMATION_FUNC * pfAnim);
NGUI_ANIM_HANDLE GUI_ANIM_Create (GUI_TIMER_TIME Period, unsigned MinTimePerFrame, void * pVoid, void (* pfSliceInfo)(int State, void * _pVoid));
XGUI_ANIM_HANDLE GUI_ANIM_Create (int Period, unsigned MinTimePerFrame, void * pVoid, void (* pfSliceInfo)(int State, void * _pVoid));
Nvoid            GUI_ANIM_Delete (GUI_ANIM_HANDLE hAnim);
Nint             GUI_ANIM_Exec   (GUI_ANIM_HANDLE hAnim);
Nvoid            GUI_ANIM_Start  (GUI_ANIM_HANDLE hAnim);
Nvoid            GUI_ANIM_StartEx(GUI_ANIM_HANDLE hAnim, int NumLoops, void (* pfOnDelete)(void * pVoid));
Nvoid            GUI_ANIM_Stop   (GUI_ANIM_HANDLE hAnim);
N
N/*********************************************************************
N*
N*       Display orientation
N*/
N/*********************************************************************
N*
N*       GUI_ORIENTATION_API
N*/
Ntypedef struct {
N  void           (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const U8 * pData, int Diff, const LCD_PIXELINDEX * pTrans);
X  void           (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const unsigned char * pData, int Diff, const unsigned long * pTrans);
N  void           (* pfDrawHLine    )(GUI_DEVICE * pDevice, int x0, int y0,  int x1);
N  void           (* pfDrawVLine    )(GUI_DEVICE * pDevice, int x , int y0,  int y1);
N  void           (* pfFillRect     )(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1);
N  LCD_PIXELINDEX (* pfGetPixelIndex)(GUI_DEVICE * pDevice, int x, int y);
X  unsigned long (* pfGetPixelIndex)(GUI_DEVICE * pDevice, int x, int y);
N  void           (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, LCD_PIXELINDEX ColorIndex);
X  void           (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, unsigned long ColorIndex);
N  void           (* pfXorPixel     )(GUI_DEVICE * pDevice, int x, int y);
N  int            BytesPerPixel;
N} GUI_ORIENTATION_API;
N
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C0;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C8;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C16;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C32;
N
N#define GUI_ORIENTATION_C0  &GUI_OrientationAPI_C0
N#define GUI_ORIENTATION_C8  &GUI_OrientationAPI_C8
N#define GUI_ORIENTATION_C16 &GUI_OrientationAPI_C16
N#define GUI_ORIENTATION_C32 &GUI_OrientationAPI_C32
N
Nint GUI_SetOrientation        (int Orientation);
Nint GUI_SetOrientationEx      (int Orientation, int LayerIndex);
Nint GUI_SetOrientationExCached(int Orientation, int LayerIndex, const GUI_ORIENTATION_API * pAPI);
N
N/*********************************************************************
N*
N*       Measure device: GUI_MEASDEV
N*/
Ntypedef GUI_HMEM GUI_MEASDEV_Handle;
Xtypedef signed long GUI_MEASDEV_Handle;
N
NGUI_MEASDEV_Handle GUI_MEASDEV_Create (void);
Nvoid               GUI_MEASDEV_Delete (GUI_MEASDEV_Handle hMemDev);
Nvoid               GUI_MEASDEV_Select (GUI_MEASDEV_Handle hMem);
Nvoid               GUI_MEASDEV_GetRect(GUI_MEASDEV_Handle hMem, GUI_RECT * pRect);
Nvoid               GUI_MEASDEV_ClearRect(GUI_MEASDEV_Handle hMem);
N
N/*********************************************************************
N*
N*       Polygon helpers
N*/
Nvoid GUI_RotatePolygon (GUI_POINT * pDest, const GUI_POINT * pSrc, int NumPoints, float Angle);
Nvoid GUI_MagnifyPolygon(GUI_POINT * pDest, const GUI_POINT * pSrc, int NumPoints, int Mag);
Nvoid GUI_EnlargePolygon(GUI_POINT * pDest, const GUI_POINT * pSrc, int NumPoints, int Len);
N
N/*********************************************************************
N*
N*       Streamed bitmaps
N*/
N#define GUI_BITMAPSTREAM_GET_BUFFER     1
N#define GUI_BITMAPSTREAM_RELEASE_BUFFER 2
N#define GUI_BITMAPSTREAM_MODIFY_PALETTE 3
N
N#define DECLARE_CREATE_FROM_STREAM(ID) int GUI_CreateBitmapFromStream##ID(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
N
NDECLARE_CREATE_FROM_STREAM(IDX)
Xint GUI_CreateBitmapFromStreamIDX(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE4)
Xint GUI_CreateBitmapFromStreamRLE4(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE8)
Xint GUI_CreateBitmapFromStreamRLE8(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(565)
Xint GUI_CreateBitmapFromStream565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M565)
Xint GUI_CreateBitmapFromStreamM565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(555)
Xint GUI_CreateBitmapFromStream555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M555)
Xint GUI_CreateBitmapFromStreamM555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(A565)
Xint GUI_CreateBitmapFromStreamA565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(AM565)
Xint GUI_CreateBitmapFromStreamAM565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(A555)
Xint GUI_CreateBitmapFromStreamA555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(AM555)
Xint GUI_CreateBitmapFromStreamAM555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE16)
Xint GUI_CreateBitmapFromStreamRLE16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLEM16)
Xint GUI_CreateBitmapFromStreamRLEM16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(24)
Xint GUI_CreateBitmapFromStream24(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(Alpha)
Xint GUI_CreateBitmapFromStreamAlpha(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M8888I)
Xint GUI_CreateBitmapFromStreamM8888I(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLEAlpha)
Xint GUI_CreateBitmapFromStreamRLEAlpha(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE32)
Xint GUI_CreateBitmapFromStreamRLE32(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(444_12)
Xint GUI_CreateBitmapFromStream444_12(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M444_12)
Xint GUI_CreateBitmapFromStreamM444_12(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(444_12_1)
Xint GUI_CreateBitmapFromStream444_12_1(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M444_12_1)
Xint GUI_CreateBitmapFromStreamM444_12_1(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(444_16)
Xint GUI_CreateBitmapFromStream444_16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M444_16)
Xint GUI_CreateBitmapFromStreamM444_16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
N
Nint  GUI_CreateBitmapFromStream   (GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
Nvoid GUI_DrawStreamedBitmap       (const void * p, int x, int y);
Nvoid GUI_DrawStreamedBitmapAuto   (const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapEx     (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapExAuto (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap555Ex  (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapM555Ex (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap565Ex  (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapM565Ex (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapA555Ex (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapAM555Ex(GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapA565Ex (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapAM565Ex(GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap24Ex   (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nvoid GUI_GetStreamedBitmapInfo    (const void * p, GUI_BITMAPSTREAM_INFO * pInfo);
Nint  GUI_GetStreamedBitmapInfoEx  (GUI_GET_DATA_FUNC * pfGetData, const void * p, GUI_BITMAPSTREAM_INFO * pInfo);
Nvoid GUI_SetStreamedBitmapHook    (GUI_BITMAPSTREAM_CALLBACK pfStreamedBitmapHook);
N
Nvoid LCD__RLE4_SetFunc (GUI_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off, const LCD_LOGPALETTE * pLogPal);
Xvoid LCD__RLE4_SetFunc (GUI_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off, const LCD_LOGPALETTE * pLogPal);
Nvoid LCD__RLE8_SetFunc (GUI_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off, const LCD_LOGPALETTE * pLogPal);
Xvoid LCD__RLE8_SetFunc (GUI_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off, const LCD_LOGPALETTE * pLogPal);
Nvoid LCD__RLE16_SetFunc(GUI_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off);
Xvoid LCD__RLE16_SetFunc(GUI_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off);
Nvoid LCD__RLE32_SetFunc(GUI_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off);
Xvoid LCD__RLE32_SetFunc(GUI_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off);
N
N/*********************************************************************
N*
N*       BMP-export
N*/
Nvoid GUI_BMP_Serialize     (GUI_CALLBACK_VOID_U8_P * pfSerialize, void * p);
Nvoid GUI_BMP_SerializeEx   (GUI_CALLBACK_VOID_U8_P * pfSerialize, int x0, int y0, int xSize, int ySize, void * p);
Nvoid GUI_BMP_SerializeExBpp(GUI_CALLBACK_VOID_U8_P * pfSerialize, int x0, int y0, int xSize, int ySize, void * p, int BitsPerPixel);
N
Nvoid GUI_BMP__WriteBitmapHeader(GUI_CALLBACK_VOID_U8_P * pfSerialize, int xSize, int ySize, void * p, int BitsPerPixel, int BytesPerLine, int BytesPerPixel, int NumColors, int Padding);
N
N/*********************************************************************
N*
N*       Time / execution related routines
N*/
Nvoid           GUI_Delay       (int Period);
NGUI_TIMER_TIME GUI_GetTime     (void);
Xint GUI_GetTime     (void);
Nint            GUI_GetTimeSlice(void);
Nint            GUI_Exec        (void);        /* Execute all jobs ... Return 0 if nothing was done. */
Nint            GUI_Exec1       (void);        /* Execute one job  ... Return 0 if nothing was done. */
Nvoid           GUI_SetTimeSlice(int TimeSlice);
N
N/*********************************************************************
N*
N*       MessageBox
N*/
Nint     GUI_MessageBox   (const char * sMessage, const char * sCaption, int Flags);
N#define GUI_MESSAGEBOX_CF_MOVEABLE (1 << 0)
N#define GUI_MESSAGEBOX_CF_MODAL    (1 << 1)
N
N#define GUI_MB_OK                20
N#define GUI_MB_WARNING           21
N
N/*********************************************************************
N*
N*       GUI_TIMER module
N*/
N#define GUI_TIMER_CF_WINDOW (1 << 0)
N#define GUI_TIMER_CF_CURSOR (1 << 1)
N
Ntypedef GUI_HMEM GUI_TIMER_HANDLE;
Xtypedef signed long GUI_TIMER_HANDLE;
N
Ntypedef struct {
N  GUI_TIMER_TIME   Time;
X  int   Time;
N  PTR_ADDR         Context;
X  unsigned long         Context;
N  GUI_TIMER_HANDLE hTimer;
N} GUI_TIMER_MESSAGE;
N
Ntypedef void GUI_TIMER_CALLBACK(/*const*/ GUI_TIMER_MESSAGE* pTM);
N
NGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK * cb, GUI_TIMER_TIME Time, PTR_ADDR Context, U16 Flags);
XGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK * cb, int Time, unsigned long Context, unsigned short Flags);
Nvoid             GUI_TIMER_Delete   (GUI_TIMER_HANDLE hObj);
N
N/* Methods changing properties */
NGUI_TIMER_TIME GUI_TIMER_GetPeriod(GUI_TIMER_HANDLE hObj);
Xint GUI_TIMER_GetPeriod(GUI_TIMER_HANDLE hObj);
Nvoid           GUI_TIMER_SetPeriod(GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Period);
Xvoid           GUI_TIMER_SetPeriod(GUI_TIMER_HANDLE hObj, int Period);
Nvoid           GUI_TIMER_SetTime  (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Period);
Xvoid           GUI_TIMER_SetTime  (GUI_TIMER_HANDLE hObj, int Period);
Nvoid           GUI_TIMER_SetDelay (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Delay);
Xvoid           GUI_TIMER_SetDelay (GUI_TIMER_HANDLE hObj, int Delay);
Nvoid           GUI_TIMER_Restart  (GUI_TIMER_HANDLE hObj);
Nint            GUI_TIMER_GetFlag  (GUI_TIMER_HANDLE hObj, int Flag); /* Not to be documented */
Nint            GUI_TIMER_Exec     (void);
N
N/*********************************************************************
N*
N*       Anti Aliasing
N*/
N#define GUI_AA_TRANS   0 // Foreground color mixed up with current content of framebuffer
N#define GUI_AA_NOTRANS 1 // Foreground color mixed up with current background color
N
Nvoid GUI_AA_DisableHiRes     (void);
Nvoid GUI_AA_EnableHiRes      (void);
Nint  GUI_AA_GetFactor        (void);
Nvoid GUI_AA_SetFactor        (int Factor);
Nvoid GUI_AA_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_AA_DrawCircle       (int x0, int y0, int r);  // Currently not implemented, only for Dave2D
Nvoid GUI_AA_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GUI_AA_DrawPolyOutline  (const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y);
Nvoid GUI_AA_DrawPolyOutlineEx(const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y, GUI_POINT * pBuffer);
Nvoid GUI_AA_DrawRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_AA_DrawRoundedRectEx(GUI_RECT * pRect, int r);
Nvoid GUI_AA_FillCircle       (int x0, int y0, int r);
Nvoid GUI_AA_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_AA_FillPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_AA_FillRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_AA_FillRoundedRectEx(GUI_RECT * pRect, int r);
Nint  GUI_AA_SetDrawMode      (int Mode);
Nvoid GUI_AA_SetpfDrawCharAA4 (int (* pfDrawChar)(int LayerIndex, int x, int y, U8 const * p, int xSize, int ySize, int BytesPerLine));
Xvoid GUI_AA_SetpfDrawCharAA4 (int (* pfDrawChar)(int LayerIndex, int x, int y, unsigned char const * p, int xSize, int ySize, int BytesPerLine));
Nvoid GUI_AA_SetGammaAA4      (U8 * pGamma);
Xvoid GUI_AA_SetGammaAA4      (unsigned char * pGamma);
Nvoid GUI_AA_GetGammaAA4      (U8 * pGamma);
Xvoid GUI_AA_GetGammaAA4      (unsigned char * pGamma);
Nvoid GUI_AA_EnableGammaAA4   (int OnOff);
N
N#define GUI_AA_PreserveTrans(OnOff) GUI_PreserveTrans(OnOff)  // For compatibility only
N
Nvoid GUI_AA_SetFuncDrawArc        (int (* pfDrawArc)    (int x0, int y0, int rx, int ry, int a0, int a1));
Nvoid GUI_AA_SetFuncDrawCircle     (int (* pfDrawCircle) (int x0, int y0, int r));
Nvoid GUI_AA_SetFuncDrawLine       (int (* pfDrawLine)   (int x0, int y0, int x1, int y1));
Nvoid GUI_AA_SetFuncDrawPolyOutline(int (* pfDrawPolyOutline)(const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y));
Nvoid GUI_AA_SetFuncFillCircle     (int (* pfFillCircle) (int x0, int y0, int r));
Nvoid GUI_AA_SetFuncFillPolygon    (int (* pfFillPolygon)(const GUI_POINT * pPoints, int NumPoints, int x0, int y0));
N
N/*********************************************************************
N*
N*       Keyboard
N*/
N/* Message layer */
Nvoid GUI_StoreKeyMsg(int Key, int Pressed);
Nvoid GUI_SendKeyMsg (int Key, int Pressed);
Nint  GUI_PollKeyMsg (void);
Nvoid GUI_GetKeyState(GUI_KEY_STATE * pState);
N
Nvoid GUI_KEY__SetHook(void (* pfHook)(const GUI_KEY_STATE *));
N
N/* Application layer */
Nint  GUI_GetKey(void);
Nint  GUI_WaitKey(void);
Nvoid GUI_StoreKey(int c);
Nvoid GUI_ClearKeyBuffer(void);
N
N/*********************************************************************
N*
N*       Task synchronization
N*/
Nvoid GUI_WaitEvent            (void);
Nvoid GUI_SignalEvent          (void);
Nvoid GUI_SetSignalEventFunc   (GUI_SIGNAL_EVENT_FUNC     pfSignalEvent);
Nvoid GUI_SetWaitEventFunc     (GUI_WAIT_EVENT_FUNC       pfWaitEvent);
Nvoid GUI_SetWaitEventTimedFunc(GUI_WAIT_EVENT_TIMED_FUNC pfWaitEventTimed);
N
N/*********************************************************************
N*
N*       Joystick, generic
N*/
Nvoid GUI_JOYSTICK_StoreState(const GUI_PID_STATE * pState);
N
N/*********************************************************************
N*
N*       PID  (Pointer input device ... mouse/touch)
N*/
Nvoid GUI_PID_StoreState     (const GUI_PID_STATE * pState);
Nint  GUI_PID_GetState       (      GUI_PID_STATE * pState);
Nvoid GUI_PID_GetCurrentState(      GUI_PID_STATE * pState);
Nint  GUI_PID_IsEmpty        (void);
Nint  GUI_PID_IsPressed      (void);
Nvoid GUI_PID_RegisterHook   (GUI_REGISTER_HOOK * pRegisterHook);
Nvoid GUI_PID_SetHook        (void (* pfHook)(      GUI_PID_STATE *));  // Public
Nvoid GUI_PID__SetHook       (void (* pfHook)(const GUI_PID_STATE *));  // Private
N
N/*********************************************************************
N*
N*       Mouse, generic
N*/
Nint  GUI_MOUSE_GetState  (      GUI_PID_STATE * pState);
Nvoid GUI_MOUSE_StoreState(const GUI_PID_STATE * pState);
N
N/*********************************************************************
N*
N*       TOUCH screen, generic
N*/
Nint  GUI_TOUCH_GetLayer     (void);
Nint  GUI_TOUCH_GetState     (GUI_PID_STATE * pState);
Nvoid GUI_TOUCH_GetUnstable  (int * px, int * py);  /* for diagnostics only */
Nvoid GUI_TOUCH_SetLayer     (int Layer);
Nvoid GUI_TOUCH_StoreState   (int x, int y);
Nvoid GUI_TOUCH_StoreStateEx (const GUI_PID_STATE * pState);
Nvoid GUI_TOUCH_StoreUnstable(int x, int y);
N
N/*********************************************************************
N*
N*       Mouse, PS2 driver
N*/
Nvoid GUI_MOUSE_DRIVER_PS2_Init(void);               /* optional */
Nvoid GUI_MOUSE_DRIVER_PS2_OnRx(unsigned char Data);
N
N/*********************************************************************
N*
N*       TOUCH screen, analog driver
N*/
Nint  GUI_TOUCH_CalcCoefficients (int NumPoints, int * pxRef, int * pyRef, int * pxSample, int * pySample, int xSize, int ySize);
Nint  GUI_TOUCH_Calibrate        (int Coord, int Log0, int Log1, int Phys0, int Phys1);
Nint  GUI_TOUCH_CalibratePoint   (int * px, int * py);
Nvoid GUI_TOUCH_EnableCalibration(int OnOff);
Nvoid GUI_TOUCH_Exec             (void);
Nint  GUI_TOUCH_GetxPhys         (void);    /* for diagnostics only */
Nint  GUI_TOUCH_GetyPhys         (void);    /* for diagnostics only */
Nvoid GUI_TOUCH_SetCalibration   (int (* pFunc)(int *, int *)); /* Not to be documented */
Nvoid GUI_TOUCH_SetOrientation   (unsigned Orientation);
Nint  GUI_TOUCH_TransformPoint   (int * px, int * py);          /* Not to be documented */
N
N/*********************************************************************
N*
N*       TOUCH: imports
N*
N* Please note: The following functions are required by the module.
N* They need to be part of your application software (or rather, part
N* of the hardware-layer of your software).
N*/
Nvoid GUI_TOUCH_X_ActivateX(void);
Nvoid GUI_TOUCH_X_ActivateY(void);
Nvoid GUI_TOUCH_X_Disable  (void);
Nint  GUI_TOUCH_X_MeasureX (void);
Nint  GUI_TOUCH_X_MeasureY (void);
N
N/*********************************************************************
N*
N*       GUI_X_
N*
N* Externals, to be defined by application
N*
N* The externals defined below should be defined by the
N* application. They are per default contained in the module
N* GUI_X.c.
N* Note that a lot if not all of these are not required in most target
N* systems.
N* For this module, samples are available for configurations
N* with or without operating system.
N*/
N//
N// Configuration
N//
Nvoid GUI_X_Config(void);
Nvoid GUI_X_Init  (void);
N
N//
N// Timing routines
N//
NGUI_TIMER_TIME GUI_X_GetTime(void);
Xint GUI_X_GetTime(void);
Nvoid           GUI_X_Delay  (int Period);
N
N//
N// Multitask routines - required only if multitasking is used (#define GUI_OS 1)
N//
Nvoid GUI_X_Unlock   (void);
Nvoid GUI_X_Lock     (void);
NU32  GUI_X_GetTaskId(void);
Xunsigned long  GUI_X_GetTaskId(void);
Nvoid GUI_X_InitOS   (void);
N
N//
N// Event driving (optional with multitasking)
N//
Nvoid GUI_X_ExecIdle      (void);
Nvoid GUI_X_WaitEvent     (void);
Nvoid GUI_X_WaitEventTimed(int Period);
Nvoid GUI_X_SignalEvent   (void);
N
N//
N// Recording (logs/warnings and errors) - required only for higher levels
N//
Nvoid GUI_X_Log     (const char * s);
Nvoid GUI_X_Warn    (const char * s);
Nvoid GUI_X_ErrorOut(const char * s);
N
N/*********************************************************************
N*
N*       Constants for fonts and bitmaps
N*/
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE4;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE4Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE8;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE8Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE16Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEM16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEM16Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE32;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE32Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEAlpha;
N
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods444_12;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM444_12;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods444_12_1;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM444_12_1;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods444_16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM444_16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods24;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods8888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM8888I;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsA565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsAM565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsA555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsAM555;
N
N#define GUI_COMPRESS_RLE4 0
N#define GUI_COMPRESS_RLE8 0
N
N#define GUI_DRAW_RLE4         &GUI_BitmapMethodsRLE4       /* Method table ! */
N#define GUI_DRAW_RLE8         &GUI_BitmapMethodsRLE8       /* Method table ! */
N#define GUI_DRAW_RLE16        &GUI_BitmapMethodsRLE16      /* Method table ! */
N#define GUI_DRAW_RLEM16       &GUI_BitmapMethodsRLEM16     /* Method table ! */
N#define GUI_DRAW_RLE32        &GUI_BitmapMethodsRLE32      /* Method table ! */
N#define GUI_DRAW_RLEALPHA     &GUI_BitmapMethodsRLEAlpha   /* Method table ! */
N
N#define GUI_DRAW_BMP444_12    &GUI_BitmapMethods444_12     /* Method table ! */
N#define GUI_DRAW_BMPM444_12   &GUI_BitmapMethodsM444_12    /* Method table ! */
N#define GUI_DRAW_BMP444_12_1  &GUI_BitmapMethods444_12_1   /* Method table ! */
N#define GUI_DRAW_BMPM444_12_1 &GUI_BitmapMethodsM444_12_1  /* Method table ! */
N#define GUI_DRAW_BMP444_16    &GUI_BitmapMethods444_16     /* Method table ! */
N#define GUI_DRAW_BMPM444_16   &GUI_BitmapMethodsM444_16    /* Method table ! */
N#define GUI_DRAW_BMP555       &GUI_BitmapMethods555        /* Method table ! */
N#define GUI_DRAW_BMPM555      &GUI_BitmapMethodsM555       /* Method table ! */
N#define GUI_DRAW_BMP565       &GUI_BitmapMethods565        /* Method table ! */
N#define GUI_DRAW_BMPM565      &GUI_BitmapMethodsM565       /* Method table ! */
N#define GUI_DRAW_BMP24        &GUI_BitmapMethods24         /* Method table ! */
N#define GUI_DRAW_BMP888       &GUI_BitmapMethods888        /* Method table ! */
N#define GUI_DRAW_BMPM888      &GUI_BitmapMethodsM888       /* Method table ! */
N#define GUI_DRAW_BMP8888      &GUI_BitmapMethods8888       /* Method table ! */
N#define GUI_DRAW_BMPM8888I    &GUI_BitmapMethodsM8888I     /* Method table ! */
N#define GUI_DRAW_BMPA555      &GUI_BitmapMethodsA555       /* Method table ! */
N#define GUI_DRAW_BMPAM555     &GUI_BitmapMethodsAM555      /* Method table ! */
N#define GUI_DRAW_BMPA565      &GUI_BitmapMethodsA565       /* Method table ! */
N#define GUI_DRAW_BMPAM565     &GUI_BitmapMethodsAM565      /* Method table ! */
N
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_Ext;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_Frm;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA2;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA4;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA2_EXT;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA4_EXT;
N
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_Ext;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_Frm;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_AA2_Ext;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_AA4_Ext;
N
N/*********************************************************************
N*
N*       GUI_KEY_...
N*
N* These ID values are basically meant to be used with widgets
N* Note that we have chosen the values to be close to existing
N* "standards", so do not change them unless forced to.
N*
N*/
N#define GUI_KEY_BACKSPACE         8         /* ASCII: BACKSPACE Crtl-H */
N#define GUI_KEY_TAB               9         /* ASCII: TAB       Crtl-I */
N#define GUI_KEY_BACKTAB           10
N#define GUI_KEY_ENTER             13        /* ASCII: ENTER     Crtl-M */
N#define GUI_KEY_LEFT              16
N#define GUI_KEY_UP                17
N#define GUI_KEY_RIGHT             18
N#define GUI_KEY_DOWN              19
N#define GUI_KEY_HOME              23
N#define GUI_KEY_END               24
N#define GUI_KEY_SHIFT             25
N#define GUI_KEY_CONTROL           26
N#define GUI_KEY_ESCAPE            27        /* ASCII: ESCAPE    0x1b   */
N#define GUI_KEY_INSERT            29
N#define GUI_KEY_DELETE            30
N#define GUI_KEY_SPACE             32
N#define GUI_KEY_PGUP              33
N#define GUI_KEY_PGDOWN            34
N
N#define GUI_KEY_F1                40
N#define GUI_KEY_F2                41
N
N/*********************************************************************
N*
N*       Dialog item IDs
N*
N*  The IDs below are arbitrary values. They just have to be unique
N*  within the dialog.
N*
N*  If you use your own Ids, we recommend to use values above GUI_ID_USER.
N*/
N#define GUI_ID_OK                1
N#define GUI_ID_CANCEL            2
N#define GUI_ID_YES               3
N#define GUI_ID_NO                4
N#define GUI_ID_CLOSE             5
N#define GUI_ID_HELP              6
N#define GUI_ID_MAXIMIZE          7
N#define GUI_ID_MINIMIZE          8
N
N#define GUI_ID_VSCROLL    0xFE
N#define GUI_ID_HSCROLL    0xFF
N
N#define GUI_ID_EDIT0      0x100
N#define GUI_ID_EDIT1      0x101
N#define GUI_ID_EDIT2      0x102
N#define GUI_ID_EDIT3      0x103
N#define GUI_ID_EDIT4      0x104
N#define GUI_ID_EDIT5      0x105
N#define GUI_ID_EDIT6      0x106
N#define GUI_ID_EDIT7      0x107
N#define GUI_ID_EDIT8      0x108
N#define GUI_ID_EDIT9      0x109
N
N#define GUI_ID_LISTBOX0   0x110
N#define GUI_ID_LISTBOX1   0x111
N#define GUI_ID_LISTBOX2   0x112
N#define GUI_ID_LISTBOX3   0x113
N#define GUI_ID_LISTBOX4   0x114
N#define GUI_ID_LISTBOX5   0x115
N#define GUI_ID_LISTBOX6   0x116
N#define GUI_ID_LISTBOX7   0x117
N#define GUI_ID_LISTBOX8   0x118
N#define GUI_ID_LISTBOX9   0x119
N
N#define GUI_ID_CHECK0     0x120
N#define GUI_ID_CHECK1     0x121
N#define GUI_ID_CHECK2     0x122
N#define GUI_ID_CHECK3     0x123
N#define GUI_ID_CHECK4     0x124
N#define GUI_ID_CHECK5     0x125
N#define GUI_ID_CHECK6     0x126
N#define GUI_ID_CHECK7     0x127
N#define GUI_ID_CHECK8     0x128
N#define GUI_ID_CHECK9     0x129
N
N#define GUI_ID_SLIDER0    0x130
N#define GUI_ID_SLIDER1    0x131
N#define GUI_ID_SLIDER2    0x132
N#define GUI_ID_SLIDER3    0x133
N#define GUI_ID_SLIDER4    0x134
N#define GUI_ID_SLIDER5    0x135
N#define GUI_ID_SLIDER6    0x136
N#define GUI_ID_SLIDER7    0x137
N#define GUI_ID_SLIDER8    0x138
N#define GUI_ID_SLIDER9    0x139
N
N#define GUI_ID_SCROLLBAR0 0x140
N#define GUI_ID_SCROLLBAR1 0x141
N#define GUI_ID_SCROLLBAR2 0x142
N#define GUI_ID_SCROLLBAR3 0x143
N
N#define GUI_ID_RADIO0     0x150
N#define GUI_ID_RADIO1     0x151
N#define GUI_ID_RADIO2     0x152
N#define GUI_ID_RADIO3     0x153
N#define GUI_ID_RADIO4     0x154
N#define GUI_ID_RADIO5     0x155
N#define GUI_ID_RADIO6     0x156
N#define GUI_ID_RADIO7     0x157
N
N#define GUI_ID_TEXT0      0x160
N#define GUI_ID_TEXT1      0x161
N#define GUI_ID_TEXT2      0x162
N#define GUI_ID_TEXT3      0x163
N#define GUI_ID_TEXT4      0x164
N#define GUI_ID_TEXT5      0x165
N#define GUI_ID_TEXT6      0x166
N#define GUI_ID_TEXT7      0x167
N#define GUI_ID_TEXT8      0x168
N#define GUI_ID_TEXT9      0x169
N
N#define GUI_ID_BUTTON0    0x170
N#define GUI_ID_BUTTON1    0x171
N#define GUI_ID_BUTTON2    0x172
N#define GUI_ID_BUTTON3    0x173
N#define GUI_ID_BUTTON4    0x174
N#define GUI_ID_BUTTON5    0x175
N#define GUI_ID_BUTTON6    0x176
N#define GUI_ID_BUTTON7    0x177
N#define GUI_ID_BUTTON8    0x178
N#define GUI_ID_BUTTON9    0x179
N
N#define GUI_ID_DROPDOWN0  0x180
N#define GUI_ID_DROPDOWN1  0x181
N#define GUI_ID_DROPDOWN2  0x182
N#define GUI_ID_DROPDOWN3  0x183
N
N#define GUI_ID_MULTIEDIT0 0x190
N#define GUI_ID_MULTIEDIT1 0x191
N#define GUI_ID_MULTIEDIT2 0x192
N#define GUI_ID_MULTIEDIT3 0x193
N
N#define GUI_ID_LISTVIEW0  0x200
N#define GUI_ID_LISTVIEW1  0x201
N#define GUI_ID_LISTVIEW2  0x202
N#define GUI_ID_LISTVIEW3  0x203
N
N#define GUI_ID_PROGBAR0   0x210
N#define GUI_ID_PROGBAR1   0x211
N#define GUI_ID_PROGBAR2   0x212
N#define GUI_ID_PROGBAR3   0x213
N
N#define GUI_ID_GRAPH0     0x220
N#define GUI_ID_GRAPH1     0x221
N#define GUI_ID_GRAPH2     0x222
N#define GUI_ID_GRAPH3     0x223
N
N#define GUI_ID_MULTIPAGE0 0x230
N#define GUI_ID_MULTIPAGE1 0x231
N#define GUI_ID_MULTIPAGE2 0x232
N#define GUI_ID_MULTIPAGE3 0x233
N
N#define GUI_ID_TREEVIEW0  0x240
N#define GUI_ID_TREEVIEW1  0x241
N#define GUI_ID_TREEVIEW2  0x242
N#define GUI_ID_TREEVIEW3  0x243
N
N#define GUI_ID_ICONVIEW0  0x250
N#define GUI_ID_ICONVIEW1  0x251
N#define GUI_ID_ICONVIEW2  0x252
N#define GUI_ID_ICONVIEW3  0x253
N
N#define GUI_ID_LISTWHEEL0 0x260
N#define GUI_ID_LISTWHEEL1 0x261
N#define GUI_ID_LISTWHEEL2 0x262
N#define GUI_ID_LISTWHEEL3 0x263
N
N#define GUI_ID_IMAGE0     0x270
N#define GUI_ID_IMAGE1     0x271
N#define GUI_ID_IMAGE2     0x272
N#define GUI_ID_IMAGE3     0x273
N#define GUI_ID_IMAGE4     0x274
N#define GUI_ID_IMAGE5     0x275
N#define GUI_ID_IMAGE6     0x276
N#define GUI_ID_IMAGE7     0x277
N#define GUI_ID_IMAGE8     0x278
N#define GUI_ID_IMAGE9     0x279
N
N#define GUI_ID_SPINBOX0   0x280
N#define GUI_ID_SPINBOX1   0x281
N#define GUI_ID_SPINBOX2   0x282
N#define GUI_ID_SPINBOX3   0x283
N#define GUI_ID_SPINBOX4   0x284
N#define GUI_ID_SPINBOX5   0x285
N#define GUI_ID_SPINBOX6   0x286
N#define GUI_ID_SPINBOX7   0x287
N#define GUI_ID_SPINBOX8   0x288
N#define GUI_ID_SPINBOX9   0x289
N
N#define GUI_ID_CALENDAR0  0x290
N
N#define GUI_ID_KNOB0      0x300
N#define GUI_ID_KNOB1      0x301
N#define GUI_ID_KNOB2      0x302
N#define GUI_ID_KNOB3      0x303
N#define GUI_ID_KNOB4      0x304
N#define GUI_ID_KNOB5      0x305
N#define GUI_ID_KNOB6      0x306
N#define GUI_ID_KNOB7      0x307
N#define GUI_ID_KNOB8      0x308
N#define GUI_ID_KNOB9      0x309
N
N#define GUI_ID_SWIPELIST0 0x320
N#define GUI_ID_SWIPELIST1 0x321
N#define GUI_ID_SWIPELIST2 0x322
N
N#define GUI_ID_USER       0x800
N
N/*********************************************************************
N*
N*       Mouse buttons
N*/
N#define GUI_LBUTTON (1 << 0) /* Left button */
N#define GUI_RBUTTON (1 << 1) /* Right button */
N#define GUI_MBUTTON (1 << 2) /* Middle button */
N#define GUI_DBUTTON (1 << 7) /* Double-click button */
N
N/*********************************************************************
N*
N*       Text styles
N*/
N#define GUI_TS_NORMAL           (0)
N#define GUI_TS_UNDERLINE        (1 << 0)
N#define GUI_TS_STRIKETHRU       (1 << 1)
N#define GUI_TS_OVERLINE         (1 << 2)
N
N/*********************************************************************
N*
N*       Line styles
N*/
N#define GUI_LS_SOLID        (0)
N#define GUI_LS_DASH         (1)
N#define GUI_LS_DOT          (2)
N#define GUI_LS_DASHDOT      (3)
N#define GUI_LS_DASHDOTDOT   (4)
N
N/*********************************************************************
N*
N*       Pen shapes
N*/
N#define GUI_PS_ROUND        (0)
N#define GUI_PS_FLAT         (1)
N#define GUI_PS_SQUARE       (2)
N
N/*********************************************************************
N*
N*       Standard colors
N*/
N#define GUI_INVALID_COLOR ((((U32)GUI_TRANS_BYTE) << 24) | 0x12345678ul)  /* Invalid color (transparency + determined color) */
N
N#if (GUI_USE_ARGB)
X#if (1)
N  #define GUI_MAKE_COLOR(ABGR)  (((((U32)ABGR) & 0xFF000000ul) ^ 0xFF000000ul) | ((((U32)ABGR) & 0x00FF0000ul) >> 16) | (((U32)ABGR) & 0x0000FF00ul) | ((((U32)ABGR) & 0x000000FFul) << 16))
N  #define GUI_MAKE_TRANS(Alpha) (255 - (Alpha))
N#else
S  #define GUI_MAKE_COLOR(ABGR)  (ABGR)
S  #define GUI_MAKE_TRANS(Alpha) (Alpha)
N#endif
N
N#if (GUI_USE_ARGB)
X#if (1)
N  #define GUI_TRANS_BYTE 0x00
N#else
S  #define GUI_TRANS_BYTE 0xFF
N#endif
N
N#define GUI_BLUE          GUI_MAKE_COLOR(0x00FF0000)
N#define GUI_GREEN         GUI_MAKE_COLOR(0x0000FF00)
N#define GUI_RED           GUI_MAKE_COLOR(0x000000FF)
N#define GUI_CYAN          GUI_MAKE_COLOR(0x00FFFF00)
N#define GUI_MAGENTA       GUI_MAKE_COLOR(0x00FF00FF)
N#define GUI_YELLOW        GUI_MAKE_COLOR(0x0000FFFF)
N#define GUI_LIGHTBLUE     GUI_MAKE_COLOR(0x00FF8080)
N#define GUI_LIGHTGREEN    GUI_MAKE_COLOR(0x0080FF80)
N#define GUI_LIGHTRED      GUI_MAKE_COLOR(0x008080FF)
N#define GUI_LIGHTCYAN     GUI_MAKE_COLOR(0x00FFFF80)
N#define GUI_LIGHTMAGENTA  GUI_MAKE_COLOR(0x00FF80FF)
N#define GUI_LIGHTYELLOW   GUI_MAKE_COLOR(0x0080FFFF)
N#define GUI_DARKBLUE      GUI_MAKE_COLOR(0x00800000)
N#define GUI_DARKGREEN     GUI_MAKE_COLOR(0x00008000)
N#define GUI_DARKRED       GUI_MAKE_COLOR(0x00000080)
N#define GUI_DARKCYAN      GUI_MAKE_COLOR(0x00808000)
N#define GUI_DARKMAGENTA   GUI_MAKE_COLOR(0x00800080)
N#define GUI_DARKYELLOW    GUI_MAKE_COLOR(0x00008080)
N#define GUI_WHITE         GUI_MAKE_COLOR(0x00FFFFFF)
N#define GUI_LIGHTGRAY     GUI_MAKE_COLOR(0x00D3D3D3)
N#define GUI_GRAY          GUI_MAKE_COLOR(0x00808080)
N#define GUI_DARKGRAY      GUI_MAKE_COLOR(0x00404040)
N#define GUI_BLACK         GUI_MAKE_COLOR(0x00000000)
N#define GUI_BROWN         GUI_MAKE_COLOR(0x002A2AA5)
N#define GUI_ORANGE        GUI_MAKE_COLOR(0x0000A5FF)
N#define GUI_TRANSPARENT   GUI_MAKE_COLOR(0xFF000000)
N
N#define GUI_GRAY_3F       GUI_MAKE_COLOR(0x003F3F3F)
N#define GUI_GRAY_50       GUI_MAKE_COLOR(0x00505050)
N#define GUI_GRAY_55       GUI_MAKE_COLOR(0x00555555)
N#define GUI_GRAY_60       GUI_MAKE_COLOR(0x00606060)
N#define GUI_GRAY_7C       GUI_MAKE_COLOR(0x007C7C7C)
N#define GUI_GRAY_9A       GUI_MAKE_COLOR(0x009A9A9A)
N#define GUI_GRAY_AA       GUI_MAKE_COLOR(0x00AAAAAA)
N#define GUI_GRAY_C0       GUI_MAKE_COLOR(0x00C0C0C0)
N#define GUI_GRAY_C8       GUI_MAKE_COLOR(0x00C8C8C8)
N#define GUI_GRAY_D0       GUI_MAKE_COLOR(0x00D0D0D0)
N#define GUI_GRAY_E7       GUI_MAKE_COLOR(0x00E7E7E7)
N#define GUI_BLUE_98       GUI_MAKE_COLOR(0x00980000)
N
N/*********************************************************************
N*
N*       MultiTouch-Support
N*/
N//
N// Defines
N//
N#define GUI_MTOUCH_FLAG_DOWN (1 << 0)
N#define GUI_MTOUCH_FLAG_MOVE (1 << 1)
N#define GUI_MTOUCH_FLAG_UP   (1 << 2)
N
N//
N// Variables
N//
Nextern T_GUI_MTOUCH_STOREEVENT GUI_MTOUCH__pStoreEvent;
N
N//
N// Interface
N//
Nvoid GUI_MTOUCH_Enable          (int OnOff);
Nint  GUI_MTOUCH_GetEvent        (GUI_MTOUCH_EVENT * pEvent);
Nint  GUI_MTOUCH_GetTouchInput   (GUI_MTOUCH_EVENT * pEvent, GUI_MTOUCH_INPUT * pBuffer, unsigned Index);
Nint  GUI_MTOUCH_IsEmpty         (void);
Nvoid GUI_MTOUCH_SetOrientation  (int Orientation);
Nvoid GUI_MTOUCH_SetOrientationEx(int Orientation, int LayerIndex);
Nvoid GUI_MTOUCH_StoreEvent      (GUI_MTOUCH_EVENT * pEvent, GUI_MTOUCH_INPUT * pInput);
N
N/*********************************************************************
N*
N*       Coordinates used in touch driver
N*/
N#define GUI_COORD_X 0
N#define GUI_COORD_Y 1
N
N/*********************************************************************
N*
N*       Addresses of standard fonts
N*/
N//
N// Proportional fonts
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Xextern const GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Xextern const GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Xextern const GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Xextern const GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Xextern const GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Xextern const GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Xextern const GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Xextern const GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Xextern const GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20_ASCII,       GUI_Font20_1;
Xextern const GUI_FONT GUI_Font20_ASCII,       GUI_Font20_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20B_ASCII,      GUI_Font20B_1;
Xextern const GUI_FONT GUI_Font20B_ASCII,      GUI_Font20B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Xextern const GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Xextern const GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Xextern const GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
Xextern const GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
N
N//
N// Proportional fonts, framed
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20F_ASCII;
Xextern const GUI_FONT GUI_Font20F_ASCII;
N
N//
N// Monospaced
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font4x6;
Xextern const GUI_FONT GUI_Font4x6;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Xextern const GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font6x8_ASCII,      GUI_Font6x8_1;
Xextern const GUI_FONT GUI_Font6x8_ASCII,      GUI_Font6x8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Xextern const GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x8_ASCII,      GUI_Font8x8_1;
Xextern const GUI_FONT GUI_Font8x8_ASCII,      GUI_Font8x8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x10_ASCII;
Xextern const GUI_FONT GUI_Font8x10_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x12_ASCII;
Xextern const GUI_FONT GUI_Font8x12_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Xextern const GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Xextern const GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Xextern const GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
Xextern const GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16_ASCII,     GUI_Font8x16_1;
Xextern const GUI_FONT GUI_Font8x16_ASCII,     GUI_Font8x16_1;
N
N//
N// Digits
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD24x32;
Xextern const GUI_FONT GUI_FontD24x32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD32;
Xextern const GUI_FONT GUI_FontD32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD36x48;
Xextern const GUI_FONT GUI_FontD36x48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48;
Xextern const GUI_FONT GUI_FontD48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48x64;
Xextern const GUI_FONT GUI_FontD48x64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD64;
Xextern const GUI_FONT GUI_FontD64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD60x80;
Xextern const GUI_FONT GUI_FontD60x80;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD80;
Xextern const GUI_FONT GUI_FontD80;
N
N//
N// Comic fonts
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Xextern const GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
Xextern const GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
N
N/*********************************************************************
N*
N*       Macros to be used
N*/
N//
N// Proportional fonts
N//
N#define GUI_FONT_8_ASCII        &GUI_Font8_ASCII
N#define GUI_FONT_8_1            &GUI_Font8_1
N#define GUI_FONT_10S_ASCII      &GUI_Font10S_ASCII
N#define GUI_FONT_10S_1          &GUI_Font10S_1
N#define GUI_FONT_10_ASCII       &GUI_Font10_ASCII
N#define GUI_FONT_10_1           &GUI_Font10_1
N#define GUI_FONT_13_ASCII       &GUI_Font13_ASCII
N#define GUI_FONT_13_1           &GUI_Font13_1
N#define GUI_FONT_13B_ASCII      &GUI_Font13B_ASCII
N#define GUI_FONT_13B_1          &GUI_Font13B_1
N#define GUI_FONT_13H_ASCII      &GUI_Font13H_ASCII
N#define GUI_FONT_13H_1          &GUI_Font13H_1
N#define GUI_FONT_13HB_ASCII     &GUI_Font13HB_ASCII
N#define GUI_FONT_13HB_1         &GUI_Font13HB_1
N#define GUI_FONT_16_ASCII       &GUI_Font16_ASCII
N#define GUI_FONT_16_1           &GUI_Font16_1
N#define GUI_FONT_16_HK          &GUI_Font16_HK
N#define GUI_FONT_16_1HK         &GUI_Font16_1HK
N#define GUI_FONT_16B_ASCII      &GUI_Font16B_ASCII
N#define GUI_FONT_16B_1          &GUI_Font16B_1
N#define GUI_FONT_20_ASCII       &GUI_Font20_ASCII
N#define GUI_FONT_20_1           &GUI_Font20_1
N#define GUI_FONT_20B_ASCII      &GUI_Font20B_ASCII
N#define GUI_FONT_20B_1          &GUI_Font20B_1
N#define GUI_FONT_24_ASCII       &GUI_Font24_ASCII
N#define GUI_FONT_24_1           &GUI_Font24_1
N#define GUI_FONT_24B_ASCII      &GUI_Font24B_ASCII
N#define GUI_FONT_24B_1          &GUI_Font24B_1
N#define GUI_FONT_32_ASCII       &GUI_Font32_ASCII
N#define GUI_FONT_32_1           &GUI_Font32_1
N#define GUI_FONT_32B_ASCII      &GUI_Font32B_ASCII
N#define GUI_FONT_32B_1          &GUI_Font32B_1
N
N//
N// Proportional fonts, framed
N//
N#define GUI_FONT_20F_ASCII      &GUI_Font20F_ASCII
N
N//
N// Monospaced
N//
N#define GUI_FONT_4X6            &GUI_Font4x6
N#define GUI_FONT_6X8            &GUI_Font6x8
N#define GUI_FONT_6X8_ASCII      &GUI_Font6x8_ASCII
N#define GUI_FONT_6X8_1          &GUI_Font6x8_1
N#define GUI_FONT_6X9            &GUI_Font6x9
N#define GUI_FONT_8X8            &GUI_Font8x8
N#define GUI_FONT_8X8_ASCII      &GUI_Font8x8_ASCII
N#define GUI_FONT_8X8_1          &GUI_Font8x8_1
N#define GUI_FONT_8X9            &GUI_Font8x9
N#define GUI_FONT_8X10_ASCII     &GUI_Font8x10_ASCII
N#define GUI_FONT_8X12_ASCII     &GUI_Font8x12_ASCII
N#define GUI_FONT_8X13_ASCII     &GUI_Font8x13_ASCII
N#define GUI_FONT_8X13_1         &GUI_Font8x13_1
N#define GUI_FONT_8X15B_ASCII    &GUI_Font8x15B_ASCII
N#define GUI_FONT_8X15B_1        &GUI_Font8x15B_1
N#define GUI_FONT_8X16           &GUI_Font8x16
N#define GUI_FONT_8X17           &GUI_Font8x17
N#define GUI_FONT_8X18           &GUI_Font8x18
N#define GUI_FONT_8X16X1X2       &GUI_Font8x16x1x2
N#define GUI_FONT_8X16X2X2       &GUI_Font8x16x2x2
N#define GUI_FONT_8X16X3X3       &GUI_Font8x16x3x3
N#define GUI_FONT_8X16_ASCII     &GUI_Font8x16_ASCII
N#define GUI_FONT_8X16_1         &GUI_Font8x16_1
N
N//
N// Digits
N//
N#define GUI_FONT_D24X32         &GUI_FontD24x32
N#define GUI_FONT_D32            &GUI_FontD32
N#define GUI_FONT_D36X48         &GUI_FontD36x48
N#define GUI_FONT_D48            &GUI_FontD48
N#define GUI_FONT_D48X64         &GUI_FontD48x64
N#define GUI_FONT_D64            &GUI_FontD64
N#define GUI_FONT_D60X80         &GUI_FontD60x80
N#define GUI_FONT_D80            &GUI_FontD80
N
N//
N// Comic fonts
N//
N#define GUI_FONT_COMIC18B_ASCII &GUI_FontComic18B_ASCII
N#define GUI_FONT_COMIC18B_1     &GUI_FontComic18B_1
N#define GUI_FONT_COMIC24B_ASCII &GUI_FontComic24B_ASCII
N#define GUI_FONT_COMIC24B_1     &GUI_FontComic24B_1
N
N/*********************************************************************
N*
N*       Text and drawing modes
N*
N* These defines come in two flavors: the long version (.._DRAWMODE_..)
N* and the short ones (.._DM_..). They are identical, feel free to use
N* which ever one you like best.
N*/
N#define GUI_DRAWMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_DRAWMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_DRAWMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_DRAWMODE_REV     LCD_DRAWMODE_REV
N#define GUI_DM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_DM_XOR           LCD_DRAWMODE_XOR
N#define GUI_DM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_DM_REV           LCD_DRAWMODE_REV
N
N#define GUI_TEXTMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_TEXTMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_TEXTMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_TEXTMODE_REV     LCD_DRAWMODE_REV
N#define GUI_TM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_TM_XOR           LCD_DRAWMODE_XOR
N#define GUI_TM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_TM_REV           LCD_DRAWMODE_REV
N
N/* Text alignment flags, horizontal */
N#define GUI_TA_LEFT       (0)
N#define GUI_TA_HORIZONTAL (3 << 0)
N#define GUI_TA_RIGHT      (1 << 0)
N#define GUI_TA_CENTER     (2 << 0)
N#define GUI_TA_HCENTER    GUI_TA_CENTER  /* easier to remember :-)  */
N
N/* Text alignment flags, vertical */
N#define GUI_TA_TOP        (0)
N#define GUI_TA_VERTICAL   (3 << 2)
N#define GUI_TA_BOTTOM     (1 << 2)
N#define GUI_TA_BASELINE   (2 << 2)
N#define GUI_TA_VCENTER    (3 << 2)
N
N/* General alignment flags */
N#define GUI_ALIGN_LEFT       GUI_TA_LEFT
N#define GUI_ALIGN_HCENTER    GUI_TA_HCENTER
N#define GUI_ALIGN_RIGHT      GUI_TA_RIGHT
N#define GUI_ALIGN_TOP        GUI_TA_TOP
N#define GUI_ALIGN_VCENTER    GUI_TA_VCENTER
N#define GUI_ALIGN_BOTTOM     GUI_TA_BOTTOM
N#define GUI_ALIGN_HORIZONTAL GUI_TA_HORIZONTAL
N#define GUI_ALIGN_VERTICAL   GUI_TA_VERTICAL
N
N/* General orientation flags */
N#define GUI_MIRROR_X (1 << 0)
N#define GUI_MIRROR_Y (1 << 1)
N#define GUI_SWAP_XY  (1 << 2)
N
N#define GUI_ROTATION_0   (0)
N#define GUI_ROTATION_CW  (GUI_MIRROR_X | GUI_SWAP_XY)
N#define GUI_ROTATION_180 (GUI_MIRROR_X | GUI_MIRROR_Y)
N#define GUI_ROTATION_CCW (GUI_MIRROR_Y | GUI_SWAP_XY)
N
N/*********************************************************************
N*
N*       Min/Max coordinates
N*
N* Define minimum and maximum coordinates in x and y
N*/
N#define GUI_XMIN -16383
N#define GUI_XMAX  16383
N#define GUI_YMIN -16383
N#define GUI_YMAX  16383
N
N/*********************************************************************
N*
N*       Defines for constants
N*/
N#define	________	0x0
N#define	_______X	0x1
N#define	______X_	0x2
N#define	______XX	0x3
N#define	_____X__	0x4
N#define	_____X_X	0x5
N#define	_____XX_	0x6
N#define	_____XXX	0x7
N#define	____X___	0x8
N#define	____X__X	0x9
N#define	____X_X_	0xa
N#define	____X_XX	0xb
N#define	____XX__	0xc
N#define	____XX_X	0xd
N#define	____XXX_	0xe
N#define	____XXXX	0xf
N#define	___X____	0x10
N#define	___X___X	0x11
N#define	___X__X_	0x12
N#define	___X__XX	0x13
N#define	___X_X__	0x14
N#define	___X_X_X	0x15
N#define	___X_XX_	0x16
N#define	___X_XXX	0x17
N#define	___XX___	0x18
N#define	___XX__X	0x19
N#define	___XX_X_	0x1a
N#define	___XX_XX	0x1b
N#define	___XXX__	0x1c
N#define	___XXX_X	0x1d
N#define	___XXXX_	0x1e
N#define	___XXXXX	0x1f
N#define	__X_____	0x20
N#define	__X____X	0x21
N#define	__X___X_	0x22
N#define	__X___XX	0x23
N#define	__X__X__	0x24
N#define	__X__X_X	0x25
N#define	__X__XX_	0x26
N#define	__X__XXX	0x27
N#define	__X_X___	0x28
N#define	__X_X__X	0x29
N#define	__X_X_X_	0x2a
N#define	__X_X_XX	0x2b
N#define	__X_XX__	0x2c
N#define	__X_XX_X	0x2d
N#define	__X_XXX_	0x2e
N#define	__X_XXXX	0x2f
N#define	__XX____	0x30
N#define	__XX___X	0x31
N#define	__XX__X_	0x32
N#define	__XX__XX	0x33
N#define	__XX_X__	0x34
N#define	__XX_X_X	0x35
N#define	__XX_XX_	0x36
N#define	__XX_XXX	0x37
N#define	__XXX___	0x38
N#define	__XXX__X	0x39
N#define	__XXX_X_	0x3a
N#define	__XXX_XX	0x3b
N#define	__XXXX__	0x3c
N#define	__XXXX_X	0x3d
N#define	__XXXXX_	0x3e
N#define	__XXXXXX	0x3f
N#define	_X______	0x40
N#define	_X_____X	0x41
N#define	_X____X_	0x42
N#define	_X____XX	0x43
N#define	_X___X__	0x44
N#define	_X___X_X	0x45
N#define	_X___XX_	0x46
N#define	_X___XXX	0x47
N#define	_X__X___	0x48
N#define	_X__X__X	0x49
N#define	_X__X_X_	0x4a
N#define	_X__X_XX	0x4b
N#define	_X__XX__	0x4c
N#define	_X__XX_X	0x4d
N#define	_X__XXX_	0x4e
N#define	_X__XXXX	0x4f
N#define	_X_X____	0x50
N#define	_X_X___X	0x51
N#define	_X_X__X_	0x52
N#define	_X_X__XX	0x53
N#define	_X_X_X__	0x54
N#define	_X_X_X_X	0x55
N#define	_X_X_XX_	0x56
N#define	_X_X_XXX	0x57
N#define	_X_XX___	0x58
N#define	_X_XX__X	0x59
N#define	_X_XX_X_	0x5a
N#define	_X_XX_XX	0x5b
N#define	_X_XXX__	0x5c
N#define	_X_XXX_X	0x5d
N#define	_X_XXXX_	0x5e
N#define	_X_XXXXX	0x5f
N#define	_XX_____	0x60
N#define	_XX____X	0x61
N#define	_XX___X_	0x62
N#define	_XX___XX	0x63
N#define	_XX__X__	0x64
N#define	_XX__X_X	0x65
N#define	_XX__XX_	0x66
N#define	_XX__XXX	0x67
N#define	_XX_X___	0x68
N#define	_XX_X__X	0x69
N#define	_XX_X_X_	0x6a
N#define	_XX_X_XX	0x6b
N#define	_XX_XX__	0x6c
N#define	_XX_XX_X	0x6d
N#define	_XX_XXX_	0x6e
N#define	_XX_XXXX	0x6f
N#define	_XXX____	0x70
N#define	_XXX___X	0x71
N#define	_XXX__X_	0x72
N#define	_XXX__XX	0x73
N#define	_XXX_X__	0x74
N#define	_XXX_X_X	0x75
N#define	_XXX_XX_	0x76
N#define	_XXX_XXX	0x77
N#define	_XXXX___	0x78
N#define	_XXXX__X	0x79
N#define	_XXXX_X_	0x7a
N#define	_XXXX_XX	0x7b
N#define	_XXXXX__	0x7c
N#define	_XXXXX_X	0x7d
N#define	_XXXXXX_	0x7e
N#define	_XXXXXXX	0x7f
N#define	X_______	0x80
N#define	X______X	0x81
N#define	X_____X_	0x82
N#define	X_____XX	0x83
N#define	X____X__	0x84
N#define	X____X_X	0x85
N#define	X____XX_	0x86
N#define	X____XXX	0x87
N#define	X___X___	0x88
N#define	X___X__X	0x89
N#define	X___X_X_	0x8a
N#define	X___X_XX	0x8b
N#define	X___XX__	0x8c
N#define	X___XX_X	0x8d
N#define	X___XXX_	0x8e
N#define	X___XXXX	0x8f
N#define	X__X____	0x90
N#define	X__X___X	0x91
N#define	X__X__X_	0x92
N#define	X__X__XX	0x93
N#define	X__X_X__	0x94
N#define	X__X_X_X	0x95
N#define	X__X_XX_	0x96
N#define	X__X_XXX	0x97
N#define	X__XX___	0x98
N#define	X__XX__X	0x99
N#define	X__XX_X_	0x9a
N#define X__XX_XX	0x9b
N#define X__XXX__	0x9c
N#define X__XXX_X	0x9d
N#define	X__XXXX_	0x9e
N#define	X__XXXXX	0x9f
N#define	X_X_____	0xa0
N#define	X_X____X	0xa1
N#define	X_X___X_	0xa2
N#define	X_X___XX	0xa3
N#define	X_X__X__	0xa4
N#define	X_X__X_X	0xa5
N#define	X_X__XX_	0xa6
N#define	X_X__XXX	0xa7
N#define	X_X_X___	0xa8
N#define	X_X_X__X	0xa9
N#define	X_X_X_X_	0xaa
N#define	X_X_X_XX	0xab
N#define	X_X_XX__	0xac
N#define	X_X_XX_X	0xad
N#define	X_X_XXX_	0xae
N#define	X_X_XXXX	0xaf
N#define	X_XX____	0xb0
N#define X_XX___X	0xb1
N#define	X_XX__X_	0xb2
N#define	X_XX__XX	0xb3
N#define	X_XX_X__	0xb4
N#define	X_XX_X_X	0xb5
N#define	X_XX_XX_	0xb6
N#define	X_XX_XXX	0xb7
N#define	X_XXX___	0xb8
N#define	X_XXX__X	0xb9
N#define	X_XXX_X_	0xba
N#define	X_XXX_XX	0xbb
N#define	X_XXXX__	0xbc
N#define	X_XXXX_X	0xbd
N#define	X_XXXXX_	0xbe
N#define	X_XXXXXX	0xbf
N#define	XX______	0xc0
N#define	XX_____X	0xc1
N#define	XX____X_	0xc2
N#define	XX____XX	0xc3
N#define	XX___X__	0xc4
N#define	XX___X_X	0xc5
N#define	XX___XX_	0xc6
N#define	XX___XXX	0xc7
N#define	XX__X___	0xc8
N#define	XX__X__X	0xc9
N#define	XX__X_X_	0xca
N#define	XX__X_XX	0xcb
N#define	XX__XX__	0xcc
N#define	XX__XX_X	0xcd
N#define	XX__XXX_	0xce
N#define XX__XXXX	0xcf
N#define	XX_X____	0xd0
N#define	XX_X___X	0xd1
N#define	XX_X__X_	0xd2
N#define	XX_X__XX	0xd3
N#define	XX_X_X__	0xd4
N#define	XX_X_X_X	0xd5
N#define	XX_X_XX_	0xd6
N#define	XX_X_XXX	0xd7
N#define	XX_XX___	0xd8
N#define	XX_XX__X	0xd9
N#define	XX_XX_X_	0xda
N#define	XX_XX_XX	0xdb
N#define	XX_XXX__	0xdc
N#define	XX_XXX_X	0xdd
N#define	XX_XXXX_	0xde
N#define	XX_XXXXX	0xdf
N#define	XXX_____	0xe0
N#define	XXX____X	0xe1
N#define	XXX___X_	0xe2
N#define	XXX___XX	0xe3
N#define	XXX__X__	0xe4
N#define	XXX__X_X	0xe5
N#define	XXX__XX_	0xe6
N#define	XXX__XXX	0xe7
N#define	XXX_X___	0xe8
N#define	XXX_X__X	0xe9
N#define	XXX_X_X_	0xea
N#define	XXX_X_XX	0xeb
N#define	XXX_XX__	0xec
N#define	XXX_XX_X	0xed
N#define	XXX_XXX_	0xee
N#define	XXX_XXXX	0xef
N#define	XXXX____	0xf0
N#define	XXXX___X	0xf1
N#define	XXXX__X_	0xf2
N#define	XXXX__XX	0xf3
N#define	XXXX_X__	0xf4
N#define	XXXX_X_X	0xf5
N#define	XXXX_XX_	0xf6
N#define	XXXX_XXX	0xf7
N#define	XXXXX___	0xf8
N#define	XXXXX__X	0xf9
N#define	XXXXX_X_	0xfa
N#define	XXXXX_XX	0xfb
N#define	XXXXXX__	0xfc
N#define	XXXXXX_X	0xfd
N#define	XXXXXXX_	0xfe
N#define	XXXXXXXX	0xff
N
N/*********************************************************************
N*
N*       Compatibility with older versions
N*/
N#define GUI_DispString_UC      GUI_UC_DispString
N#define TOUCH_X_ActivateX      GUI_TOUCH_X_ActivateX
N#define TOUCH_X_ActivateY      GUI_TOUCH_X_ActivateY
N#define TOUCH_X_Disable        GUI_TOUCH_X_Disable
N#define TOUCH_X_MeasureX       GUI_TOUCH_X_MeasureX
N#define TOUCH_X_MeasureY       GUI_TOUCH_X_MeasureY
N#define GUI_SelLayer           GUI_SelectLayer
N#define GUI_MEMDEV_FadeDevices GUI_MEMDEV_FadeInDevices
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif   /* ifdef GUI_H */
N
N/*************************** End of file ****************************/
L 52 "..\..\..\ThirdParty\emWin\Include\WM.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/* Static memory devices */
N#ifndef   WM_SUPPORT_STATIC_MEMDEV
N  #define WM_SUPPORT_STATIC_MEMDEV GUI_SUPPORT_MEMDEV
N#endif
N
N/* Support for transparency. Switching it off makes Wm smaller and faster */
N#ifndef   WM_SUPPORT_TRANSPARENCY
N  #define WM_SUPPORT_TRANSPARENCY 1 /* Should be defined outside of GUI_WINSUPPORT because of '#if GUI_WINSUPPORT && WM_SUPPORT_TRANSPARENCY' in some files */
N#endif
N
N/* This is for tests only. It will fill the invalid area of a window.
N   Can be used for debugging. */
N#ifndef WM_SUPPORT_DIAG
N  #ifdef WIN32   /* In simulation */
S    #define WM_SUPPORT_DIAG GUI_WINSUPPORT
N  #else
N    #define WM_SUPPORT_DIAG 0
N  #endif
N#endif
N
N/* Make sure we actually have configured windows. If we have not,
N  there is no point for a windows manager and it will therefor not
N  generate any code !
N*/
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Config defaults
N*/
N#ifndef   WM_ASSERT
N  #define WM_ASSERT(expr) GUI_DEBUG_ASSERT(expr)
N#endif
N
N#ifndef   WM_SUPPORT_TOUCH
N  #define WM_SUPPORT_TOUCH        GUI_SUPPORT_TOUCH
N#endif
N
N/* Allow older API calls */
N#ifndef   WM_COMPATIBLE_MODE
N  #define WM_COMPATIBLE_MODE 1
N#endif
N
N/* Send a message if visibility of a window has changed */
N#ifndef   WM_SUPPORT_NOTIFY_VIS_CHANGED
N  #define WM_SUPPORT_NOTIFY_VIS_CHANGED 0
N#endif
N
N#ifndef   WM_SUPPORT_CPP
N  #if defined (_MSC_VER)
X  #if 0L
S    #define WM_SUPPORT_CPP 1
N  #else
N    #define WM_SUPPORT_CPP 0
N  #endif
N#endif
N
N/*********************************************************************
N*
N*       Locking macros
N*/
N#define WM_LOCK()   GUI_LOCK()
N#define WM_UNLOCK() GUI_UNLOCK()
N
N#define WM_LOCK_H(hWin) (WM_Obj *)GUI_LOCK_H(hWin)
N
N/*********************************************************************
N*
N*       Data types
N*/
Ntypedef struct WM_WINDOW_INFO WM_WINDOW_INFO;
N
Nstruct WM_WINDOW_INFO {
N  GUI_HMEM hWin;
X  signed long hWin;
N  GUI_HMEM hParent;
X  signed long hParent;
N  GUI_HMEM hFirstChild;
X  signed long hFirstChild;
N  GUI_HMEM hNext;
X  signed long hNext;
N  GUI_RECT Rect;
N  U32      Status;
X  unsigned long      Status;
N  U32      DebugId;
X  unsigned long      DebugId;
N  WM_WINDOW_INFO * pNext;
N};
N
Ntypedef struct {
N  int Key, PressedCnt;
N} WM_KEY_INFO;
N
Ntypedef struct {
N  int NumItems, v, PageSize;
N} WM_SCROLL_STATE;
N
Ntypedef struct {
N  int Done;
N  int ReturnValue;
N} WM_DIALOG_STATUS;
N
Ntypedef struct {
N  int x,y;
N  U8  State;
X  unsigned char  State;
N  U8  StatePrev;
X  unsigned char  StatePrev;
N} WM_PID_STATE_CHANGED_INFO;
N
Ntypedef struct {
N  U8  Cmd;
X  unsigned char  Cmd;
N  U8  FinalMove;
X  unsigned char  FinalMove;
N  U8  StopMotion;
X  unsigned char  StopMotion;
N  U8  IsDragging;
X  unsigned char  IsDragging;
N  int dx, dy, da;
N  int xPos, yPos;
N  int Period;
N  int SnapX;
N  int SnapY;
N  U8  IsOutside;
X  unsigned char  IsOutside;
N  unsigned Overlap;
N  U32 Flags;
X  unsigned long Flags;
N  GUI_PID_STATE * pState;
N  GUI_HMEM hContext;
X  signed long hContext;
N} WM_MOTION_INFO;
N
Ntypedef struct {
N  I32       FactorMin;   // Minimum factor to be used (<< 16)
X  signed long       FactorMin;   
N  I32       FactorMax;   // Maximum factor to be used (<< 16)
X  signed long       FactorMax;   
N  U32       xSize;       // Native xSize of window to be zoomed in pixels
X  unsigned long       xSize;       
N  U32       ySize;       // Native ySize of window to be zoomed in pixels
X  unsigned long       ySize;       
N  U32       xSizeParent; // xSize of parent window
X  unsigned long       xSizeParent; 
N  U32       ySizeParent; // ySize of parent window
X  unsigned long       ySizeParent; 
N  I32       Factor0;     // Primary factor when starting zoom gesture (<< 16)
X  signed long       Factor0;     
N  int       xPos0;       // Primary window position in x when starting the gesture
N  int       yPos0;       // Primary window position in y when starting the gesture
N  GUI_POINT Center0;     // Primary center point when starting the gesture
N} WM_ZOOM_INFO;
N
Ntypedef struct {
N  int            Flags;     // Information regarding gesture type
N  GUI_POINT      Point;     // Relative movement
N  GUI_POINT      Center;    // Center point for zooming
N  I32            Angle;     // Angle between the touch points
X  signed long            Angle;     
N  I32            Factor;    // Current zoom factor
X  signed long            Factor;    
N  WM_ZOOM_INFO * pZoomInfo; // Pointer to WM_ZOOM_INFO structure
N} WM_GESTURE_INFO;
N
Ntypedef struct {
N  int dx, dy;
N} WM_MOVE_INFO;
N
N/*********************************************************************
N*
N*       Gesture flags for multi touch support
N*/
N#define WM_GF_BEGIN  (1 << 0)
N#define WM_GF_END    (1 << 1)
N#define WM_GF_PAN    (1 << 2)
N#define WM_GF_ZOOM   (1 << 3)
N#define WM_GF_ROTATE (1 << 4)
N#define WM_GF_DTAP   (1 << 5)
N
N/*********************************************************************
N*
N*       Messages Ids
N*
N* The following is the list of windows messages.
N*/
N#define WM_CREATE                   0x0001  /* The first message received, right after client has actually been created */
N#define WM_MOVE                     0x0003  /* window has been moved (Same as WIN32) */
N
N#define WM_SIZE                     0x0005  /* Is sent to a window after its size has changed (Same as WIN32, do not change !) */
N
N#define WM_DELETE                   11      /* Delete (Destroy) command: This tells the client to free its data strutures since the window
N                                               it is associates with no longer exists.*/
N#define WM_TOUCH                    0x0240  /* Touch screen message */
N#define WM_TOUCH_CHILD              13      /* Touch screen message to ancestors */
N#define WM_KEY                      14      /* Key has been pressed */
N
N#define WM_PAINT                    0x000F  /* Repaint window (because content is (partially) invalid */
N
N#if GUI_SUPPORT_MOUSE
X#if 1
N#define WM_MOUSEOVER                16      /* Mouse has moved, no key pressed */
N#define WM_MOUSEOVER_END            18      /* Mouse has moved, no key pressed */
N#endif
N
N#define WM_PID_STATE_CHANGED        17      /* Pointer input device state has changed */
N
N#define WM_GET_INSIDE_RECT          20      /* get inside rectangle: client rectangle minus pixels lost to effect */
N#define WM_GET_ID                   21      /* Get id of widget */
N#define WM_SET_ID                   22      /* Set id of widget */
N#define WM_GET_CLIENT_WINDOW        23      /* Get window handle of client window. Default is the same as window */
N#define WM_CAPTURE_RELEASED         24      /* Let window know that mouse capture is over */
N
N#define WM_INIT_DIALOG              29      /* Inform dialog that it is ready for init */
N
N#define WM_SET_FOCUS                30      /* Inform window that it has gotten or lost the focus */
N#define WM_GET_ACCEPT_FOCUS         31      /* Find out if window can accept the focus */
N#define WM_NOTIFY_CHILD_HAS_FOCUS   32      /* Sent to parent when child receives / loses focus */
N
N#define WM_NOTIFY_OWNER_KEY         33      /* Some widgets (e.g. listbox) notify owner when receiving key messages */
N
N#define WM_GET_BKCOLOR              34      /* Return back ground color (only frame window and similar) */
N#define WM_GET_SCROLL_STATE         35      /* Query state of scroll bar */
N
N#define WM_SET_SCROLL_STATE         36      /* Set scroll info ... only effective for scrollbars */
N
N#define WM_NOTIFY_CLIENTCHANGE      37      /* Client area may have changed */
N#define WM_NOTIFY_PARENT            38      /* Notify parent. Information is detailed as notification code */
N#define WM_NOTIFY_PARENT_REFLECTION 39      /* Notify parent reflection.
N                                               Sometimes send back as a result of the WM_NOTIFY_PARENT message
N                                               to let child react on behalf of its parent.
N                                               Information is detailed as notification code */
N#define WM_NOTIFY_ENABLE            40      /* Enable or disable widget */
N#define WM_NOTIFY_VIS_CHANGED       41      /* Visibility of a window has or may have changed */
N
N#define WM_HANDLE_DIALOG_STATUS     42      /* Set or get dialog status */
N#define WM_GET_RADIOGROUP           43      /* Send to all siblings and children of a radio control when
N                                               selection changed */
N#define WM_MENU                     44      /* Send to owner window of menu widget */
N#define WM_SCREENSIZE_CHANGED       45      /* Send to all windows when size of screen has changed */
N#define WM_PRE_PAINT                46      /* Send to a window before it receives a WM_PAINT message */
N#define WM_POST_PAINT               47      /* Send to a window after (the last) WM_PAINT message */
N
N#define WM_MOTION                   48      /* Automatic motion messages */
N
N#define WM_GET_WINDOW_ID            49      /* Return widget type specific Id (DebugId) */
N
N#define WM_PRE_BANDING              50      /* Send before starting banding process */
N#define WM_POST_BANDING             51      /* Send after finishing banding process */
N
N#define WM_USER_DATA                52      /* Send immediately after setting user data */
N#define WM_SET_CALLBACK             53      /* Send immediately after setting user data */
N
N#define WM_GESTURE                  0x0119  /* Gesture message */
N
N#define WM_TIMER                    0x0113  /* Timer has expired              (Keep the same as WIN32) */
N#define WM_WIDGET                   0x0300  /* 256 messages reserved for Widget messages */
N#define WM_USER                     0x0400  /* Reserved for user messages ... (Keep the same as WIN32) */
N
N/*********************************************************************
N*
N*       Motion messages
N*/
N#define WM_MOTION_INIT    0
N#define WM_MOTION_MOVE    1
N#define WM_MOTION_GETPOS  2
N#define WM_MOTION_GETCONTEXT 3
N
N/*********************************************************************
N*
N*       Motion flags
N*/
N#define WM_MOTION_MANAGE_BY_WINDOW   (1 << 0) // Window movement is managed by window itself
N
N/*********************************************************************
N*
N*       Notification codes
N*
N* The following is the list of notification codes send
N* with the WM_NOTIFY_PARENT message
N*/
N#define WM_NOTIFICATION_CLICKED             1
N#define WM_NOTIFICATION_RELEASED            2
N#define WM_NOTIFICATION_MOVED_OUT           3
N#define WM_NOTIFICATION_SEL_CHANGED         4
N#define WM_NOTIFICATION_VALUE_CHANGED       5
N#define WM_NOTIFICATION_SCROLLBAR_ADDED     6      /* Scroller added */
N#define WM_NOTIFICATION_CHILD_DELETED       7      /* Inform window that child is about to be deleted */
N#define WM_NOTIFICATION_GOT_FOCUS           8
N#define WM_NOTIFICATION_LOST_FOCUS          9
N#define WM_NOTIFICATION_SCROLL_CHANGED     10
N
N#define WM_NOTIFICATION_WIDGET             11      /* Space for widget defined notifications */
N#define WM_NOTIFICATION_USER               16      /* Space for  application (user) defined notifications */
N
N/*********************************************************************
N*
N*       Memory management
N*/
N#define WM_HWIN        GUI_HWIN
N#define WM_HWIN_NULL   GUI_HMEM_NULL
N#define WM_HMEM        GUI_HMEM
N#define WM_HMEM_NULL   GUI_HMEM_NULL
N#define WM_HTIMER      GUI_HMEM
N
N/*********************************************************************
N*
N*       Window defines
N*/
N#define WM_HBKWIN      WM_GetDesktopWindow()                /* Handle of background window */
N#define WM_UNATTACHED  ((WM_HMEM) - 1)                      /* Do not attach to a window */
N
N/*********************************************************************
N*
N*       Window create flags.
N*
N* These flags can be passed to the create window
N* function as flag-parameter. The flags are combinable using the
N* binary or operator.
N*/
N#define WM_CF_HASTRANS         (1UL << 0)  /* Has transparency. Needs to be defined for windows which do not fill the entire
N                                          section of their (client) rectangle. */
N#define WM_CF_HIDE             (0UL << 1)  /* Hide window after creation (default !) */
N#define WM_CF_SHOW             (1UL << 1)  /* Show window after creation */
N#define WM_CF_MEMDEV           (1UL << 2)  /* Use memory device for redraws */
N#define WM_CF_STAYONTOP        (1UL << 3)  /* Stay on top */
N#define WM_CF_DISABLED         (1UL << 4)  /* Disabled: Does not receive PID (mouse & touch) input */
N
N/* Create only flags ... Not available as status flags */
N#define WM_CF_ACTIVATE         (1UL << 5)  /* If automatic activation upon creation of window is desired */
N#define WM_CF_FGND             (0UL << 6)  /* Put window in foreground after creation (default !) */
N#define WM_CF_BGND             (1UL << 6)  /* Put window in background after creation */
N
N/* Anchor flags */
N#define WM_CF_ANCHOR_RIGHT     (1UL << 7)  /* Right anchor ...  If parent is resized, distance to right  will remain const (left is default) */
N#define WM_CF_ANCHOR_BOTTOM    (1UL << 8)  /* Bottom anchor ... If parent is resized, distance to bottom will remain const (top  is default) */
N#define WM_CF_ANCHOR_LEFT      (1UL << 9)  /* Left anchor ...   If parent is resized, distance to left   will remain const (left is default) */
N#define WM_CF_ANCHOR_TOP       (1UL << 10) /* Top anchor ...    If parent is resized, distance to top    will remain const (top  is default) */
N
N#define WM_CF_CONST_OUTLINE    (1UL << 11) /* Constant outline. This is relevant for transparent windows only. If a window is transparent
N                                              and does not have a constant outline, its background is invalided instead of the window itself.
N                                              This causes add. computation time when redrawing. */
N#define WM_CF_LATE_CLIP        (1UL << 12)
N#define WM_CF_MEMDEV_ON_REDRAW (1UL << 13)
N
N#define WM_SF_INVALID_DRAW     (1UL << 14)
N#define WM_SF_DELETE           (1UL << 15) /* Marks the window to be deleted within WM_Exec() when no callback routine is executed */
N
N#define WM_CF_STATIC           (1UL << 16) /* Use static memory device for redraws */
N
N#define WM_CF_MOTION_X         (1UL << 17) /* Window can be moved automatically in X axis */
N#define WM_CF_MOTION_Y         (1UL << 18) /* Window can be moved automatically in Y axis */
N
N#define WM_CF_GESTURE          (1UL << 19) /* Marks the window to be a able to receive gesture messages */
N
N#define WM_CF_ZOOM             (1UL << 20) /* Window can be scaled automatically by multi touch gesture input */
N
N#define WM_CF_MOTION_R         (1UL << 21) // Window can be rotated
N
N/*********************************************************************
N*
N*       Window manager types
N*/
Ntypedef struct WM_Obj     WM_Obj;
Ntypedef struct WM_MESSAGE WM_MESSAGE;
N
Ntypedef void WM_CALLBACK( WM_MESSAGE * pMsg);
N
Nstruct WM_MESSAGE {
N  int MsgId;            /* type of message */
N  WM_HWIN hWin;         /* Destination window */
X  GUI_HWIN hWin;          
N  WM_HWIN hWinSrc;      /* Source window  */
X  GUI_HWIN hWinSrc;       
N  union {
N    const void * p;     /* Message specific data pointer */
N    int v;
N    PTR_ADDR u;
X    unsigned long u;
N    GUI_COLOR Color;
N    void (* pFunc)(void);
N  } Data;
N};
N
Nstruct WM_Obj {
N  GUI_RECT Rect;        /* Outer dimensions of window */
N  GUI_RECT InvalidRect; /* Invalid rectangle */
N  WM_CALLBACK* cb;      /* Ptr to notification callback */
N  WM_HWIN hNextLin;     /* Next window in linear list */
X  GUI_HWIN hNextLin;      
N  WM_HWIN hParent;
X  GUI_HWIN hParent;
N  WM_HWIN hFirstChild;
X  GUI_HWIN hFirstChild;
N  WM_HWIN hNext;
X  GUI_HWIN hNext;
N  #if WM_SUPPORT_STATIC_MEMDEV
X  #if 1
N    GUI_MEMDEV_Handle hMem; /* Static memory device */
N  #endif
N  U32 Status;           /* Status flags */
X  unsigned long Status;            
N  #if WM_SUPPORT_CPP
X  #if 0
S    void * ObjPtr;
N  #endif
N};
N
Ntypedef void WM_tfPollPID(void);
Ntypedef void WM_tfForEach(WM_HWIN hWin, void * pData);
Xtypedef void WM_tfForEach(GUI_HWIN hWin, void * pData);
N
Ntypedef void (* WM_tfInvalidateParent)  (const GUI_RECT * pInvalidRect, WM_HWIN hParent, WM_HWIN hStop);
Xtypedef void (* WM_tfInvalidateParent)  (const GUI_RECT * pInvalidRect, GUI_HWIN hParent, GUI_HWIN hStop);
Ntypedef void (* WM_tfInvalidateDrawFunc)(WM_HWIN hWin);
Xtypedef void (* WM_tfInvalidateDrawFunc)(GUI_HWIN hWin);
Ntypedef void (* WM_tfPaint1Func)        (WM_HWIN hWin);
Xtypedef void (* WM_tfPaint1Func)        (GUI_HWIN hWin);
N
Ntypedef struct {
N  WM_HMEM  hTimer;
X  signed long  hTimer;
N  WM_HWIN  hWin;
X  GUI_HWIN  hWin;
N  int      UserId;
N} WM_TIMER_OBJ;
N
N/*********************************************************************
N*
N*       General control routines
N*/
Nvoid WM_Activate  (void);
Nvoid WM_Deactivate(void);
Nvoid WM_Init      (void);
Nint  WM_Exec      (void);    /* Execute all jobs ... Return 0 if nothing was done. */
Nint  WM_Exec1     (void);    // Execute only one job
NU32  WM_SetCreateFlags(U32 Flags);
Xunsigned long  WM_SetCreateFlags(unsigned long Flags);
NWM_tfPollPID * WM_SetpfPollPID(WM_tfPollPID * pf);
N
N/*********************************************************************
N*
N*       Window manager interface
N*/
Nvoid    WM_AttachWindow              (WM_HWIN hWin, WM_HWIN hParent);
Xvoid    WM_AttachWindow              (GUI_HWIN hWin, GUI_HWIN hParent);
Nvoid    WM_AttachWindowAt            (WM_HWIN hWin, WM_HWIN hParent, int x, int y);
Xvoid    WM_AttachWindowAt            (GUI_HWIN hWin, GUI_HWIN hParent, int x, int y);
Nint     WM_CheckScrollPos            (WM_SCROLL_STATE * pScrollState, int Pos, int LowerDist, int UpperDist); /* not to be documented (may change in future version) */
Nvoid    WM_ClrHasTrans               (WM_HWIN hWin);
Xvoid    WM_ClrHasTrans               (GUI_HWIN hWin);
NWM_HWIN WM_CreateWindow              (int x0, int y0, int xSize, int ySize, U32 Style, WM_CALLBACK * cb, int NumExtraBytes);
XGUI_HWIN WM_CreateWindow              (int x0, int y0, int xSize, int ySize, unsigned long Style, WM_CALLBACK * cb, int NumExtraBytes);
NWM_HWIN WM_CreateWindowAsChild       (int x0, int y0, int xSize, int ySize, WM_HWIN hWinParent, U32 Style, WM_CALLBACK* cb, int NumExtraBytes);
XGUI_HWIN WM_CreateWindowAsChild       (int x0, int y0, int xSize, int ySize, GUI_HWIN hWinParent, unsigned long Style, WM_CALLBACK* cb, int NumExtraBytes);
Nvoid    WM_DeleteWindow              (WM_HWIN hWin);
Xvoid    WM_DeleteWindow              (GUI_HWIN hWin);
Nvoid    WM_DetachWindow              (WM_HWIN hWin);
Xvoid    WM_DetachWindow              (GUI_HWIN hWin);
Nvoid    WM_EnableGestures            (WM_HWIN hWin, int OnOff);
Xvoid    WM_EnableGestures            (GUI_HWIN hWin, int OnOff);
Nint     WM_GetHasTrans               (WM_HWIN hWin);
Xint     WM_GetHasTrans               (GUI_HWIN hWin);
NWM_HWIN WM_GetFocusedWindow          (void);
XGUI_HWIN WM_GetFocusedWindow          (void);
Nint     WM_GetInvalidRect            (WM_HWIN hWin, GUI_RECT * pRect);
Xint     WM_GetInvalidRect            (GUI_HWIN hWin, GUI_RECT * pRect);
Nint     WM_GetStayOnTop              (WM_HWIN hWin);
Xint     WM_GetStayOnTop              (GUI_HWIN hWin);
Nvoid    WM_HideWindow                (WM_HWIN hWin);
Xvoid    WM_HideWindow                (GUI_HWIN hWin);
Nvoid    WM_InvalidateArea            (const GUI_RECT * pRect);
Nvoid    WM_InvalidateRect            (WM_HWIN hWin, const GUI_RECT * pRect);
Xvoid    WM_InvalidateRect            (GUI_HWIN hWin, const GUI_RECT * pRect);
Nvoid    WM_InvalidateWindow          (WM_HWIN hWin);
Xvoid    WM_InvalidateWindow          (GUI_HWIN hWin);
Nvoid    WM_InvalidateWindowAndDescsEx(WM_HWIN hWin, const GUI_RECT * pInvalidRect, U16 Flags);
Xvoid    WM_InvalidateWindowAndDescsEx(GUI_HWIN hWin, const GUI_RECT * pInvalidRect, unsigned short Flags);
Nvoid    WM_InvalidateWindowAndDescs  (WM_HWIN hWin);    /* not to be documented (may change in future version) */
Xvoid    WM_InvalidateWindowAndDescs  (GUI_HWIN hWin);     
Nint     WM_IsEnabled                 (WM_HWIN hObj);
Xint     WM_IsEnabled                 (GUI_HWIN hObj);
Nchar    WM_IsCompletelyCovered       (WM_HWIN hWin);    /* Checks if the window is completely covered by other windows */
Xchar    WM_IsCompletelyCovered       (GUI_HWIN hWin);     
Nchar    WM_IsCompletelyVisible       (WM_HWIN hWin);    /* Is the window completely visible ? */
Xchar    WM_IsCompletelyVisible       (GUI_HWIN hWin);     
Nint     WM_IsFocusable               (WM_HWIN hWin);
Xint     WM_IsFocusable               (GUI_HWIN hWin);
Nint     WM_IsVisible                 (WM_HWIN hWin);
Xint     WM_IsVisible                 (GUI_HWIN hWin);
Nint     WM_IsWindow                  (WM_HWIN hWin);    /* Check validity */
Xint     WM_IsWindow                  (GUI_HWIN hWin);     
Nvoid    WM_Rect2Screen               (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid    WM_Rect2Screen               (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid    WM_Rect2Client               (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid    WM_Rect2Client               (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid    WM_SetAnchor                 (WM_HWIN hWin, U16 AnchorFlags);
Xvoid    WM_SetAnchor                 (GUI_HWIN hWin, unsigned short AnchorFlags);
Nvoid    WM_SetHasTrans               (WM_HWIN hWin);
Xvoid    WM_SetHasTrans               (GUI_HWIN hWin);
Nvoid    WM_SetId                     (WM_HWIN hObj, int Id);
Xvoid    WM_SetId                     (GUI_HWIN hObj, int Id);
Nvoid    WM_SetStayOnTop              (WM_HWIN hWin, int OnOff);
Xvoid    WM_SetStayOnTop              (GUI_HWIN hWin, int OnOff);
Nvoid    WM_SetTransState             (WM_HWIN hWin, unsigned State);
Xvoid    WM_SetTransState             (GUI_HWIN hWin, unsigned State);
Nvoid    WM_ShowWindow                (WM_HWIN hWin);
Xvoid    WM_ShowWindow                (GUI_HWIN hWin);
Nvoid    WM_ValidateRect              (WM_HWIN hWin, const GUI_RECT * pRect);
Xvoid    WM_ValidateRect              (GUI_HWIN hWin, const GUI_RECT * pRect);
Nvoid    WM_ValidateWindow            (WM_HWIN hWin);
Xvoid    WM_ValidateWindow            (GUI_HWIN hWin);
Nvoid    WM_XY2Screen                 (WM_HWIN hWin, int * px, int * py);
Xvoid    WM_XY2Screen                 (GUI_HWIN hWin, int * px, int * py);
Nvoid    WM_XY2Client                 (WM_HWIN hWin, int * px, int * py);
Xvoid    WM_XY2Client                 (GUI_HWIN hWin, int * px, int * py);
N
N#define WM_GetFocussedWindow WM_GetFocusedWindow
N#define WM_IsFocussable      WM_IsFocusable
N
N/* Gesture support */
Nvoid WM_GESTURE_Enable  (int OnOff);
Nint  WM_GESTURE_EnableEx(int OnOff, int MaxFactor);
Nvoid WM_GESTURE_Exec    (void);
NI32  WM_GESTURE_SetThresholdAngle(I32 ThresholdAngle);
Xsigned long  WM_GESTURE_SetThresholdAngle(signed long ThresholdAngle);
NI32  WM_GESTURE_SetThresholdDist (I32 ThresholdDist);
Xsigned long  WM_GESTURE_SetThresholdDist (signed long ThresholdDist);
N
N/* Motion support */
Nvoid     WM_MOTION_Enable          (int OnOff);
Nvoid     WM_MOTION_SetMovement     (WM_HWIN hWin, int Axis, I32 Speed, I32 Dist);
Xvoid     WM_MOTION_SetMovement     (GUI_HWIN hWin, int Axis, signed long Speed, signed long Dist);
Nvoid     WM_MOTION_SetMotion       (WM_HWIN hWin, int Axis, I32 Speed, I32 Deceleration);
Xvoid     WM_MOTION_SetMotion       (GUI_HWIN hWin, int Axis, signed long Speed, signed long Deceleration);
Nvoid     WM_MOTION_SetMoveable     (WM_HWIN hWin, U32 Flags, int OnOff);
Xvoid     WM_MOTION_SetMoveable     (GUI_HWIN hWin, unsigned long Flags, int OnOff);
Nvoid     WM_MOTION_SetDeceleration (WM_HWIN hWin, int Axis, I32 Deceleration);
Xvoid     WM_MOTION_SetDeceleration (GUI_HWIN hWin, int Axis, signed long Deceleration);
Nunsigned WM_MOTION_SetDefaultPeriod(unsigned Period);
Nvoid     WM_MOTION_SetSpeed        (WM_HWIN hWin, int Axis, I32 Velocity);
Xvoid     WM_MOTION_SetSpeed        (GUI_HWIN hWin, int Axis, signed long Velocity);
Nvoid     WM_MOTION_SetMinMotion    (unsigned MinMotion);
Nvoid     WM_MOTION_SetThreshold    (unsigned Threshold);
N
N/* Motion support, private interface */
NWM_HMEM WM_MOTION__CreateContext(void);
Xsigned long WM_MOTION__CreateContext(void);
Nvoid    WM_MOTION__DeleteContext(WM_HMEM hContext);
Xvoid    WM_MOTION__DeleteContext(signed long hContext);
N
N/* Motion support, private function(s) */
Nvoid     WM__SetMotionCallback (void(* cbMotion) (GUI_PID_STATE * pState, void * p));
N
N/* Static memory devices */
N#if (GUI_SUPPORT_MEMDEV)
X#if (1)
N  #define GUI_MEMDEV_EDGE_LEFT   0
N  #define GUI_MEMDEV_EDGE_RIGHT  1
N  #define GUI_MEMDEV_EDGE_TOP    2
N  #define GUI_MEMDEV_EDGE_BOTTOM 3
N
N  int               GUI_MEMDEV_BlendWinBk       (WM_HWIN hWin, int Period, U32 BlendColor, U8 BlendIntens);
X  int               GUI_MEMDEV_BlendWinBk       (GUI_HWIN hWin, int Period, unsigned long BlendColor, unsigned char BlendIntens);
N  int               GUI_MEMDEV_BlurAndBlendWinBk(WM_HWIN hWin, int Period, U8 BlurDepth, U32 BlendColor, U8 BlendIntens);
X  int               GUI_MEMDEV_BlurAndBlendWinBk(GUI_HWIN hWin, int Period, unsigned char BlurDepth, unsigned long BlendColor, unsigned char BlendIntens);
N  int               GUI_MEMDEV_BlurWinBk        (WM_HWIN hWin, int Period, U8 BlurDepth);
X  int               GUI_MEMDEV_BlurWinBk        (GUI_HWIN hWin, int Period, unsigned char BlurDepth);
N  void              GUI_MEMDEV_CreateStatic     (WM_HWIN hWin);
X  void              GUI_MEMDEV_CreateStatic     (GUI_HWIN hWin);
N  GUI_MEMDEV_Handle GUI_MEMDEV_CreateWindowDevice(WM_HWIN hWin);
X  GUI_MEMDEV_Handle GUI_MEMDEV_CreateWindowDevice(GUI_HWIN hWin);
N  int               GUI_MEMDEV_FadeInWindow     (WM_HWIN hWin, int Period);
X  int               GUI_MEMDEV_FadeInWindow     (GUI_HWIN hWin, int Period);
N  int               GUI_MEMDEV_FadeOutWindow    (WM_HWIN hWin, int Period);
X  int               GUI_MEMDEV_FadeOutWindow    (GUI_HWIN hWin, int Period);
N  GUI_MEMDEV_Handle GUI_MEMDEV_GetStaticDevice  (WM_HWIN hWin);
X  GUI_MEMDEV_Handle GUI_MEMDEV_GetStaticDevice  (GUI_HWIN hWin);
N  GUI_MEMDEV_Handle GUI_MEMDEV_GetWindowDevice  (WM_HWIN hWin);
X  GUI_MEMDEV_Handle GUI_MEMDEV_GetWindowDevice  (GUI_HWIN hWin);
N  int               GUI_MEMDEV_MoveInWindow     (WM_HWIN hWin, int x, int y, int a180, int Period);
X  int               GUI_MEMDEV_MoveInWindow     (GUI_HWIN hWin, int x, int y, int a180, int Period);
N  int               GUI_MEMDEV_MoveOutWindow    (WM_HWIN hWin, int x, int y, int a180, int Period);
X  int               GUI_MEMDEV_MoveOutWindow    (GUI_HWIN hWin, int x, int y, int a180, int Period);
N  void              GUI_MEMDEV_Paint1Static     (WM_HWIN hWin);                                     /* not to be documented */
X  void              GUI_MEMDEV_Paint1Static     (GUI_HWIN hWin);                                      
N  int               GUI_MEMDEV_ShiftInWindow    (WM_HWIN hWin, int Period, int Direction);
X  int               GUI_MEMDEV_ShiftInWindow    (GUI_HWIN hWin, int Period, int Direction);
N  int               GUI_MEMDEV_ShiftOutWindow   (WM_HWIN hWin, int Period, int Direction);
X  int               GUI_MEMDEV_ShiftOutWindow   (GUI_HWIN hWin, int Period, int Direction);
N  int               GUI_MEMDEV_SwapWindow       (WM_HWIN hWin, int Period, int Edge);
X  int               GUI_MEMDEV_SwapWindow       (GUI_HWIN hWin, int Period, int Edge);
N
N  void              GUI_MEMDEV__CreateStatic    (WM_HWIN hWin);
X  void              GUI_MEMDEV__CreateStatic    (GUI_HWIN hWin);
N#endif
N
N/* Move/resize windows */
Nvoid WM_MoveWindow                (WM_HWIN hWin, int dx, int dy);
Xvoid WM_MoveWindow                (GUI_HWIN hWin, int dx, int dy);
Nvoid WM_ResizeWindow              (WM_HWIN hWin, int dx, int dy);
Xvoid WM_ResizeWindow              (GUI_HWIN hWin, int dx, int dy);
Nvoid WM_MoveTo                    (WM_HWIN hWin, int x, int y);
Xvoid WM_MoveTo                    (GUI_HWIN hWin, int x, int y);
Nvoid WM_MoveChildTo               (WM_HWIN hWin, int x, int y);
Xvoid WM_MoveChildTo               (GUI_HWIN hWin, int x, int y);
Nvoid WM_SetSize                   (WM_HWIN hWin, int XSize, int YSize);
Xvoid WM_SetSize                   (GUI_HWIN hWin, int XSize, int YSize);
Nvoid WM_SetWindowPos              (WM_HWIN hWin, int xPos, int yPos, int xSize, int ySize);
Xvoid WM_SetWindowPos              (GUI_HWIN hWin, int xPos, int yPos, int xSize, int ySize);
Nint  WM_SetXSize                  (WM_HWIN hWin, int xSize);
Xint  WM_SetXSize                  (GUI_HWIN hWin, int xSize);
Nint  WM_SetYSize                  (WM_HWIN hWin, int ySize);
Xint  WM_SetYSize                  (GUI_HWIN hWin, int ySize);
Nint  WM_SetScrollbarH             (WM_HWIN hWin, int OnOff); /* not to be documented (may change in future version) */
Xint  WM_SetScrollbarH             (GUI_HWIN hWin, int OnOff);  
Nint  WM_SetScrollbarV             (WM_HWIN hWin, int OnOff); /* not to be documented (may change in future version) */
Xint  WM_SetScrollbarV             (GUI_HWIN hWin, int OnOff);  
N
N/* ToolTip support */
N#define WM_TOOLTIP_PI_FIRST 0
N#define WM_TOOLTIP_PI_SHOW  1
N#define WM_TOOLTIP_PI_NEXT  2
N
N#define WM_TOOLTIP_CI_BK    0
N#define WM_TOOLTIP_CI_FRAME 1
N#define WM_TOOLTIP_CI_TEXT  2
N
Ntypedef WM_HMEM WM_TOOLTIP_HANDLE;
Xtypedef signed long WM_TOOLTIP_HANDLE;
N
Ntypedef struct {
N  int          Id;
N  const char * pText;
N} TOOLTIP_INFO;
N
Nint               WM_TOOLTIP_AddTool         (WM_TOOLTIP_HANDLE hToolTip, WM_HWIN hTool, const char * pText);
Xint               WM_TOOLTIP_AddTool         (WM_TOOLTIP_HANDLE hToolTip, GUI_HWIN hTool, const char * pText);
NWM_TOOLTIP_HANDLE WM_TOOLTIP_Create          (WM_HWIN hDlg, const TOOLTIP_INFO * pInfo, unsigned NumItems);
XWM_TOOLTIP_HANDLE WM_TOOLTIP_Create          (GUI_HWIN hDlg, const TOOLTIP_INFO * pInfo, unsigned NumItems);
Nvoid              WM_TOOLTIP_Delete          (WM_TOOLTIP_HANDLE hToolTip);
NGUI_COLOR         WM_TOOLTIP_SetDefaultColor (unsigned Index, GUI_COLOR Color);
Nconst GUI_FONT *  WM_TOOLTIP_SetDefaultFont  (const GUI_FONT * pFont);
Nunsigned          WM_TOOLTIP_SetDefaultPeriod(unsigned Index, unsigned Period);
N
N/* ToolTip support, private */
Nvoid WM__SetToolTipCallback(void(* cbToolTip)(GUI_PID_STATE * pState, WM_HWIN));
Xvoid WM__SetToolTipCallback(void(* cbToolTip)(GUI_PID_STATE * pState, GUI_HWIN));
N
N/* Timer */
N#ifdef GUI_X_CREATE_TIMER
S  int  WM_CreateTimer    (WM_HWIN hWin, int UserID, int Period, int Mode); /* not to be documented (may change in future version) */
S  void WM_DeleteTimer    (WM_HWIN hWin, int UserId); /* not to be documented (may change in future version) */
N#else
N  WM_HMEM WM_CreateTimer (WM_HWIN hWin, int UserID, int Period, int Mode); /* not to be documented (may change in future version) */
X  signed long WM_CreateTimer (GUI_HWIN hWin, int UserID, int Period, int Mode);  
N  void    WM_DeleteTimer (WM_HMEM hTimer); /* not to be documented (may change in future version) */
X  void    WM_DeleteTimer (signed long hTimer);  
N  void    WM_RestartTimer(WM_HMEM hTimer, int Period);
X  void    WM_RestartTimer(signed long hTimer, int Period);
N#endif
Nint WM_GetTimerId(WM_HTIMER hTimer);
Xint WM_GetTimerId(signed long hTimer);
N
N/* Diagnostics */
Nint WM_GetNumWindows(void);
Nint WM_GetNumInvalidWindows(void);
N
N/* Scroll state related functions */
Nvoid WM_CheckScrollBounds(WM_SCROLL_STATE * pScrollState); /* not to be documented (may change in future version) */
Nint  WM_GetScrollPosH    (WM_HWIN hWin);
Xint  WM_GetScrollPosH    (GUI_HWIN hWin);
Nint  WM_GetScrollPosV    (WM_HWIN hWin);
Xint  WM_GetScrollPosV    (GUI_HWIN hWin);
Nvoid WM_SetScrollPosH    (WM_HWIN hWin, unsigned ScrollPos);
Xvoid WM_SetScrollPosH    (GUI_HWIN hWin, unsigned ScrollPos);
Nvoid WM_SetScrollPosV    (WM_HWIN hWin, unsigned ScrollPos);
Xvoid WM_SetScrollPosV    (GUI_HWIN hWin, unsigned ScrollPos);
Nint  WM_SetScrollValue   (WM_SCROLL_STATE * pScrollState, int v); /* not to be documented (may change in future version) */
N
N/* Get / Set (new) callback function */
NWM_CALLBACK * WM_SetCallback(WM_HWIN hWin, WM_CALLBACK * cb);
XWM_CALLBACK * WM_SetCallback(GUI_HWIN hWin, WM_CALLBACK * cb);
NWM_CALLBACK * WM_GetCallback(WM_HWIN hWin);
XWM_CALLBACK * WM_GetCallback(GUI_HWIN hWin);
N
N/* Get size/origin of a window */
Nvoid      WM_GetClientRect           (GUI_RECT * pRect);
Nvoid      WM_GetClientRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid      WM_GetClientRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid      WM_GetInsideRect           (GUI_RECT * pRect);
Nvoid      WM_GetInsideRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid      WM_GetInsideRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid      WM_GetInsideRectExScrollbar(WM_HWIN hWin, GUI_RECT * pRect); /* not to be documented (may change in future version) */
Xvoid      WM_GetInsideRectExScrollbar(GUI_HWIN hWin, GUI_RECT * pRect);  
Nvoid      WM_GetWindowRect           (GUI_RECT * pRect);
Nvoid      WM_GetWindowRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid      WM_GetWindowRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
Nint       WM_GetOrgX                 (void);
Nint       WM_GetOrgY                 (void);
Nint       WM_GetWindowOrgX           (WM_HWIN hWin);
Xint       WM_GetWindowOrgX           (GUI_HWIN hWin);
Nint       WM_GetWindowOrgY           (WM_HWIN hWin);
Xint       WM_GetWindowOrgY           (GUI_HWIN hWin);
Nint       WM_GetWindowSizeX          (WM_HWIN hWin);
Xint       WM_GetWindowSizeX          (GUI_HWIN hWin);
Nint       WM_GetWindowSizeY          (WM_HWIN hWin);
Xint       WM_GetWindowSizeY          (GUI_HWIN hWin);
NWM_HWIN   WM_GetFirstChild           (WM_HWIN hWin);
XGUI_HWIN   WM_GetFirstChild           (GUI_HWIN hWin);
NWM_HWIN   WM_GetNextSibling          (WM_HWIN hWin);
XGUI_HWIN   WM_GetNextSibling          (GUI_HWIN hWin);
NWM_HWIN   WM_GetParent               (WM_HWIN hWin);
XGUI_HWIN   WM_GetParent               (GUI_HWIN hWin);
NWM_HWIN   WM_GetPrevSibling          (WM_HWIN hWin);
XGUI_HWIN   WM_GetPrevSibling          (GUI_HWIN hWin);
Nint       WM_GetId                   (WM_HWIN hWin);
Xint       WM_GetId                   (GUI_HWIN hWin);
NWM_HWIN   WM_GetScrollbarV           (WM_HWIN hWin);
XGUI_HWIN   WM_GetScrollbarV           (GUI_HWIN hWin);
NWM_HWIN   WM_GetScrollbarH           (WM_HWIN hWin);
XGUI_HWIN   WM_GetScrollbarH           (GUI_HWIN hWin);
NWM_HWIN   WM_GetScrollPartner        (WM_HWIN hWin);
XGUI_HWIN   WM_GetScrollPartner        (GUI_HWIN hWin);
NWM_HWIN   WM_GetClientWindow         (WM_HWIN hObj);
XGUI_HWIN   WM_GetClientWindow         (GUI_HWIN hObj);
NGUI_COLOR WM_GetBkColor              (WM_HWIN hObj);
XGUI_COLOR WM_GetBkColor              (GUI_HWIN hObj);
N
N/* Change Z-Order of windows */
Nvoid WM_BringToBottom(WM_HWIN hWin);
Xvoid WM_BringToBottom(GUI_HWIN hWin);
Nvoid WM_BringToTop(WM_HWIN hWin);
Xvoid WM_BringToTop(GUI_HWIN hWin);
N
NGUI_COLOR WM_SetDesktopColor  (GUI_COLOR Color);
NGUI_COLOR WM_SetDesktopColorEx(GUI_COLOR Color, unsigned int LayerIndex);
Nvoid      WM_SetDesktopColors (GUI_COLOR Color);
N
N/* Select window used for drawing operations */
NWM_HWIN WM_SelectWindow           (WM_HWIN  hWin);
XGUI_HWIN WM_SelectWindow           (GUI_HWIN  hWin);
NWM_HWIN WM_GetActiveWindow        (void);
XGUI_HWIN WM_GetActiveWindow        (void);
Nvoid    WM_Paint                  (WM_HWIN hObj);
Xvoid    WM_Paint                  (GUI_HWIN hObj);
Nvoid    WM_Update                 (WM_HWIN hWin);
Xvoid    WM_Update                 (GUI_HWIN hWin);
Nvoid    WM_PaintWindowAndDescs    (WM_HWIN hWin);
Xvoid    WM_PaintWindowAndDescs    (GUI_HWIN hWin);
Nvoid    WM_UpdateWindowAndDescs   (WM_HWIN hWin);
Xvoid    WM_UpdateWindowAndDescs   (GUI_HWIN hWin);
N
N/* Get foreground/background windows */
NWM_HWIN WM_GetDesktopWindow  (void);
XGUI_HWIN WM_GetDesktopWindow  (void);
NWM_HWIN WM_GetDesktopWindowEx(unsigned int LayerIndex);
XGUI_HWIN WM_GetDesktopWindowEx(unsigned int LayerIndex);
N
N/* Reduce clipping area of a window */
Nconst GUI_RECT * WM_SetUserClipRect(const GUI_RECT * pRect);
Nvoid             WM_SetDefault     (void);
N
N/* Use of memory devices */
Nvoid WM_EnableMemdev              (WM_HWIN hWin);
Xvoid WM_EnableMemdev              (GUI_HWIN hWin);
Nvoid WM_DisableMemdev             (WM_HWIN hWin);
Xvoid WM_DisableMemdev             (GUI_HWIN hWin);
N
N/* Automatic use of multiple buffers */
Nint WM_MULTIBUF_Enable  (int OnOff);
Nint WM_MULTIBUF_EnableEx(int OnOff, U32 LayerMask);
Xint WM_MULTIBUF_EnableEx(int OnOff, unsigned long LayerMask);
N
Nextern const GUI_MULTIBUF_API * WM_MULTIBUF__pAPI;
N
Ntypedef void (* T_WM_EXEC_GESTURE)(void);
N
Nextern T_WM_EXEC_GESTURE WM__pExecGestures;
N
N/* ... */
Nint WM_OnKey(int Key, int Pressed);
Nvoid WM_MakeModal(WM_HWIN hWin);
Xvoid WM_MakeModal(GUI_HWIN hWin);
Nint WM_SetModalLayer(int LayerIndex);
Nint WM_GetModalLayer(void);
N
N/*********************************************************************
N*
N*       Message related functions
N*
N*  Please note that some of these functions do not yet show up in the
N*  documentation, as they should not be required by application program.
N*/
Nvoid      WM_NotifyParent         (WM_HWIN hWin, int Notification);
Xvoid      WM_NotifyParent         (GUI_HWIN hWin, int Notification);
Nvoid      WM_SendMessage          (WM_HWIN hWin, WM_MESSAGE * p);
Xvoid      WM_SendMessage          (GUI_HWIN hWin, WM_MESSAGE * p);
Nvoid      WM_SendMessageNoPara    (WM_HWIN hWin, int MsgId);             /* not to be documented (may change in future */
Xvoid      WM_SendMessageNoPara    (GUI_HWIN hWin, int MsgId);              
Nvoid      WM_DefaultProc          (WM_MESSAGE * pMsg);
Nint       WM_BroadcastMessage     (WM_MESSAGE * pMsg);
Nvoid      WM_SetScrollState       (WM_HWIN hWin, const WM_SCROLL_STATE * pState);
Xvoid      WM_SetScrollState       (GUI_HWIN hWin, const WM_SCROLL_STATE * pState);
Nvoid      WM_SetEnableState       (WM_HWIN hItem, int State);
Xvoid      WM_SetEnableState       (GUI_HWIN hItem, int State);
Nvoid      WM_SendToParent         (WM_HWIN hWin, WM_MESSAGE * pMsg);
Xvoid      WM_SendToParent         (GUI_HWIN hWin, WM_MESSAGE * pMsg);
Nint       WM_HasFocus             (WM_HWIN hWin);
Xint       WM_HasFocus             (GUI_HWIN hWin);
Nint       WM_SetFocus             (WM_HWIN hWin);
Xint       WM_SetFocus             (GUI_HWIN hWin);
NWM_HWIN   WM_SetFocusOnNextChild  (WM_HWIN hParent);     /* Set the focus to the next child */
XGUI_HWIN   WM_SetFocusOnNextChild  (GUI_HWIN hParent);      
NWM_HWIN   WM_SetFocusOnPrevChild  (WM_HWIN hParent);     /* Set the focus to the previous child */
XGUI_HWIN   WM_SetFocusOnPrevChild  (GUI_HWIN hParent);      
NWM_HWIN   WM_GetDialogItem        (WM_HWIN hWin, int Id);
XGUI_HWIN   WM_GetDialogItem        (GUI_HWIN hWin, int Id);
Nvoid      WM_EnableWindow         (WM_HWIN hWin);
Xvoid      WM_EnableWindow         (GUI_HWIN hWin);
Nvoid      WM_DisableWindow        (WM_HWIN hWin);
Xvoid      WM_DisableWindow        (GUI_HWIN hWin);
Nvoid      WM_GetScrollState       (WM_HWIN hObj, WM_SCROLL_STATE * pScrollState);
Xvoid      WM_GetScrollState       (GUI_HWIN hObj, WM_SCROLL_STATE * pScrollState);
N
N/*********************************************************************
N*
N*       Managing user data
N*/
Nint       WM_GetUserData   (WM_HWIN hWin, void * pDest, int SizeOfBuffer);
Xint       WM_GetUserData   (GUI_HWIN hWin, void * pDest, int SizeOfBuffer);
Nint       WM_SetUserData   (WM_HWIN hWin, const void * pSrc, int SizeOfBuffer);
Xint       WM_SetUserData   (GUI_HWIN hWin, const void * pSrc, int SizeOfBuffer);
Nint       WM__GetUserDataEx(WM_HWIN hWin, void * pDest, int NumBytes, int SizeOfObject);
Xint       WM__GetUserDataEx(GUI_HWIN hWin, void * pDest, int NumBytes, int SizeOfObject);
Nint       WM__SetUserDataEx(WM_HWIN hWin, const void * pSrc, int NumBytes, int SizeOfObject);
Xint       WM__SetUserDataEx(GUI_HWIN hWin, const void * pSrc, int NumBytes, int SizeOfObject);
N
N/*********************************************************************
N*
N*       Capturing input focus
N*/
Nint  WM_HasCaptured   (WM_HWIN hWin);
Xint  WM_HasCaptured   (GUI_HWIN hWin);
Nvoid WM_SetCapture    (WM_HWIN hObj, int AutoRelease);
Xvoid WM_SetCapture    (GUI_HWIN hObj, int AutoRelease);
Nvoid WM_SetCaptureMove(WM_HWIN hWin, const GUI_PID_STATE * pState, int MinVisibility, int LimitTop); /* Not yet documented */
Xvoid WM_SetCaptureMove(GUI_HWIN hWin, const GUI_PID_STATE * pState, int MinVisibility, int LimitTop);  
Nvoid WM_ReleaseCapture(void);
N
N/*********************************************************************
N*
N*       Misc routines
N*/
Nint       WM_HandlePID      (void);
NWM_HWIN   WM_Screen2hWin    (int x, int y);
XGUI_HWIN   WM_Screen2hWin    (int x, int y);
NWM_HWIN   WM_Screen2hWinEx  (WM_HWIN hStop, int x, int y);
XGUI_HWIN   WM_Screen2hWinEx  (GUI_HWIN hStop, int x, int y);
Nvoid      WM_ForEachDesc    (WM_HWIN hWin, WM_tfForEach * pcb, void * pData);
Xvoid      WM_ForEachDesc    (GUI_HWIN hWin, WM_tfForEach * pcb, void * pData);
Nvoid      WM_SetScreenSize  (int xSize, int ySize);
Nint       WM_PollSimMsg     (void);
Nint       WM_GetWindowInfo  (WM_WINDOW_INFO * pInfo, int FirstWindow);
N
N/*********************************************************************
N*
N*       Diagnostics routines
N*/
N#if (WM_SUPPORT_DIAG)
X#if (0)
Svoid WM_DIAG_EnableInvalidationColoring(int OnOff);
N#endif
N
N/*********************************************************************
N*
N*       Macros for compatibility with older versions
N*/
N#if WM_COMPATIBLE_MODE
X#if 1
N  #define HBWIN             WM_HWIN
N  #define HBWIN_NULL        WM_HWIN_NULL
N
N  #define WM_HideWin        WM_HideWindow
N  #define WM_ShowWin        WM_ShowWindow
N  #define WM_GetKey         GUI_GetKey
N  #define WM_WaitKey        GUI_WaitKey
N
N  #define WM_ExecIdle       WM_Exec
N  #define WM_ExecIdle1      WM_Exec1
N
N  #define WM_Invalidate     WM_InvalidateWindow
N  #define WM_GetWinRect     WM_GetWindowRect
N  #define WM_GetWinOrgX     WM_GetWindowOrgX
N  #define WM_GetWinOrgY     WM_GetWindowOrgY
N  #define WM_GetWinSizeX    WM_GetWindowSizeX
N  #define WM_GetWinSizeY    WM_GetWindowSizeY
N  #define WM_GetXSize       WM_GetWindowSizeX
N  #define WM_GetYSize       WM_GetWindowSizeY
N  #define WM_SelWin         WM_SelectWindow
N  #define WM_GetBackgroundWindow  WM_GetDesktopWindow
N  #define WM_GetForegroundWindow    0
N  #define WM_SetForegroundWindow    WM_BringToTop
N  #define WM_SetUserClipArea WM_SetUserClipRect
N
N
N  #define WM_Start()
N  #define WM_Stop()
N  #define WM_SetBkWindowColor(Color)  WM_SetDesktopColor(Color)
N
N#endif
N
N
N#endif   /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif   /* WM_H */
N
N/*************************** End of file ****************************/
L 48 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N
N#include "BUTTON.h"
L 1 "..\..\..\ThirdParty\emWin\Include\BUTTON.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : BUTTON.h
NPurpose     : BUTTON public header file (API)
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef BUTTON_H
N#define BUTTON_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
L 1 "..\..\..\ThirdParty\emWin\Include\DIALOG_Intern.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : Dialog.h
NPurpose     : Dialog box include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef DIALOG_INTERN_H
N#define DIALOG_INTERN_H
N
N#include "WM.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {        // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef struct  GUI_WIDGET_CREATE_INFO_struct GUI_WIDGET_CREATE_INFO;
Ntypedef WM_HWIN GUI_WIDGET_CREATE_FUNC        (const GUI_WIDGET_CREATE_INFO * pCreate, WM_HWIN hWin, int x0, int y0, WM_CALLBACK * cb);
Xtypedef GUI_HWIN GUI_WIDGET_CREATE_FUNC        (const GUI_WIDGET_CREATE_INFO * pCreate, GUI_HWIN hWin, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       Structures
N*
N**********************************************************************
N*/
Nstruct GUI_WIDGET_CREATE_INFO_struct {
N  GUI_WIDGET_CREATE_FUNC * pfCreateIndirect;
N  const char             * pName;            // Text ... Not used on all widgets
N  I16                      Id;               // ID ... should be unique in a dialog
X  signed short                      Id;               
N  I16                      x0;               // x position
X  signed short                      x0;               
N  I16                      y0;               // y position
X  signed short                      y0;               
N  I16                      xSize;            // x size
X  signed short                      xSize;            
N  I16                      ySize;            // y size
X  signed short                      ySize;            
N  U16                      Flags;            // Widget specific create flags (opt.)
X  unsigned short                      Flags;            
N  I32                      Para;             // Widget specific parameter (opt.)
X  signed long                      Para;             
N  U32                      NumExtraBytes;    // Number of extra bytes usable with <WIDGET>_SetUserData & <WIDGET>_GetUserData
X  unsigned long                      NumExtraBytes;    
N};
N
N/*********************************************************************
N*
N*       Public API functions
N*
N**********************************************************************
N*/
NWM_HWIN            GUI_CreateDialogBox   (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, WM_HWIN hParent, int x0, int y0);
XGUI_HWIN            GUI_CreateDialogBox   (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, GUI_HWIN hParent, int x0, int y0);
Nvoid               GUI_EndDialog         (WM_HWIN hWin, int r);
Xvoid               GUI_EndDialog         (GUI_HWIN hWin, int r);
Nint                GUI_ExecDialogBox     (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, WM_HWIN hParent, int x0, int y0);
Xint                GUI_ExecDialogBox     (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, GUI_HWIN hParent, int x0, int y0);
Nint                GUI_ExecCreatedDialog (WM_HWIN hDialog);
Xint                GUI_ExecCreatedDialog (GUI_HWIN hDialog);
NWM_DIALOG_STATUS * GUI_GetDialogStatusPtr(WM_HWIN hDialog);                                    // Not to be documented
XWM_DIALOG_STATUS * GUI_GetDialogStatusPtr(GUI_HWIN hDialog);                                    
Nvoid               GUI_SetDialogStatusPtr(WM_HWIN hDialog, WM_DIALOG_STATUS * pDialogStatus);  // Not to be documented
Xvoid               GUI_SetDialogStatusPtr(GUI_HWIN hDialog, WM_DIALOG_STATUS * pDialogStatus);  
N
N/*********************************************************************
N*
N*       Obsolete
N*/
NLCD_COLOR          DIALOG_GetBkColor(void);
NLCD_COLOR          DIALOG_SetBkColor(LCD_COLOR BkColor);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // DIALOG_INTERN_H
N
N/*************************** End of file ****************************/
L 49 "..\..\..\ThirdParty\emWin\Include\BUTTON.h" 2
N#include "WIDGET.h"
L 1 "..\..\..\ThirdParty\emWin\Include\WIDGET.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WIDGET.h
NPurpose     : Widget interface
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef WIDGET_H        /* Avoid multiple inclusion  */
N#define WIDGET_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#include "WM_Intern.h"  /* Window manager, including some internals, which speed things up */
L 1 "..\..\..\ThirdParty\emWin\Include\WM_Intern.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WM_Intern.h
NPurpose     : Windows manager internal include
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_INTERN_H            /* Make sure we only include it once */
N#define WM_INTERN_H            /* Make sure we only include it once */
N
N#include "WM.h"
N#include "GUI_Private.h"
L 1 "..\..\..\ThirdParty\emWin\Include\GUI_Private.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_Private.h
NPurpose     : GUI internal declarations
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef GUI_PRIVATE_H
N#define GUI_PRIVATE_H
N
N#include "GUI.h"
N#include "LCD_Protected.h"
L 1 "..\..\..\ThirdParty\emWin\Include\LCD_Protected.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : LCD_Protected.h
NPurpose     : LCD level - To be used only internally by the GUI
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_PROTECTED_H
N#define LCD_PROTECTED_H
N
N#include "LCD.h"
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Data types
N*/
Ntypedef struct {
N  LCD_COLOR * paColor;
N  I16         NumEntries;
X  signed short         NumEntries;
N} LCD_LUT_INFO;
N
Ntypedef struct {
N  tLCDDEV_DrawPixel  * pfDrawPixel;
N  tLCDDEV_DrawHLine  * pfDrawHLine;
N  tLCDDEV_DrawVLine  * pfDrawVLine;
N  tLCDDEV_FillRect   * pfFillRect;
N  tLCDDEV_DrawBitmap * pfDrawBitmap;
N} LCD_API_LIST;
N
N/*********************************************************************
N*
N*       External data
N*/
Nextern GUI_CONST_STORAGE U8 LCD_aMirror[256];
Xextern const unsigned char LCD_aMirror[256];
Nextern LCD_PIXELINDEX * LCD__aConvTable;
Xextern unsigned long * LCD__aConvTable;
N
N/*********************************************************************
N*
N*       Misc functions
N*/
Nvoid LCD_UpdateColorIndices   (void);
Nint  LCD_PassingBitmapsAllowed(void);
Nvoid LCD_EnableCursor         (int OnOff);
Nvoid LCD_SelectLCD            (void);
N
Nvoid LCD_DrawBitmap(int x0,    int y0,
N                    int xsize, int ysize,
N                    int xMul,  int yMul,
N                    int BitsPerPixel,
N                    int BytesPerLine,
N                    const U8 * pPixel,
X                    const unsigned char * pPixel,
N                    const LCD_PIXELINDEX * pTrans);
X                    const unsigned long * pTrans);
N
Nvoid LCD__DrawBitmap_1bpp(int x0,    int y0,
N                          int xsize, int ysize,
N                          int xMul,  int yMul,
N                          int BitsPerPixel,
N                          int BytesPerLine,
N                          const U8 * pPixel,
X                          const unsigned char * pPixel,
N                          const LCD_PIXELINDEX * pTrans,
X                          const unsigned long * pTrans,
N                          int OffData);
N
N/*********************************************************************
N*
N*       Internal used color conversion routines
N*/
NtLCDDEV_Index2Color LCD_Index2Color_444_12;
NtLCDDEV_Index2Color LCD_Index2Color_M444_12;
NtLCDDEV_Index2Color LCD_Index2Color_444_12_1;
NtLCDDEV_Index2Color LCD_Index2Color_M444_12_1;
NtLCDDEV_Index2Color LCD_Index2Color_444_16;
NtLCDDEV_Index2Color LCD_Index2Color_M444_16;
NtLCDDEV_Index2Color LCD_Index2Color_555;
NtLCDDEV_Index2Color LCD_Index2Color_565;
NtLCDDEV_Index2Color LCD_Index2Color_8666;
NtLCDDEV_Index2Color LCD_Index2Color_888;
NtLCDDEV_Index2Color LCD_Index2Color_8888;
NtLCDDEV_Index2Color LCD_Index2Color_M8888I;
NtLCDDEV_Index2Color LCD_Index2Color_M555;
NtLCDDEV_Index2Color LCD_Index2Color_M565;
NtLCDDEV_Index2Color LCD_Index2Color_M888;
N
NtLCDDEV_Color2Index LCD_Color2Index_8666;
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif /* LCD_PROTECTED_H */
N
N/*************************** End of file ****************************/
N
L 49 "..\..\..\ThirdParty\emWin\Include\GUI_Private.h" 2
N#include "GUI_Debug.h"
L 1 "..\..\..\ThirdParty\emWin\Include\GUI_Debug.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_Debug.h
NPurpose     : Debug macros
N----------------------------------------------------------------------
N   Debug macros for logging
N
N In the GUI Simulation, all output is transferred into the log window.
N*/
N
N#ifndef GUI_DEBUG_H
N#define GUI_DEBUG_H
N
N#include <stddef.h>
N
N#include "GUI.h"
N
N#define GUI_DEBUG_LEVEL_NOCHECK       0  /* No run time checks are performed */
N#define GUI_DEBUG_LEVEL_CHECK_PARA    1  /* Parameter checks are performed to avoid crashes */
N#define GUI_DEBUG_LEVEL_CHECK_ALL     2  /* Parameter checks and consistency checks are performed */
N#define GUI_DEBUG_LEVEL_LOG_ERRORS    3  /* Errors are recorded */
N#define GUI_DEBUG_LEVEL_LOG_WARNINGS  4  /* Errors & Warnings are recorded */
N#define GUI_DEBUG_LEVEL_LOG_ALL       5  /* Errors, Warnings and Messages are recorded. */
N
N#ifndef GUI_DEBUG_LEVEL
N  #ifdef WIN32
S    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_LOG_WARNINGS  /* Simulation should log all warnings */
N  #else
N    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_NOCHECK       /* For most targets, min. size is important */
N  #endif
N#endif
N
N#define GUI_LOCK_H(hMem)   GUI_ALLOC_LockH(hMem)
N#define GUI_UNLOCK_H(pMem) GUI_ALLOC_UnlockH((void **)&pMem)
N
N/*******************************************************************
N*
N*               Commandline
N*
N********************************************************************
N*/
N
N#ifdef WIN32
S  #define GUI_DEBUG_GETCMDLINE() SIM_GetCmdLine()
N#else
N  #define GUI_DEBUG_GETCMDLINE() 0
N#endif
N
N/*******************************************************************
N*
N*               Error macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ERRORS
X#if 0 >= 3
S  #define GUI_DEBUG_ERROROUT(s)              GUI_ErrorOut(s)
S  #define GUI_DEBUG_ERROROUT1(s,p0)          GUI_ErrorOut1(s,p0)
S  #define GUI_DEBUG_ERROROUT2(s,p0,p1)       GUI_ErrorOut2(s,p0,p1)
S  #define GUI_DEBUG_ERROROUT3(s,p0,p1,p2)    GUI_ErrorOut3(s,p0,p1,p2)
S  #define GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3) GUI_ErrorOut4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_ERROROUT_IF(exp,s)              { if (exp) GUI_DEBUG_ERROROUT(s); }
S  #define GUI_DEBUG_ERROROUT1_IF(exp,s,p0)          { if (exp) GUI_DEBUG_ERROROUT1(s,p0); }
S  #define GUI_DEBUG_ERROROUT2_IF(exp,s,p0,p1)       { if (exp) GUI_DEBUG_ERROROUT2(s,p0,p1); }
S  #define GUI_DEBUG_ERROROUT3_IF(exp,s,p0,p1,p2)    { if (exp) GUI_DEBUG_ERROROUT3(s,p0,p1,p2); }
S  #define GUI_DEBUG_ERROROUT4_IF(exp,s,p0,p1,p2,p3) { if (exp) GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_ERROROUT(s)
N  #define GUI_DEBUG_ERROROUT1(s,p0)
N  #define GUI_DEBUG_ERROROUT2(s,p0,p1)
N  #define GUI_DEBUG_ERROROUT3(s,p0,p1,p2)
N  #define GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_ERROROUT_IF(exp,s)
N  #define GUI_DEBUG_ERROROUT1_IF(exp,s,p0)
N  #define GUI_DEBUG_ERROROUT2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_ERROROUT3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_ERROROUT4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Warning macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_WARNINGS
X#if 0 >= 4
S  #define GUI_DEBUG_WARN(s)              GUI_Warn(s)
S  #define GUI_DEBUG_WARN1(s,p0)          GUI_Warn1(s,p0)
S  #define GUI_DEBUG_WARN2(s,p0,p1)       GUI_Warn2(s,p0,p1)
S  #define GUI_DEBUG_WARN3(s,p0,p1,p2)    GUI_Warn3(s,p0,p1,p2)
S  #define GUI_DEBUG_WARN4(s,p0,p1,p2,p3) GUI_Warn4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_WARN_IF(exp,s)                  { if (exp) GUI_DEBUG_WARN(s); }
S  #define GUI_DEBUG_WARN1_IF(exp,s,p0)              { if (exp) GUI_DEBUG_WARN1(s,p0); }
S  #define GUI_DEBUG_WARN2_IF(exp,s,p0,p1)           { if (exp) GUI_DEBUG_WARN2(s,p0,p1); }
S  #define GUI_DEBUG_WARN3_IF(exp,s,p0,p1,p2)        { if (exp) GUI_DEBUG_WARN3(s,p0,p1,p2); }
S  #define GUI_DEBUG_WARN4_IF(exp,s,p0,p1,p2,p3)     { if (exp) GUI_DEBUG_WARN4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_WARN(s)
N  #define GUI_DEBUG_WARN1(s,p0)
N  #define GUI_DEBUG_WARN2(s,p0,p1)
N  #define GUI_DEBUG_WARN3(s,p0,p1,p2)
N  #define GUI_DEBUG_WARN4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_WARN_IF(exp,s)
N  #define GUI_DEBUG_WARN1_IF(exp,s,p0)
N  #define GUI_DEBUG_WARN2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_WARN3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_WARN4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Logging macros
N*
N********************************************************************
N*/
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ALL
X#if 0 >= 5
S  #define GUI_DEBUG_LOG(s)              GUI_Log(s)
S  #define GUI_DEBUG_LOG1(s,p0)          GUI_Log1(s,p0)
S  #define GUI_DEBUG_LOG2(s,p0,p1)       GUI_Log2(s,p0,p1)
S  #define GUI_DEBUG_LOG3(s,p0,p1,p2)    GUI_Log3(s,p0,p1,p2)
S  #define GUI_DEBUG_LOG4(s,p0,p1,p2,p3) GUI_Log4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_LOG_IF(exp,s)                   { if (exp) GUI_DEBUG_LOG(s); }
S  #define GUI_DEBUG_LOG1_IF(exp,s,p0)               { if (exp) GUI_DEBUG_LOG1(s,p0); }
S  #define GUI_DEBUG_LOG2_IF(exp,s,p0,p1)            { if (exp) GUI_DEBUG_LOG2(s,p0,p1); }
S  #define GUI_DEBUG_LOG3_IF(exp,s,p0,p1,p2)         { if (exp) GUI_DEBUG_LOG3(s,p0,p1,p2); }
S  #define GUI_DEBUG_LOG4_IF(exp,s,p0,p1,p2,p3)      { if (exp) GUI_DEBUG_LOG4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_LOG(s)
N  #define GUI_DEBUG_LOG1(s,p0)
N  #define GUI_DEBUG_LOG2(s,p0,p1)
N  #define GUI_DEBUG_LOG3(s,p0,p1,p2)
N  #define GUI_DEBUG_LOG4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_LOG_IF(exp,s)
N  #define GUI_DEBUG_LOG1_IF(exp,s,p0)
N  #define GUI_DEBUG_LOG2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_LOG3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_LOG4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Asserts
N*
N********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ERRORS
X#if 0 >= 3
S  #define GUI_DEBUG_ASSERT(exp)                     { if (!exp) GUI_DEBUG_ERROROUT(#exp); }
N#else
N  #define GUI_DEBUG_ASSERT(exp)
N#endif
N
N#endif /* LCD_H */
N
N
N
N
N/*************************** End of file ****************************/
L 50 "..\..\..\ThirdParty\emWin\Include\GUI_Private.h" 2
N#if GUI_WINSUPPORT
X#if 1
N  #include "WM_GUI.h"
N#endif
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defaults for config switches
N*
N**********************************************************************
N
N  The config switches below do not affect the interface in GUI.h and
N  are therefor not required to be in GUI.h.
N*/
N
N/* Short address area.
N   For  most compilers, this is "near" or "__near"
N   We do not use this except for some CPUs which we know to always have some
N   near memory, because the GUI_Context and some other data will be declared
N   to be in this short address (near) memory area as it has a major effect
N   on performance.
N   Please define in GUIConf.h (if you want to use it)
N*/
N#ifndef GUI_SADDR
N  #define GUI_SADDR
N#endif
N
N#ifndef GUI_DEFAULT_FONT
S  #define GUI_DEFAULT_FONT    &GUI_Font6x8
N#endif
N
N#ifndef GUI_DEFAULT_CURSOR
N  #define GUI_DEFAULT_CURSOR  &GUI_CursorArrowM
N#endif
N
N#ifndef GUI_DEFAULT_BKCOLOR
N  #define GUI_DEFAULT_BKCOLOR GUI_BLACK
N#endif
N
N#ifndef GUI_DEFAULT_COLOR
N  #define GUI_DEFAULT_COLOR   GUI_WHITE
N#endif
N
N/*********************************************************************
N*
N*       Angles
N*
N**********************************************************************
N*/
N#define GUI_45DEG  512
N#define GUI_90DEG  (2 * GUI_45DEG)
N#define GUI_180DEG (4 * GUI_45DEG)
N#define GUI_360DEG (8 * GUI_45DEG)
N
N/*********************************************************************
N*
N*       Locking checks
N*
N**********************************************************************
N*/
N#if defined (WIN32) && defined (_DEBUG) && GUI_OS
X#if 0L && 0L && (1)
S  #define GUI_ASSERT_LOCK()    GUITASK_AssertLock()
S  #define GUI_ASSERT_NO_LOCK() GUITASK_AssertNoLock()
S  void GUITASK_AssertLock(void);
S  void GUITASK_AssertNoLock(void);
N#else
N  #define GUI_ASSERT_LOCK()
N  #define GUI_ASSERT_NO_LOCK()
N#endif
N
N/*********************************************************************
N*
N*       Division tables
N*
N**********************************************************************
N*/
Nextern const U8 GUI__aConvert_15_255[(1 << 4)];
Xextern const unsigned char GUI__aConvert_15_255[(1 << 4)];
Nextern const U8 GUI__aConvert_31_255[(1 << 5)];
Xextern const unsigned char GUI__aConvert_31_255[(1 << 5)];
Nextern const U8 GUI__aConvert_63_255[(1 << 6)];
Xextern const unsigned char GUI__aConvert_63_255[(1 << 6)];
Nextern const U8 GUI__aConvert_255_15[(1 << 8)];
Xextern const unsigned char GUI__aConvert_255_15[(1 << 8)];
Nextern const U8 GUI__aConvert_255_31[(1 << 8)];
Xextern const unsigned char GUI__aConvert_255_31[(1 << 8)];
Nextern const U8 GUI__aConvert_255_63[(1 << 8)];
Xextern const unsigned char GUI__aConvert_255_63[(1 << 8)];
N
N/*********************************************************************
N*
N*       Usage internals
N*
N**********************************************************************
N*/
Ntypedef GUI_HMEM GUI_USAGE_Handle;
Xtypedef signed long GUI_USAGE_Handle;
Ntypedef struct tsUSAGE_APIList tUSAGE_APIList;
Ntypedef struct GUI_Usage GUI_USAGE;
N#define GUI_USAGE_h GUI_USAGE_Handle
N
Ntypedef GUI_USAGE_h tUSAGE_CreateCompatible(GUI_USAGE * p);
Xtypedef GUI_USAGE_Handle tUSAGE_CreateCompatible(GUI_USAGE * p);
Ntypedef void        tUSAGE_AddPixel        (GUI_USAGE * p, int x, int y);
Ntypedef void        tUSAGE_AddHLine        (GUI_USAGE * p, int x0, int y0, int len);
Ntypedef void        tUSAGE_Clear           (GUI_USAGE * p);
Ntypedef void        tUSAGE_Delete          (GUI_USAGE_h h);
Xtypedef void        tUSAGE_Delete          (GUI_USAGE_Handle h);
Ntypedef int         tUSAGE_GetNextDirty    (GUI_USAGE * p, int * pxOff, int yOff);
N#define GUI_USAGE_LOCK_H(h) ((GUI_USAGE *)GUI_LOCK_H(h))
N
Nvoid GUI_USAGE_DecUseCnt(GUI_USAGE_Handle  hUsage);
N
NGUI_USAGE_Handle GUI_USAGE_BM_Create(int x0, int y0, int xsize, int ysize, int Flags);
Nvoid    GUI_USAGE_Select(GUI_USAGE_Handle hUsage);
Nvoid    GUI_USAGE_AddRect(GUI_USAGE * pUsage, int x0, int y0, int xSize, int ySize);
N#define GUI_USAGE_AddPixel(p, x,y)            p->pAPI->pfAddPixel(p,x,y)
N#define GUI_USAGE_AddHLine(p,x,y,len)         p->pAPI->pfAddHLine(p,x,y,len)
N#define GUI_USAGE_Clear(p)                    p->pAPI->pfClear(p)
N#define GUI_USAGE_Delete(p)                   p->pAPI->pfDelete(p)
N#define GUI_USAGE_GetNextDirty(p,pxOff, yOff) p->pAPI->pfGetNextDirty(p,pxOff, yOff)
N
Nstruct tsUSAGE_APIList {
N  tUSAGE_AddPixel         * pfAddPixel;
N  tUSAGE_AddHLine         * pfAddHLine;
N  tUSAGE_Clear            * pfClear;
N  tUSAGE_CreateCompatible * pfCreateCompatible;
N  tUSAGE_Delete           * pfDelete;
N  tUSAGE_GetNextDirty     * pfGetNextDirty;
N} ;
N
Nstruct GUI_Usage {
N  I16P x0, y0, XSize, YSize;
X  signed short x0, y0, XSize, YSize;
N  const tUSAGE_APIList * pAPI;
N  I16 UseCnt;
X  signed short UseCnt;
N};
N
N/*********************************************************************
N*
N*       GUI_MEMDEV
N*
N**********************************************************************
N*/
N#if GUI_SUPPORT_MEMDEV
X#if 1
N
Ntypedef struct {
N  GUI_DEVICE * pDevice;
N  I16P                   x0, y0, XSize, YSize;
X  signed short                   x0, y0, XSize, YSize;
N  unsigned               BytesPerLine;
N  unsigned               BitsPerPixel;
N  GUI_HMEM               hUsage;
X  signed long               hUsage;
N} GUI_MEMDEV;
N
N#define      GUI_MEMDEV_LOCK_H(h) ((GUI_MEMDEV *)GUI_LOCK_H(h))
N
Nvoid         GUI_MEMDEV__CopyFromLCD (GUI_MEMDEV_Handle hMem);
Nvoid         GUI_MEMDEV__GetRect     (GUI_RECT * pRect);
Nunsigned     GUI_MEMDEV__Color2Index (LCD_COLOR Color);
NLCD_COLOR    GUI_MEMDEV__Index2Color (int Index);
Nunsigned int GUI_MEMDEV__GetIndexMask(void);
Nvoid         GUI_MEMDEV__SetAlphaCallback(unsigned(* pcbSetAlpha)(U8));
Xvoid         GUI_MEMDEV__SetAlphaCallback(unsigned(* pcbSetAlpha)(unsigned char));
N
NGUI_MEMDEV_Handle GUI_MEMDEV__CreateFixed(int x0, int y0, int xSize, int ySize, int Flags,
N                                          const GUI_DEVICE_API     * pDeviceAPI,
N                                          const LCD_API_COLOR_CONV * pColorConvAPI);
N
Nvoid              GUI_MEMDEV__DrawSizedAt        (GUI_MEMDEV_Handle hMem, int xPos, int yPos, int xSize, int ySize);
NGUI_MEMDEV_Handle GUI_MEMDEV__GetEmptyCopy32     (GUI_MEMDEV_Handle hMem, int * pxSize, int * pySize, int * pxPos, int * pyPos);
Nvoid              GUI_MEMDEV__ReadLine           (int x0, int y, int x1, LCD_PIXELINDEX * pBuffer);
Xvoid              GUI_MEMDEV__ReadLine           (int x0, int y, int x1, unsigned long * pBuffer);
Nvoid              GUI_MEMDEV__WriteToActiveAlpha (GUI_MEMDEV_Handle hMem,int x, int y);
Nvoid              GUI_MEMDEV__WriteToActiveAt    (GUI_MEMDEV_Handle hMem,int x, int y);
Nvoid              GUI_MEMDEV__WriteToActiveOpaque(GUI_MEMDEV_Handle hMem,int x, int y);
Nvoid            * GUI_MEMDEV__XY2PTR             (int x,int y);
Nvoid            * GUI_MEMDEV__XY2PTREx           (GUI_MEMDEV * pDev, int x,int y);
Nvoid              GUI_MEMDEV__BlendColor32       (GUI_MEMDEV_Handle hMem, U32 BlendColor, U8 BlendIntens);
Xvoid              GUI_MEMDEV__BlendColor32       (GUI_MEMDEV_Handle hMem, unsigned long BlendColor, unsigned char BlendIntens);
N
Nunsigned GUI__AlphaPreserveTrans(int OnOff);
N
Nextern unsigned GUI_MEMDEV__TimePerFrame;
N
N#define GUI_TIME_PER_FRAME (GUI_TIMER_TIME)GUI_MEMDEV__TimePerFrame
N
N#define GUI_POS_AUTO -4095   /* Position value for auto-pos */
N
N#endif
N
N/*********************************************************************
N*
N*       LCD_HL_ level defines
N*
N**********************************************************************
N*/
N#define LCD_HL_DrawHLine             GUI_pContext->pLCD_HL->pfDrawHLine
N#define LCD_HL_DrawPixel             GUI_pContext->pLCD_HL->pfDrawPixel
N
N/*********************************************************************
N*
N*       Helper functions
N*
N**********************************************************************
N*/
N#define GUI_ZEROINIT(Obj) GUI__MEMSET(Obj, 0, sizeof(Obj))
Nint  GUI_cos(int angle);
Nint  GUI_sin(int angle);
Nextern const U32 GUI_Pow10[10];
Xextern const unsigned long GUI_Pow10[10];
N
N/* Multi-touch */
Nvoid GUI_MTOUCH__ManagePID(int OnOff);
N
N/* Anti-aliased drawing */
Nint  GUI_AA_Init       (int x0, int x1);
Nint  GUI_AA_Init_HiRes (int x0, int x1);
Nvoid GUI_AA_Exit       (void);
NI16  GUI_AA_HiRes2Pixel(int HiRes);
Xsigned short  GUI_AA_HiRes2Pixel(int HiRes);
N
Nvoid GL_DrawCircleAA_HiRes(int x0, int y0, int r);
Nvoid GL_FillCircleAA_HiRes (int x0, int y0, int r);
Nvoid GL_FillEllipseAA_HiRes(int x0, int y0, int rx, int ry);
N
Nvoid GUI_AA__DrawCharAA2(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8 * pData);
Xvoid GUI_AA__DrawCharAA2(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char * pData);
Nvoid GUI_AA__DrawCharAA4(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8 * pData);
Xvoid GUI_AA__DrawCharAA4(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char * pData);
Nvoid GUI_AA__DrawCharAA8(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8 * pData);
Xvoid GUI_AA__DrawCharAA8(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char * pData);
N
N/* Alpha blending helper functions */
N#define GUI_ALPHABLENDING_DONE  (1 << 0)
N
Nint      GUI__GetAlphaBuffer    (U32 ** ppCurrent, U32 ** ppConvert, U32 ** ppData, int * pVXSizeMax);
Xint      GUI__GetAlphaBuffer    (unsigned long ** ppCurrent, unsigned long ** ppConvert, unsigned long ** ppData, int * pVXSizeMax);
Nint      GUI__AllocAlphaBuffer  (int AllocDataBuffer);
NU32    * GUI__DoAlphaBlending   (int x, int y, U32 * pData, int xSize, tLCDDEV_Index2Color * pfIndex2Color_DEV, int * pDone);
Xunsigned long    * GUI__DoAlphaBlending   (int x, int y, unsigned long * pData, int xSize, tLCDDEV_Index2Color * pfIndex2Color_DEV, int * pDone);
Nunsigned GUI__SetAlphaBufferSize(int xSize);
N
N/* System independent font routines */
Nint        GUI_SIF__GetCharDistX       (U16P c, int * pSizeX);
Xint        GUI_SIF__GetCharDistX       (unsigned short c, int * pSizeX);
Nvoid       GUI_SIF__GetFontInfo        (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Nchar       GUI_SIF__IsInFont           (const GUI_FONT * pFont, U16 c);
Xchar       GUI_SIF__IsInFont           (const GUI_FONT * pFont, unsigned short c);
Nconst U8 * GUI_SIF__GetpCharInfo       (const GUI_FONT * pFont, U16P c, unsigned SizeOfCharInfo);
Xconst unsigned char * GUI_SIF__GetpCharInfo       (const GUI_FONT * pFont, unsigned short c, unsigned SizeOfCharInfo);
Nint        GUI_SIF__GetNumCharAreas    (const GUI_FONT * pFont);
Nint        GUI_SIF__GetCharDistX_ExtFrm(U16P c, int * pSizeX);
Xint        GUI_SIF__GetCharDistX_ExtFrm(unsigned short c, int * pSizeX);
Nvoid       GUI_SIF__GetFontInfo_ExtFrm (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Nchar       GUI_SIF__IsInFont_ExtFrm    (const GUI_FONT * pFont, U16 c);
Xchar       GUI_SIF__IsInFont_ExtFrm    (const GUI_FONT * pFont, unsigned short c);
Nint        GUI_SIF__GetCharInfo_ExtFrm (U16P c, GUI_CHARINFO_EXT * pInfo);
Xint        GUI_SIF__GetCharInfo_ExtFrm (unsigned short c, GUI_CHARINFO_EXT * pInfo);
Nvoid       GUI_SIF__ClearLine_ExtFrm   (const char * s, int Len);
N
N/* External binary font routines */
Nint        GUI_XBF__GetOff       (const GUI_XBF_DATA * pXBF_Data, unsigned c, U32 * pOff);
Xint        GUI_XBF__GetOff       (const GUI_XBF_DATA * pXBF_Data, unsigned c, unsigned long * pOff);
Nint        GUI_XBF__GetOffAndSize(const GUI_XBF_DATA * pXBF_Data, unsigned c, U32 * pOff, U16 * pSize);
Xint        GUI_XBF__GetOffAndSize(const GUI_XBF_DATA * pXBF_Data, unsigned c, unsigned long * pOff, unsigned short * pSize);
Nint        GUI_XBF__GetCharDistX (U16P c, int * pSizeX);
Xint        GUI_XBF__GetCharDistX (unsigned short c, int * pSizeX);
Nvoid       GUI_XBF__GetFontInfo  (const GUI_FONT * pFont, GUI_FONTINFO * pInfo);
Nchar       GUI_XBF__IsInFont     (const GUI_FONT * pFont, U16 c);
Xchar       GUI_XBF__IsInFont     (const GUI_FONT * pFont, unsigned short c);
Nint        GUI_XBF__GetCharInfo  (U16P c, GUI_CHARINFO_EXT * pInfo);
Xint        GUI_XBF__GetCharInfo  (unsigned short c, GUI_CHARINFO_EXT * pInfo);
Nvoid       GUI_XBF__ClearLine    (const char * s, int Len);
N
N/* Conversion routines */
Nvoid GUI_AddHex     (U32 v, U8 Len, char ** ps);
Xvoid GUI_AddHex     (unsigned long v, unsigned char Len, char ** ps);
Nvoid GUI_AddBin     (U32 v, U8 Len, char ** ps);
Xvoid GUI_AddBin     (unsigned long v, unsigned char Len, char ** ps);
Nvoid GUI_AddDecMin  (I32 v, char ** ps);
Xvoid GUI_AddDecMin  (signed long v, char ** ps);
Nvoid GUI_AddDecShift(I32 v, U8 Len, U8 Shift, char ** ps);
Xvoid GUI_AddDecShift(signed long v, unsigned char Len, unsigned char Shift, char ** ps);
Nlong GUI_AddSign    (long v, char ** ps);
Nint  GUI_Long2Len   (I32 v);
Xint  GUI_Long2Len   (signed long v);
N
N#define GUI_UC__GetCharSize(sText)  GUI_pUC_API->pfGetCharSize(sText)
N#define GUI_UC__GetCharCode(sText)  GUI_pUC_API->pfGetCharCode(sText)
N
Nint   GUI_UC__CalcSizeOfChar   (U16 Char);
Xint   GUI_UC__CalcSizeOfChar   (unsigned short Char);
NU16   GUI_UC__GetCharCodeInc   (const char ** ps);
Xunsigned short   GUI_UC__GetCharCodeInc   (const char ** ps);
Nint   GUI_UC__NumChars2NumBytes(const char * s, int NumChars);
Nint   GUI_UC__NumBytes2NumChars(const char * s, int NumBytes);
N
Nint  GUI__GetLineNumChars  (const char * s, int MaxNumChars);
Nint  GUI__GetNumChars      (const char * s);
Nint  GUI__GetOverlap       (U16 Char);
Xint  GUI__GetOverlap       (unsigned short Char);
Nint  GUI__GetLineDistX     (const char * s, int Len);
Nint  GUI__GetFontSizeY     (void);
Nint  GUI__HandleEOLine     (const char ** ps);
Nvoid GUI__InvertRectColors (int x0, int y0, int x1, int y1);
Nvoid GUI__DispLine         (const char * s, int Len, const GUI_RECT * pr);
Nvoid GUI__AddSpaceHex      (U32 v, U8 Len, char ** ps);
Xvoid GUI__AddSpaceHex      (unsigned long v, unsigned char Len, char ** ps);
Nvoid GUI__CalcTextRect     (const char * pText, const GUI_RECT * pTextRectIn, GUI_RECT * pTextRectOut, int TextAlign);
N
Nvoid GUI__ClearTextBackground(int xDist, int yDist);
N
Nint  GUI__WrapGetNumCharsDisp       (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint  GUI__WrapGetNumCharsToNextLine (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint  GUI__WrapGetNumBytesToNextLine (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
N//void GUI__memset    (U8  * p, U8 Fill, int NumBytes);
Nvoid GUI__memset16  (U16 * p, U16 Fill, int NumWords);
Xvoid GUI__memset16  (unsigned short * p, unsigned short Fill, int NumWords);
Nint  GUI__strlen    (const char * s);
Nint  GUI__strcmp    (const char * s0, const char * s1);
Nint  GUI__strcmp_hp (GUI_HMEM hs0, const char * s1);
Xint  GUI__strcmp_hp (signed long hs0, const char * s1);
N
N/* Get cursor position */
Nint  GUI__GetCursorPosX     (const char * s, int Index, int MaxNumChars);
Nint  GUI__GetCursorPosChar  (const char * s, int x, int NumCharsToNextLine);
NU16  GUI__GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
N
N/* Arabic support (tbd) */
NU16  GUI__GetPresentationForm     (U16 Char, U16 Next, U16 Prev, int * pIgnoreNext, const char * s);
Xunsigned short  GUI__GetPresentationForm     (unsigned short Char, unsigned short Next, unsigned short Prev, int * pIgnoreNext, const char * s);
Nint  GUI__IsArabicCharacter       (U16 c);
Xint  GUI__IsArabicCharacter       (unsigned short c);
N
N/* BiDi support */
Nint  GUI__BIDI_Log2Vis           (const char * s, int NumChars, char * pBuffer, int BufferSize);
Nint  GUI__BIDI_GetCursorPosX     (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCursorPosChar  (const char * s, int NumChars, int x);
NU16  GUI__BIDI_GetLogChar        (const char * s, int NumChars, int Index);
Xunsigned short  GUI__BIDI_GetLogChar        (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCharDir        (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_IsNSM             (U16 Char);
Xint  GUI__BIDI_IsNSM             (unsigned short Char);
NU16  GUI__BIDI_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__BIDI_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Nint  GUI__BIDI_GetWordWrap       (const char * s, int xSize, int * pxDist);
Nint  GUI__BIDI_GetCharWrap       (const char * s, int xSize);
N
N#if (GUI_USE_BIDI2)
X#if (1)
N
N#define GUI__BIDI_Log2Vis            GUI__BIDI2_Log2Vis
N#define GUI__BIDI_GetCursorPosX      GUI__BIDI2_GetCursorPosX
N#define GUI__BIDI_GetCursorPosChar   GUI__BIDI2_GetCursorPosChar
N#define GUI__BIDI_GetLogChar         GUI__BIDI2_GetLogChar
N#define GUI__BIDI_GetCharDir         GUI__BIDI2_GetCharDir
N#define GUI__BIDI_IsNSM              GUI__BIDI2_IsNSM
N#define GUI__BIDI_GetCursorCharacter GUI__BIDI2_GetCursorCharacter
N#define GUI__BIDI_GetWordWrap        GUI__BIDI2_GetWordWrap
N#define GUI__BIDI_GetCharWrap        GUI__BIDI2_GetCharWrap
N#define GUI__BIDI_SetBaseDir         GUI__BIDI2_SetBaseDir
N#define GUI__BIDI_GetBaseDir         GUI__BIDI2_GetBaseDir
N
Nint  GUI__BIDI_Log2Vis           (const char * s, int NumChars, char * pBuffer, int BufferSize);
Xint  GUI__BIDI2_Log2Vis           (const char * s, int NumChars, char * pBuffer, int BufferSize);
Nint  GUI__BIDI_GetCursorPosX     (const char * s, int NumChars, int Index);
Xint  GUI__BIDI2_GetCursorPosX     (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCursorPosChar  (const char * s, int NumChars, int x);
Xint  GUI__BIDI2_GetCursorPosChar  (const char * s, int NumChars, int x);
NU16  GUI__BIDI_GetLogChar        (const char * s, int NumChars, int Index);
Xunsigned short  GUI__BIDI2_GetLogChar        (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCharDir        (const char * s, int NumChars, int Index);
Xint  GUI__BIDI2_GetCharDir        (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_IsNSM             (U16 Char);
Xint  GUI__BIDI2_IsNSM             (unsigned short Char);
NU16  GUI__BIDI_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__BIDI2_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Nint  GUI__BIDI_GetWordWrap       (const char * s, int xSize, int * pxDist);
Xint  GUI__BIDI2_GetWordWrap       (const char * s, int xSize, int * pxDist);
Nint  GUI__BIDI_GetCharWrap       (const char * s, int xSize);
Xint  GUI__BIDI2_GetCharWrap       (const char * s, int xSize);
Nvoid GUI__BIDI_SetBaseDir        (int Dir);
Xvoid GUI__BIDI2_SetBaseDir        (int Dir);
Nint  GUI__BIDI_GetBaseDir        (void);
Xint  GUI__BIDI2_GetBaseDir        (void);
N
N#else
S
S#define GUI__BIDI_SetBaseDir
S#define GUI__BIDI_GetBaseDir
S
N#endif
N
Nconst char * GUI__BIDI_Log2VisBuffered(const char * s, int * pMaxNumChars, int Mode);
N
Nextern int GUI__BIDI_Enabled;
N
Nextern int (* _pfGUI__BIDI_Log2Vis         )(const char * s, int NumChars, char * pBuffer, int BufferSize);
Nextern int (* _pfGUI__BIDI_GetCursorPosX   )(const char * s, int NumChars, int Index);
Nextern int (* _pfGUI__BIDI_GetCursorPosChar)(const char * s, int NumChars, int x);
Nextern U16 (* _pfGUI__BIDI_GetLogChar      )(const char * s, int NumChars, int Index);
Xextern unsigned short (* _pfGUI__BIDI_GetLogChar      )(const char * s, int NumChars, int Index);
Nextern int (* _pfGUI__BIDI_GetCharDir      )(const char * s, int NumChars, int Index);
Nextern int (* _pfGUI__BIDI_IsNSM           )(U16 Char);
Xextern int (* _pfGUI__BIDI_IsNSM           )(unsigned short Char);
N
N/* BiDi-related function pointers */
Nextern const char * (* GUI_CharLine_pfLog2Vis)(const char * s, int * pMaxNumChars, int Mode);
N
Nextern int (* GUI__GetCursorPos_pfGetPosX)     (const char * s, int MaxNumChars, int Index);
Nextern int (* GUI__GetCursorPos_pfGetPosChar)  (const char * s, int MaxNumChars, int x);
Nextern U16 (* GUI__GetCursorPos_pfGetCharacter)(const char * s, int MaxNumChars, int Index, int * pIsRTL);
Xextern unsigned short (* GUI__GetCursorPos_pfGetCharacter)(const char * s, int MaxNumChars, int Index, int * pIsRTL);
N
Nextern int (* GUI__Wrap_pfGetWordWrap)(const char * s, int xSize, int * pxDist);
Nextern int (* GUI__Wrap_pfGetCharWrap)(const char * s, int xSize);
N
N/* Proportional  font support */
Nconst GUI_FONT_PROP * GUIPROP__FindChar(const GUI_FONT_PROP * pProp, U16P c);
Xconst GUI_FONT_PROP * GUIPROP__FindChar(const GUI_FONT_PROP * pProp, unsigned short c);
N
N/* Extended proportional font support */
Nconst GUI_FONT_PROP_EXT * GUIPROP_EXT__FindChar(const GUI_FONT_PROP_EXT * pPropExt, U16P c);
Xconst GUI_FONT_PROP_EXT * GUIPROP_EXT__FindChar(const GUI_FONT_PROP_EXT * pPropExt, unsigned short c);
Nvoid  GUIPROP_EXT__DispLine      (const char * s, int Len);
Nvoid  GUIPROP_EXT__ClearLine     (const char * s, int Len);
Nvoid  GUIPROP_EXT__SetfpClearLine(void (* fpClearLine)(const char * s, int Len));
N
N/* Reading data routines */
NU16 GUI__Read16(const U8 ** ppData);
Xunsigned short GUI__Read16(const unsigned char ** ppData);
NU32 GUI__Read32(const U8 ** ppData);
Xunsigned long GUI__Read32(const unsigned char ** ppData);
N
N/* Virtual screen support */
Nvoid GUI__GetOrg(int * px, int * py);
Nvoid GUI__SetOrgHook(void(* pfHook)(int x, int y));
N
N/* Timer support */
Nint              GUI_TIMER__IsActive       (void);
NGUI_TIMER_TIME   GUI_TIMER__GetPeriod      (void);
Xint   GUI_TIMER__GetPeriod      (void);
NGUI_TIMER_HANDLE GUI_TIMER__GetFirstTimer  (PTR_ADDR * pContext);
XGUI_TIMER_HANDLE GUI_TIMER__GetFirstTimer  (unsigned long * pContext);
NGUI_TIMER_HANDLE GUI_TIMER__GetNextTimerLin(GUI_TIMER_HANDLE hTimer, PTR_ADDR * pContext);
XGUI_TIMER_HANDLE GUI_TIMER__GetNextTimerLin(GUI_TIMER_HANDLE hTimer, unsigned long * pContext);
N
N/* Get function pointers for color conversion */
NtLCDDEV_Index2Color * GUI_GetpfIndex2ColorEx(int LayerIndex);
NtLCDDEV_Color2Index * GUI_GetpfColor2IndexEx(int LayerIndex);
N
Nint GUI_GetBitsPerPixelEx(int LayerIndex);
N
NLCD_PIXELINDEX * LCD_GetpPalConvTable        (const LCD_LOGPALETTE * pLogPal);
Xunsigned long * LCD_GetpPalConvTable        (const LCD_LOGPALETTE * pLogPal);
NLCD_PIXELINDEX * LCD_GetpPalConvTableUncached(const LCD_LOGPALETTE * pLogPal);
Xunsigned long * LCD_GetpPalConvTableUncached(const LCD_LOGPALETTE * pLogPal);
NLCD_PIXELINDEX * LCD_GetpPalConvTableBM      (const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
Xunsigned long * LCD_GetpPalConvTableBM      (const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
N
N/* Setting a function for converting a color palette to an array of index values */
Nvoid GUI_SetFuncGetpPalConvTable(LCD_PIXELINDEX * (* pFunc)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex));
Xvoid GUI_SetFuncGetpPalConvTable(unsigned long * (* pFunc)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex));
N
N/*********************************************************************
N*
N*       Format definitions used by streamed bitmaps
N*
N*   IMPORTANT: DO NOT CHANGE THESE VALUES!
N*   THEY HAVE TO CORRESPOND TO THE DEFINITIONS WITHIN THE CODE OF THE BITMAPCONVERTER!
N*/
N#define GUI_STREAM_FORMAT_INDEXED    100 /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE4       6   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE8       7   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_565        8   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M565       9   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_555        10  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M555       11  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE16      12  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLEM16     13  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_8888       16  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE32      15  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_24         17  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLEALPHA   18  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_444_12     19  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M444_12    20  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_444_12_1   21  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M444_12_1  22  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_444_16     23  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M444_16    24  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_A555       25  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_AM555      26  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_A565       27  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_AM565      28  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M8888I     29  /* DO NOT CHANGE */
N
Nvoid GUI__ReadHeaderFromStream  (GUI_BITMAP_STREAM * pBitmapHeader, const U8 * pData);
Xvoid GUI__ReadHeaderFromStream  (GUI_BITMAP_STREAM * pBitmapHeader, const unsigned char * pData);
Nvoid GUI__CreateBitmapFromStream(const GUI_BITMAP_STREAM * pBitmapHeader, const void * pData, GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const GUI_BITMAP_METHODS * pMethods);
N
N/* Cache management */
Nint GUI__ManageCache  (int Cmd);
Nint GUI__ManageCacheEx(int LayerIndex, int Cmd);
N
N/*********************************************************************
N*
N*       2d - GL
N*
N**********************************************************************
N*/
Nvoid GL_DispChar         (U16 c);
Xvoid GL_DispChar         (unsigned short c);
Nvoid GL_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GL_DrawBitmap       (const GUI_BITMAP * pBM, int x0, int y0);
Nvoid GL_DrawCircle       (int x0, int y0, int r);
Nvoid GL_DrawEllipse      (int x0, int y0, int rx, int ry, int w);
Nvoid GL_DrawHLine        (int y0, int x0, int x1);
Nvoid GL_DrawPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GL_DrawPoint        (int x,  int y);
Nvoid GL_DrawLine1        (int x0, int y0, int x1, int y1);
Nvoid GL_DrawLine1Ex      (int x0, int y0, int x1, int y1, unsigned * pPixelCnt);
Nvoid GL_DrawLineRel      (int dx, int dy);
Nvoid GL_DrawLineTo       (int x,  int y);
Nvoid GL_DrawLineToEx     (int x,  int y, unsigned * pPixelCnt);
Nvoid GL_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GL_DrawLineEx       (int x0, int y0, int x1, int y1, unsigned * pPixelCnt);
Nvoid GL_MoveTo           (int x,  int y);
Nvoid GL_FillCircle       (int x0, int y0, int r);
Nvoid GL_FillCircleAA     (int x0, int y0, int r);
Nvoid GL_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GL_FillPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GL_SetDefault       (void);
N
N/*********************************************************************
N*
N*       Replacement of memcpy() and memset()
N*
N**********************************************************************
N*/
N//
N// Configurable function pointers
N//
Nextern void * (* GUI__pfMemset)(void * pDest, int Fill, size_t Cnt);
Nextern void * (* GUI__pfMemcpy)(void * pDest, const void * pSrc, size_t Cnt);
N
Nextern int    (* GUI__pfStrcmp)(const char *, const char *);
Nextern size_t (* GUI__pfStrlen)(const char *);
Nextern char * (* GUI__pfStrcpy)(char *, const char *);
N//
N// Macros for typesave use of function pointers
N//
N#define GUI__MEMSET(pDest, Fill, Cnt) GUI__pfMemset((void *)(pDest), (int)(Fill), (size_t)(Cnt))
N#define GUI__MEMCPY(pDest, pSrc, Cnt) GUI__pfMemcpy((void *)(pDest), (const void *)(pSrc), (size_t)(Cnt))
N
N/*********************************************************************
N*
N*       Callback pointers for dynamic linkage
N*
N**********************************************************************
NDynamic linkage pointers reduces configuration hassles.
N*/
Ntypedef int  GUI_tfTimer(void);
Ntypedef int  WM_tfHandlePID(void);
N
N/*********************************************************************
N*
N*       Text rotation
N*
N**********************************************************************
N*/
Nextern GUI_RECT  GUI_RectDispString; /* Used by LCD_Rotate...() and GUI_DispStringInRect() */
N
N/*********************************************************************
N*
N*       Flag for setting transparency for 'EXT' fonts
N*
N**********************************************************************
N*/
Nextern U8 GUI__CharHasTrans;
Xextern unsigned char GUI__CharHasTrans;
N
N/*********************************************************************
N*
N*       Multitasking support
N*
N**********************************************************************
N*/
Nextern int GUITASK__EntranceCnt;
N
N/*********************************************************************
N*
N*       Bitmap related functions
N*
N**********************************************************************
N*/
N
Nint       GUI_GetBitmapPixelIndex(const GUI_BITMAP * pBMP, unsigned x, unsigned y);
NGUI_COLOR GUI_GetBitmapPixelColor(const GUI_BITMAP * pBMP, unsigned x, unsigned y);
Nint       GUI_GetBitmapPixelIndexEx(int BitsPerPixel, int BytesPerLine, const U8 * pData, unsigned x, unsigned y);
Xint       GUI_GetBitmapPixelIndexEx(int BitsPerPixel, int BytesPerLine, const unsigned char * pData, unsigned x, unsigned y);
N
Nvoid      GUI__DrawBitmap16bpp (int x0, int y0, int xsize, int ysize, const U8 * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color, const LCD_API_COLOR_CONV * pColorConvAPI);
Xvoid      GUI__DrawBitmap16bpp (int x0, int y0, int xsize, int ysize, const unsigned char * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color, const LCD_API_COLOR_CONV * pColorConvAPI);
Nvoid      GUI__DrawBitmapA16bpp(int x0, int y0, int xSize, int ySize, const U8 * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color);
Xvoid      GUI__DrawBitmapA16bpp(int x0, int y0, int xSize, int ySize, const unsigned char * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color);
Nvoid      GUI__SetPixelAlpha   (int x, int y, U8 Alpha, LCD_COLOR Color);
Xvoid      GUI__SetPixelAlpha   (int x, int y, unsigned char Alpha, LCD_COLOR Color);
NLCD_COLOR GUI__MixColors       (LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR GUI__MixColors       (LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
Nvoid      GUI__MixColorsBulk   (U32 * pFG, U32 * pBG, U32 * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, U8 Intens);
Xvoid      GUI__MixColorsBulk   (unsigned long * pFG, unsigned long * pBG, unsigned long * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, unsigned char Intens);
N
Nextern const GUI_UC_ENC_APILIST GUI_UC_None;
N
N/*********************************************************************
N*
N*       LCDDEV_L0_xxx
N*
N**********************************************************************
N*/
N#define LCDDEV_L0_Color2Index         GUI__apDevice[GUI_pContext->SelLayer]->pColorConvAPI->pfColor2Index
N#define LCDDEV_L0_Index2Color         GUI__apDevice[GUI_pContext->SelLayer]->pColorConvAPI->pfIndex2Color
N
N#define LCDDEV_L0_DrawBitmap          GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawBitmap
N#define LCDDEV_L0_DrawHLine           GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawHLine
N#define LCDDEV_L0_DrawVLine           GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawVLine
N#define LCDDEV_L0_DrawPixel           GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawPixel
N#define LCDDEV_L0_FillRect            GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfFillRect
N#define LCDDEV_L0_GetPixel            GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetPixel
N#define LCDDEV_L0_GetRect             GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetRect
N#define LCDDEV_L0_GetPixelIndex       GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetPixelIndex
N#define LCDDEV_L0_SetPixelIndex       GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfSetPixelIndex
N#define LCDDEV_L0_XorPixel            GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfXorPixel
N#define LCDDEV_L0_GetDevFunc          GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetDevFunc
N
Nvoid LCD_ReadRect  (int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid LCD_ReadRect  (int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
Nvoid GUI_ReadRect  (int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid GUI_ReadRect  (int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
Nvoid GUI_ReadRectEx(int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid GUI_ReadRectEx(int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
N
Nvoid LCD_ReadRectNoClip(int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid LCD_ReadRectNoClip(int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
N
N/*********************************************************************
N*
N*       Internal color management
N*
N**********************************************************************
N*/
Ntypedef struct {
N  void         (* pfSetColor)   (LCD_COLOR Index);
N  void         (* pfSetBkColor) (LCD_COLOR Index);
N  LCD_DRAWMODE (* pfSetDrawMode)(LCD_DRAWMODE dm);
N} LCD_SET_COLOR_API;
N
Nextern const LCD_SET_COLOR_API * LCD__pSetColorAPI;
N
N#define LCD__SetBkColorIndex(Index) (*GUI_pContext->LCD_pBkColorIndex = Index)
N#define LCD__SetColorIndex(Index)   (*GUI_pContext->LCD_pColorIndex   = Index)
N#define LCD__GetBkColorIndex()      (*GUI_pContext->LCD_pBkColorIndex)
N#define LCD__GetColorIndex()        (*GUI_pContext->LCD_pColorIndex)
N
N/* The following 2 defines are only required for compatibility to older versions of the TTF library */
N#define LCD_BKCOLORINDEX (*GUI_pContext->LCD_pBkColorIndex)
N#define LCD_COLORINDEX   (*GUI_pContext->LCD_pColorIndex)
N
N/*********************************************************************
N*
N*       EXTERNs for GL_CORE
N*
N**********************************************************************
N*/
Nextern const GUI_FONT * GUI__pFontDefault;
Nextern GUI_COLOR        GUI__ColorDefault;
Nextern GUI_COLOR        GUI__BkColorDefault;
N
Nextern GUI_SADDR GUI_CONTEXT * GUI_pContext;
Xextern  GUI_CONTEXT * GUI_pContext;
N
Nextern GUI_DEVICE * GUI__apDevice[GUI_NUM_LAYERS];
Xextern GUI_DEVICE * GUI__apDevice[1];
N
N//
N// Function pointer for converting a palette containing a color array into an index array
N//
Nextern LCD_PIXELINDEX * (* GUI_pfGetpPalConvTable)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
Xextern unsigned long * (* GUI_pfGetpPalConvTable)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
N
N//
N// Function pointer for mixing up 2 colors
N//
Nextern LCD_COLOR (* GUI__pfMixColors)(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
Xextern LCD_COLOR (* GUI__pfMixColors)(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
N
N//
N// Function pointer for mixing up arrays of colors
N//
Nextern void (* GUI__pfMixColorsBulk)(U32 * pFG, U32 * pBG, U32 * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, U8 Intens);
Xextern void (* GUI__pfMixColorsBulk)(unsigned long * pFG, unsigned long * pBG, unsigned long * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, unsigned char Intens);
N
N//
N// Function pointer for mixing color and gamma values
N//
Nextern LCD_COLOR (* LCD_AA_pfMixColors16)(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
Xextern LCD_COLOR (* LCD_AA_pfMixColors16)(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
N
N//
N// Function pointer for drawing alpha memory devices
N//
Nextern GUI_DRAWMEMDEV_FUNC   * GUI__pfDrawAlphaMemdevFunc;
Xextern GUI_DRAWMEMDEV_16BPP_FUNC   * GUI__pfDrawAlphaMemdevFunc;
Nextern GUI_DRAWMEMDEV_FUNC   * GUI__pfDrawM565MemdevFunc;
Xextern GUI_DRAWMEMDEV_16BPP_FUNC   * GUI__pfDrawM565MemdevFunc;
N
N//
N// Function pointer for drawing alpha bitmaps
N//
Nextern GUI_DRAWBITMAP_FUNC * GUI__pfDrawAlphaBitmapFunc;
Nextern GUI_DRAWBITMAP_FUNC * GUI__pfDrawM565BitmapFunc;
N
Nextern U8 GUI__DrawStreamedBitmap;
Xextern unsigned char GUI__DrawStreamedBitmap;
N
N//
N// API list to be used for MultiBuffering
N//
Nextern const GUI_MULTIBUF_API    GUI_MULTIBUF_APIList;
Nextern const GUI_MULTIBUF_API    GUI_MULTIBUF_APIListMasked;
Nextern const GUI_MULTIBUF_API_EX GUI_MULTIBUF_APIListEx;
N
N#ifdef  GL_CORE_C
S  #define GUI_EXTERN
N#else
N  #define GUI_EXTERN extern
N#endif
N
NGUI_EXTERN   void (* GUI_pfExecAnimations)(void);
Xextern   void (* GUI_pfExecAnimations)(void);
NGUI_EXTERN   int  (* GUI_pfUpdateSoftLayer)(void);
Xextern   int  (* GUI_pfUpdateSoftLayer)(void);
N
N#ifdef WIN32
S  GUI_EXTERN void (* GUI_pfSoftlayerGetPixel)(int x, int y, void * p);
N#endif
N
NGUI_EXTERN void (* GUI_pfHookMTOUCH)(const GUI_MTOUCH_STATE * pState);
Xextern void (* GUI_pfHookMTOUCH)(const GUI_MTOUCH_STATE * pState);
N
NGUI_EXTERN const GUI_UC_ENC_APILIST * GUI_pUC_API; /* Unicode encoding API */
Xextern const GUI_UC_ENC_APILIST * GUI_pUC_API;  
N
NGUI_EXTERN GUI_SADDR char             GUI_DecChar;
Xextern  char             GUI_DecChar;
NGUI_EXTERN           GUI_tfTimer    * GUI_pfTimerExec;
Xextern           GUI_tfTimer    * GUI_pfTimerExec;
NGUI_EXTERN           WM_tfHandlePID * WM_pfHandlePID;
Xextern           WM_tfHandlePID * WM_pfHandlePID;
NGUI_EXTERN   void (* GUI_pfDispCharStyle)(U16 Char);
Xextern   void (* GUI_pfDispCharStyle)(unsigned short Char);
NGUI_EXTERN   void (* GUI_pfDispCharLine)(int x0);
Xextern   void (* GUI_pfDispCharLine)(int x0);
N
NGUI_EXTERN           int GUI__BufferSize; // Required buffer size in pixels for alpha blending and/or antialiasing
Xextern           int GUI__BufferSize; 
NGUI_EXTERN           int GUI_AA__ClipX0;  // x0-clipping value for AA module
Xextern           int GUI_AA__ClipX0;  
N
NGUI_EXTERN           I8  GUI__aNumBuffers[GUI_NUM_LAYERS]; // Number of buffers used per layer
Xextern           signed char  GUI__aNumBuffers[1]; 
NGUI_EXTERN           U8  GUI__PreserveTrans;
Xextern           unsigned char  GUI__PreserveTrans;
NGUI_EXTERN           U8  GUI__IsInitialized;
Xextern           unsigned char  GUI__IsInitialized;
N
NGUI_EXTERN           U8  GUI__NumLayersInUse;
Xextern           unsigned char  GUI__NumLayersInUse;
NGUI_EXTERN           U32 GUI__LayerMask;
Xextern           unsigned long GUI__LayerMask;
N
N#if GUI_SUPPORT_ROTATION
X#if 1
N  GUI_EXTERN const tLCD_APIList * GUI_pLCD_APIList; /* Used for rotating text */
X  extern const tLCD_APIList * GUI_pLCD_APIList;  
N#endif
N
NGUI_EXTERN I16 GUI_OrgX, GUI_OrgY;
Xextern signed short GUI_OrgX, GUI_OrgY;
N
N#undef GUI_EXTERN
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif /* GUI_PRIVATE_H */
N
N/*************************** End of file ****************************/
L 49 "..\..\..\ThirdParty\emWin\Include\WM_Intern.h" 2
N
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       defines
N*
N**********************************************************************
N
N  The following could be placed in a file of its own as it is not
N  used outside of the window manager
N
N*/
N/* Basic Windows status flags.
N   For module-internally use only !
N*/
N#define WM_SF_HASTRANS          WM_CF_HASTRANS
N#define WM_SF_MEMDEV            WM_CF_MEMDEV
N#define WM_SF_MEMDEV_ON_REDRAW  WM_CF_MEMDEV_ON_REDRAW
N#define WM_SF_DISABLED          WM_CF_DISABLED  /* Disabled: Does not receive PID (mouse & touch) input */
N#define WM_SF_ISVIS             WM_CF_SHOW      /* Is visible flag */
N
N#define WM_SF_STAYONTOP         WM_CF_STAYONTOP
N#define WM_SF_LATE_CLIP         WM_CF_LATE_CLIP
N#define WM_SF_ANCHOR_RIGHT      WM_CF_ANCHOR_RIGHT
N#define WM_SF_ANCHOR_BOTTOM     WM_CF_ANCHOR_BOTTOM
N#define WM_SF_ANCHOR_LEFT       WM_CF_ANCHOR_LEFT
N#define WM_SF_ANCHOR_TOP        WM_CF_ANCHOR_TOP
N
N#define WM_SF_INVALID           WM_CF_ACTIVATE  /* We reuse this flag, as it is create only and Invalid is status only */
N
N#define WM_SF_CONST_OUTLINE     WM_CF_CONST_OUTLINE       /* Constant outline.*/
N
N#define WM_H2P(hWin)            ((WM_Obj*)GUI_ALLOC_h2p(hWin))
N
N
N#if GUI_DEBUG_LEVEL  >= GUI_DEBUG_LEVEL_LOG_WARNINGS
X#if 0  >= 4
S  #define WM_ASSERT_NOT_IN_PAINT() { if (WM__PaintCallbackCnt) \
S                                       GUI_DEBUG_ERROROUT("Function may not be called from within a paint event"); \
S                                   }
X  #define WM_ASSERT_NOT_IN_PAINT() { if (WM__PaintCallbackCnt)                                        GUI_DEBUG_ERROROUT("Function may not be called from within a paint event");                                    }
N#else
N  #define WM_ASSERT_NOT_IN_PAINT()
N#endif
N
N/*********************************************************************
N*
N*       Data types & structures
N*
N**********************************************************************
N*/
Ntypedef struct {
N  WM_HWIN hOld;
X  GUI_HWIN hOld;
N  WM_HWIN hNew;
X  GUI_HWIN hNew;
N} WM_NOTIFY_CHILD_HAS_FOCUS_INFO;
N
Ntypedef struct WM_CRITICAL_HANDLE {
N  struct  WM_CRITICAL_HANDLE * pNext;
N  volatile WM_HWIN hWin;
X  volatile GUI_HWIN hWin;
N} WM_CRITICAL_HANDLE;
N
N/*********************************************************************
N*
N*       Data (extern)
N*
N**********************************************************************
N*/
Nextern U32            WM__CreateFlags;
Xextern unsigned long            WM__CreateFlags;
Nextern WM_HWIN        WM__ahCapture[GUI_NUM_LAYERS];
Xextern GUI_HWIN        WM__ahCapture[1];
Nextern WM_HWIN        WM__ahWinFocus[GUI_NUM_LAYERS];
Xextern GUI_HWIN        WM__ahWinFocus[1];
Nextern char           WM__CaptureReleaseAuto;
Nextern WM_tfPollPID * WM_pfPollPID;
Nextern U8             WM__PaintCallbackCnt;      /* Public for assertions only */
Xextern unsigned char             WM__PaintCallbackCnt;       
Nextern WM_HWIN        WM__hCreateStatic;
Xextern GUI_HWIN        WM__hCreateStatic;
N
N#if WM_SUPPORT_TRANSPARENCY
X#if 1
N  extern int     WM__TransWindowCnt;
N  extern WM_HWIN WM__hATransWindow;
X  extern GUI_HWIN WM__hATransWindow;
N#endif
N
N#if WM_SUPPORT_DIAG
X#if 0
S  extern void (*WM__pfShowInvalid)(WM_HWIN hWin);
N#endif
N
Nextern WM_CRITICAL_HANDLE     WM__aCHWinModal[GUI_NUM_LAYERS];
Xextern WM_CRITICAL_HANDLE     WM__aCHWinModal[1];
Nextern WM_CRITICAL_HANDLE     WM__aCHWinLast[GUI_NUM_LAYERS];
Xextern WM_CRITICAL_HANDLE     WM__aCHWinLast[1];
Nextern int                    WM__ModalLayer;
N
N#if GUI_SUPPORT_MOUSE
X#if 1
N  extern WM_CRITICAL_HANDLE   WM__aCHWinMouseOver[GUI_NUM_LAYERS];
X  extern WM_CRITICAL_HANDLE   WM__aCHWinMouseOver[1];
N#endif
N
N#ifdef WM_C
S  #define GUI_EXTERN
N#else
N  #define GUI_EXTERN extern
N#endif
N
N#if (GUI_NUM_LAYERS > 1)
X#if (1 > 1)
S  GUI_EXTERN U32                       WM__InvalidLayerMask;
S  GUI_EXTERN unsigned                  WM__TouchedLayer;
S  #define WM__TOUCHED_LAYER            WM__TouchedLayer
N#else
N  #define WM__TOUCHED_LAYER            GUI_CURSOR_LAYER
N#endif
N
NGUI_EXTERN U16     WM__NumWindows;
Xextern unsigned short     WM__NumWindows;
NGUI_EXTERN U16     WM__NumInvalidWindows;
Xextern unsigned short     WM__NumInvalidWindows;
NGUI_EXTERN WM_HWIN WM__FirstWin;
Xextern GUI_HWIN WM__FirstWin;
NGUI_EXTERN WM_CRITICAL_HANDLE * WM__pFirstCriticalHandle;
Xextern WM_CRITICAL_HANDLE * WM__pFirstCriticalHandle;
N
NGUI_EXTERN WM_HWIN   WM__ahDesktopWin[GUI_NUM_LAYERS];
Xextern GUI_HWIN   WM__ahDesktopWin[1];
NGUI_EXTERN GUI_COLOR WM__aBkColor[GUI_NUM_LAYERS];
Xextern GUI_COLOR WM__aBkColor[1];
N
N#undef GUI_EXTERN
N
N/*********************************************************************
N*
N*       Prototypes
N*
N**********************************************************************
N*/
Nvoid    WM__ActivateClipRect        (void);
Nint     WM__ClipAtParentBorders     (GUI_RECT * pRect, WM_HWIN hWin);
Xint     WM__ClipAtParentBorders     (GUI_RECT * pRect, GUI_HWIN hWin);
Nvoid    WM__Client2Screen           (const WM_Obj * pWin, GUI_RECT * pRect);
Nvoid    WM__DeleteAssocTimer        (WM_HWIN hWin);
Xvoid    WM__DeleteAssocTimer        (GUI_HWIN hWin);
Nvoid    WM__DeleteSecure            (WM_HWIN hWin);
Xvoid    WM__DeleteSecure            (GUI_HWIN hWin);
Nvoid    WM__DetachWindow            (WM_HWIN hChild);
Xvoid    WM__DetachWindow            (GUI_HWIN hChild);
Nvoid    WM__ForEachDesc             (WM_HWIN hWin, WM_tfForEach * pcb, void * pData);
Xvoid    WM__ForEachDesc             (GUI_HWIN hWin, WM_tfForEach * pcb, void * pData);
Nvoid    WM__GetClientRectWin        (const WM_Obj * pWin, GUI_RECT * pRect);
Nvoid    WM__GetClientRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid    WM__GetClientRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
NWM_HWIN WM__GetFirstSibling         (WM_HWIN hWin);
XGUI_HWIN WM__GetFirstSibling         (GUI_HWIN hWin);
NWM_HWIN WM__GetFocusedChild         (WM_HWIN hWin);
XGUI_HWIN WM__GetFocusedChild         (GUI_HWIN hWin);
Nint     WM__GetHasFocus             (WM_HWIN hWin);
Xint     WM__GetHasFocus             (GUI_HWIN hWin);
NWM_HWIN WM__GetLastSibling          (WM_HWIN hWin);
XGUI_HWIN WM__GetLastSibling          (GUI_HWIN hWin);
NWM_HWIN WM__GetPrevSibling          (WM_HWIN hWin);
XGUI_HWIN WM__GetPrevSibling          (GUI_HWIN hWin);
Nint     WM__GetTopLevelLayer        (WM_HWIN hWin);
Xint     WM__GetTopLevelLayer        (GUI_HWIN hWin);
Nint     WM__GetWindowSizeX          (const WM_Obj * pWin);
Nint     WM__GetWindowSizeY          (const WM_Obj * pWin);
Nvoid    WM__InsertWindowIntoList    (WM_HWIN hWin, WM_HWIN hParent);
Xvoid    WM__InsertWindowIntoList    (GUI_HWIN hWin, GUI_HWIN hParent);
Nvoid    WM__Invalidate1Abs          (WM_HWIN hWin, const GUI_RECT * pRect);
Xvoid    WM__Invalidate1Abs          (GUI_HWIN hWin, const GUI_RECT * pRect);
Nvoid    WM__InvalidateAreaBelow     (const GUI_RECT * pRect, WM_HWIN StopWin);
Xvoid    WM__InvalidateAreaBelow     (const GUI_RECT * pRect, GUI_HWIN StopWin);
Nvoid    WM__InvalidateRectEx        (const GUI_RECT * pInvalidRect, WM_HWIN hParent, WM_HWIN hStop);
Xvoid    WM__InvalidateRectEx        (const GUI_RECT * pInvalidRect, GUI_HWIN hParent, GUI_HWIN hStop);
Nvoid    WM__InvalidateTransAreaAbove(const GUI_RECT * pRect, WM_HWIN StopWin);
Xvoid    WM__InvalidateTransAreaAbove(const GUI_RECT * pRect, GUI_HWIN StopWin);
Nint     WM__IntersectRect           (GUI_RECT * pDest, const GUI_RECT * pr0, const GUI_RECT * pr1);
Nint     WM__IsAncestor              (WM_HWIN hChild, WM_HWIN hParent);
Xint     WM__IsAncestor              (GUI_HWIN hChild, GUI_HWIN hParent);
Nint     WM__IsAncestorOrSelf        (WM_HWIN hChild, WM_HWIN hParent);
Xint     WM__IsAncestorOrSelf        (GUI_HWIN hChild, GUI_HWIN hParent);
Nint     WM__IsChild                 (WM_HWIN hWin, WM_HWIN hParent);
Xint     WM__IsChild                 (GUI_HWIN hWin, GUI_HWIN hParent);
Nint     WM__IsEnabled               (WM_HWIN hWin);
Xint     WM__IsEnabled               (GUI_HWIN hWin);
Nint     WM__IsInModalArea           (WM_HWIN hWin);
Xint     WM__IsInModalArea           (GUI_HWIN hWin);
Nint     WM__IsInWindow              (WM_Obj * pWin, int x, int y);
Nint     WM__IsWindow                (WM_HWIN hWin);
Xint     WM__IsWindow                (GUI_HWIN hWin);
Nvoid    WM__LeaveIVRSearch          (void);
Nvoid    WM__MoveTo                  (WM_HWIN hWin, int x, int y);
Xvoid    WM__MoveTo                  (GUI_HWIN hWin, int x, int y);
Nvoid    WM__MoveWindow              (WM_HWIN hWin, int dx, int dy);
Xvoid    WM__MoveWindow              (GUI_HWIN hWin, int dx, int dy);
Nvoid    WM__NotifyVisChanged        (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid    WM__NotifyVisChanged        (GUI_HWIN hWin, GUI_RECT * pRect);
Nint     WM__RectIsNZ                (const GUI_RECT * pr);
Nvoid    WM__RemoveWindowFromList    (WM_HWIN hWin);
Xvoid    WM__RemoveWindowFromList    (GUI_HWIN hWin);
Nvoid    WM__Screen2Client           (const WM_Obj * pWin, GUI_RECT * pRect);
Nvoid    WM__SelectTopLevelLayer     (WM_HWIN  hWin);
Xvoid    WM__SelectTopLevelLayer     (GUI_HWIN  hWin);
Nvoid    WM__SendMsgNoData           (WM_HWIN hWin, U8 MsgId);
Xvoid    WM__SendMsgNoData           (GUI_HWIN hWin, unsigned char MsgId);
Nvoid    WM__SendMessage             (WM_HWIN hWin, WM_MESSAGE * pm);
Xvoid    WM__SendMessage             (GUI_HWIN hWin, WM_MESSAGE * pm);
Nvoid    WM__SendMessageIfEnabled    (WM_HWIN hWin, WM_MESSAGE * pm);
Xvoid    WM__SendMessageIfEnabled    (GUI_HWIN hWin, WM_MESSAGE * pm);
Nvoid    WM__SendMessageNoPara       (WM_HWIN hWin, int MsgId);
Xvoid    WM__SendMessageNoPara       (GUI_HWIN hWin, int MsgId);
Nvoid    WM__SendPIDMessage          (WM_HWIN hWin, WM_MESSAGE * pMsg);
Xvoid    WM__SendPIDMessage          (GUI_HWIN hWin, WM_MESSAGE * pMsg);
Nint     WM__SetScrollbarH           (WM_HWIN hWin, int OnOff);
Xint     WM__SetScrollbarH           (GUI_HWIN hWin, int OnOff);
Nint     WM__SetScrollbarV           (WM_HWIN hWin, int OnOff);
Xint     WM__SetScrollbarV           (GUI_HWIN hWin, int OnOff);
Nvoid    WM__UpdateChildPositions    (WM_Obj * pObj, int dx0, int dy0, int dx1, int dy1);
Nvoid    WM_PID__GetPrevState        (GUI_PID_STATE * pPrevState, int Layer);
Nvoid    WM_PID__SetPrevState        (GUI_PID_STATE * pPrevState, int Layer);
Nvoid    WM__SendTouchMessage        (WM_HWIN hWin, WM_MESSAGE * pMsg);
Xvoid    WM__SendTouchMessage        (GUI_HWIN hWin, WM_MESSAGE * pMsg);
N
NU16     WM_GetFlags                 (WM_HWIN hWin);
Xunsigned short     WM_GetFlags                 (GUI_HWIN hWin);
Nint     WM__Paint                   (WM_HWIN hWin);
Xint     WM__Paint                   (GUI_HWIN hWin);
Nvoid    WM__Paint1                  (WM_HWIN hWin);
Xvoid    WM__Paint1                  (GUI_HWIN hWin);
Nvoid    WM__AddCriticalHandle       (WM_CRITICAL_HANDLE * pCH);
Nvoid    WM__RemoveCriticalHandle    (WM_CRITICAL_HANDLE * pCH);
Nvoid    WM__SetLastTouched          (WM_HWIN hWin);
Xvoid    WM__SetLastTouched          (GUI_HWIN hWin);
N
N#if WM_SUPPORT_STATIC_MEMDEV
X#if 1
N  void    WM__InvalidateDrawAndDescs(WM_HWIN hWin);
X  void    WM__InvalidateDrawAndDescs(GUI_HWIN hWin);
N#else
S  #define WM__InvalidateDrawAndDescs(hWin)
N#endif
N
N/* Static memory devices */
N#if (GUI_SUPPORT_MEMDEV)
X#if (1)
N  typedef struct {
N    int xSize, ySize; // Size of bk window
N  } EFFECT_CONTEXT;
N
N  int  GUI_MEMDEV__CalcParaFadeIn    (int Period, int TimeUsed);
N  void GUI_MEMDEV__ClipBK            (EFFECT_CONTEXT * pContext);
N  void GUI_MEMDEV__RemoveStaticDevice(WM_HWIN hWin);
X  void GUI_MEMDEV__RemoveStaticDevice(GUI_HWIN hWin);
N  void GUI_MEMDEV__UndoClipBK        (EFFECT_CONTEXT * pContext);
N#endif
N
Nvoid WM__InvalidateParent(const GUI_RECT * pInvalidRect, WM_HWIN hParent, WM_HWIN hStop);
Xvoid WM__InvalidateParent(const GUI_RECT * pInvalidRect, GUI_HWIN hParent, GUI_HWIN hStop);
Nvoid WM__InvalidateRect  (const GUI_RECT * pInvalidRect, WM_HWIN hParent, WM_HWIN hStop, U16 Flags);
Xvoid WM__InvalidateRect  (const GUI_RECT * pInvalidRect, GUI_HWIN hParent, GUI_HWIN hStop, unsigned short Flags);
N
NWM_tfInvalidateParent   WM__SetInvalidateParentFunc(WM_tfInvalidateParent pfInvalidateParentFunc);
NWM_tfInvalidateDrawFunc WM__SetInvalidateDrawFunc  (WM_tfInvalidateDrawFunc pfInvalidateDrawFunc);
NWM_tfPaint1Func         WM__SetPaint1Func          (WM_tfPaint1Func pfPaint1Func);
N
N#endif   /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* WM_INTERN_H */
N
N/*************************** End of file ****************************/
L 52 "..\..\..\ThirdParty\emWin\Include\WIDGET.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Typedefs
N*
N**********************************************************************
N*/
Ntypedef struct {
N  WM_HWIN    hWin;
X  GUI_HWIN    hWin;
N  int        Cmd;         /* WIDGET_ITEM_GET_XSIZE, WIDGET_ITEM_GET_YSIZE, WIDGET_ITEM_DRAW, */
N  int        ItemIndex;
N  int        Col;
N  int        x0, y0, x1, y1;
N  void     * p;
N} WIDGET_ITEM_DRAW_INFO;
N
Ntypedef int  WIDGET_DRAW_ITEM_FUNC(const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Ntypedef void WIDGET_PAINT         (WM_HWIN hObj);
Xtypedef void WIDGET_PAINT         (GUI_HWIN hObj);
Ntypedef void WIDGET_CREATE        (WM_HWIN hObj);
Xtypedef void WIDGET_CREATE        (GUI_HWIN hObj);
N
Ntypedef struct {
N  WIDGET_PAINT  * pfPaint;
N  WIDGET_CREATE * pfCreate;
N  void          * pSkinPrivate;
N} WIDGET_SKIN;
N
N/*********************************************************************
N*
N*       Important: WIDGET_DRAW_ITEM_FUNC needs to be defined
N*                  in SCROLLBAR.h!
N*
N**********************************************************************
N*/
N#include "SCROLLBAR.h"
L 1 "..\..\..\ThirdParty\emWin\Include\SCROLLBAR.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : SCROLLBAR.h
NPurpose     : SCROLLBAR include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef SCROLLBAR_H
N#define SCROLLBAR_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
L 1 "..\..\..\ThirdParty\emWin\Include\WIDGET.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WIDGET.h
NPurpose     : Widget interface
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef WIDGET_H        /* Avoid multiple inclusion  */
S#define WIDGET_H
S
S#if defined(__cplusplus)
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
S#endif
S
S#include "WM_Intern.h"  /* Window manager, including some internals, which speed things up */
S
S#if GUI_WINSUPPORT
S
S/*********************************************************************
S*
S*       Typedefs
S*
S**********************************************************************
S*/
Stypedef struct {
S  WM_HWIN    hWin;
S  int        Cmd;         /* WIDGET_ITEM_GET_XSIZE, WIDGET_ITEM_GET_YSIZE, WIDGET_ITEM_DRAW, */
S  int        ItemIndex;
S  int        Col;
S  int        x0, y0, x1, y1;
S  void     * p;
S} WIDGET_ITEM_DRAW_INFO;
S
Stypedef int  WIDGET_DRAW_ITEM_FUNC(const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Stypedef void WIDGET_PAINT         (WM_HWIN hObj);
Stypedef void WIDGET_CREATE        (WM_HWIN hObj);
S
Stypedef struct {
S  WIDGET_PAINT  * pfPaint;
S  WIDGET_CREATE * pfCreate;
S  void          * pSkinPrivate;
S} WIDGET_SKIN;
S
S/*********************************************************************
S*
S*       Important: WIDGET_DRAW_ITEM_FUNC needs to be defined
S*                  in SCROLLBAR.h!
S*
S**********************************************************************
S*/
S#include "SCROLLBAR.h"
S
S/*********************************************************************
S*
S*       Defines
S*
S**********************************************************************
S*/
S/*********************************************************************
S*
S*       Unique widget id's
S*/
S#define BUTTON_ID    0x42555454UL /* BUTT */
S#define CHECKBOX_ID  0x43484543UL /* CHEC */
S#define DROPDOWN_ID  0x44524f50UL /* DROP */
S#define EDIT_ID      0x45444954UL /* EDIT */
S#define FRAMEWIN_ID  0x4652414dUL /* FRAM */
S#define FRAMECLNT_ID 0x46524143UL /* FRAC */
S#define GRAPH_ID     0x47524150UL /* GRAP */
S#define HEADER_ID    0x48454144UL /* HEAD */
S#define LISTBOX_ID   0x4C495342UL /* LISB */
S#define LISTVIEW_ID  0x4C495356UL /* LISV */
S#define LISTWHEEL_ID 0x4C495357UL /* LISW */
S#define MENU_ID      0x4d454e55UL /* MENU */
S#define MULTIEDIT_ID 0x4d554c45UL /* MULE */
S#define MULTIPAGE_ID 0x4d554c50UL /* MULP */
S#define MPAGECLNT_ID 0x4d50434CUL /* MPCL */
S#define PROGBAR_ID   0x50524f47UL /* PROG */
S#define RADIO_ID     0x52414449UL /* RADI */
S#define SCROLLBAR_ID 0x5343524fUL /* SCRO */
S#define SLIDER_ID    0x534c4944UL /* SLID */
S#define SWIPELIST_ID 0x53574950UL /* SWIP */
S#define TEXT_ID      0x54455854UL /* TEXT */
S#define TREEVIEW_ID  0x54524545UL /* TREE */
S#define ICONVIEW_ID  0x49434f4eUL /* ICON */
S#define IMAGE_ID     0x494d4147UL /* IMAG */
S#define SPINBOX_ID   0x5350494eUL /* SPIN */
S#define KNOB_ID      0x4b4e4f42UL /* KNOB */
S#define WINDOW_ID    0x57494e44UL /* WIND */
S
S#define WIDGET_LOCK(hWin)       ((WIDGET*)GUI_LOCK_H(hWin))
S
S/*********************************************************************
S*
S*       Config switches
S*/
S
S#ifndef   WIDGET_USE_PARENT_EFFECT
S  #define WIDGET_USE_PARENT_EFFECT 0
S#endif
S#ifndef   WIDGET_USE_FLEX_SKIN
S  #if WM_SUPPORT_TRANSPARENCY
S    #define WIDGET_USE_FLEX_SKIN     1
S  #else
S    #define WIDGET_USE_FLEX_SKIN     0
S  #endif
S#endif
S#if !defined(WIDGET_USE_SCHEME_SMALL) && !defined(WIDGET_USE_SCHEME_MEDIUM) && !defined(WIDGET_USE_SCHEME_LARGE)
S  #define WIDGET_USE_SCHEME_SMALL  1
S  #define WIDGET_USE_SCHEME_MEDIUM 0
S  #define WIDGET_USE_SCHEME_LARGE  0
S#endif
S#ifndef   WIDGET_USE_SCHEME_SMALL
S  #define WIDGET_USE_SCHEME_SMALL  0
S#endif
S#ifndef   WIDGET_USE_SCHEME_MEDIUM
S  #define WIDGET_USE_SCHEME_MEDIUM 0
S#endif
S#ifndef   WIDGET_USE_SCHEME_LARGE
S  #define WIDGET_USE_SCHEME_LARGE  0
S#endif
S#if (WIDGET_USE_SCHEME_SMALL + WIDGET_USE_SCHEME_MEDIUM + WIDGET_USE_SCHEME_LARGE) > 1
S  #error Only one scheme can be selected!
S#endif
S
S/*********************************************************************
S*
S*       States
S*/
S
S#define WIDGET_STATE_FOCUS              (1 << 0)
S#define WIDGET_STATE_VERTICAL           (1 << 3)
S#define WIDGET_STATE_FOCUSABLE          (1 << 4)
S
S#define WIDGET_STATE_USER0              (1 << 8)    /* Freely available for derived widget */
S#define WIDGET_STATE_USER1              (1 << 9)    /* Freely available for derived widget */
S#define WIDGET_STATE_USER2              (1 << 10)   /* Freely available for derived widget */
S
S#define WIDGET_STATE_FOCUSSABLE         WIDGET_STATE_FOCUSABLE
S
S/*********************************************************************
S*
S*       Skinning message identifiers
S*/
S#define WIDGET_ITEM_CREATE              0
S#define WIDGET_ITEM_DRAW                1
S#define WIDGET_ITEM_DRAW_ARROW          2
S#define WIDGET_ITEM_DRAW_ARROW_L        3
S#define WIDGET_ITEM_DRAW_ARROW_R        4
S#define WIDGET_ITEM_DRAW_BACKGROUND     5
S#define WIDGET_ITEM_DRAW_BITMAP         6
S#define WIDGET_ITEM_DRAW_BUTTON         7
S#define WIDGET_ITEM_DRAW_BUTTON_L       8
S#define WIDGET_ITEM_DRAW_BUTTON_R       9
S#define WIDGET_ITEM_DRAW_FOCUS         10
S#define WIDGET_ITEM_DRAW_FRAME         11
S#define WIDGET_ITEM_DRAW_OVERLAP       12
S#define WIDGET_ITEM_DRAW_OVERLAY       13
S#define WIDGET_ITEM_DRAW_SEP           14
S#define WIDGET_ITEM_DRAW_SHAFT         15
S#define WIDGET_ITEM_DRAW_SHAFT_L       16
S#define WIDGET_ITEM_DRAW_SHAFT_R       17
S#define WIDGET_ITEM_DRAW_TEXT          18
S#define WIDGET_ITEM_DRAW_THUMB         19
S#define WIDGET_ITEM_DRAW_TICKS         20
S#define WIDGET_ITEM_GET_BORDERSIZE_B   21
S#define WIDGET_ITEM_GET_BORDERSIZE_L   22
S#define WIDGET_ITEM_GET_BORDERSIZE_R   23
S#define WIDGET_ITEM_GET_BORDERSIZE_T   24
S#define WIDGET_ITEM_GET_BUTTONSIZE     25
S#define WIDGET_ITEM_GET_XSIZE          26
S#define WIDGET_ITEM_GET_YSIZE          27
S#define WIDGET_ITEM_GET_RADIUS         28
S#define WIDGET_ITEM_APPLY_PROPS        29  // Not to be documented. Use this message identifier to update the
S                                           // properties of attached widgets from <WIDGET>_DrawSkinFlex().
S#define WIDGET_DRAW_BACKGROUND         30
S
S#define WIDGET_DRAW_OVERLAY    WIDGET_ITEM_DRAW_OVERLAY
S
S/*********************************************************************
S*
S*       Messages
S*/
S
S#define WM_WIDGET_SET_EFFECT    (WM_WIDGET + 0)
S
S/*********************************************************************
S*
S*       Create flags
S*/
S
S#define WIDGET_CF_VERTICAL      WIDGET_STATE_VERTICAL
S
S/*********************************************************************
S*
S*        Widget object
S*
S* The widget object is the base class for most widgets
S*/
Stypedef struct {
S  int EffectSize;
S  void (* pfDrawUp)      (void);
S  void (* pfDrawUpRect)  (const GUI_RECT * pRect);
S  void (* pfDrawDown)    (void);
S  void (* pfDrawDownRect)(const GUI_RECT * pRect);
S  void (* pfDrawFlat)    (void);
S  void (* pfDrawFlatRect)(const GUI_RECT * pRect);
S} WIDGET_EFFECT;
S
Stypedef struct {
S  WM_Obj      Win;
S  const WIDGET_EFFECT* pEffect;
S  I16 Id;
S  U16 State;
S  #if GUI_DEBUG_LEVEL > 1
S    U32 DebugId;
S  #endif  
S} WIDGET;
S
S
S/*********************************************************************
S*
S*         GUI_DRAW
S*
S* The GUI_DRAW object is used as base class for selfdrawing,
S* non-windows objects. They are used as content of different widgets,
S* such as the bitmap or header widgets.
S*/
S/* Declare Object struct */
Stypedef struct GUI_DRAW GUI_DRAW;
Stypedef void   GUI_DRAW_SELF_CB (WM_HWIN hWin);
Stypedef WM_HMEM GUI_DRAW_HANDLE;
S
S/* Declare Object constants (member functions etc)  */
Stypedef struct {
S  void (* pfDraw)    (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
S  int  (* pfGetXSize)(GUI_DRAW_HANDLE hDrawObj);
S  int  (* pfGetYSize)(GUI_DRAW_HANDLE hDrawObj);
S} GUI_DRAW_CONSTS;
S
S/* Declare Object */
Sstruct GUI_DRAW {
S  const GUI_DRAW_CONSTS* pConsts;
S  union {
S    const void * pData;
S    GUI_DRAW_SELF_CB* pfDraw;
S  } Data;
S  I16 xOff, yOff;
S};
S
S/* GUI_DRAW_ API */
Svoid GUI_DRAW__Draw    (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
Sint  GUI_DRAW__GetXSize(GUI_DRAW_HANDLE hDrawObj);
Sint  GUI_DRAW__GetYSize(GUI_DRAW_HANDLE hDrawObj);
S
Svoid GUI_DrawStreamedEnableAuto(void);
S
S/* GUI_DRAW_ Constructurs for different objects */
SWM_HMEM GUI_DRAW_BITMAP_Create  (const GUI_BITMAP* pBitmap, int x, int y);
SWM_HMEM GUI_DRAW_BMP_Create     (const void* pBMP, int x, int y);
SWM_HMEM GUI_DRAW_STREAMED_Create(const GUI_BITMAP_STREAM * pBitmap, int x, int y);
SWM_HMEM GUI_DRAW_SELF_Create(GUI_DRAW_SELF_CB* pfDraw, int x, int y);
S
S/*********************************************************************
S*
S*       Global data
S*
S**********************************************************************
S*/
S
Sextern const WIDGET_EFFECT WIDGET_Effect_3D;
Sextern const WIDGET_EFFECT WIDGET_Effect_3D1L;
Sextern const WIDGET_EFFECT WIDGET_Effect_3D2L;
Sextern const WIDGET_EFFECT WIDGET_Effect_None;
Sextern const WIDGET_EFFECT WIDGET_Effect_Simple;
S
S/*********************************************************************
S*
S*       Internal API routines
S*
S**********************************************************************
S*/
S
Svoid      WIDGET__DrawFocusRect      (WIDGET * pWidget, const GUI_RECT * pRect, int Dist);
Svoid      WIDGET__DrawHLine          (WIDGET * pWidget, int y, int x0, int x1);
Svoid      WIDGET__DrawTriangle       (WIDGET * pWidget, int x, int y, int Size, int Inc);
Svoid      WIDGET__DrawVLine          (WIDGET * pWidget, int x, int y0, int y1);
Svoid      WIDGET__EFFECT_DrawDownRect(WIDGET * pWidget, GUI_RECT * pRect);
Svoid      WIDGET__EFFECT_DrawDown    (WIDGET * pWidget);
Svoid      WIDGET__EFFECT_DrawUpRect  (WIDGET * pWidget, GUI_RECT * pRect);
Svoid      WIDGET__FillRectEx         (WIDGET * pWidget, const GUI_RECT * pRect);
Sint       WIDGET__GetWindowSizeX     (WM_HWIN hWin);
SGUI_COLOR WIDGET__GetBkColor         (WM_HWIN hObj);
Sint       WIDGET__GetXSize           (const WIDGET * pWidget);
Sint       WIDGET__GetYSize           (const WIDGET * pWidget);
Svoid      WIDGET__GetClientRect      (WIDGET * pWidget, GUI_RECT * pRect);
Svoid      WIDGET__GetInsideRect      (WIDGET * pWidget, GUI_RECT * pRect);
Svoid      WIDGET__Init               (WIDGET * pWidget, int Id, U16 State);
Svoid      WIDGET__RotateRect90       (WIDGET * pWidget, GUI_RECT * pDest, const GUI_RECT * pRect);
Svoid      WIDGET__SetScrollState     (WM_HWIN hWin, const WM_SCROLL_STATE * pVState, const WM_SCROLL_STATE * pState);
Svoid      WIDGET__FillStringInRect   (const char * pText, const GUI_RECT * pFillRect, const GUI_RECT * pTextRectMax, const GUI_RECT * pTextRectAct);
S
S//
S// Function pointers for drawing streamed bitmaps
S//
Sextern void (* GUI__pfDrawStreamedBitmap)  (const void * p, int x, int y);
Sextern int  (* GUI__pfDrawStreamedBitmapEx)(GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
S
S/*********************************************************************
S*
S*       API routines
S*
S**********************************************************************
S*/
Svoid  WIDGET_SetState     (WM_HWIN hObj, int State);
Svoid  WIDGET_AndState     (WM_HWIN hObj, int State);
Svoid  WIDGET_OrState      (WM_HWIN hObj, int State);
Sint   WIDGET_HandleActive (WM_HWIN hObj, WM_MESSAGE* pMsg);
Sint   WIDGET_GetState     (WM_HWIN hObj);
Sint   WIDGET_SetWidth     (WM_HWIN hObj, int Width);
Svoid  WIDGET_SetFocusable (WM_HWIN hObj, int State);
S
Svoid  WIDGET_EFFECT_3D_DrawUp(void);
S
Sconst WIDGET_EFFECT* WIDGET_SetDefaultEffect(const WIDGET_EFFECT* pEffect);
S
Svoid  WIDGET_SetEffect              (WM_HWIN hObj, const WIDGET_EFFECT* pEffect);
S
Sconst WIDGET_EFFECT* WIDGET_GetDefaultEffect(void);
S
Svoid WIDGET_EFFECT_3D_SetColor    (unsigned Index, GUI_COLOR Color);
Svoid WIDGET_EFFECT_3D1L_SetColor  (unsigned Index, GUI_COLOR Color);
Svoid WIDGET_EFFECT_3D2L_SetColor  (unsigned Index, GUI_COLOR Color);
Svoid WIDGET_EFFECT_Simple_SetColor(unsigned Index, GUI_COLOR Color);
S
SGUI_COLOR WIDGET_EFFECT_3D_GetColor    (unsigned Index);
SGUI_COLOR WIDGET_EFFECT_3D1L_GetColor  (unsigned Index);
SGUI_COLOR WIDGET_EFFECT_3D2L_GetColor  (unsigned Index);
SGUI_COLOR WIDGET_EFFECT_Simple_GetColor(unsigned Index);
S
Sint WIDGET_EFFECT_3D_GetNumColors(void);
Sint WIDGET_EFFECT_3D1L_GetNumColors(void);
Sint WIDGET_EFFECT_3D2L_GetNumColors(void);
Sint WIDGET_EFFECT_Simple_GetNumColors(void);
S
S/*********************************************************************
S*
S*       Compatibility macros
S*
S**********************************************************************
S*/
S#define WIDGET_EnableStreamAuto() GUI_DrawStreamedEnableAuto()
S
S#define WIDGET_SetDefaultEffect_3D()     WIDGET_SetDefaultEffect(&WIDGET_Effect_3D)
S#define WIDGET_SetDefaultEffect_3D1L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D1L)
S#define WIDGET_SetDefaultEffect_3D2L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D2L)
S#define WIDGET_SetDefaultEffect_None()   WIDGET_SetDefaultEffect(&WIDGET_Effect_None)
S#define WIDGET_SetDefaultEffect_Simple() WIDGET_SetDefaultEffect(&WIDGET_Effect_Simple)
S
S#endif /* GUI_WINSUPPORT */
S
S#if defined(__cplusplus)
S  }
S#endif
S
N#endif   /* SLIDER_H */
N
N/*************************** End of file ****************************/
L 50 "..\..\..\ThirdParty\emWin\Include\SCROLLBAR.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define SCROLLBAR_CI_THUMB 0
N#define SCROLLBAR_CI_SHAFT 1
N#define SCROLLBAR_CI_ARROW 2
N
N/*********************************************************************
N*
N*       States
N*/
N#define SCROLLBAR_STATE_PRESSED   WIDGET_STATE_USER0
N
N/*********************************************************************
N*
N*       Create / Status flags
N*/
N#define SCROLLBAR_CF_VERTICAL     WIDGET_CF_VERTICAL
N#define SCROLLBAR_CF_FOCUSABLE    WIDGET_STATE_FOCUSABLE
N
N#define SCROLLBAR_CF_FOCUSSABLE   SCROLLBAR_CF_FOCUSABLE
N
N/************************************************************
N*
N*       Skinning property indices
N*/
N#define SCROLLBAR_SKINFLEX_PI_PRESSED   0
N#define SCROLLBAR_SKINFLEX_PI_UNPRESSED 1
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM SCROLLBAR_Handle;
Xtypedef signed long SCROLLBAR_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorUpper[2];
N  GUI_COLOR aColorLower[2];
N  GUI_COLOR aColorShaft[2];
N  GUI_COLOR ColorArrow;
N  GUI_COLOR ColorGrasp;
N} SCROLLBAR_SKINFLEX_PROPS;
N
Ntypedef struct {
N  int IsVertical;
N  int State;
N} SCROLLBAR_SKINFLEX_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NSCROLLBAR_Handle SCROLLBAR_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
XSCROLLBAR_Handle SCROLLBAR_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
NSCROLLBAR_Handle SCROLLBAR_CreateAttached(WM_HWIN hParent, int SpecialFlags);
XSCROLLBAR_Handle SCROLLBAR_CreateAttached(GUI_HWIN hParent, int SpecialFlags);
NSCROLLBAR_Handle SCROLLBAR_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XSCROLLBAR_Handle SCROLLBAR_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NSCROLLBAR_Handle SCROLLBAR_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XSCROLLBAR_Handle SCROLLBAR_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NSCROLLBAR_Handle SCROLLBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XSCROLLBAR_Handle SCROLLBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid SCROLLBAR_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
N/* Methods changing properties */
N
Nvoid      SCROLLBAR_AddValue   (SCROLLBAR_Handle hObj, int Add);
Nvoid      SCROLLBAR_Dec        (SCROLLBAR_Handle hObj);
Nvoid      SCROLLBAR_Inc        (SCROLLBAR_Handle hObj);
Nint       SCROLLBAR_GetUserData(SCROLLBAR_Handle hObj, void * pDest, int NumBytes);
NGUI_COLOR SCROLLBAR_SetColor   (SCROLLBAR_Handle hObj, int Index, GUI_COLOR Color);
Nvoid      SCROLLBAR_SetNumItems(SCROLLBAR_Handle hObj, int NumItems);
Nvoid      SCROLLBAR_SetPageSize(SCROLLBAR_Handle hObj, int PageSize);
Nvoid      SCROLLBAR_SetValue   (SCROLLBAR_Handle hObj, int v);
Nint       SCROLLBAR_SetWidth   (SCROLLBAR_Handle hObj, int Width);
Nvoid      SCROLLBAR_SetState   (SCROLLBAR_Handle hObj, const WM_SCROLL_STATE* pState);
Nint       SCROLLBAR_SetUserData(SCROLLBAR_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid SCROLLBAR_GetSkinFlexProps     (SCROLLBAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid SCROLLBAR_SetSkinClassic       (SCROLLBAR_Handle hObj);
Nvoid SCROLLBAR_SetSkin              (SCROLLBAR_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  SCROLLBAR_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid SCROLLBAR_SetSkinFlexProps     (const SCROLLBAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid SCROLLBAR_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * SCROLLBAR_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define SCROLLBAR_SKIN_FLEX    SCROLLBAR_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
Nint       SCROLLBAR_GetDefaultWidth(void);
NGUI_COLOR SCROLLBAR_SetDefaultColor(GUI_COLOR Color, unsigned int Index); /* Not yet documented */
Nint       SCROLLBAR_SetDefaultWidth(int DefaultWidth);
N
N/*********************************************************************
N*
N*       Global functions
N*
N**********************************************************************
N*/
Nint       SCROLLBAR_GetThumbSizeMin(void);
Nint       SCROLLBAR_SetThumbSizeMin(int ThumbSizeMin);
N
N/*********************************************************************
N*
N*       Query state
N*
N**********************************************************************
N*/
NGUI_COLOR SCROLLBAR_GetColor   (SCROLLBAR_Handle hObj, int Index);
Nint       SCROLLBAR_GetNumItems(SCROLLBAR_Handle hObj);
Nint       SCROLLBAR_GetPageSize(SCROLLBAR_Handle hObj);
Nint       SCROLLBAR_GetValue   (SCROLLBAR_Handle hObj);
N
N/*********************************************************************
N*
N*       Macros for compatibility
N*
N**********************************************************************
N*/
N#define SCROLLBAR_BKCOLOR0_DEFAULT SCROLLBAR_COLOR_ARROW_DEFAULT
N#define SCROLLBAR_BKCOLOR1_DEFAULT SCROLLBAR_COLOR_SHAFT_DEFAULT
N#define SCROLLBAR_COLOR0_DEFAULT   SCROLLBAR_COLOR_THUMB_DEFAULT
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // SCROLLBAR_H
N
N/*************************** End of file ****************************/
L 88 "..\..\..\ThirdParty\emWin\Include\WIDGET.h" 2
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Unique widget id's
N*/
N#define BUTTON_ID    0x42555454UL /* BUTT */
N#define CHECKBOX_ID  0x43484543UL /* CHEC */
N#define DROPDOWN_ID  0x44524f50UL /* DROP */
N#define EDIT_ID      0x45444954UL /* EDIT */
N#define FRAMEWIN_ID  0x4652414dUL /* FRAM */
N#define FRAMECLNT_ID 0x46524143UL /* FRAC */
N#define GRAPH_ID     0x47524150UL /* GRAP */
N#define HEADER_ID    0x48454144UL /* HEAD */
N#define LISTBOX_ID   0x4C495342UL /* LISB */
N#define LISTVIEW_ID  0x4C495356UL /* LISV */
N#define LISTWHEEL_ID 0x4C495357UL /* LISW */
N#define MENU_ID      0x4d454e55UL /* MENU */
N#define MULTIEDIT_ID 0x4d554c45UL /* MULE */
N#define MULTIPAGE_ID 0x4d554c50UL /* MULP */
N#define MPAGECLNT_ID 0x4d50434CUL /* MPCL */
N#define PROGBAR_ID   0x50524f47UL /* PROG */
N#define RADIO_ID     0x52414449UL /* RADI */
N#define SCROLLBAR_ID 0x5343524fUL /* SCRO */
N#define SLIDER_ID    0x534c4944UL /* SLID */
N#define SWIPELIST_ID 0x53574950UL /* SWIP */
N#define TEXT_ID      0x54455854UL /* TEXT */
N#define TREEVIEW_ID  0x54524545UL /* TREE */
N#define ICONVIEW_ID  0x49434f4eUL /* ICON */
N#define IMAGE_ID     0x494d4147UL /* IMAG */
N#define SPINBOX_ID   0x5350494eUL /* SPIN */
N#define KNOB_ID      0x4b4e4f42UL /* KNOB */
N#define WINDOW_ID    0x57494e44UL /* WIND */
N
N#define WIDGET_LOCK(hWin)       ((WIDGET*)GUI_LOCK_H(hWin))
N
N/*********************************************************************
N*
N*       Config switches
N*/
N
N#ifndef   WIDGET_USE_PARENT_EFFECT
N  #define WIDGET_USE_PARENT_EFFECT 0
N#endif
N#ifndef   WIDGET_USE_FLEX_SKIN
N  #if WM_SUPPORT_TRANSPARENCY
X  #if 1
N    #define WIDGET_USE_FLEX_SKIN     1
N  #else
S    #define WIDGET_USE_FLEX_SKIN     0
N  #endif
N#endif
N#if !defined(WIDGET_USE_SCHEME_SMALL) && !defined(WIDGET_USE_SCHEME_MEDIUM) && !defined(WIDGET_USE_SCHEME_LARGE)
X#if !0L && !0L && !0L
N  #define WIDGET_USE_SCHEME_SMALL  1
N  #define WIDGET_USE_SCHEME_MEDIUM 0
N  #define WIDGET_USE_SCHEME_LARGE  0
N#endif
N#ifndef   WIDGET_USE_SCHEME_SMALL
S  #define WIDGET_USE_SCHEME_SMALL  0
N#endif
N#ifndef   WIDGET_USE_SCHEME_MEDIUM
S  #define WIDGET_USE_SCHEME_MEDIUM 0
N#endif
N#ifndef   WIDGET_USE_SCHEME_LARGE
S  #define WIDGET_USE_SCHEME_LARGE  0
N#endif
N#if (WIDGET_USE_SCHEME_SMALL + WIDGET_USE_SCHEME_MEDIUM + WIDGET_USE_SCHEME_LARGE) > 1
X#if (1 + 0 + 0) > 1
S  #error Only one scheme can be selected!
N#endif
N
N/*********************************************************************
N*
N*       States
N*/
N
N#define WIDGET_STATE_FOCUS              (1 << 0)
N#define WIDGET_STATE_VERTICAL           (1 << 3)
N#define WIDGET_STATE_FOCUSABLE          (1 << 4)
N
N#define WIDGET_STATE_USER0              (1 << 8)    /* Freely available for derived widget */
N#define WIDGET_STATE_USER1              (1 << 9)    /* Freely available for derived widget */
N#define WIDGET_STATE_USER2              (1 << 10)   /* Freely available for derived widget */
N
N#define WIDGET_STATE_FOCUSSABLE         WIDGET_STATE_FOCUSABLE
N
N/*********************************************************************
N*
N*       Skinning message identifiers
N*/
N#define WIDGET_ITEM_CREATE              0
N#define WIDGET_ITEM_DRAW                1
N#define WIDGET_ITEM_DRAW_ARROW          2
N#define WIDGET_ITEM_DRAW_ARROW_L        3
N#define WIDGET_ITEM_DRAW_ARROW_R        4
N#define WIDGET_ITEM_DRAW_BACKGROUND     5
N#define WIDGET_ITEM_DRAW_BITMAP         6
N#define WIDGET_ITEM_DRAW_BUTTON         7
N#define WIDGET_ITEM_DRAW_BUTTON_L       8
N#define WIDGET_ITEM_DRAW_BUTTON_R       9
N#define WIDGET_ITEM_DRAW_FOCUS         10
N#define WIDGET_ITEM_DRAW_FRAME         11
N#define WIDGET_ITEM_DRAW_OVERLAP       12
N#define WIDGET_ITEM_DRAW_OVERLAY       13
N#define WIDGET_ITEM_DRAW_SEP           14
N#define WIDGET_ITEM_DRAW_SHAFT         15
N#define WIDGET_ITEM_DRAW_SHAFT_L       16
N#define WIDGET_ITEM_DRAW_SHAFT_R       17
N#define WIDGET_ITEM_DRAW_TEXT          18
N#define WIDGET_ITEM_DRAW_THUMB         19
N#define WIDGET_ITEM_DRAW_TICKS         20
N#define WIDGET_ITEM_GET_BORDERSIZE_B   21
N#define WIDGET_ITEM_GET_BORDERSIZE_L   22
N#define WIDGET_ITEM_GET_BORDERSIZE_R   23
N#define WIDGET_ITEM_GET_BORDERSIZE_T   24
N#define WIDGET_ITEM_GET_BUTTONSIZE     25
N#define WIDGET_ITEM_GET_XSIZE          26
N#define WIDGET_ITEM_GET_YSIZE          27
N#define WIDGET_ITEM_GET_RADIUS         28
N#define WIDGET_ITEM_APPLY_PROPS        29  // Not to be documented. Use this message identifier to update the
N                                           // properties of attached widgets from <WIDGET>_DrawSkinFlex().
N#define WIDGET_DRAW_BACKGROUND         30
N
N#define WIDGET_DRAW_OVERLAY    WIDGET_ITEM_DRAW_OVERLAY
N
N/*********************************************************************
N*
N*       Messages
N*/
N
N#define WM_WIDGET_SET_EFFECT    (WM_WIDGET + 0)
N
N/*********************************************************************
N*
N*       Create flags
N*/
N
N#define WIDGET_CF_VERTICAL      WIDGET_STATE_VERTICAL
N
N/*********************************************************************
N*
N*        Widget object
N*
N* The widget object is the base class for most widgets
N*/
Ntypedef struct {
N  int EffectSize;
N  void (* pfDrawUp)      (void);
N  void (* pfDrawUpRect)  (const GUI_RECT * pRect);
N  void (* pfDrawDown)    (void);
N  void (* pfDrawDownRect)(const GUI_RECT * pRect);
N  void (* pfDrawFlat)    (void);
N  void (* pfDrawFlatRect)(const GUI_RECT * pRect);
N} WIDGET_EFFECT;
N
Ntypedef struct {
N  WM_Obj      Win;
N  const WIDGET_EFFECT* pEffect;
N  I16 Id;
X  signed short Id;
N  U16 State;
X  unsigned short State;
N  #if GUI_DEBUG_LEVEL > 1
X  #if 0 > 1
S    U32 DebugId;
N  #endif  
N} WIDGET;
N
N
N/*********************************************************************
N*
N*         GUI_DRAW
N*
N* The GUI_DRAW object is used as base class for selfdrawing,
N* non-windows objects. They are used as content of different widgets,
N* such as the bitmap or header widgets.
N*/
N/* Declare Object struct */
Ntypedef struct GUI_DRAW GUI_DRAW;
Ntypedef void   GUI_DRAW_SELF_CB (WM_HWIN hWin);
Xtypedef void   GUI_DRAW_SELF_CB (GUI_HWIN hWin);
Ntypedef WM_HMEM GUI_DRAW_HANDLE;
Xtypedef signed long GUI_DRAW_HANDLE;
N
N/* Declare Object constants (member functions etc)  */
Ntypedef struct {
N  void (* pfDraw)    (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
X  void (* pfDraw)    (GUI_DRAW_HANDLE hDrawObj, GUI_HWIN hObj, int x, int y);
N  int  (* pfGetXSize)(GUI_DRAW_HANDLE hDrawObj);
N  int  (* pfGetYSize)(GUI_DRAW_HANDLE hDrawObj);
N} GUI_DRAW_CONSTS;
N
N/* Declare Object */
Nstruct GUI_DRAW {
N  const GUI_DRAW_CONSTS* pConsts;
N  union {
N    const void * pData;
N    GUI_DRAW_SELF_CB* pfDraw;
N  } Data;
N  I16 xOff, yOff;
X  signed short xOff, yOff;
N};
N
N/* GUI_DRAW_ API */
Nvoid GUI_DRAW__Draw    (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
Xvoid GUI_DRAW__Draw    (GUI_DRAW_HANDLE hDrawObj, GUI_HWIN hObj, int x, int y);
Nint  GUI_DRAW__GetXSize(GUI_DRAW_HANDLE hDrawObj);
Nint  GUI_DRAW__GetYSize(GUI_DRAW_HANDLE hDrawObj);
N
Nvoid GUI_DrawStreamedEnableAuto(void);
N
N/* GUI_DRAW_ Constructurs for different objects */
NWM_HMEM GUI_DRAW_BITMAP_Create  (const GUI_BITMAP* pBitmap, int x, int y);
Xsigned long GUI_DRAW_BITMAP_Create  (const GUI_BITMAP* pBitmap, int x, int y);
NWM_HMEM GUI_DRAW_BMP_Create     (const void* pBMP, int x, int y);
Xsigned long GUI_DRAW_BMP_Create     (const void* pBMP, int x, int y);
NWM_HMEM GUI_DRAW_STREAMED_Create(const GUI_BITMAP_STREAM * pBitmap, int x, int y);
Xsigned long GUI_DRAW_STREAMED_Create(const GUI_BITMAP_STREAM * pBitmap, int x, int y);
NWM_HMEM GUI_DRAW_SELF_Create(GUI_DRAW_SELF_CB* pfDraw, int x, int y);
Xsigned long GUI_DRAW_SELF_Create(GUI_DRAW_SELF_CB* pfDraw, int x, int y);
N
N/*********************************************************************
N*
N*       Global data
N*
N**********************************************************************
N*/
N
Nextern const WIDGET_EFFECT WIDGET_Effect_3D;
Nextern const WIDGET_EFFECT WIDGET_Effect_3D1L;
Nextern const WIDGET_EFFECT WIDGET_Effect_3D2L;
Nextern const WIDGET_EFFECT WIDGET_Effect_None;
Nextern const WIDGET_EFFECT WIDGET_Effect_Simple;
N
N/*********************************************************************
N*
N*       Internal API routines
N*
N**********************************************************************
N*/
N
Nvoid      WIDGET__DrawFocusRect      (WIDGET * pWidget, const GUI_RECT * pRect, int Dist);
Nvoid      WIDGET__DrawHLine          (WIDGET * pWidget, int y, int x0, int x1);
Nvoid      WIDGET__DrawTriangle       (WIDGET * pWidget, int x, int y, int Size, int Inc);
Nvoid      WIDGET__DrawVLine          (WIDGET * pWidget, int x, int y0, int y1);
Nvoid      WIDGET__EFFECT_DrawDownRect(WIDGET * pWidget, GUI_RECT * pRect);
Nvoid      WIDGET__EFFECT_DrawDown    (WIDGET * pWidget);
Nvoid      WIDGET__EFFECT_DrawUpRect  (WIDGET * pWidget, GUI_RECT * pRect);
Nvoid      WIDGET__FillRectEx         (WIDGET * pWidget, const GUI_RECT * pRect);
Nint       WIDGET__GetWindowSizeX     (WM_HWIN hWin);
Xint       WIDGET__GetWindowSizeX     (GUI_HWIN hWin);
NGUI_COLOR WIDGET__GetBkColor         (WM_HWIN hObj);
XGUI_COLOR WIDGET__GetBkColor         (GUI_HWIN hObj);
Nint       WIDGET__GetXSize           (const WIDGET * pWidget);
Nint       WIDGET__GetYSize           (const WIDGET * pWidget);
Nvoid      WIDGET__GetClientRect      (WIDGET * pWidget, GUI_RECT * pRect);
Nvoid      WIDGET__GetInsideRect      (WIDGET * pWidget, GUI_RECT * pRect);
Nvoid      WIDGET__Init               (WIDGET * pWidget, int Id, U16 State);
Xvoid      WIDGET__Init               (WIDGET * pWidget, int Id, unsigned short State);
Nvoid      WIDGET__RotateRect90       (WIDGET * pWidget, GUI_RECT * pDest, const GUI_RECT * pRect);
Nvoid      WIDGET__SetScrollState     (WM_HWIN hWin, const WM_SCROLL_STATE * pVState, const WM_SCROLL_STATE * pState);
Xvoid      WIDGET__SetScrollState     (GUI_HWIN hWin, const WM_SCROLL_STATE * pVState, const WM_SCROLL_STATE * pState);
Nvoid      WIDGET__FillStringInRect   (const char * pText, const GUI_RECT * pFillRect, const GUI_RECT * pTextRectMax, const GUI_RECT * pTextRectAct);
N
N//
N// Function pointers for drawing streamed bitmaps
N//
Nextern void (* GUI__pfDrawStreamedBitmap)  (const void * p, int x, int y);
Nextern int  (* GUI__pfDrawStreamedBitmapEx)(GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
N
N/*********************************************************************
N*
N*       API routines
N*
N**********************************************************************
N*/
Nvoid  WIDGET_SetState     (WM_HWIN hObj, int State);
Xvoid  WIDGET_SetState     (GUI_HWIN hObj, int State);
Nvoid  WIDGET_AndState     (WM_HWIN hObj, int State);
Xvoid  WIDGET_AndState     (GUI_HWIN hObj, int State);
Nvoid  WIDGET_OrState      (WM_HWIN hObj, int State);
Xvoid  WIDGET_OrState      (GUI_HWIN hObj, int State);
Nint   WIDGET_HandleActive (WM_HWIN hObj, WM_MESSAGE* pMsg);
Xint   WIDGET_HandleActive (GUI_HWIN hObj, WM_MESSAGE* pMsg);
Nint   WIDGET_GetState     (WM_HWIN hObj);
Xint   WIDGET_GetState     (GUI_HWIN hObj);
Nint   WIDGET_SetWidth     (WM_HWIN hObj, int Width);
Xint   WIDGET_SetWidth     (GUI_HWIN hObj, int Width);
Nvoid  WIDGET_SetFocusable (WM_HWIN hObj, int State);
Xvoid  WIDGET_SetFocusable (GUI_HWIN hObj, int State);
N
Nvoid  WIDGET_EFFECT_3D_DrawUp(void);
N
Nconst WIDGET_EFFECT* WIDGET_SetDefaultEffect(const WIDGET_EFFECT* pEffect);
N
Nvoid  WIDGET_SetEffect              (WM_HWIN hObj, const WIDGET_EFFECT* pEffect);
Xvoid  WIDGET_SetEffect              (GUI_HWIN hObj, const WIDGET_EFFECT* pEffect);
N
Nconst WIDGET_EFFECT* WIDGET_GetDefaultEffect(void);
N
Nvoid WIDGET_EFFECT_3D_SetColor    (unsigned Index, GUI_COLOR Color);
Nvoid WIDGET_EFFECT_3D1L_SetColor  (unsigned Index, GUI_COLOR Color);
Nvoid WIDGET_EFFECT_3D2L_SetColor  (unsigned Index, GUI_COLOR Color);
Nvoid WIDGET_EFFECT_Simple_SetColor(unsigned Index, GUI_COLOR Color);
N
NGUI_COLOR WIDGET_EFFECT_3D_GetColor    (unsigned Index);
NGUI_COLOR WIDGET_EFFECT_3D1L_GetColor  (unsigned Index);
NGUI_COLOR WIDGET_EFFECT_3D2L_GetColor  (unsigned Index);
NGUI_COLOR WIDGET_EFFECT_Simple_GetColor(unsigned Index);
N
Nint WIDGET_EFFECT_3D_GetNumColors(void);
Nint WIDGET_EFFECT_3D1L_GetNumColors(void);
Nint WIDGET_EFFECT_3D2L_GetNumColors(void);
Nint WIDGET_EFFECT_Simple_GetNumColors(void);
N
N/*********************************************************************
N*
N*       Compatibility macros
N*
N**********************************************************************
N*/
N#define WIDGET_EnableStreamAuto() GUI_DrawStreamedEnableAuto()
N
N#define WIDGET_SetDefaultEffect_3D()     WIDGET_SetDefaultEffect(&WIDGET_Effect_3D)
N#define WIDGET_SetDefaultEffect_3D1L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D1L)
N#define WIDGET_SetDefaultEffect_3D2L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D2L)
N#define WIDGET_SetDefaultEffect_None()   WIDGET_SetDefaultEffect(&WIDGET_Effect_None)
N#define WIDGET_SetDefaultEffect_Simple() WIDGET_SetDefaultEffect(&WIDGET_Effect_Simple)
N
N#endif /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* SLIDER_H */
N
N/*************************** End of file ****************************/
L 50 "..\..\..\ThirdParty\emWin\Include\BUTTON.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Create flags
N*/
N/* For compatibility only ! */
N#define BUTTON_CF_HIDE   WM_CF_HIDE
N#define BUTTON_CF_SHOW   WM_CF_SHOW
N#define BUTTON_CF_MEMDEV WM_CF_MEMDEV
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define BUTTON_CI_UNPRESSED 0
N#define BUTTON_CI_PRESSED   1
N#define BUTTON_CI_DISABLED  2
N
N/*********************************************************************
N*
N*       Bitmap indices
N*/
N#define BUTTON_BI_UNPRESSED 0
N#define BUTTON_BI_PRESSED   1
N#define BUTTON_BI_DISABLED  2
N
N/*********************************************************************
N*
N*       States
N*/
N#define BUTTON_STATE_FOCUS      WIDGET_STATE_FOCUS
N#define BUTTON_STATE_PRESSED    WIDGET_STATE_USER0
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define BUTTON_SKINFLEX_PI_PRESSED     0
N#define BUTTON_SKINFLEX_PI_FOCUSED     1
N#define BUTTON_SKINFLEX_PI_ENABLED     2
N#define BUTTON_SKINFLEX_PI_DISABLED    3
N
N#define BUTTON_SKINFLEX_PI_FOCUSSED BUTTON_SKINFLEX_PI_FOCUSED
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM BUTTON_Handle;
Xtypedef signed long BUTTON_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorUpper[2];
N  GUI_COLOR aColorLower[2];
N  int Radius;
N} BUTTON_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create function(s)
N
N  Note: the parameters to a create function may vary.
N         Some widgets may have multiple create functions
N*/
N
NBUTTON_Handle BUTTON_Create        (int x0, int y0, int xSize, int ySize, int ID, int Flags);
NBUTTON_Handle BUTTON_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags);
XBUTTON_Handle BUTTON_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags);
NBUTTON_Handle BUTTON_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XBUTTON_Handle BUTTON_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NBUTTON_Handle BUTTON_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XBUTTON_Handle BUTTON_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NBUTTON_Handle BUTTON_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XBUTTON_Handle BUTTON_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR        BUTTON_GetDefaultBkColor   (unsigned Index);
Nconst GUI_FONT * BUTTON_GetDefaultFont      (void);
Nint              BUTTON_GetDefaultTextAlign (void);
NGUI_COLOR        BUTTON_GetDefaultTextColor (unsigned Index);
Nvoid             BUTTON_SetDefaultBkColor   (GUI_COLOR Color, unsigned Index);
NGUI_COLOR        BUTTON_SetDefaultFocusColor(GUI_COLOR Color);
Nvoid             BUTTON_SetDefaultFont      (const GUI_FONT * pFont);
Nvoid             BUTTON_SetDefaultTextAlign (int Align);
Nvoid             BUTTON_SetDefaultTextColor (GUI_COLOR Color, unsigned Index);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid BUTTON_Callback(WM_MESSAGE *pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
NGUI_COLOR          BUTTON_GetBkColor         (BUTTON_Handle hObj, unsigned int Index);
Nconst GUI_BITMAP * BUTTON_GetBitmap          (BUTTON_Handle hObj,unsigned int Index);
Nconst GUI_FONT   * BUTTON_GetFont            (BUTTON_Handle hObj);
NGUI_COLOR          BUTTON_GetFrameColor      (BUTTON_Handle hObj);
NWIDGET           * BUTTON_GetpWidget         (BUTTON_Handle hObj);
Nvoid               BUTTON_GetText            (BUTTON_Handle hObj, char * pBuffer, int MaxLen);
NGUI_COLOR          BUTTON_GetTextColor       (BUTTON_Handle hObj, unsigned int Index);
Nint                BUTTON_GetTextAlign       (BUTTON_Handle hObj);
Nint                BUTTON_GetUserData        (BUTTON_Handle hObj, void * pDest, int NumBytes);
Nunsigned           BUTTON_IsPressed          (BUTTON_Handle hObj);
Nvoid               BUTTON_SetBitmap          (BUTTON_Handle hObj, unsigned int Index, const GUI_BITMAP * pBitmap);
Nvoid               BUTTON_SetBitmapEx        (BUTTON_Handle hObj, unsigned int Index, const GUI_BITMAP * pBitmap, int x, int y);
Nvoid               BUTTON_SetBkColor         (BUTTON_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid               BUTTON_SetBMP             (BUTTON_Handle hObj, unsigned int Index, const void * pBitmap);
Nvoid               BUTTON_SetBMPEx           (BUTTON_Handle hObj, unsigned int Index, const void * pBitmap, int x, int y);
Nvoid               BUTTON_SetFont            (BUTTON_Handle hObj, const GUI_FONT * pfont);
Nvoid               BUTTON_SetFrameColor      (BUTTON_Handle hObj, GUI_COLOR Color);
Nvoid               BUTTON_SetState           (BUTTON_Handle hObj, int State);                                    /* Not to be doc. */
Nvoid               BUTTON_SetPressed         (BUTTON_Handle hObj, int State);
NGUI_COLOR          BUTTON_SetFocusColor      (BUTTON_Handle hObj, GUI_COLOR Color);
Nvoid               BUTTON_SetStreamedBitmap  (BUTTON_Handle hObj, unsigned int Index, const GUI_BITMAP_STREAM * pBitmap);
Nvoid               BUTTON_SetStreamedBitmapEx(BUTTON_Handle hObj, unsigned int Index, const GUI_BITMAP_STREAM * pBitmap, int x, int y);
Nint                BUTTON_SetText            (BUTTON_Handle hObj, const char* s);
Nvoid               BUTTON_SetTextAlign       (BUTTON_Handle hObj, int Align);
Nvoid               BUTTON_SetTextColor       (BUTTON_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid               BUTTON_SetTextOffset      (BUTTON_Handle hObj, int xPos, int yPos);
Nvoid               BUTTON_SetSelfDrawEx      (BUTTON_Handle hObj, unsigned int Index, GUI_DRAW_SELF_CB * pDraw, int x, int y); /* Not to be doc. */
Nvoid               BUTTON_SetSelfDraw        (BUTTON_Handle hObj, unsigned int Index, GUI_DRAW_SELF_CB * pDraw);               /* Not to be doc. */
Nvoid               BUTTON_SetReactOnLevel    (void);
Nvoid               BUTTON_SetReactOnTouch    (void);
Nint                BUTTON_SetUserData        (BUTTON_Handle hObj, const void * pSrc, int NumBytes);
N
N#define BUTTON_SetFocussable BUTTON_SetFocusable
N#define BUTTON_SetFocusable  WIDGET_SetFocusable
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid BUTTON_GetSkinFlexProps     (BUTTON_SKINFLEX_PROPS * pProps, int Index);
Nvoid BUTTON_SetSkinClassic       (BUTTON_Handle hObj);
Nvoid BUTTON_SetSkin              (BUTTON_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  BUTTON_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid BUTTON_SetSkinFlexProps     (const BUTTON_SKINFLEX_PROPS * pProps, int Index);
Nvoid BUTTON_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * BUTTON_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define BUTTON_SKIN_FLEX    BUTTON_DrawSkinFlex
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   // GUI_WINSUPPORT
N#endif   // BUTTON_H
N
N/*************************** End of file ****************************/
L 50 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "CALENDAR.h"
L 1 "..\..\..\ThirdParty\emWin\Include\CALENDAR.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : CALENDAR.h
NPurpose     : Message box interface
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef CALENDAR_H
N#define CALENDAR_H
N
N#include "WM.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define CALENDAR_CI_WEEKEND 0
N#define CALENDAR_CI_WEEKDAY 1
N#define CALENDAR_CI_SEL     2
N
N#define CALENDAR_CI_HEADER  3
N#define CALENDAR_CI_MONTH   4
N#define CALENDAR_CI_LABEL   5
N#define CALENDAR_CI_FRAME   6
N
N#define CALENDAR_FI_CONTENT 0
N#define CALENDAR_FI_HEADER  1
N
N#define CALENDAR_SI_HEADER  0
N#define CALENDAR_SI_CELL_X  1
N#define CALENDAR_SI_CELL_Y  2
N
N/*********************************************************************
N*
N*       Notification codes
N*
N* The following is the list of notification codes specific to this widget,
N* Send with the WM_NOTIFY_PARENT message
N*/
N#define CALENDAR_NOTIFICATION_MONTH_CLICKED  (WM_NOTIFICATION_WIDGET + 0)
N#define CALENDAR_NOTIFICATION_MONTH_RELEASED (WM_NOTIFICATION_WIDGET + 1)
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       CALENDAR_DATE
N*/
Ntypedef struct {
N  int Year;
N  int Month;
N  int Day;
N} CALENDAR_DATE;
N
N/*********************************************************************
N*
N*       CALENDAR_SKINFLEX_PROPS
N*/
Ntypedef struct {
N  GUI_COLOR aColorFrame[3]; // Frame colors of buttons
N  GUI_COLOR aColorUpper[2]; // Upper gradient colors of buttons
N  GUI_COLOR aColorLower[2]; // Lower gradient colors of buttons
N  GUI_COLOR ColorArrow;     // Arrow colors
N} CALENDAR_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Public code
N*
N**********************************************************************
N*/
NWM_HWIN CALENDAR_Create           (WM_HWIN hParent, int xPos, int yPos, unsigned Year, unsigned Month, unsigned Day, unsigned FirstDayOfWeek, int Id, int Flags);
XGUI_HWIN CALENDAR_Create           (GUI_HWIN hParent, int xPos, int yPos, unsigned Year, unsigned Month, unsigned Day, unsigned FirstDayOfWeek, int Id, int Flags);
Nvoid    CALENDAR_GetDate          (WM_HWIN hWin, CALENDAR_DATE * pDate);
Xvoid    CALENDAR_GetDate          (GUI_HWIN hWin, CALENDAR_DATE * pDate);
Nint     CALENDAR_GetDaysOfMonth   (CALENDAR_DATE * pDate);
Nvoid    CALENDAR_GetSel           (WM_HWIN hWin, CALENDAR_DATE * pDate);
Xvoid    CALENDAR_GetSel           (GUI_HWIN hWin, CALENDAR_DATE * pDate);
Nint     CALENDAR_GetWeekday       (CALENDAR_DATE * pDate);
Nvoid    CALENDAR_SetDate          (WM_HWIN hWin, CALENDAR_DATE * pDate);
Xvoid    CALENDAR_SetDate          (GUI_HWIN hWin, CALENDAR_DATE * pDate);
Nvoid    CALENDAR_SetSel           (WM_HWIN hWin, CALENDAR_DATE * pDate);
Xvoid    CALENDAR_SetSel           (GUI_HWIN hWin, CALENDAR_DATE * pDate);
Nvoid    CALENDAR_ShowDate         (WM_HWIN hWin, CALENDAR_DATE * pDate);
Xvoid    CALENDAR_ShowDate         (GUI_HWIN hWin, CALENDAR_DATE * pDate);
Nint     CALENDAR_AddKey           (WM_HWIN hWin, int Key);
Xint     CALENDAR_AddKey           (GUI_HWIN hWin, int Key);
N
N/*********************************************************************
N*
N*       Default related
N*/
Nvoid    CALENDAR_SetDefaultBkColor(unsigned Index, GUI_COLOR Color);
Nvoid    CALENDAR_SetDefaultColor  (unsigned Index, GUI_COLOR Color);
Nvoid    CALENDAR_SetDefaultDays   (const char ** apDays);
Nvoid    CALENDAR_SetDefaultFont   (unsigned Index, const GUI_FONT * pFont);
Nvoid    CALENDAR_SetDefaultMonths (const char ** apMonths);
Nvoid    CALENDAR_SetDefaultSize   (unsigned Index, unsigned Size);
N
N/*********************************************************************
N*
N*       Skinning related
N*/
Nvoid    CALENDAR_GetSkinFlexProps (CALENDAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid    CALENDAR_SetSkinFlexProps (const CALENDAR_SKINFLEX_PROPS * pProps, int Index);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid CALENDAR_Callback(WM_MESSAGE * pMsg);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif // GUI_WINSUPPORT
N#endif // CALENDAR_H
N
N/*************************** End of file ****************************/
L 51 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "CHECKBOX.h"
L 1 "..\..\..\ThirdParty\emWin\Include\CHECKBOX.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : CHECKBOX.h
NPurpose     : CHECKBOX include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef CHECKBOX_H
N#define CHECKBOX_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define CHECKBOX_CI_DISABLED 0
N#define CHECKBOX_CI_ENABLED  1
N
N/*********************************************************************
N*
N*       Bitmap indices
N*/
N#define CHECKBOX_BI_INACTIV_UNCHECKED 0
N#define CHECKBOX_BI_ACTIV_UNCHECKED   1
N#define CHECKBOX_BI_INACTIV_CHECKED   2
N#define CHECKBOX_BI_ACTIV_CHECKED     3
N#define CHECKBOX_BI_INACTIV_3STATE    4
N#define CHECKBOX_BI_ACTIV_3STATE      5
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define CHECKBOX_SKINFLEX_PI_ENABLED     0
N#define CHECKBOX_SKINFLEX_PI_DISABLED    1
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM CHECKBOX_Handle;
Xtypedef signed long CHECKBOX_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorInner[2];
N  GUI_COLOR ColorCheck;
N  int       ButtonSize;
N} CHECKBOX_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NCHECKBOX_Handle CHECKBOX_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags);
XCHECKBOX_Handle CHECKBOX_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags);
NCHECKBOX_Handle CHECKBOX_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XCHECKBOX_Handle CHECKBOX_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NCHECKBOX_Handle CHECKBOX_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XCHECKBOX_Handle CHECKBOX_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NCHECKBOX_Handle CHECKBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XCHECKBOX_Handle CHECKBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid CHECKBOX_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
Nint              CHECKBOX_GetDefaultAlign     (void);
NGUI_COLOR        CHECKBOX_GetDefaultBkColor   (void);
Nconst GUI_FONT * CHECKBOX_GetDefaultFont      (void);
Nint              CHECKBOX_GetDefaultSpacing   (void);
Nint              CHECKBOX_GetDefaultTextAlign (void);
NGUI_COLOR        CHECKBOX_GetDefaultTextColor (void);
Nint              CHECKBOX_GetUserData         (CHECKBOX_Handle hObj, void * pDest, int NumBytes);
Nvoid             CHECKBOX_SetDefaultAlign     (int Align);
Nvoid             CHECKBOX_SetDefaultBkColor   (GUI_COLOR Color);
NGUI_COLOR        CHECKBOX_SetDefaultFocusColor(GUI_COLOR Color);
Nvoid             CHECKBOX_SetDefaultFont      (const GUI_FONT * pFont);
Nvoid             CHECKBOX_SetDefaultImage     (const GUI_BITMAP * pBitmap, unsigned int Index);
Nvoid             CHECKBOX_SetDefaultSpacing   (int Spacing);
Nvoid             CHECKBOX_SetDefaultTextAlign (int Align);
Nvoid             CHECKBOX_SetDefaultTextColor (GUI_COLOR Color);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
NGUI_COLOR          CHECKBOX_GetBkColor   (CHECKBOX_Handle hObj);
NGUI_COLOR          CHECKBOX_GetBoxBkColor(CHECKBOX_Handle hObj, int Index);
NGUI_COLOR          CHECKBOX_GetFocusColor(CHECKBOX_Handle hObj);
Nconst GUI_FONT   * CHECKBOX_GetFont      (CHECKBOX_Handle hObj);
Nconst GUI_BITMAP * CHECKBOX_GetImage     (CHECKBOX_Handle hObj, unsigned int Index);
Nint                CHECKBOX_GetState     (CHECKBOX_Handle hObj);
Nint                CHECKBOX_GetText      (CHECKBOX_Handle hObj, char * pBuffer, int MaxLen);
Nint                CHECKBOX_GetTextAlign (CHECKBOX_Handle hObj);
NGUI_COLOR          CHECKBOX_GetTextColor (CHECKBOX_Handle hObj);
Nint                CHECKBOX_IsChecked    (CHECKBOX_Handle hObj);
Nvoid               CHECKBOX_SetBkColor   (CHECKBOX_Handle hObj, GUI_COLOR Color);
NGUI_COLOR          CHECKBOX_SetBoxBkColor(CHECKBOX_Handle hObj, GUI_COLOR Color, int Index);
NGUI_COLOR          CHECKBOX_SetFocusColor(CHECKBOX_Handle hObj, GUI_COLOR Color);
Nvoid               CHECKBOX_SetFont      (CHECKBOX_Handle hObj, const GUI_FONT * pFont);
Nvoid               CHECKBOX_SetImage     (CHECKBOX_Handle hObj, const GUI_BITMAP * pBitmap, unsigned int Index);
Nvoid               CHECKBOX_SetNumStates (CHECKBOX_Handle hObj, unsigned NumStates);
Nvoid               CHECKBOX_SetSpacing   (CHECKBOX_Handle hObj, unsigned Spacing);
Nvoid               CHECKBOX_SetState     (CHECKBOX_Handle hObj, unsigned State);
Nvoid               CHECKBOX_SetText      (CHECKBOX_Handle hObj, const char * pText);
Nvoid               CHECKBOX_SetTextAlign (CHECKBOX_Handle hObj, int Align);
Nvoid               CHECKBOX_SetTextColor (CHECKBOX_Handle hObj, GUI_COLOR Color);
Nint                CHECKBOX_SetUserData  (CHECKBOX_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid CHECKBOX_GetSkinFlexProps      (CHECKBOX_SKINFLEX_PROPS * pProps, int Index);
Nvoid CHECKBOX_SetSkinClassic        (CHECKBOX_Handle hObj);
Nvoid CHECKBOX_SetSkin               (CHECKBOX_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  CHECKBOX_DrawSkinFlex          (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid CHECKBOX_SetSkinFlexProps      (const CHECKBOX_SKINFLEX_PROPS * pProps, int Index);
Nvoid CHECKBOX_SetDefaultSkinClassic (void);
Nint  CHECKBOX_GetSkinFlexButtonSize (CHECKBOX_Handle hObj);
Nvoid CHECKBOX_SetSkinFlexButtonSize (CHECKBOX_Handle hObj, int ButtonSize);
NWIDGET_DRAW_ITEM_FUNC * CHECKBOX_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define CHECKBOX_SKIN_FLEX    CHECKBOX_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Macros for compatibility
N*
N**********************************************************************
N*/
N
N#define CHECKBOX_Check(hObj)   CHECKBOX_SetState(hObj, 1)
N#define CHECKBOX_Uncheck(hObj) CHECKBOX_SetState(hObj, 0)
N
N#define CHECKBOX_BI_INACTIV    CHECKBOX_BI_INACTIV_CHECKED
N#define CHECKBOX_BI_ACTIV      CHECKBOX_BI_ACTIV_CHECKED
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // CHECKBOX_H
N
N/*************************** End of file ****************************/
L 52 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "CHOOSECOLOR.h"
L 1 "..\..\..\ThirdParty\emWin\Include\CHOOSECOLOR.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : CHOOSECOLOR.h
NPurpose     : Message box interface
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef CHOOSECOLOR_H
N#define CHOOSECOLOR_H
N
N#include "WM.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define CHOOSECOLOR_CF_MOVEABLE FRAMEWIN_CF_MOVEABLE
N
N#define CHOOSECOLOR_CI_FRAME 0
N#define CHOOSECOLOR_CI_FOCUS 1
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       CHOOSECOLOR_PROPS
N*/
Ntypedef struct {
N  unsigned  aBorder[2];
N  unsigned  aSpace[2];
N  unsigned  aButtonSize[2];
N  GUI_COLOR aColor[2];
N} CHOOSECOLOR_PROPS;
N
N/*********************************************************************
N*
N*       CHOOSECOLOR_CONTEXT
N*/
Ntypedef struct {
N  U32               LastColor;
X  unsigned long               LastColor;
N  const GUI_COLOR * pColor;
N  unsigned          NumColors;
N  unsigned          NumColorsPerLine;
N  int               SelOld;
N  int               Sel;
N  WM_HWIN           hParent;
X  GUI_HWIN           hParent;
N  CHOOSECOLOR_PROPS Props;
N} CHOOSECOLOR_CONTEXT;
N
N/*********************************************************************
N*
N*       Public code
N*
N**********************************************************************
N*/
NWM_HWIN CHOOSECOLOR_Create(WM_HWIN           hParent,
XGUI_HWIN CHOOSECOLOR_Create(GUI_HWIN           hParent,
N                           int               xPos,
N                           int               yPos,
N                           int               xSize,
N                           int               ySize,
N                           const GUI_COLOR * pColor,
N                           unsigned          NumColors,
N                           unsigned          NumColorsPerLine,
N                           int               Sel,
N                           const char      * sCaption,
N                           int               Flags);
N
Nint  CHOOSECOLOR_GetSel(WM_HWIN hObj);
Xint  CHOOSECOLOR_GetSel(GUI_HWIN hObj);
Nvoid CHOOSECOLOR_SetSel(WM_HWIN hObj, int Sel);
Xvoid CHOOSECOLOR_SetSel(GUI_HWIN hObj, int Sel);
N
Nvoid CHOOSECOLOR_SetDefaultColor     (unsigned Index, GUI_COLOR Color);
Nvoid CHOOSECOLOR_SetDefaultSpace     (unsigned Index, unsigned Space);
Nvoid CHOOSECOLOR_SetDefaultBorder    (unsigned Index, unsigned Border);
Nvoid CHOOSECOLOR_SetDefaultButtonSize(unsigned Index, unsigned ButtonSize);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid CHOOSECOLOR_Callback(WM_MESSAGE * pMsg);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif /* GUI_WINSUPPORT */
N
N#endif /* CHOOSECOLOR_H */
N
N/*************************** End of file ****************************/
L 53 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "CHOOSEFILE.h"
L 1 "..\..\..\ThirdParty\emWin\Include\CHOOSEFILE.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : CHOOSEFILE.h
NPurpose     : File dialog interface
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef CHOOSEFILE_H
N#define CHOOSEFILE_H
N
N#include "WM.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define CHOOSEFILE_FINDFIRST 0
N#define CHOOSEFILE_FINDNEXT  1
N
N#define CHOOSEFILE_FLAG_DIRECTORY (1 << 0)
N
N#ifndef   CHOOSEFILE_MAXLEN
N  #define CHOOSEFILE_MAXLEN 256
N#endif
N
N#define CHOOSEFILE_BI_CANCEL 0
N#define CHOOSEFILE_BI_OK     1
N#define CHOOSEFILE_BI_UP     2
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       CHOOSEFILE_INFO
N*/
Ntypedef struct CHOOSEFILE_INFO CHOOSEFILE_INFO;
N
Nstruct CHOOSEFILE_INFO {
N  int               Cmd;                                 // Command for GetData() function
N  int               Id;                                  // Id of pressed button (for internal use only)
N  const char      * pMask;                               // Mask to be used for searching files
N  char            * pName;                               // (for internal use only)
N  char            * pExt;                                // (for internal use only)
N  char            * pAttrib;                             // (for internal use only)
N  WM_TOOLTIP_HANDLE hToolTip;                            // (for internal use only)
N  U32               SizeL;                               // FileSize low word
X  unsigned long               SizeL;                               
N  U32               SizeH;                               // FileSize high word
X  unsigned long               SizeH;                               
N  U32               Flags;                               // File flags
X  unsigned long               Flags;                               
N  char              pRoot[CHOOSEFILE_MAXLEN];            // Buffer used internally and for passing result
X  char              pRoot[256];            
N  int            (* pfGetData)(CHOOSEFILE_INFO * pInfo); // Pointer to GetData() function
N};
N
N/*********************************************************************
N*
N*       Functions
N*
N**********************************************************************
N*/
NWM_HWIN CHOOSEFILE_Create(WM_HWIN           hParent,  // Parent window
XGUI_HWIN CHOOSEFILE_Create(GUI_HWIN           hParent,  
N                          int               xPos,     // xPosition in window coordinates
N                          int               yPos,     // yPosition in window coordinates
N                          int               xSize,    // xSize in pixels
N                          int               ySize,    // ySize in pixels
N                          const char      * apRoot[], // Pointers to root strings
N                          int               NumRoot,  // Number of roots
N                          int               SelRoot,  // Root to be selected at first
N                          const char      * sCaption, // Shown in title bar
N                          int               Flags,    // Flags for FRAMEWINDOW
N                          CHOOSEFILE_INFO * pInfo     // Pointer to CHOOSEFILE_INFO structure
N                          );
N
Nvoid    CHOOSEFILE_Callback            (WM_MESSAGE * pMsg);
Nvoid    CHOOSEFILE_EnableToolTips      (void);
Nvoid    CHOOSEFILE_SetButtonText       (WM_HWIN hWin, unsigned ButtonIndex, const char * pText);
Xvoid    CHOOSEFILE_SetButtonText       (GUI_HWIN hWin, unsigned ButtonIndex, const char * pText);
Nvoid    CHOOSEFILE_SetDefaultButtonText(unsigned ButtonIndex, const char * pText);
Nvoid    CHOOSEFILE_SetDelim            (char Delim);
Nvoid    CHOOSEFILE_SetToolTips         (const TOOLTIP_INFO * pInfo, int NumItems);
Nvoid    CHOOSEFILE_SetTopMode          (unsigned OnOff);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif /* GUI_WINSUPPORT */
N
N#endif /* CHOOSEFILE_H */
N
N/*************************** End of file ****************************/
L 54 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "DROPDOWN.h"
L 1 "..\..\..\ThirdParty\emWin\Include\DROPDOWN.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : DROPDOWN.h
NPurpose     : Multiple choice object include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef DROPDOWN_H
N#define DROPDOWN_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "LISTBOX.h"
L 1 "..\..\..\ThirdParty\emWin\Include\LISTBOX.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : LISTBOX.h
NPurpose     : LISTBOX widget include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef LISTBOX_H
N#define LISTBOX_H
N
N#include "WM.h"
N#include "WIDGET.h"             /* Req. for WIDGET_DRAW_ITEM_FUNC */
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       defines
N*
N**********************************************************************
N*/
N
N#define LISTBOX_ALL_ITEMS  -1
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define LISTBOX_CI_UNSEL    0
N#define LISTBOX_CI_SEL      1
N#define LISTBOX_CI_SELFOCUS 2
N#define LISTBOX_CI_DISABLED 3
N
N/************************************************************
N*
N*       States
N*/
Ntypedef WM_HMEM LISTBOX_Handle;
Xtypedef signed long LISTBOX_Handle;
N
N/*********************************************************************
N*
N*               Notification codes
N*
N* The following is the list of notification codes specific to this widget,
N* Send with the WM_NOTIFY_PARENT message
N*/
N#define LISTBOX_NOTIFICATION_LOST_FOCUS    (WM_NOTIFICATION_WIDGET + 0)
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define LISTBOX_CF_AUTOSCROLLBAR_H   (1 << 0)
N#define LISTBOX_CF_AUTOSCROLLBAR_V   (1 << 1)
N#define LISTBOX_CF_MULTISEL          (1 << 2)
N#define LISTBOX_CF_WRAP              (1 << 3)
N#define LISTBOX_CF_FIXEDSCROLLMODE   (1 << 4)
N#define LISTBOX_SF_AUTOSCROLLBAR_H   LISTBOX_CF_AUTOSCROLLBAR_H
N#define LISTBOX_SF_AUTOSCROLLBAR_V   LISTBOX_CF_AUTOSCROLLBAR_V
N#define LISTBOX_SF_MULTISEL          LISTBOX_CF_MULTISEL
N#define LISTBOX_SF_WRAP              LISTBOX_CF_WRAP
N#define LISTBOX_SF_FIXEDSCROLLMODE   LISTBOX_CF_FIXEDSCROLLMODE
N
N/************************************************************
N*
N*       Fixed scroll mode flags
N*/
N#define LISTBOX_FM_OFF               0  // Turn fixed mode off
N#define LISTBOX_FM_ON                1  // Turn fixed mode on
N#define LISTBOX_FM_CENTER            2  // Set fixed mode to center
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
N
NLISTBOX_Handle LISTBOX_Create        (const GUI_ConstString * ppText, int x0, int y0, int xSize, int ySize, int Flags);
NLISTBOX_Handle LISTBOX_CreateAsChild (const GUI_ConstString * ppText, WM_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
XLISTBOX_Handle LISTBOX_CreateAsChild (const GUI_ConstString * ppText, GUI_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
NLISTBOX_Handle LISTBOX_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText);
XLISTBOX_Handle LISTBOX_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText);
NLISTBOX_Handle LISTBOX_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText, int NumExtraBytes);
XLISTBOX_Handle LISTBOX_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText, int NumExtraBytes);
NLISTBOX_Handle LISTBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XLISTBOX_Handle LISTBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid LISTBOX_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
Nint              LISTBOX_AddKey           (LISTBOX_Handle hObj, int Key);
Nvoid             LISTBOX_AddString        (LISTBOX_Handle hObj, const char * s);
Nvoid             LISTBOX_AddStringH       (LISTBOX_Handle hObj, WM_HMEM hString); /* Not to be documented!!! */
Xvoid             LISTBOX_AddStringH       (LISTBOX_Handle hObj, signed long hString);  
Nvoid             LISTBOX_DecSel           (LISTBOX_Handle hObj);
Nvoid             LISTBOX_DeleteItem       (LISTBOX_Handle hObj, unsigned Index);
Nvoid             LISTBOX_EnableWrapMode   (LISTBOX_Handle hObj, int OnOff);
NGUI_COLOR        LISTBOX_GetBkColor       (LISTBOX_Handle hObj, unsigned Index);
Nconst GUI_FONT * LISTBOX_GetFont          (LISTBOX_Handle hObj);
Nunsigned         LISTBOX_GetItemSpacing   (LISTBOX_Handle hObj);
Nunsigned         LISTBOX_GetNumItems      (LISTBOX_Handle hObj);
Nint              LISTBOX_GetSel           (LISTBOX_Handle hObj);
NGUI_COLOR        LISTBOX_GetTextColor     (LISTBOX_Handle hObj, unsigned Index);
Nint              LISTBOX_GetItemDisabled  (LISTBOX_Handle hObj, unsigned Index);
Nint              LISTBOX_GetItemSel       (LISTBOX_Handle hObj, unsigned Index);
Nvoid             LISTBOX_GetItemText      (LISTBOX_Handle hObj, unsigned Index, char * pBuffer, int MaxSize);
Nint              LISTBOX_GetMulti         (LISTBOX_Handle hObj);
NWM_HWIN          LISTBOX_GetOwner         (LISTBOX_Handle hObj);
XGUI_HWIN          LISTBOX_GetOwner         (LISTBOX_Handle hObj);
Nint              LISTBOX_GetScrollStepH   (LISTBOX_Handle hObj);
Nint              LISTBOX_GetTextAlign     (LISTBOX_Handle hObj);
Nint              LISTBOX_GetUserData      (LISTBOX_Handle hObj, void * pDest, int NumBytes);
Nvoid             LISTBOX_IncSel           (LISTBOX_Handle hObj);
Nvoid             LISTBOX_InsertString     (LISTBOX_Handle hObj, const char * s, unsigned Index);
Nvoid             LISTBOX_InvalidateItem   (LISTBOX_Handle hObj, int Index);
Nint              LISTBOX_OwnerDraw        (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid             LISTBOX_SetAutoScrollH   (LISTBOX_Handle hObj, int OnOff);
Nvoid             LISTBOX_SetAutoScrollV   (LISTBOX_Handle hObj, int OnOff);
Nvoid             LISTBOX_SetBkColor       (LISTBOX_Handle hObj, unsigned Index, GUI_COLOR color);
Nvoid             LISTBOX_SetFixedScrollPos(LISTBOX_Handle hObj, U16 FixedScrollPos, U8 Mode);
Xvoid             LISTBOX_SetFixedScrollPos(LISTBOX_Handle hObj, unsigned short FixedScrollPos, unsigned char Mode);
Nvoid             LISTBOX_SetFont          (LISTBOX_Handle hObj, const GUI_FONT * pFont);
Nvoid             LISTBOX_SetItemDisabled  (LISTBOX_Handle hObj, unsigned Index, int OnOff);
Nvoid             LISTBOX_SetItemSel       (LISTBOX_Handle hObj, unsigned Index, int OnOff);
Nvoid             LISTBOX_SetItemSpacing   (LISTBOX_Handle hObj, unsigned Value);
Nvoid             LISTBOX_SetMulti         (LISTBOX_Handle hObj, int Mode);
Nvoid             LISTBOX_SetOwner         (LISTBOX_Handle hObj, WM_HWIN hOwner);
Xvoid             LISTBOX_SetOwner         (LISTBOX_Handle hObj, GUI_HWIN hOwner);
Nvoid             LISTBOX_SetOwnerDraw     (LISTBOX_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid             LISTBOX_SetScrollStepH   (LISTBOX_Handle hObj, int Value);
Nvoid             LISTBOX_SetSel           (LISTBOX_Handle hObj, int Sel);
Nvoid             LISTBOX_SetScrollbarColor(LISTBOX_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid             LISTBOX_SetScrollbarWidth(LISTBOX_Handle hObj, unsigned Width);
Nvoid             LISTBOX_SetString        (LISTBOX_Handle hObj, const char * s, unsigned Index);
Nvoid             LISTBOX_SetText          (LISTBOX_Handle hObj, const GUI_ConstString * ppText);
Nvoid             LISTBOX_SetTextAlign     (LISTBOX_Handle hObj, int Align);
NGUI_COLOR        LISTBOX_SetTextColor     (LISTBOX_Handle hObj, unsigned Index, GUI_COLOR Color);
Nint              LISTBOX_SetUserData      (LISTBOX_Handle hObj, const void * pSrc, int NumBytes);
Nint              LISTBOX_UpdateScrollers  (LISTBOX_Handle hObj);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
Nconst GUI_FONT * LISTBOX_GetDefaultFont(void);
Nint              LISTBOX_GetDefaultScrollStepH (void);
NGUI_COLOR        LISTBOX_GetDefaultBkColor     (unsigned Index);
Nint              LISTBOX_GetDefaultTextAlign   (void);
NGUI_COLOR        LISTBOX_GetDefaultTextColor   (unsigned Index);
Nvoid             LISTBOX_SetDefaultFont        (const GUI_FONT * pFont);
Nvoid             LISTBOX_SetDefaultScrollStepH (int Value);
Nvoid             LISTBOX_SetDefaultBkColor     (unsigned Index, GUI_COLOR Color);
Nvoid             LISTBOX_SetDefaultTextAlign   (int Align);
Nvoid             LISTBOX_SetDefaultTextColor   (unsigned Index, GUI_COLOR Color);
N
N/*********************************************************************
N*
N*       Compatibility to older versions
N*
N**********************************************************************
N*/
N
N#define LISTBOX_SetBackColor(hObj, Index, Color) LISTBOX_SetBkColor(hObj, Index, Color)
N#define LISTBOX_DeleteString  LISTBOX_DeleteItem
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // LISTBOX_H
N
N/*************************** End of file ****************************/
L 50 "..\..\..\ThirdParty\emWin\Include\DROPDOWN.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/************************************************************
N*
N*       Create flags
N*/
N#define DROPDOWN_CF_AUTOSCROLLBAR   (1 << 0)
N#define DROPDOWN_CF_UP              (1 << 1)
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define DROPDOWN_CI_UNSEL    0
N#define DROPDOWN_CI_SEL      1
N#define DROPDOWN_CI_SELFOCUS 2
N
N#define DROPDOWN_CI_ARROW    0
N#define DROPDOWN_CI_BUTTON   1
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define DROPDOWN_SKINFLEX_PI_EXPANDED 0
N#define DROPDOWN_SKINFLEX_PI_FOCUSED  1
N#define DROPDOWN_SKINFLEX_PI_ENABLED  2
N#define DROPDOWN_SKINFLEX_PI_DISABLED 3
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM DROPDOWN_Handle;
Xtypedef signed long DROPDOWN_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorUpper[2];
N  GUI_COLOR aColorLower[2];
N  GUI_COLOR ColorArrow;
N  GUI_COLOR ColorText;
N  GUI_COLOR ColorSep;
N  int Radius;
N} DROPDOWN_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NDROPDOWN_Handle DROPDOWN_Create        (WM_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
XDROPDOWN_Handle DROPDOWN_Create        (GUI_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
NDROPDOWN_Handle DROPDOWN_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XDROPDOWN_Handle DROPDOWN_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NDROPDOWN_Handle DROPDOWN_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XDROPDOWN_Handle DROPDOWN_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NDROPDOWN_Handle DROPDOWN_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XDROPDOWN_Handle DROPDOWN_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid DROPDOWN_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid             DROPDOWN_AddKey           (DROPDOWN_Handle hObj, int Key);
Nvoid             DROPDOWN_AddString        (DROPDOWN_Handle hObj, const char* s);
Nvoid             DROPDOWN_Collapse         (DROPDOWN_Handle hObj);
Nvoid             DROPDOWN_DecSel           (DROPDOWN_Handle hObj);
Nvoid             DROPDOWN_DecSelExp        (DROPDOWN_Handle hObj);
Nvoid             DROPDOWN_DeleteItem       (DROPDOWN_Handle hObj, unsigned int Index);
Nvoid             DROPDOWN_Expand           (DROPDOWN_Handle hObj);
NGUI_COLOR        DROPDOWN_GetBkColor       (DROPDOWN_Handle hObj, unsigned int Index);
NGUI_COLOR        DROPDOWN_GetColor         (DROPDOWN_Handle hObj, unsigned int Index);
Nconst GUI_FONT * DROPDOWN_GetFont          (DROPDOWN_Handle hObj);
Nunsigned         DROPDOWN_GetItemDisabled  (DROPDOWN_Handle hObj, unsigned Index);
Nunsigned         DROPDOWN_GetItemSpacing   (DROPDOWN_Handle hObj);
Nint              DROPDOWN_GetItemText      (DROPDOWN_Handle hObj, unsigned Index, char * pBuffer, int MaxSize);
NLISTBOX_Handle   DROPDOWN_GetListbox       (DROPDOWN_Handle hObj);
Nint              DROPDOWN_GetNumItems      (DROPDOWN_Handle hObj);
Nint              DROPDOWN_GetSel           (DROPDOWN_Handle hObj);
Nint              DROPDOWN_GetSelExp        (DROPDOWN_Handle hObj);
NGUI_COLOR        DROPDOWN_GetTextColor     (DROPDOWN_Handle hObj, unsigned int Index);
Nint              DROPDOWN_GetUserData      (DROPDOWN_Handle hObj, void * pDest, int NumBytes);
Nvoid             DROPDOWN_IncSel           (DROPDOWN_Handle hObj);
Nvoid             DROPDOWN_IncSelExp        (DROPDOWN_Handle hObj);
Nvoid             DROPDOWN_InsertString     (DROPDOWN_Handle hObj, const char* s, unsigned int Index);
Nvoid             DROPDOWN_SetAutoScroll    (DROPDOWN_Handle hObj, int OnOff);
Nvoid             DROPDOWN_SetBkColor       (DROPDOWN_Handle hObj, unsigned int Index, GUI_COLOR color);
Nvoid             DROPDOWN_SetColor         (DROPDOWN_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid             DROPDOWN_SetFont          (DROPDOWN_Handle hObj, const GUI_FONT * pfont);
Nvoid             DROPDOWN_SetItemDisabled  (DROPDOWN_Handle hObj, unsigned Index, int OnOff);
Nvoid             DROPDOWN_SetItemSpacing   (DROPDOWN_Handle hObj, unsigned Value);
Nint              DROPDOWN_SetListHeight    (DROPDOWN_Handle hObj, unsigned Height);
Nvoid             DROPDOWN_SetScrollbarColor(DROPDOWN_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid             DROPDOWN_SetScrollbarWidth(DROPDOWN_Handle hObj, unsigned Width);
Nvoid             DROPDOWN_SetSel           (DROPDOWN_Handle hObj, int Sel);
Nvoid             DROPDOWN_SetSelExp        (DROPDOWN_Handle hObj, int Sel);
Nvoid             DROPDOWN_SetTextAlign     (DROPDOWN_Handle hObj, int Align);
Nvoid             DROPDOWN_SetTextColor     (DROPDOWN_Handle hObj, unsigned int index, GUI_COLOR color);
Nvoid             DROPDOWN_SetTextHeight    (DROPDOWN_Handle hObj, unsigned TextHeight);
Nint              DROPDOWN_SetUpMode        (DROPDOWN_Handle hObj, int OnOff);
Nint              DROPDOWN_SetUserData      (DROPDOWN_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid DROPDOWN_GetSkinFlexProps     (DROPDOWN_SKINFLEX_PROPS * pProps, int Index);
Nvoid DROPDOWN_SetSkinClassic       (DROPDOWN_Handle hObj);
Nvoid DROPDOWN_SetSkin              (DROPDOWN_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  DROPDOWN_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid DROPDOWN_SetSkinFlexProps     (const DROPDOWN_SKINFLEX_PROPS * pProps, int Index);
Nvoid DROPDOWN_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * DROPDOWN_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define DROPDOWN_SKIN_FLEX    DROPDOWN_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR        DROPDOWN_GetDefaultBkColor       (int Index);
NGUI_COLOR        DROPDOWN_GetDefaultColor         (int Index);
Nconst GUI_FONT * DROPDOWN_GetDefaultFont          (void);
NGUI_COLOR        DROPDOWN_GetDefaultScrollbarColor(int Index);
Nvoid             DROPDOWN_SetDefaultFont          (const GUI_FONT * pFont);
NGUI_COLOR        DROPDOWN_SetDefaultBkColor       (int Index, GUI_COLOR Color);
NGUI_COLOR        DROPDOWN_SetDefaultColor         (int Index, GUI_COLOR Color);
NGUI_COLOR        DROPDOWN_SetDefaultScrollbarColor(int Index, GUI_COLOR Color);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // DROPDOWN_H
N
N/*************************** End of file ****************************/
L 55 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "EDIT.h"
L 1 "..\..\..\ThirdParty\emWin\Include\EDIT.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : EDIT.h
NPurpose     : EDIT include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef EDIT_H
N#define EDIT_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h" // Required for Create indirect data structure
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {             // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defaults for configuration switches
N*
N*  The following are defaults for config switches which affect the
N*  interface specified in this module
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N//
N// Create / Status flags
N//
N#define EDIT_CF_LEFT    GUI_TA_LEFT
N#define EDIT_CF_RIGHT   GUI_TA_RIGHT
N#define EDIT_CF_HCENTER GUI_TA_HCENTER
N#define EDIT_CF_VCENTER GUI_TA_VCENTER
N#define EDIT_CF_TOP     GUI_TA_TOP
N#define EDIT_CF_BOTTOM  GUI_TA_BOTTOM
N
N//
N// Color indices
N//
N#define EDIT_CI_DISABLED 0
N#define EDIT_CI_ENABLED  1
N#define EDIT_CI_CURSOR   2
N
N//
N// Signed or normal mode
N//
N#define GUI_EDIT_NORMAL                  (0 << 0)
N#define GUI_EDIT_SIGNED                  (1 << 0)
N#define GUI_EDIT_SUPPRESS_LEADING_ZEROES (1 << 1)
N
N//
N// Cursor coloring
N//
N#define GUI_EDIT_SHOWCURSOR              (1 << 2)
N#define GUI_EDIT_CUSTCOLORMODE           (1 << 3)
N#define GUI_EDIT_CURSORBLINK             (1 << 4)
N
N//
N// Edit modes
N//
N#define GUI_EDIT_MODE_INSERT    0
N#define GUI_EDIT_MODE_OVERWRITE 1
N
N//
N// Compatibility macros
N//
N#define EDIT_CI_DISABELD EDIT_CI_DISABLED
N#define EDIT_CI_ENABELD  EDIT_CI_ENABLED
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM EDIT_Handle;
Xtypedef signed long EDIT_Handle;
Ntypedef void tEDIT_AddKeyEx    (EDIT_Handle hObj, int Key);
Ntypedef void tEDIT_UpdateBuffer(EDIT_Handle hObj);
N
N/*********************************************************************
N*
N*             Create functions
N*/
NEDIT_Handle EDIT_Create        (int x0, int y0, int xSize, int ySize, int Id, int MaxLen, int Flags);
NEDIT_Handle EDIT_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, int MaxLen);
XEDIT_Handle EDIT_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, int MaxLen);
NEDIT_Handle EDIT_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int MaxLen);
XEDIT_Handle EDIT_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int MaxLen);
NEDIT_Handle EDIT_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int MaxLen, int NumExtraBytes);
XEDIT_Handle EDIT_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int MaxLen, int NumExtraBytes);
NEDIT_Handle EDIT_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XEDIT_Handle EDIT_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid EDIT_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
Nvoid EDIT_SetDefaultBkColor  (unsigned int Index, GUI_COLOR Color);
Nvoid EDIT_SetDefaultFont     (const GUI_FONT * pFont);
Nvoid EDIT_SetDefaultTextAlign(int Align);
Nvoid EDIT_SetDefaultTextColor(unsigned int Index, GUI_COLOR Color);
N
N/*********************************************************************
N*
N*             Individual member functions
N*/
N//
N// Query preferences
N//
NGUI_COLOR        EDIT_GetDefaultBkColor(unsigned int Index);
Nconst GUI_FONT * EDIT_GetDefaultFont(void);
Nint              EDIT_GetDefaultTextAlign(void);
NGUI_COLOR        EDIT_GetDefaultTextColor(unsigned int Index);
N//
N// Methods changing properties
N//
Nvoid EDIT_AddKey           (EDIT_Handle hObj, int Key);
Nvoid EDIT_EnableBlink      (EDIT_Handle hObj, int Period, int OnOff);
NGUI_COLOR EDIT_GetBkColor  (EDIT_Handle hObj, unsigned int Index);
Nvoid EDIT_SetBkColor       (EDIT_Handle hObj, unsigned int Index, GUI_COLOR color);
Nvoid EDIT_SetCursorAtChar  (EDIT_Handle hObj, int Pos);
Nvoid EDIT_SetCursorAtPixel (EDIT_Handle hObj, int xPos);
Nvoid EDIT_SetFont          (EDIT_Handle hObj, const GUI_FONT * pFont);
Nint  EDIT_SetInsertMode    (EDIT_Handle hObj, int OnOff);
Nvoid EDIT_SetMaxLen        (EDIT_Handle hObj, int MaxLen);
Nvoid EDIT_SetpfAddKeyEx    (EDIT_Handle hObj, tEDIT_AddKeyEx * pfAddKeyEx);
Nvoid EDIT_SetpfUpdateBuffer(EDIT_Handle hObj, tEDIT_UpdateBuffer * pfUpdateBuffer);
Nvoid EDIT_SetText          (EDIT_Handle hObj, const char * s);
Nvoid EDIT_SetTextAlign     (EDIT_Handle hObj, int Align);
NGUI_COLOR EDIT_GetTextColor(EDIT_Handle hObj, unsigned int Index);
Nvoid EDIT_SetTextColor     (EDIT_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid EDIT_SetSel           (EDIT_Handle hObj, int FirstChar, int LastChar);
Nint  EDIT_SetUserData      (EDIT_Handle hObj, const void * pSrc, int NumBytes);
Nint  EDIT_EnableInversion  (EDIT_Handle hObj, int OnOff);
N//
N// Get/Set user input
N//
Nint   EDIT_GetCursorCharPos  (EDIT_Handle hObj);
Nvoid  EDIT_GetCursorPixelPos (EDIT_Handle hObj, int * pxPos, int * pyPos);
Nfloat EDIT_GetFloatValue     (EDIT_Handle hObj);
Nconst GUI_FONT * EDIT_GetFont(EDIT_Handle hObj);
Nint   EDIT_GetNumChars       (EDIT_Handle hObj);
Nvoid  EDIT_GetText           (EDIT_Handle hObj, char * sDest, int MaxLen);
Nint   EDIT_GetTextAlign      (EDIT_Handle hObj);
NI32   EDIT_GetValue          (EDIT_Handle hObj);
Xsigned long   EDIT_GetValue          (EDIT_Handle hObj);
Nvoid  EDIT_SetFloatValue     (EDIT_Handle hObj, float Value);
Nint   EDIT_GetUserData       (EDIT_Handle hObj, void * pDest, int NumBytes);
Nvoid  EDIT_SetValue          (EDIT_Handle hObj, I32 Value);
Xvoid  EDIT_SetValue          (EDIT_Handle hObj, signed long Value);
N
N#define EDIT_SetFocussable EDIT_SetFocusable
N#define EDIT_SetFocusable  WIDGET_SetFocusable
N
N/*********************************************************************
N*
N*             Routines for editing values
N*
N**********************************************************************
N*/
Nvoid  EDIT_SetHexMode  (EDIT_Handle hEdit, U32 Value, U32 Min, U32 Max);
Xvoid  EDIT_SetHexMode  (EDIT_Handle hEdit, unsigned long Value, unsigned long Min, unsigned long Max);
Nvoid  EDIT_SetBinMode  (EDIT_Handle hEdit, U32 Value, U32 Min, U32 Max);
Xvoid  EDIT_SetBinMode  (EDIT_Handle hEdit, unsigned long Value, unsigned long Min, unsigned long Max);
Nvoid  EDIT_SetDecMode  (EDIT_Handle hEdit, I32 Value, I32 Min, I32 Max, int Shift, U8 Flags);
Xvoid  EDIT_SetDecMode  (EDIT_Handle hEdit, signed long Value, signed long Min, signed long Max, int Shift, unsigned char Flags);
Nvoid  EDIT_SetFloatMode(EDIT_Handle hEdit, float Value, float Min, float Max, int Shift, U8 Flags);
Xvoid  EDIT_SetFloatMode(EDIT_Handle hEdit, float Value, float Min, float Max, int Shift, unsigned char Flags);
Nvoid  EDIT_SetTextMode (EDIT_Handle hEdit);
Nvoid  EDIT_SetUlongMode(EDIT_Handle hEdit, U32 Value, U32 Min, U32 Max);
Xvoid  EDIT_SetUlongMode(EDIT_Handle hEdit, unsigned long Value, unsigned long Min, unsigned long Max);
N
NU32   GUI_EditHex      (U32 Value, U32 Min, U32 Max, int Len, int xSize);
Xunsigned long   GUI_EditHex      (unsigned long Value, unsigned long Min, unsigned long Max, int Len, int xSize);
NU32   GUI_EditBin      (U32 Value, U32 Min, U32 Max, int Len, int xSize);
Xunsigned long   GUI_EditBin      (unsigned long Value, unsigned long Min, unsigned long Max, int Len, int xSize);
NI32   GUI_EditDec      (I32 Value, I32 Min, I32 Max, int Len, int xSize, int Shift, U8 Flags);
Xsigned long   GUI_EditDec      (signed long Value, signed long Min, signed long Max, int Len, int xSize, int Shift, unsigned char Flags);
Nfloat GUI_EditFloat    (float Value, float Min, float Max, int Len, int xSize, int Shift, U8 Flags);
Xfloat GUI_EditFloat    (float Value, float Min, float Max, int Len, int xSize, int Shift, unsigned char Flags);
Nvoid  GUI_EditString   (char * pString, int Len, int xSize);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // EDIT_H
N
N/*************************** End of file ****************************/
L 56 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "FRAMEWIN.h"
L 1 "..\..\..\ThirdParty\emWin\Include\FRAMEWIN.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : FRAMEWIN.h
NPurpose     : Frame window include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef FRAMEWIN_H
N#define FRAMEWIN_H
N
N#include "WM.h"
N#include "WIDGET.h"             /* Req. for WIDGET_DRAW_ITEM_FUNC */
N#if GUI_WINSUPPORT
X#if 1
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Configuration
N*/
N#ifndef   FRAMEWIN_ALLOW_DRAG_ON_FRAME
N  #define FRAMEWIN_ALLOW_DRAG_ON_FRAME 1
N#endif
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define FRAMEWIN_CI_INACTIVE 0
N#define FRAMEWIN_CI_ACTIVE   1
N
N/*********************************************************************
N*
N*       Create / Status flags
N*/
N#define FRAMEWIN_CF_ACTIVE     (1<<3)
N#define FRAMEWIN_CF_MOVEABLE   (1<<4)
N#define FRAMEWIN_CF_TITLEVIS   (1<<5)
N#define FRAMEWIN_CF_MINIMIZED  (1<<6)
N#define FRAMEWIN_CF_MAXIMIZED  (1<<7)
N#define FRAMEWIN_CF_DRAGGING   (1<<8)
N
N#define FRAMEWIN_SF_ACTIVE     FRAMEWIN_CF_ACTIVE
N#define FRAMEWIN_SF_MOVEABLE   FRAMEWIN_CF_MOVEABLE
N#define FRAMEWIN_SF_TITLEVIS   FRAMEWIN_CF_TITLEVIS
N#define FRAMEWIN_SF_MINIMIZED  FRAMEWIN_CF_MINIMIZED
N#define FRAMEWIN_SF_MAXIMIZED  FRAMEWIN_CF_MAXIMIZED
N#define FRAMEWIN_SF_DRAGGING   FRAMEWIN_CF_DRAGGING
N
N/*********************************************************************
N*
N*       BUTTON Flags
N*/
N#define FRAMEWIN_BUTTON_RIGHT   (1<<0)
N#define FRAMEWIN_BUTTON_LEFT    (1<<1)
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define FRAMEWIN_SKINFLEX_PI_ACTIVE   0
N#define FRAMEWIN_SKINFLEX_PI_INACTIVE 1
N
N/*********************************************************************
N*
N*       Getting border size
N*/
N#define FRAMEWIN_BORDERSIZE_T 0
N#define FRAMEWIN_BORDERSIZE_L 1
N#define FRAMEWIN_BORDERSIZE_B 2
N#define FRAMEWIN_BORDERSIZE_R 3
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM FRAMEWIN_Handle;
Xtypedef signed long FRAMEWIN_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorTitle[2];
N  int Radius;
N  int SpaceX;
N  int BorderSizeL;
N  int BorderSizeR;
N  int BorderSizeT;
N  int BorderSizeB;
N} FRAMEWIN_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NFRAMEWIN_Handle FRAMEWIN_Create        (const char * pTitle, WM_CALLBACK * cb, int Flags, int x0, int y0, int xSize, int ySize);
NFRAMEWIN_Handle FRAMEWIN_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, const char * pText, WM_CALLBACK * cb, int Flags);
XFRAMEWIN_Handle FRAMEWIN_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, const char * pText, WM_CALLBACK * cb, int Flags);
NFRAMEWIN_Handle FRAMEWIN_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb);
XFRAMEWIN_Handle FRAMEWIN_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb);
NFRAMEWIN_Handle FRAMEWIN_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb, int NumExtraBytes);
XFRAMEWIN_Handle FRAMEWIN_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb, int NumExtraBytes);
NFRAMEWIN_Handle FRAMEWIN_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XFRAMEWIN_Handle FRAMEWIN_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid FRAMEWIN_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions: Set Properties
N*
N**********************************************************************
N*/
NWM_HWIN FRAMEWIN_AddButton     (FRAMEWIN_Handle hObj, int Flags, int Off, int Id);
XGUI_HWIN FRAMEWIN_AddButton     (FRAMEWIN_Handle hObj, int Flags, int Off, int Id);
NWM_HWIN FRAMEWIN_AddCloseButton(FRAMEWIN_Handle hObj, int Flags, int Off);
XGUI_HWIN FRAMEWIN_AddCloseButton(FRAMEWIN_Handle hObj, int Flags, int Off);
NWM_HWIN FRAMEWIN_AddMaxButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
XGUI_HWIN FRAMEWIN_AddMaxButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
Nvoid    FRAMEWIN_AddMenu       (FRAMEWIN_Handle hObj, WM_HWIN hMenu);
Xvoid    FRAMEWIN_AddMenu       (FRAMEWIN_Handle hObj, GUI_HWIN hMenu);
NWM_HWIN FRAMEWIN_AddMinButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
XGUI_HWIN FRAMEWIN_AddMinButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
Nvoid    FRAMEWIN_Minimize      (FRAMEWIN_Handle hObj);
Nvoid    FRAMEWIN_Maximize      (FRAMEWIN_Handle hObj);
Nvoid    FRAMEWIN_Restore       (FRAMEWIN_Handle hObj);
Nvoid    FRAMEWIN_SetActive     (FRAMEWIN_Handle hObj, int State);
Nvoid    FRAMEWIN_SetBarColor   (FRAMEWIN_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetBorderSize (FRAMEWIN_Handle hObj, unsigned Size);
Nvoid    FRAMEWIN_SetClientColor(FRAMEWIN_Handle hObj, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetFont       (FRAMEWIN_Handle hObj, const GUI_FONT * pFont);
Nvoid    FRAMEWIN_SetMoveable   (FRAMEWIN_Handle hObj, int State);
Nvoid    FRAMEWIN_SetOwnerDraw  (FRAMEWIN_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid    FRAMEWIN_SetResizeable (FRAMEWIN_Handle hObj, int State);
Nvoid    FRAMEWIN_SetText       (FRAMEWIN_Handle hObj, const char* s);
Nvoid    FRAMEWIN_SetTextAlign  (FRAMEWIN_Handle hObj, int Align);
Nvoid    FRAMEWIN_SetTextColor  (FRAMEWIN_Handle hObj, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetTextColorEx(FRAMEWIN_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetTitleVis   (FRAMEWIN_Handle hObj, int Show);
Nint     FRAMEWIN_SetTitleHeight(FRAMEWIN_Handle hObj, int Height);
Nint     FRAMEWIN_SetUserData   (FRAMEWIN_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid FRAMEWIN_GetSkinFlexProps     (FRAMEWIN_SKINFLEX_PROPS * pProps, int Index);
Nvoid FRAMEWIN_SetSkinClassic       (FRAMEWIN_Handle hObj);
Nvoid FRAMEWIN_SetSkin              (FRAMEWIN_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  FRAMEWIN_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid FRAMEWIN_SetSkinFlexProps     (const FRAMEWIN_SKINFLEX_PROPS * pProps, int Index);
Nvoid FRAMEWIN_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * FRAMEWIN_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define FRAMEWIN_SKIN_FLEX    FRAMEWIN_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Member functions: Get Properties
N*
N**********************************************************************
N*/
Nconst GUI_FONT * FRAMEWIN_GetFont(FRAMEWIN_Handle hObj);
N
Nint       FRAMEWIN_GetActive      (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_GetTitleHeight (FRAMEWIN_Handle hObj);
NGUI_COLOR FRAMEWIN_GetBarColor    (FRAMEWIN_Handle hObj, unsigned Index);
Nint       FRAMEWIN_GetBorderSize  (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_GetBorderSizeEx(FRAMEWIN_Handle hObj, unsigned Edge);
Nvoid      FRAMEWIN_GetText        (FRAMEWIN_Handle hObj, char * pBuffer, int MaxLen);
Nint       FRAMEWIN_GetTextAlign   (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_GetUserData    (FRAMEWIN_Handle hObj, void * pDest, int NumBytes);
Nint       FRAMEWIN_IsMinimized    (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_IsMaximized    (FRAMEWIN_Handle hObj);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR        FRAMEWIN_GetDefaultBarColor   (unsigned Index);
Nint              FRAMEWIN_GetDefaultBorderSize (void);
Nint              FRAMEWIN_GetDefaultTitleHeight(void);
NGUI_COLOR        FRAMEWIN_GetDefaultClientColor(void);
Nconst GUI_FONT * FRAMEWIN_GetDefaultFont       (void);
NGUI_COLOR        FRAMEWIN_GetDefaultTextColor  (unsigned Index);
Nint              FRAMEWIN_OwnerDraw            (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid             FRAMEWIN_SetDefaultBarColor   (unsigned Index, GUI_COLOR Color);
Nvoid             FRAMEWIN_SetDefaultBorderSize (int DefaultBorderSize);
Nvoid             FRAMEWIN_SetDefaultTitleHeight(int DefaultTitleHeight);
Nvoid             FRAMEWIN_SetDefaultClientColor(GUI_COLOR Color);
Nvoid             FRAMEWIN_SetDefaultFont       (const GUI_FONT * pFont);
Nint              FRAMEWIN_SetDefaultTextAlign  (int TextAlign);
Nvoid             FRAMEWIN_SetDefaultTextColor  (unsigned Index, GUI_COLOR Color);
N
N/*********************************************************************
N*
N*       Macros for compatibility
N*
N**********************************************************************
N*/
N#define         FRAMEWIN_SetDefaultCaptionSize(Height)       FRAMEWIN_SetDefaultTitleHeight(Height)
N#define         FRAMEWIN_GetDefaultCaptionSize()             FRAMEWIN_GetDefaultTitleHeight()
N#define         FRAMEWIN_CreateButton(hObj, Flags, Off, Id)  FRAMEWIN_AddButton(hObj, Flags, Off, Id) 
N#define         FRAMEWIN_CreateCloseButton(hObj, Flags, Off) FRAMEWIN_AddCloseButton(hObj, Flags, Off)
N#define         FRAMEWIN_CreateMaxButton(hObj, Flags, Off)   FRAMEWIN_AddMaxButton(hObj, Flags, Off)  
N#define         FRAMEWIN_CreateMinButton(hObj, Flags, Off)   FRAMEWIN_AddMinButton(hObj, Flags, Off)  
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // FRAMEWIN_H
N
N/*************************** End of file ****************************/
L 57 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "GRAPH.h"
L 1 "..\..\..\ThirdParty\emWin\Include\GRAPH.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GRAPH.h
NPurpose     : GRAPH include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef GRAPH_H
N#define GRAPH_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define GRAPH_CI_BK                  0
N#define GRAPH_CI_BORDER              1
N#define GRAPH_CI_FRAME               2
N#define GRAPH_CI_GRID                3
N
N#define GRAPH_SCALE_CF_HORIZONTAL    (0 << 0)
N#define GRAPH_SCALE_CF_VERTICAL      (1 << 0)
N
N#define GRAPH_SCALE_SF_HORIZONTAL    GRAPH_SCALE_CF_HORIZONTAL
N#define GRAPH_SCALE_SF_VERTICAL      GRAPH_SCALE_CF_VERTICAL
N
N#define GRAPH_DRAW_FIRST             0
N#define GRAPH_DRAW_AFTER_BORDER      1
N#define GRAPH_DRAW_LAST              2
N
N#define GRAPH_ALIGN_RIGHT            (0 << 0)
N#define GRAPH_ALIGN_LEFT             (1 << 0)
N
N//
N// Creation flags (ExFlags)
N//
N#define GRAPH_CF_GRID_FIXED_X        (1 << 0)
N#define GRAPH_CF_AVOID_SCROLLBAR_H   (1 << 1)
N#define GRAPH_CF_AVOID_SCROLLBAR_V   (1 << 2)
N
N//
N// Status flags
N//
N#define GRAPH_SF_AVOID_SCROLLBAR_H   GRAPH_CF_AVOID_SCROLLBAR_H
N#define GRAPH_SF_AVOID_SCROLLBAR_V   GRAPH_CF_AVOID_SCROLLBAR_V
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM GRAPH_Handle;
Xtypedef signed long GRAPH_Handle;
Ntypedef WM_HMEM GRAPH_DATA_Handle;
Xtypedef signed long GRAPH_DATA_Handle;
Ntypedef WM_HMEM GRAPH_SCALE_Handle;
Xtypedef signed long GRAPH_SCALE_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
N
NGRAPH_Handle GRAPH_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XGRAPH_Handle GRAPH_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NGRAPH_Handle GRAPH_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XGRAPH_Handle GRAPH_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NGRAPH_Handle GRAPH_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XGRAPH_Handle GRAPH_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
NGRAPH_DATA_Handle  GRAPH_DATA_XY_Create(GUI_COLOR Color, unsigned MaxNumItems, const GUI_POINT * pData, unsigned NumItems);
NGRAPH_DATA_Handle  GRAPH_DATA_YT_Create(GUI_COLOR Color, unsigned MaxNumItems, const I16 * pData, unsigned NumItems);
XGRAPH_DATA_Handle  GRAPH_DATA_YT_Create(GUI_COLOR Color, unsigned MaxNumItems, const signed short * pData, unsigned NumItems);
NGRAPH_SCALE_Handle GRAPH_SCALE_Create  (int Pos, int TextAlign, unsigned Flags, unsigned TickDist);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid GRAPH_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid      GRAPH_AttachData             (GRAPH_Handle hObj, GRAPH_DATA_Handle hData);
Nvoid      GRAPH_AttachScale            (GRAPH_Handle hObj, GRAPH_SCALE_Handle hScale);
Nvoid      GRAPH_DetachData             (GRAPH_Handle hObj, GRAPH_DATA_Handle hData);
Nvoid      GRAPH_DetachScale            (GRAPH_Handle hObj, GRAPH_SCALE_Handle hScale);
NGUI_COLOR GRAPH_GetColor               (GRAPH_Handle hObj, unsigned Index);
NI32       GRAPH_GetScrollValue         (GRAPH_Handle hObj, U8 Coord);
Xsigned long       GRAPH_GetScrollValue         (GRAPH_Handle hObj, unsigned char Coord);
Nint       GRAPH_GetUserData            (GRAPH_Handle hObj, void * pDest, int NumBytes);
Nvoid      GRAPH_SetAutoScrollbar       (GRAPH_Handle hObj, U8 Coord, U8 OnOff);
Xvoid      GRAPH_SetAutoScrollbar       (GRAPH_Handle hObj, unsigned char Coord, unsigned char OnOff);
Nvoid      GRAPH_SetBorder              (GRAPH_Handle hObj, unsigned BorderL, unsigned BorderT, unsigned BorderR, unsigned BorderB);
NGUI_COLOR GRAPH_SetColor               (GRAPH_Handle hObj, GUI_COLOR Color, unsigned Index);
Nunsigned  GRAPH_SetGridFixedX          (GRAPH_Handle hObj, unsigned OnOff);
Nunsigned  GRAPH_SetGridOffX            (GRAPH_Handle hObj, unsigned Value);
Nunsigned  GRAPH_SetGridOffY            (GRAPH_Handle hObj, unsigned Value);
Nunsigned  GRAPH_SetGridVis             (GRAPH_Handle hObj, unsigned OnOff);
Nunsigned  GRAPH_SetGridDistX           (GRAPH_Handle hObj, unsigned Value);
Nunsigned  GRAPH_SetGridDistY           (GRAPH_Handle hObj, unsigned Value);
NU8        GRAPH_SetLineStyleH          (GRAPH_Handle hObj, U8 Value);
Xunsigned char        GRAPH_SetLineStyleH          (GRAPH_Handle hObj, unsigned char Value);
NU8        GRAPH_SetLineStyleV          (GRAPH_Handle hObj, U8 Value);
Xunsigned char        GRAPH_SetLineStyleV          (GRAPH_Handle hObj, unsigned char Value);
Nvoid      GRAPH_SetLineStyle           (GRAPH_Handle hObj, U8 Value);
Xvoid      GRAPH_SetLineStyle           (GRAPH_Handle hObj, unsigned char Value);
Nvoid      GRAPH_SetScrollValue         (GRAPH_Handle hObj, U8 Coord, U32 Value);
Xvoid      GRAPH_SetScrollValue         (GRAPH_Handle hObj, unsigned char Coord, unsigned long Value);
Nunsigned  GRAPH_SetVSizeX              (GRAPH_Handle hObj, unsigned Value);
Nunsigned  GRAPH_SetVSizeY              (GRAPH_Handle hObj, unsigned Value);
Nint       GRAPH_SetUserData            (GRAPH_Handle hObj, const void * pSrc, int NumBytes);
Nvoid      GRAPH_SetUserDraw            (GRAPH_Handle hObj, void (* pOwnerDraw)(WM_HWIN, int));
Xvoid      GRAPH_SetUserDraw            (GRAPH_Handle hObj, void (* pOwnerDraw)(GUI_HWIN, int));
N
Nvoid      GRAPH_DATA_YT_AddValue       (GRAPH_DATA_Handle hDataObj, I16 Value);
Xvoid      GRAPH_DATA_YT_AddValue       (GRAPH_DATA_Handle hDataObj, signed short Value);
Nvoid      GRAPH_DATA_YT_Clear          (GRAPH_DATA_Handle hDataObj);
Nvoid      GRAPH_DATA_YT_Delete         (GRAPH_DATA_Handle hDataObj);
Nint       GRAPH_DATA_YT_GetValue       (GRAPH_DATA_Handle hDataObj, I16 * pValue, U32 Index);
Xint       GRAPH_DATA_YT_GetValue       (GRAPH_DATA_Handle hDataObj, signed short * pValue, unsigned long Index);
N
Nvoid      GRAPH_DATA_YT_SetAlign       (GRAPH_DATA_Handle hDataObj, int Align);
Nvoid      GRAPH_DATA_YT_SetOffY        (GRAPH_DATA_Handle hDataObj, int Off);
Nvoid      GRAPH_DATA_YT_MirrorX        (GRAPH_DATA_Handle hDataObj, int OnOff);
N
Nvoid      GRAPH_DATA_XY_AddPoint       (GRAPH_DATA_Handle hDataObj, GUI_POINT * pPoint);
Nvoid      GRAPH_DATA_XY_Clear          (GRAPH_DATA_Handle hDataObj);
Nvoid      GRAPH_DATA_XY_Delete         (GRAPH_DATA_Handle hDataObj);
Nunsigned  GRAPH_DATA_XY_GetLineVis     (GRAPH_DATA_Handle hDataObj);
Nint       GRAPH_DATA_XY_GetPoint       (GRAPH_DATA_Handle hDataObj, GUI_POINT * pPoint, U32 Index);
Xint       GRAPH_DATA_XY_GetPoint       (GRAPH_DATA_Handle hDataObj, GUI_POINT * pPoint, unsigned long Index);
Nunsigned  GRAPH_DATA_XY_GetPointVis    (GRAPH_DATA_Handle hDataObj);
Nvoid      GRAPH_DATA_XY_SetLineStyle   (GRAPH_DATA_Handle hDataObj, U8 LineStyle);
Xvoid      GRAPH_DATA_XY_SetLineStyle   (GRAPH_DATA_Handle hDataObj, unsigned char LineStyle);
Nunsigned  GRAPH_DATA_XY_SetLineVis     (GRAPH_DATA_Handle hDataObj, unsigned OnOff);
Nvoid      GRAPH_DATA_XY_SetOffX        (GRAPH_DATA_Handle hDataObj, int Off);
Nvoid      GRAPH_DATA_XY_SetOffY        (GRAPH_DATA_Handle hDataObj, int Off);
Nvoid      GRAPH_DATA_XY_SetPenSize     (GRAPH_DATA_Handle hDataObj, U8 PenSize);
Xvoid      GRAPH_DATA_XY_SetPenSize     (GRAPH_DATA_Handle hDataObj, unsigned char PenSize);
Nvoid      GRAPH_DATA_XY_SetPointSize   (GRAPH_DATA_Handle hDataObj, unsigned PointSize);
Nunsigned  GRAPH_DATA_XY_SetPointVis    (GRAPH_DATA_Handle hDataObj, unsigned OnOff);
Nvoid      GRAPH_DATA_XY_SetOwnerDraw   (GRAPH_DATA_Handle hDataObj, WIDGET_DRAW_ITEM_FUNC * pOwnerDraw);
N
Nvoid             GRAPH_SCALE_Delete      (GRAPH_SCALE_Handle hScaleObj);
Nfloat            GRAPH_SCALE_SetFactor   (GRAPH_SCALE_Handle hScaleObj, float Factor);
Nconst GUI_FONT * GRAPH_SCALE_SetFont     (GRAPH_SCALE_Handle hScaleObj, const GUI_FONT * pFont);
Nint              GRAPH_SCALE_SetNumDecs  (GRAPH_SCALE_Handle hScaleObj, int NumDecs);
Nint              GRAPH_SCALE_SetOff      (GRAPH_SCALE_Handle hScaleObj, int Off);
Nint              GRAPH_SCALE_SetPos      (GRAPH_SCALE_Handle hScaleObj, int Pos);
NGUI_COLOR        GRAPH_SCALE_SetTextColor(GRAPH_SCALE_Handle hScaleObj, GUI_COLOR Color);
Nunsigned         GRAPH_SCALE_SetTickDist (GRAPH_SCALE_Handle hScaleObj, unsigned Value);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // GRAPH_H
N
N/*************************** End of file ****************************/
L 58 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "HEADER.h"
L 1 "..\..\..\ThirdParty\emWin\Include\HEADER.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : HEADER.h
NPurpose     : HEADER include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef HEADER_H
N#define HEADER_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
N
Ntypedef WM_HMEM HEADER_Handle;
Xtypedef signed long HEADER_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[2];
N  GUI_COLOR aColorUpper[2];
N  GUI_COLOR aColorLower[2];
N  GUI_COLOR ColorArrow;
N} HEADER_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
N
NHEADER_Handle HEADER_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, int SpecialFlags);
XHEADER_Handle HEADER_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, int SpecialFlags);
NHEADER_Handle HEADER_CreateAttached(WM_HWIN hParent, int Id, int SpecialFlags);
XHEADER_Handle HEADER_CreateAttached(GUI_HWIN hParent, int Id, int SpecialFlags);
NHEADER_Handle HEADER_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XHEADER_Handle HEADER_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NHEADER_Handle HEADER_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XHEADER_Handle HEADER_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NHEADER_Handle HEADER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XHEADER_Handle HEADER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid HEADER_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N/* Set defaults */
NGUI_COLOR          HEADER_SetDefaultArrowColor(GUI_COLOR Color);
NGUI_COLOR          HEADER_SetDefaultBkColor   (GUI_COLOR Color);
Nconst GUI_CURSOR * HEADER_SetDefaultCursor    (const GUI_CURSOR * pCursor);
Nconst GUI_FONT *   HEADER_SetDefaultFont      (const GUI_FONT * pFont);
Nint                HEADER_SetDefaultBorderH   (int Spacing);
Nint                HEADER_SetDefaultBorderV   (int Spacing);
NGUI_COLOR          HEADER_SetDefaultTextColor (GUI_COLOR Color);
N
N/* Get defaults */
NGUI_COLOR          HEADER_GetDefaultArrowColor(void);
NGUI_COLOR          HEADER_GetDefaultBkColor   (void);
Nconst GUI_CURSOR * HEADER_GetDefaultCursor    (void);
Nconst GUI_FONT *   HEADER_GetDefaultFont      (void);
Nint                HEADER_GetDefaultBorderH   (void);
Nint                HEADER_GetDefaultBorderV   (void);
NGUI_COLOR          HEADER_GetDefaultTextColor (void);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid             HEADER_AddItem            (HEADER_Handle hObj, int Width, const char * s, int Align);
Nvoid             HEADER_DeleteItem         (HEADER_Handle hObj, unsigned Index);
NGUI_COLOR        HEADER_GetArrowColor      (HEADER_Handle hObj);
NGUI_COLOR        HEADER_GetBkColor         (HEADER_Handle hObj);
Nconst GUI_FONT * HEADER_GetFont            (HEADER_Handle hObj);
Nint              HEADER_GetHeight          (HEADER_Handle hObj);
Nint              HEADER_GetItemText        (HEADER_Handle hObj, unsigned Index, char * pBuffer, int MaxSize);
Nint              HEADER_GetItemWidth       (HEADER_Handle hObj, unsigned Index);
Nint              HEADER_GetNumItems        (HEADER_Handle hObj);
Nint              HEADER_GetSel             (HEADER_Handle hObj);
NGUI_COLOR        HEADER_GetTextColor       (HEADER_Handle hObj);
Nint              HEADER_GetUserData        (HEADER_Handle hObj, void * pDest, int NumBytes);
Nvoid             HEADER_SetArrowColor      (HEADER_Handle hObj, GUI_COLOR Color);
Nvoid             HEADER_SetBitmap          (HEADER_Handle hObj, unsigned Index, const GUI_BITMAP * pBitmap);
Nvoid             HEADER_SetBitmapEx        (HEADER_Handle hObj, unsigned Index, const GUI_BITMAP * pBitmap, int x, int y);
Nvoid             HEADER_SetBkColor         (HEADER_Handle hObj, GUI_COLOR Color);
Nvoid             HEADER_SetBMP             (HEADER_Handle hObj, unsigned Index, const void * pBitmap);
Nvoid             HEADER_SetBMPEx           (HEADER_Handle hObj, unsigned Index, const void * pBitmap, int x, int y);
Nvoid             HEADER_SetDirIndicator    (HEADER_Handle hObj, int Column, int Reverse); /* !!!Not to be documented!!! */
Nvoid             HEADER_SetDragLimit       (HEADER_Handle hObj, unsigned DragLimit);
Nunsigned         HEADER_SetFixed           (HEADER_Handle hObj, unsigned Fixed);
Nvoid             HEADER_SetFont            (HEADER_Handle hObj, const GUI_FONT * pFont);
Nvoid             HEADER_SetHeight          (HEADER_Handle hObj, int Height);
Nvoid             HEADER_SetTextAlign       (HEADER_Handle hObj, unsigned Index, int Align);
Nvoid             HEADER_SetItemText        (HEADER_Handle hObj, unsigned Index, const char * s);
Nvoid             HEADER_SetItemWidth       (HEADER_Handle hObj, unsigned Index, int Width);
Nvoid             HEADER_SetScrollPos       (HEADER_Handle hObj, int ScrollPos);
Nvoid             HEADER_SetStreamedBitmap  (HEADER_Handle hObj, unsigned Index, const GUI_BITMAP_STREAM * pBitmap);
Nvoid             HEADER_SetStreamedBitmapEx(HEADER_Handle hObj, unsigned Index, const GUI_BITMAP_STREAM * pBitmap, int x, int y);
Nvoid             HEADER_SetTextColor       (HEADER_Handle hObj, GUI_COLOR Color);
Nint              HEADER_SetUserData        (HEADER_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid HEADER_GetSkinFlexProps     (HEADER_SKINFLEX_PROPS * pProps, int Index);
Nvoid HEADER_SetSkinClassic       (HEADER_Handle hObj);
Nvoid HEADER_SetSkin              (HEADER_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  HEADER_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid HEADER_SetSkinFlexProps     (const HEADER_SKINFLEX_PROPS * pProps, int Index);
Nvoid HEADER_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * HEADER_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define HEADER_SKIN_FLEX          HEADER_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Macros for compatibility with older versions
N*
N**********************************************************************
N*/
N
N#ifdef HEADER_SPACING_H
S  #define HEADER_BORDER_H_DEFAULT HEADER_SPACING_H
N#endif
N#ifdef HEADER_SPACING_V
S  #define HEADER_BORDER_V_DEFAULT HEADER_SPACING_V
N#endif
N#define HEADER_SetDefaultSpacingH(Value) HEADER_SetDefaultBorderH(Value)
N#define HEADER_SetDefaultSpacingV(Value) HEADER_SetDefaultBorderV(Value)
N#define HEADER_GetDefaultSpacingH()      HEADER_GetDefaultBorderH()
N#define HEADER_GetDefaultSpacingV()      HEADER_GetDefaultBorderV()
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // HEADER_H
N
N/*************************** End of file ****************************/
L 59 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "ICONVIEW.h"
L 1 "..\..\..\ThirdParty\emWin\Include\ICONVIEW.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : ICONVIEW.h
NPurpose     : ICONVIEW include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef ICONVIEW_H
N#define ICONVIEW_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N//
N// Status- and create flags
N//
N#define ICONVIEW_CF_AUTOSCROLLBAR_V (1 << 1)
N#define ICONVIEW_SF_AUTOSCROLLBAR_V ICONVIEW_CF_AUTOSCROLLBAR_V
N
N//
N// Color indices
N//
N#define ICONVIEW_CI_BK              0
N#define ICONVIEW_CI_UNSEL           0
N#define ICONVIEW_CI_SEL             1
N#define ICONVIEW_CI_DISABLED        2
N
N//
N// Icon alignment flags, horizontal
N//
N#define ICONVIEW_IA_HCENTER         (0 << 0)
N#define ICONVIEW_IA_LEFT            (1 << 0)
N#define ICONVIEW_IA_RIGHT           (2 << 0)
N
N//
N// Icon alignment flags, vertical
N//
N#define ICONVIEW_IA_VCENTER         (0 << 2)
N#define ICONVIEW_IA_BOTTOM          (1 << 2)
N#define ICONVIEW_IA_TOP             (2 << 2)
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM ICONVIEW_Handle;
Xtypedef signed long ICONVIEW_Handle;
N
N/*********************************************************************
N*
N*       Public functions
N*
N**********************************************************************
N*/
NICONVIEW_Handle ICONVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int xSizeItems, int ySizeItems);
XICONVIEW_Handle ICONVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int xSizeItems, int ySizeItems);
NICONVIEW_Handle ICONVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int xSizeItems, int ySizeItems, int NumExtraBytes);
XICONVIEW_Handle ICONVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int xSizeItems, int ySizeItems, int NumExtraBytes);
NICONVIEW_Handle ICONVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XICONVIEW_Handle ICONVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
Nint              ICONVIEW_AddBitmapItem           (ICONVIEW_Handle hObj, const GUI_BITMAP * pBitmap, const char * pText);
Nint              ICONVIEW_AddBMPItem              (ICONVIEW_Handle hObj, const U8 * pBMP, const char * pText);
Xint              ICONVIEW_AddBMPItem              (ICONVIEW_Handle hObj, const unsigned char * pBMP, const char * pText);
Nint              ICONVIEW_AddBMPItemEx            (ICONVIEW_Handle hObj, const void * pBMP, GUI_GET_DATA_FUNC * pfGetData, const char * pText);
Nint              ICONVIEW_AddStreamedBitmapItem   (ICONVIEW_Handle hObj, const void * pStreamedBitmap, const char * pText);
Nvoid             ICONVIEW_DeleteItem              (ICONVIEW_Handle hObj, unsigned Index);
N//void             ICONVIEW_EnableStreamAuto        (void);
NGUI_COLOR        ICONVIEW_GetBkColor              (ICONVIEW_Handle hObj, int Index);
Nconst GUI_FONT * ICONVIEW_GetFont                 (ICONVIEW_Handle hObj);
NU32              ICONVIEW_GetItemUserData         (ICONVIEW_Handle hObj, int Index);
Xunsigned long              ICONVIEW_GetItemUserData         (ICONVIEW_Handle hObj, int Index);
Nint              ICONVIEW_GetNumItems             (ICONVIEW_Handle hObj);
Nint              ICONVIEW_GetItemText             (ICONVIEW_Handle hObj, int Index, char * pBuffer, int MaxSize);
Nint              ICONVIEW_GetSel                  (ICONVIEW_Handle hObj);
NGUI_COLOR        ICONVIEW_GetTextColor            (ICONVIEW_Handle hObj, int Index);
Nint              ICONVIEW_GetUserData             (ICONVIEW_Handle hObj, void * pDest, int NumBytes);
NGUI_BITMAP *     ICONVIEW_GetItemBitmap           (ICONVIEW_Handle hObj, int ItemIndex);
Nint              ICONVIEW_GetReleasedItem         (ICONVIEW_Handle hObj);
Nint              ICONVIEW_InsertBitmapItem        (ICONVIEW_Handle hObj, const GUI_BITMAP * pBitmap, const char * pText, int Index);
Nint              ICONVIEW_InsertBMPItem           (ICONVIEW_Handle hObj, const U8 * pBMP, const char * pText, int Index);
Xint              ICONVIEW_InsertBMPItem           (ICONVIEW_Handle hObj, const unsigned char * pBMP, const char * pText, int Index);
Nint              ICONVIEW_InsertBMPItemEx         (ICONVIEW_Handle hObj, const void * pBMP, GUI_GET_DATA_FUNC * pfGetData, const char * pText, int Index);
Nint              ICONVIEW_InsertStreamedBitmapItem(ICONVIEW_Handle hObj, const void * pStreamedBitmap, const char * pText, int Index);
Nint              ICONVIEW_OwnerDraw               (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nint              ICONVIEW_SetBitmapItem           (ICONVIEW_Handle hObj, int Index, const GUI_BITMAP * pBitmap);
Nvoid             ICONVIEW_SetBkColor              (ICONVIEW_Handle hObj, int Index, GUI_COLOR Color);
Nint              ICONVIEW_SetBMPItem              (ICONVIEW_Handle hObj, const U8 * pBMP, int Index);
Xint              ICONVIEW_SetBMPItem              (ICONVIEW_Handle hObj, const unsigned char * pBMP, int Index);
Nint              ICONVIEW_SetBMPItemEx            (ICONVIEW_Handle hObj, const void * pBMP, GUI_GET_DATA_FUNC * pfGetData, int Index);
Nvoid             ICONVIEW_SetFont                 (ICONVIEW_Handle hObj, const GUI_FONT * pFont);
Nvoid             ICONVIEW_SetFrame                (ICONVIEW_Handle hObj, int Coord, int Value);
Nvoid             ICONVIEW_SetItemText             (ICONVIEW_Handle hObj, int Index, const char * pText);
Nvoid             ICONVIEW_SetItemUserData         (ICONVIEW_Handle hObj, int Index, U32 UserData);
Xvoid             ICONVIEW_SetItemUserData         (ICONVIEW_Handle hObj, int Index, unsigned long UserData);
Nvoid             ICONVIEW_SetOwnerDraw            (ICONVIEW_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid             ICONVIEW_SetSel                  (ICONVIEW_Handle hObj, int Sel);
Nvoid             ICONVIEW_SetSpace                (ICONVIEW_Handle hObj, int Coord, int Value);
Nint              ICONVIEW_SetStreamedBitmapItem   (ICONVIEW_Handle hObj, int Index, const void * pStreamedBitmap);
Nvoid             ICONVIEW_SetIconAlign            (ICONVIEW_Handle hObj, int IconAlign);
Nvoid             ICONVIEW_SetTextAlign            (ICONVIEW_Handle hObj, int TextAlign);
Nvoid             ICONVIEW_SetTextColor            (ICONVIEW_Handle hObj, int Index, GUI_COLOR Color);
Nint              ICONVIEW_SetUserData             (ICONVIEW_Handle hObj, const void * pSrc, int NumBytes);
Nvoid             ICONVIEW_SetWrapMode             (ICONVIEW_Handle hObj, GUI_WRAPMODE WrapMode);
N
Nvoid             ICONVIEW_Callback                (WM_MESSAGE * pMsg);
N
N//
N// Compatibility macro
N//
N#define ICONVIEW_EnableStreamAuto() GUI_DrawStreamedEnableAuto()
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // ICONVIEW_H
N
N/*************************** End of file ****************************/
L 60 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "IMAGE.h"
L 1 "..\..\..\ThirdParty\emWin\Include\IMAGE.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : IMAGE.h
NPurpose     : Image include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef IMAGE_H
N#define IMAGE_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" { // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define IMAGE_CF_MEMDEV   (1 << 0) // Widget uses an internal memory device which speeds up use of compressed images (GIF, JPEG, PNG)
N#define IMAGE_CF_TILE     (1 << 1) // Uses tiling to fill up the whole area of the widget
N#define IMAGE_CF_ALPHA    (1 << 2) // Needs to be set if alpha blending is required (PNG)
N#define IMAGE_CF_ATTACHED (1 << 3) // Widget size is fixed to the parent border
N#define IMAGE_CF_AUTOSIZE (1 << 4) // Widget size is taken from the attached image
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM IMAGE_Handle;
Xtypedef signed long IMAGE_Handle;
N
N/*********************************************************************
N*
N*       Public functions
N*
N**********************************************************************
N*/
NIMAGE_Handle IMAGE_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XIMAGE_Handle IMAGE_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NIMAGE_Handle IMAGE_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XIMAGE_Handle IMAGE_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NIMAGE_Handle IMAGE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XIMAGE_Handle IMAGE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
Nvoid IMAGE_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nint  IMAGE_GetUserData(IMAGE_Handle hObj, void * pDest, int NumBytes);
Nvoid IMAGE_SetBitmap  (IMAGE_Handle hWin, const GUI_BITMAP * pBitmap);
Nvoid IMAGE_SetBMP     (IMAGE_Handle hObj, const void * pData, U32 FileSize);
Xvoid IMAGE_SetBMP     (IMAGE_Handle hObj, const void * pData, unsigned long FileSize);
Nvoid IMAGE_SetBMPEx   (IMAGE_Handle hObj, GUI_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid IMAGE_SetDTA     (IMAGE_Handle hObj, const void * pData, U32 FileSize);
Xvoid IMAGE_SetDTA     (IMAGE_Handle hObj, const void * pData, unsigned long FileSize);
Nvoid IMAGE_SetDTAEx   (IMAGE_Handle hObj, GUI_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid IMAGE_SetGIF     (IMAGE_Handle hObj, const void * pData, U32 FileSize);
Xvoid IMAGE_SetGIF     (IMAGE_Handle hObj, const void * pData, unsigned long FileSize);
Nvoid IMAGE_SetGIFEx   (IMAGE_Handle hObj, GUI_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid IMAGE_SetJPEG    (IMAGE_Handle hObj, const void * pData, U32 FileSize);
Xvoid IMAGE_SetJPEG    (IMAGE_Handle hObj, const void * pData, unsigned long FileSize);
Nvoid IMAGE_SetJPEGEx  (IMAGE_Handle hObj, GUI_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid IMAGE_SetPNG     (IMAGE_Handle hObj, const void * pData, U32 FileSize);
Xvoid IMAGE_SetPNG     (IMAGE_Handle hObj, const void * pData, unsigned long FileSize);
Nvoid IMAGE_SetPNGEx   (IMAGE_Handle hObj, GUI_GET_DATA_FUNC * pfGetData, void * pVoid);
Nint  IMAGE_SetUserData(IMAGE_Handle hObj, const void * pSrc, int NumBytes);
N
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif // GUI_WINSUPPORT
N#endif // IMAGE_H
N
N/*************************** End of file ****************************/
L 61 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "KNOB.h"
L 1 "..\..\..\ThirdParty\emWin\Include\KNOB.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : KNOB.h
NPurpose     : KNOB include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef KNOB_H
N#define KNOB_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      // Req. for Create indirect data structure
N#include "WIDGET.h"
N#include "GUI_Debug.h"
N
N#if (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
X#if (1 && 1)
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {                  // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM KNOB_Handle;
Xtypedef signed long KNOB_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NKNOB_Handle KNOB_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int Id);
XKNOB_Handle KNOB_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int Id);
NKNOB_Handle KNOB_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int Id, int NumExtraBytes);
XKNOB_Handle KNOB_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int Id, int NumExtraBytes);
NKNOB_Handle KNOB_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XKNOB_Handle KNOB_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid KNOB_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid KNOB_AddValue   (KNOB_Handle hObj, I32 Value);
Xvoid KNOB_AddValue   (KNOB_Handle hObj, signed long Value);
Nint  KNOB_GetUserData(KNOB_Handle hObj, void * pDest, int NumBytes);               // Gets user defined data
NI32  KNOB_GetValue   (KNOB_Handle hObj);                                           // Returns the position of the knob in tenth of degree
Xsigned long  KNOB_GetValue   (KNOB_Handle hObj);                                           
Nvoid KNOB_SetBkColor (KNOB_Handle hObj, GUI_COLOR Color);                          // Sets the BK color of the widget
Nvoid KNOB_SetBkDevice(KNOB_Handle hObj, GUI_MEMDEV_Handle hMemBk);                 // Sets the background device
Nvoid KNOB_SetDevice  (KNOB_Handle hObj, GUI_MEMDEV_Handle hMemSrc);                // Sets the memory device with the drawn knob
Nvoid KNOB_SetKeyValue(KNOB_Handle hObj, I32 KeyValue);                             // Sets the value the knob will rotate on one key press
Xvoid KNOB_SetKeyValue(KNOB_Handle hObj, signed long KeyValue);                             
Nvoid KNOB_SetOffset  (KNOB_Handle hObj, I32 Offset);                               // Sets the offset angle of the knob
Xvoid KNOB_SetOffset  (KNOB_Handle hObj, signed long Offset);                               
Nvoid KNOB_SetPeriod  (KNOB_Handle hObj, I32 Period);                               // Sets the period in which the knob stops
Xvoid KNOB_SetPeriod  (KNOB_Handle hObj, signed long Period);                               
Nvoid KNOB_SetPos     (KNOB_Handle hObj, I32 Pos);                                  // Sets position of the knob in tenth of degree
Xvoid KNOB_SetPos     (KNOB_Handle hObj, signed long Pos);                                  
Nvoid KNOB_SetRange   (KNOB_Handle hObj, I32 MinRange, I32 MaxRange);               // Sets the usable range of the knob widget
Xvoid KNOB_SetRange   (KNOB_Handle hObj, signed long MinRange, signed long MaxRange);               
Nvoid KNOB_SetSnap    (KNOB_Handle hObj, I32 Snap);                                 // Sets Snap positions where the knob stops
Xvoid KNOB_SetSnap    (KNOB_Handle hObj, signed long Snap);                                 
Nvoid KNOB_SetTickSize(KNOB_Handle hObj, I32 TickSize);                             // Sets the ticksize, in 1/10 of degree
Xvoid KNOB_SetTickSize(KNOB_Handle hObj, signed long TickSize);                             
Nint  KNOB_SetUserData(KNOB_Handle hObj, const void * pSrc, int NumBytes);          // Sets user defined data
N
N/*********************************************************************
N*
N*       Global functions
N*
N**********************************************************************
N*/
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // (GUI_SUPPORT_MEMDEV && GUI_WINSUPPORT)
N#endif  // KNOB_H
N
N/*************************** End of file ****************************/
L 62 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "LISTBOX.h"
N#include "LISTVIEW.h"
L 1 "..\..\..\ThirdParty\emWin\Include\LISTVIEW.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : LISTVIEW.h
NPurpose     : LISTVIEW include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef LISTVIEW_H
N#define LISTVIEW_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      // Req. for Create indirect data structure
N#include "ICONVIEW.h"
N#include "HEADER.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*/
N#define LISTVIEW_ALL_ITEMS  -1
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define LISTVIEW_CI_UNSEL       0
N#define LISTVIEW_CI_SEL         1
N#define LISTVIEW_CI_SELFOCUS    2
N#define LISTVIEW_CI_DISABLED    3
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define LISTVIEW_CF_AUTOSCROLLBAR_H   (1 << 0)
N#define LISTVIEW_CF_AUTOSCROLLBAR_V   (1 << 1)
N#define LISTVIEW_CF_CELL_SELECT       (1 << 2)                     // Create Flag used to enable cell selection
N#define LISTVIEW_SF_AUTOSCROLLBAR_H   LISTVIEW_CF_AUTOSCROLLBAR_H
N#define LISTVIEW_SF_AUTOSCROLLBAR_V   LISTVIEW_CF_AUTOSCROLLBAR_V
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM LISTVIEW_Handle;
Xtypedef signed long LISTVIEW_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NLISTVIEW_Handle LISTVIEW_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, int SpecialFlags);
XLISTVIEW_Handle LISTVIEW_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, int SpecialFlags);
NLISTVIEW_Handle LISTVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XLISTVIEW_Handle LISTVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NLISTVIEW_Handle LISTVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XLISTVIEW_Handle LISTVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NLISTVIEW_Handle LISTVIEW_CreateAttached(WM_HWIN hParent, int Id, int SpecialFlags);
XLISTVIEW_Handle LISTVIEW_CreateAttached(GUI_HWIN hParent, int Id, int SpecialFlags);
NLISTVIEW_Handle LISTVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XLISTVIEW_Handle LISTVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid LISTVIEW_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nint              LISTVIEW_AddColumn           (LISTVIEW_Handle hObj, int Width, const char * s, int Align);
Nint              LISTVIEW_AddRow              (LISTVIEW_Handle hObj, const GUI_ConstString * ppText);
Nint              LISTVIEW_CompareText         (const void * p0, const void * p1);
Nint              LISTVIEW_CompareDec          (const void * p0, const void * p1);
Nvoid             LISTVIEW_DecSel              (LISTVIEW_Handle hObj);
Nvoid             LISTVIEW_DeleteAllRows       (LISTVIEW_Handle hObj);
Nvoid             LISTVIEW_DeleteColumn        (LISTVIEW_Handle hObj, unsigned Index);
Nvoid             LISTVIEW_DeleteRow           (LISTVIEW_Handle hObj, unsigned Index);
Nvoid             LISTVIEW_DeleteRowSorted     (LISTVIEW_Handle hObj, int Row);
Nvoid             LISTVIEW_DisableRow          (LISTVIEW_Handle hObj, unsigned Row);
Nvoid             LISTVIEW_DisableSort         (LISTVIEW_Handle hObj);
Nvoid             LISTVIEW_EnableCellSelect    (LISTVIEW_Handle hObj, unsigned OnOff);  // Enables/disables cell selection
Nvoid             LISTVIEW_EnableRow           (LISTVIEW_Handle hObj, unsigned Row);
Nvoid             LISTVIEW_EnableSort          (LISTVIEW_Handle hObj);
NGUI_COLOR        LISTVIEW_GetBkColor          (LISTVIEW_Handle hObj, unsigned Index);
Nconst GUI_FONT * LISTVIEW_GetFont             (LISTVIEW_Handle hObj);
NHEADER_Handle    LISTVIEW_GetHeader           (LISTVIEW_Handle hObj);
Nvoid             LISTVIEW_GetItemRect         (LISTVIEW_Handle hObj, U32 Col, U32 Row, GUI_RECT * pRect);
Xvoid             LISTVIEW_GetItemRect         (LISTVIEW_Handle hObj, unsigned long Col, unsigned long Row, GUI_RECT * pRect);
Nvoid             LISTVIEW_GetItemText         (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, char * pBuffer, unsigned MaxSize);
Nunsigned         LISTVIEW_GetItemTextLen      (LISTVIEW_Handle hObj, unsigned Column, unsigned Row);
Nvoid             LISTVIEW_GetItemTextSorted   (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, char * pBuffer, unsigned MaxSize);
Nunsigned         LISTVIEW_GetLBorder          (LISTVIEW_Handle hObj);
Nunsigned         LISTVIEW_GetNumColumns       (LISTVIEW_Handle hObj);
Nunsigned         LISTVIEW_GetNumRows          (LISTVIEW_Handle hObj);
Nunsigned         LISTVIEW_GetRBorder          (LISTVIEW_Handle hObj);
Nint              LISTVIEW_GetSel              (LISTVIEW_Handle hObj);
Nint              LISTVIEW_GetSelCol           (LISTVIEW_Handle hObj);
Nint              LISTVIEW_GetSelUnsorted      (LISTVIEW_Handle hObj);
Nint              LISTVIEW_GetTextAlign        (LISTVIEW_Handle hObj, unsigned ColIndex);
NGUI_COLOR        LISTVIEW_GetTextColor        (LISTVIEW_Handle hObj, unsigned Index);
Nint              LISTVIEW_GetUserData         (LISTVIEW_Handle hObj, void * pDest, int NumBytes);
NU32              LISTVIEW_GetUserDataRow      (LISTVIEW_Handle hObj, unsigned Row);
Xunsigned long              LISTVIEW_GetUserDataRow      (LISTVIEW_Handle hObj, unsigned Row);
NGUI_WRAPMODE     LISTVIEW_GetWrapMode         (LISTVIEW_Handle hObj);
Nvoid             LISTVIEW_IncSel              (LISTVIEW_Handle hObj);
Nint              LISTVIEW_InsertRow           (LISTVIEW_Handle hObj, unsigned Index, const GUI_ConstString * ppText);
Nint              LISTVIEW_OwnerDraw           (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nunsigned         LISTVIEW_RowIsDisabled       (LISTVIEW_Handle hObj, unsigned Row);
Nvoid             LISTVIEW_SetAutoScrollH      (LISTVIEW_Handle hObj, int OnOff);
Nvoid             LISTVIEW_SetAutoScrollV      (LISTVIEW_Handle hObj, int OnOff);
Nvoid             LISTVIEW_SetItemBitmap       (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, int xOff, int yOff, const GUI_BITMAP * pBitmap);
Nvoid             LISTVIEW_SetBkColor          (LISTVIEW_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid             LISTVIEW_SetColumnWidth      (LISTVIEW_Handle hObj, unsigned int Index, int Width);
Nvoid             LISTVIEW_SetCompareFunc      (LISTVIEW_Handle hObj, unsigned Column, int (* fpCompare)(const void * p0, const void * p1));
Nunsigned         LISTVIEW_SetFixed            (LISTVIEW_Handle hObj, unsigned Fixed);
Nvoid             LISTVIEW_SetFont             (LISTVIEW_Handle hObj, const GUI_FONT * pFont);
Nint              LISTVIEW_SetGridVis          (LISTVIEW_Handle hObj, int Show);
Nvoid             LISTVIEW_SetHeaderHeight     (LISTVIEW_Handle hObj, unsigned HeaderHeight);
Nvoid             LISTVIEW_SetItemBkColor      (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, unsigned int Index, GUI_COLOR Color);
Nvoid             LISTVIEW_SetItemText         (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, const char * s);
Nvoid             LISTVIEW_SetItemTextColor    (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, unsigned int Index, GUI_COLOR Color);
Nvoid             LISTVIEW_SetItemTextSorted   (LISTVIEW_Handle hObj, unsigned Column, unsigned Row, const char * pText);
Nvoid             LISTVIEW_SetLBorder          (LISTVIEW_Handle hObj, unsigned BorderSize);
Nvoid             LISTVIEW_SetOwnerDraw        (LISTVIEW_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid             LISTVIEW_SetRBorder          (LISTVIEW_Handle hObj, unsigned BorderSize);
Nunsigned         LISTVIEW_SetRowHeight        (LISTVIEW_Handle hObj, unsigned RowHeight);
Nvoid             LISTVIEW_SetSel              (LISTVIEW_Handle hObj, int Sel);
Nvoid             LISTVIEW_SetSelCol           (LISTVIEW_Handle hObj, int NewCol);
Nvoid             LISTVIEW_SetSelUnsorted      (LISTVIEW_Handle hObj, int Sel);
Nunsigned         LISTVIEW_SetSort             (LISTVIEW_Handle hObj, unsigned Column, unsigned Reverse);
Nvoid             LISTVIEW_SetTextAlign        (LISTVIEW_Handle hObj, unsigned int Index, int Align);
Nvoid             LISTVIEW_SetTextColor        (LISTVIEW_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nint              LISTVIEW_SetUserData         (LISTVIEW_Handle hObj, const void * pSrc, int NumBytes);
Nvoid             LISTVIEW_SetUserDataRow      (LISTVIEW_Handle hObj, unsigned Row, U32 UserData);
Xvoid             LISTVIEW_SetUserDataRow      (LISTVIEW_Handle hObj, unsigned Row, unsigned long UserData);
Nvoid             LISTVIEW_SetWrapMode         (LISTVIEW_Handle hObj, GUI_WRAPMODE WrapMode);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
NGUI_COLOR        LISTVIEW_SetDefaultBkColor  (unsigned  Index, GUI_COLOR Color);
Nconst GUI_FONT * LISTVIEW_SetDefaultFont     (const GUI_FONT * pFont);
NGUI_COLOR        LISTVIEW_SetDefaultGridColor(GUI_COLOR Color);
NGUI_COLOR        LISTVIEW_SetDefaultTextColor(unsigned  Index, GUI_COLOR Color);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // LISTVIEW_H
N
N/*************************** End of file ****************************/
L 64 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "LISTWHEEL.h"
L 1 "..\..\..\ThirdParty\emWin\Include\LISTWHEEL.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : LISTWHEEL.h
NPurpose     : LISTWHEEL widget include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef LISTWHEEL_H
N#define LISTWHEEL_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {        // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define LISTWHEEL_CI_UNSEL 0
N#define LISTWHEEL_CI_SEL   1
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM LISTWHEEL_Handle;
Xtypedef signed long LISTWHEEL_Handle;
N
N/*********************************************************************
N*
N*       Standard member functions
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NLISTWHEEL_Handle LISTWHEEL_Create        (const GUI_ConstString * ppText, int x0, int y0, int xSize, int ySize, int Flags);
NLISTWHEEL_Handle LISTWHEEL_CreateAsChild (const GUI_ConstString * ppText, WM_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
XLISTWHEEL_Handle LISTWHEEL_CreateAsChild (const GUI_ConstString * ppText, GUI_HWIN hWinParent, int x0, int y0, int xSize, int ySize, int Flags);
NLISTWHEEL_Handle LISTWHEEL_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XLISTWHEEL_Handle LISTWHEEL_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
NLISTWHEEL_Handle LISTWHEEL_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent,
XLISTWHEEL_Handle LISTWHEEL_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent,
N                                          int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText);
NLISTWHEEL_Handle LISTWHEEL_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent,
XLISTWHEEL_Handle LISTWHEEL_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent,
N                                          int WinFlags, int ExFlags, int Id, const GUI_ConstString * ppText, int NumExtraBytes);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid LISTWHEEL_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid      LISTWHEEL_AddString      (LISTWHEEL_Handle hObj, const char * s);
NGUI_COLOR LISTWHEEL_GetBkColor     (LISTWHEEL_Handle hObj, unsigned int Index);
Nvoid *    LISTWHEEL_GetItemData    (LISTWHEEL_Handle hObj, unsigned Index); /* not to be documented */
Nvoid      LISTWHEEL_GetItemText    (LISTWHEEL_Handle hObj, unsigned Index, char * pBuffer, int MaxSize);
Nint       LISTWHEEL_GetItemFromPos (LISTWHEEL_Handle hObj, int yPos);
Nint       LISTWHEEL_GetLBorder     (LISTWHEEL_Handle hObj);
Nunsigned  LISTWHEEL_GetLineHeight  (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetNumItems    (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetPos         (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetRBorder     (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetSel         (LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetSnapPosition(LISTWHEEL_Handle hObj);
Nint       LISTWHEEL_GetTextAlign   (LISTWHEEL_Handle hObj);
NGUI_COLOR LISTWHEEL_GetTextColor   (LISTWHEEL_Handle hObj, unsigned int Index);
Nint       LISTWHEEL_GetUserData    (LISTWHEEL_Handle hObj, void * pDest, int NumBytes);
Nint       LISTWHEEL_IsMoving       (LISTWHEEL_Handle hObj);
Nvoid      LISTWHEEL_MoveToPos      (LISTWHEEL_Handle hObj, unsigned int Index);
Nint       LISTWHEEL_OwnerDraw      (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid      LISTWHEEL_SetBkColor     (LISTWHEEL_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid      LISTWHEEL_SetDeceleration(LISTWHEEL_Handle hObj, unsigned Deceleration);
Nvoid      LISTWHEEL_SetFont        (LISTWHEEL_Handle hObj, const GUI_FONT * pFont);
Nvoid      LISTWHEEL_SetItemData    (LISTWHEEL_Handle hObj, unsigned Index, void * pData); /* not to be documented */
Nvoid      LISTWHEEL_SetLBorder     (LISTWHEEL_Handle hObj, unsigned BorderSize);
Nvoid      LISTWHEEL_SetLineHeight  (LISTWHEEL_Handle hObj, unsigned LineHeight);
Nvoid      LISTWHEEL_SetOwnerDraw   (LISTWHEEL_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfOwnerDraw);
Nvoid      LISTWHEEL_SetPos         (LISTWHEEL_Handle hObj, unsigned int Index);
Nvoid      LISTWHEEL_SetRBorder     (LISTWHEEL_Handle hObj, unsigned BorderSize);
Nvoid      LISTWHEEL_SetSel         (LISTWHEEL_Handle hObj, int Sel);
Nvoid      LISTWHEEL_SetSnapPosition(LISTWHEEL_Handle hObj, int SnapPosition);
Nvoid      LISTWHEEL_SetText        (LISTWHEEL_Handle hObj, const GUI_ConstString * ppText);
Nvoid      LISTWHEEL_SetTextAlign   (LISTWHEEL_Handle hObj, int Align);
Nvoid      LISTWHEEL_SetTextColor   (LISTWHEEL_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid      LISTWHEEL_SetTimerPeriod (LISTWHEEL_Handle hObj, GUI_TIMER_TIME TimerPeriod);
Xvoid      LISTWHEEL_SetTimerPeriod (LISTWHEEL_Handle hObj, int TimerPeriod);
Nint       LISTWHEEL_SetUserData    (LISTWHEEL_Handle hObj, const void * pSrc, int NumBytes);
Nvoid      LISTWHEEL_SetVelocity    (LISTWHEEL_Handle hObj, int Velocity);
N
Nconst GUI_FONT * LISTWHEEL_GetFont(LISTWHEEL_Handle hObj);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // LISTWHEEL_H
N
N/*************************** End of file ****************************/
L 65 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "MENU.h"
L 1 "..\..\..\ThirdParty\emWin\Include\MENU.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : MENU.h
NPurpose     : MENU include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef MENU_H
N#define MENU_H
N
N#include "WM.h"
N#include "WIDGET.h"
N#include "DIALOG_Intern.h"      // Required for Create indirect data structure
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define MENU_SKIN_FLEX    MENU_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Create flags
N*/
N#define MENU_CF_HORIZONTAL              (0<<0)
N#define MENU_CF_VERTICAL                (1<<0)
N#define MENU_CF_OPEN_ON_POINTEROVER     (1<<1)  // Normally a menu opens first when clicked on it
N#define MENU_CF_CLOSE_ON_SECOND_CLICK   (1<<2)  // Normally a menu closes only when clicked outside it
N#define MENU_CF_HIDE_DISABLED_SEL       (1<<3)  // Hides the selection when a disabled item is selected
N
N/*********************************************************************
N*
N*       Menu item flags
N*/
N#define MENU_IF_DISABLED                (1<<0)  // Indicates that item is disabled
N#define MENU_IF_SEPARATOR               (1<<1)  // Indicates that item is a separator
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define MENU_CI_ENABLED                 0
N#define MENU_CI_SELECTED                1
N#define MENU_CI_DISABLED                2
N#define MENU_CI_DISABLED_SEL            3
N#define MENU_CI_ACTIVE_SUBMENU          4
N
N/*********************************************************************
N*
N*       Border indices
N*/
N#define MENU_BI_LEFT                    0
N#define MENU_BI_RIGHT                   1
N#define MENU_BI_TOP                     2
N#define MENU_BI_BOTTOM                  3
N
N/*********************************************************************
N*
N*       Message types
N*/
N#define MENU_ON_ITEMSELECT              0   // Send to owner when selecting a menu item
N#define MENU_ON_INITMENU                1   // Send to owner when for the first time selecting a submenu
N#define MENU_ON_INITSUBMENU             2   // Send to owner when selecting a submenu
N#define MENU_ON_OPEN                    3   // Internal message of menu widget (only send to submenus)
N#define MENU_ON_CLOSE                   4   // Internal message of menu widget (only send to submenus)
N#define MENU_IS_MENU                    5   // Internal message of menu widget. Owner must call
N                                            // WM_DefaultProc() when not handle the message
N#define MENU_ON_ITEMACTIVATE            6   // Send to owner when highlighting a menu item
N#define MENU_ON_ITEMPRESSED             7   // Send to owner when a menu item has been pressed
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define MENU_SKINFLEX_PI_ENABLED        0
N#define MENU_SKINFLEX_PI_SELECTED       1
N#define MENU_SKINFLEX_PI_DISABLED       2
N#define MENU_SKINFLEX_PI_DISABLED_SEL   3
N#define MENU_SKINFLEX_PI_ACTIVE_SUBMENU 4
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N
Ntypedef WM_HMEM MENU_Handle;
Xtypedef signed long MENU_Handle;
N
Ntypedef struct {
N  //
N  // Background
N  //  
N  GUI_COLOR aBkColorH[2];
N  GUI_COLOR BkColorV;
N  GUI_COLOR FrameColorH;
N  GUI_COLOR FrameColorV;
N  //
N  // Selection
N  //
N  GUI_COLOR aSelColorH[2];
N  GUI_COLOR aSelColorV[2];
N  GUI_COLOR FrameColorSelH;
N  GUI_COLOR FrameColorSelV;
N  //
N  // Separator
N  //
N  GUI_COLOR aSepColorH[2];
N  GUI_COLOR aSepColorV[2];
N  //
N  // Arrow
N  //
N  GUI_COLOR ArrowColor;
N  //
N  // Text
N  //
N  GUI_COLOR TextColor;
N} MENU_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Menu message data
N*/
Ntypedef struct {
N  U16 MsgType;
X  unsigned short MsgType;
N  U16 ItemId;
X  unsigned short ItemId;
N} MENU_MSG_DATA;
N
N/*********************************************************************
N*
N*       Menu item data
N*/
Ntypedef struct {
N  const char  * pText;
N  U16           Id;
X  unsigned short           Id;
N  U16           Flags;
X  unsigned short           Flags;
N  MENU_Handle   hSubmenu;
N} MENU_ITEM_DATA;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NMENU_Handle MENU_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XMENU_Handle MENU_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
NMENU_Handle MENU_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XMENU_Handle MENU_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NMENU_Handle MENU_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XMENU_Handle MENU_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid MENU_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Individual member functions
N*
N**********************************************************************
N*/
Nvoid             MENU_AddItem       (MENU_Handle hObj, const MENU_ITEM_DATA * pItemData);
Nvoid             MENU_Attach        (MENU_Handle hObj, WM_HWIN hDestWin, int x, int y, int xSize, int ySize, int Flags);
Xvoid             MENU_Attach        (MENU_Handle hObj, GUI_HWIN hDestWin, int x, int y, int xSize, int ySize, int Flags);
Nvoid             MENU_DeleteItem    (MENU_Handle hObj, U16 ItemId);
Xvoid             MENU_DeleteItem    (MENU_Handle hObj, unsigned short ItemId);
Nvoid             MENU_DisableItem   (MENU_Handle hObj, U16 ItemId);
Xvoid             MENU_DisableItem   (MENU_Handle hObj, unsigned short ItemId);
Nvoid             MENU_EnableItem    (MENU_Handle hObj, U16 ItemId);
Xvoid             MENU_EnableItem    (MENU_Handle hObj, unsigned short ItemId);
NGUI_COLOR        MENU_GetBkColor    (MENU_Handle hObj, unsigned ColorIndex);
Nconst GUI_FONT * MENU_GetFont       (MENU_Handle hObj);
Nvoid             MENU_GetItem       (MENU_Handle hObj, U16 ItemId, MENU_ITEM_DATA * pItemData);
Xvoid             MENU_GetItem       (MENU_Handle hObj, unsigned short ItemId, MENU_ITEM_DATA * pItemData);
Nvoid             MENU_GetItemText   (MENU_Handle hObj, U16 ItemId, char * pBuffer, unsigned BufferSize);
Xvoid             MENU_GetItemText   (MENU_Handle hObj, unsigned short ItemId, char * pBuffer, unsigned BufferSize);
Nunsigned         MENU_GetNumItems   (MENU_Handle hObj);
NWM_HWIN          MENU_GetOwner      (MENU_Handle hObj);
XGUI_HWIN          MENU_GetOwner      (MENU_Handle hObj);
NGUI_COLOR        MENU_GetTextColor  (MENU_Handle hObj, unsigned ColorIndex);
Nint              MENU_GetUserData   (MENU_Handle hObj, void * pDest, int NumBytes);
Nvoid             MENU_InsertItem    (MENU_Handle hObj, U16 ItemId, const MENU_ITEM_DATA * pItemData);
Xvoid             MENU_InsertItem    (MENU_Handle hObj, unsigned short ItemId, const MENU_ITEM_DATA * pItemData);
Nvoid             MENU_Popup         (MENU_Handle hObj, WM_HWIN hDestWin, int x, int y, int xSize, int ySize, int Flags);
Xvoid             MENU_Popup         (MENU_Handle hObj, GUI_HWIN hDestWin, int x, int y, int xSize, int ySize, int Flags);
Nvoid             MENU_SetBkColor    (MENU_Handle hObj, unsigned ColorIndex, GUI_COLOR Color);
Nvoid             MENU_SetBorderSize (MENU_Handle hObj, unsigned BorderIndex, U8 BorderSize);
Xvoid             MENU_SetBorderSize (MENU_Handle hObj, unsigned BorderIndex, unsigned char BorderSize);
Nvoid             MENU_SetFont       (MENU_Handle hObj, const GUI_FONT * pFont);
Nvoid             MENU_SetItem       (MENU_Handle hObj, U16 ItemId, const MENU_ITEM_DATA * pItemData);
Xvoid             MENU_SetItem       (MENU_Handle hObj, unsigned short ItemId, const MENU_ITEM_DATA * pItemData);
Nvoid             MENU_SetOwner      (MENU_Handle hObj, WM_HWIN hOwner);
Xvoid             MENU_SetOwner      (MENU_Handle hObj, GUI_HWIN hOwner);
Nint              MENU_SetSel        (MENU_Handle hObj, int Sel);
Nvoid             MENU_SetTextColor  (MENU_Handle hObj, unsigned ColorIndex, GUI_COLOR Color);
Nint              MENU_SetUserData   (MENU_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR             MENU_GetDefaultTextColor  (unsigned ColorIndex);
NGUI_COLOR             MENU_GetDefaultBkColor    (unsigned ColorIndex);
NU8                    MENU_GetDefaultBorderSize (unsigned BorderIndex);
Xunsigned char                    MENU_GetDefaultBorderSize (unsigned BorderIndex);
Nconst WIDGET_EFFECT * MENU_GetDefaultEffect     (void);
Nconst GUI_FONT      * MENU_GetDefaultFont       (void);
Nvoid                  MENU_SetDefaultTextColor  (unsigned ColorIndex, GUI_COLOR Color);
Nvoid                  MENU_SetDefaultBkColor    (unsigned ColorIndex, GUI_COLOR Color);
Nvoid                  MENU_SetDefaultBorderSize (unsigned BorderIndex, U8 BorderSize);
Xvoid                  MENU_SetDefaultBorderSize (unsigned BorderIndex, unsigned char BorderSize);
Nvoid                  MENU_SetDefaultEffect     (const WIDGET_EFFECT * pEffect);
Nvoid                  MENU_SetDefaultFont       (const GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nint                     MENU_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid                    MENU_GetSkinFlexProps     (MENU_SKINFLEX_PROPS * pProps, int Index);
NWIDGET_DRAW_ITEM_FUNC * MENU_SetDefaultSkin       (WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nvoid                    MENU_SetDefaultSkinClassic(void);
Nvoid                    MENU_SetSkinClassic       (MENU_Handle hObj);
Nvoid                    MENU_SetSkin              (MENU_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nvoid                    MENU_SetSkinFlexProps     (const MENU_SKINFLEX_PROPS * pProps, int Index);
Nvoid                    MENU_SkinEnableArrow      (MENU_Handle hObj, int OnOff);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // MENU_H
N
N/*************************** End of file ****************************/
L 66 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "MULTIEDIT.h"
L 1 "..\..\..\ThirdParty\emWin\Include\MULTIEDIT.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : MULTIEDIT.h
NPurpose     : MULTIEDIT include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef MULTIEDIT_H
N#define MULTIEDIT_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#define MULTIEDIT_CF_READONLY        (1 << 0)
N#define MULTIEDIT_CF_INSERT          (1 << 2)
N#define MULTIEDIT_CF_AUTOSCROLLBAR_V (1 << 3)
N#define MULTIEDIT_CF_AUTOSCROLLBAR_H (1 << 4)
N#define MULTIEDIT_CF_PASSWORD        (1 << 5)
N#define MULTIEDIT_CF_SHOWCURSOR      (1 << 6)
N
N#define MULTIEDIT_SF_READONLY        MULTIEDIT_CF_READONLY
N#define MULTIEDIT_SF_INSERT          MULTIEDIT_CF_INSERT
N#define MULTIEDIT_SF_AUTOSCROLLBAR_V MULTIEDIT_CF_AUTOSCROLLBAR_V
N#define MULTIEDIT_SF_AUTOSCROLLBAR_H MULTIEDIT_CF_AUTOSCROLLBAR_H
N#define MULTIEDIT_SF_PASSWORD        MULTIEDIT_CF_PASSWORD
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define MULTIEDIT_CI_EDIT     0
N#define MULTIEDIT_CI_READONLY 1
N
N/*********************************************************************
N*
N*                         Public Types
N*
N**********************************************************************
N*/
N
Ntypedef WM_HMEM MULTIEDIT_HANDLE;
Xtypedef signed long MULTIEDIT_HANDLE;
N
N/*********************************************************************
N*
N*                 Create functions
N*
N**********************************************************************
N*/
NMULTIEDIT_HANDLE MULTIEDIT_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, int ExFlags, const char * pText, int MaxLen);
XMULTIEDIT_HANDLE MULTIEDIT_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, int ExFlags, const char * pText, int MaxLen);
NMULTIEDIT_HANDLE MULTIEDIT_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int BufferSize, const char * pText);
XMULTIEDIT_HANDLE MULTIEDIT_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int BufferSize, const char * pText);
NMULTIEDIT_HANDLE MULTIEDIT_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XMULTIEDIT_HANDLE MULTIEDIT_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
NMULTIEDIT_HANDLE MULTIEDIT_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int BufferSize, const char * pText, int NumExtraBytes);
XMULTIEDIT_HANDLE MULTIEDIT_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int BufferSize, const char * pText, int NumExtraBytes);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid MULTIEDIT_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*                 Member functions
N*
N**********************************************************************
N*/
N
Nint              MULTIEDIT_AddKey           (MULTIEDIT_HANDLE hObj, U16 Key);
Xint              MULTIEDIT_AddKey           (MULTIEDIT_HANDLE hObj, unsigned short Key);
Nint              MULTIEDIT_AddText          (MULTIEDIT_HANDLE hObj, const char * s);
Nvoid             MULTIEDIT_EnableBlink      (MULTIEDIT_HANDLE hObj, int Period, int OnOff);
NGUI_COLOR        MULTIEDIT_GetBkColor       (MULTIEDIT_HANDLE hObj, unsigned Index);
Nint              MULTIEDIT_GetCursorCharPos (MULTIEDIT_HANDLE hObj);
Nvoid             MULTIEDIT_GetCursorPixelPos(MULTIEDIT_HANDLE hObj, int * pxPos, int * pyPos);
Nconst GUI_FONT * MULTIEDIT_GetFont          (MULTIEDIT_HANDLE hObj);
Nvoid             MULTIEDIT_GetPrompt        (MULTIEDIT_HANDLE hObj, char* sDest, int MaxNumChars);
Nvoid             MULTIEDIT_GetText          (MULTIEDIT_HANDLE hObj, char* sDest, int MaxNumChars);
NGUI_COLOR        MULTIEDIT_GetTextColor     (MULTIEDIT_HANDLE hObj, unsigned Index);
Nint              MULTIEDIT_GetTextSize      (MULTIEDIT_HANDLE hObj);
Nint              MULTIEDIT_GetUserData      (MULTIEDIT_HANDLE hObj, void * pDest, int NumBytes);
Nvoid             MULTIEDIT_SetTextAlign     (MULTIEDIT_HANDLE hObj, int Align);
Nvoid             MULTIEDIT_SetAutoScrollH   (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid             MULTIEDIT_SetAutoScrollV   (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid             MULTIEDIT_SetBkColor       (MULTIEDIT_HANDLE hObj, unsigned Index, GUI_COLOR color);
Nvoid             MULTIEDIT_SetCursorCharPos (MULTIEDIT_HANDLE hObj, int x, int y);       /* Not yet implemented */
Nvoid             MULTIEDIT_SetCursorPixelPos(MULTIEDIT_HANDLE hObj, int x, int y);       /* Not yet implemented */
Nvoid             MULTIEDIT_SetCursorOffset  (MULTIEDIT_HANDLE hObj, int Offset);
Nvoid             MULTIEDIT_SetHBorder       (MULTIEDIT_HANDLE hObj, unsigned HBorder);
Nvoid             MULTIEDIT_SetFocusable     (MULTIEDIT_HANDLE hObj, int State);
Nvoid             MULTIEDIT_SetFont          (MULTIEDIT_HANDLE hObj, const GUI_FONT * pFont);
Nvoid             MULTIEDIT_SetInsertMode    (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid             MULTIEDIT_SetBufferSize    (MULTIEDIT_HANDLE hObj, int BufferSize);
Nvoid             MULTIEDIT_SetMaxNumChars   (MULTIEDIT_HANDLE hObj, unsigned MaxNumChars);
Nvoid             MULTIEDIT_SetPrompt        (MULTIEDIT_HANDLE hObj, const char* sPrompt);
Nvoid             MULTIEDIT_SetReadOnly      (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid             MULTIEDIT_SetPasswordMode  (MULTIEDIT_HANDLE hObj, int OnOff);
Nvoid             MULTIEDIT_SetText          (MULTIEDIT_HANDLE hObj, const char* s);
Nvoid             MULTIEDIT_SetTextColor     (MULTIEDIT_HANDLE hObj, unsigned Index, GUI_COLOR color);
Nint              MULTIEDIT_SetUserData      (MULTIEDIT_HANDLE hObj, const void * pSrc, int NumBytes);
Nvoid             MULTIEDIT_SetWrapNone      (MULTIEDIT_HANDLE hObj);
Nvoid             MULTIEDIT_SetWrapChar      (MULTIEDIT_HANDLE hObj);
Nvoid             MULTIEDIT_SetWrapWord      (MULTIEDIT_HANDLE hObj);
Nint              MULTIEDIT_ShowCursor       (MULTIEDIT_HANDLE hObj, unsigned OnOff);
N
N#define MULTIEDIT_SetFocussable MULTIEDIT_SetFocusable
N
N/*********************************************************************
N*
N*       Macros for compatibility with older versions
N*
N**********************************************************************
N*/
N
N#define MULTIEDIT_SetMaxLen(hObj, MaxLen) MULTIEDIT_SetBufferSize(hObj, MaxLen)
N#define MULTIEDIT_GetStringSize           MULTIEDIT_GetTextSize
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // MULTIEDIT_H
N
N/*************************** End of file ****************************/
L 67 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "MULTIPAGE.h"
L 1 "..\..\..\ThirdParty\emWin\Include\MULTIPAGE.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : MULTIPAGE.h
NPurpose     : MULTIPAGE include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef MULTIPAGE_H
N#define MULTIPAGE_H
N
N#include "WM.h"
N#include "DIALOG.h"   // Required for Create indirect data structure
L 1 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : Dialog.h
NPurpose     : Dialog box include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef DIALOG_H
S#define DIALOG_H
S
S#include "WM.h"
S
S#include "BUTTON.h"
S#include "CALENDAR.h"
S#include "CHECKBOX.h"
S#include "CHOOSECOLOR.h"
S#include "CHOOSEFILE.h"
S#include "DROPDOWN.h"
S#include "EDIT.h"
S#include "FRAMEWIN.h"
S#include "GRAPH.h"
S#include "HEADER.h"
S#include "ICONVIEW.h"
S#include "IMAGE.h"
S#include "KNOB.h"
S#include "LISTBOX.h"
S#include "LISTVIEW.h"
S#include "LISTWHEEL.h"
S#include "MENU.h"
S#include "MULTIEDIT.h"
S#include "MULTIPAGE.h"
S#include "PROGBAR.h"
S#include "RADIO.h"
S#include "SCROLLBAR.h"
S#include "SLIDER.h"
S#include "SPINBOX.h"
S#include "SWIPELIST.h"
S#include "TEXT.h"
S#include "TREEVIEW.h"
S
S#if GUI_WINSUPPORT
S
S#if defined(__cplusplus)
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
S#endif
S
S/*********************************************************************
S*
S*       WINDOW API
S*/
SWM_HWIN   WINDOW_CreateEx         (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb);
SWM_HWIN   WINDOW_CreateUser       (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb, int NumExtraBytes);
SWM_HWIN   WINDOW_CreateIndirect   (const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
SGUI_COLOR WINDOW_GetDefaultBkColor(void);
Sint       WINDOW_GetUserData      (WM_HWIN hObj, void * pDest, int NumBytes);
Svoid      WINDOW_SetBkColor       (WM_HWIN hObj, GUI_COLOR Color);
Svoid      WINDOW_SetDefaultBkColor(GUI_COLOR Color);
Sint       WINDOW_SetUserData      (WM_HWIN hObj, const void * pSrc, int NumBytes);
S
Svoid WINDOW_Callback(WM_MESSAGE * pMsg);
S
S#if defined(__cplusplus)
S  }
S#endif
S
S#endif  // GUI_WINSUPPORT
N#endif  // DIALOG_H
N
N/*************************** End of file ****************************/
L 49 "..\..\..\ThirdParty\emWin\Include\MULTIPAGE.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {        // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Create / Status flags
N*/
N#define MULTIPAGE_ALIGN_LEFT           (0 << 0)
N#define MULTIPAGE_ALIGN_RIGHT          (1 << 0)
N#define MULTIPAGE_ALIGN_TOP            (0 << 2)
N#define MULTIPAGE_ALIGN_BOTTOM         (1 << 2)
N
N#define MULTIPAGE_CF_ROTATE_CW          WIDGET_CF_VERTICAL
N
N#define MULTIPAGE_CI_DISABLED           0
N#define MULTIPAGE_CI_ENABLED            1
N
N#define MULTIPAGE_SKIN_FRAME_LEFT      (1 << 0)
N#define MULTIPAGE_SKIN_FRAME_RIGHT     (1 << 1)
N#define MULTIPAGE_SKIN_FRAME_TOP       (1 << 2)
N#define MULTIPAGE_SKIN_FRAME_BOTTOM    (1 << 3)
N#define MULTIPAGE_SKIN_FRAME_ALL       (MULTIPAGE_SKIN_FRAME_LEFT | MULTIPAGE_SKIN_FRAME_RIGHT | MULTIPAGE_SKIN_FRAME_TOP | MULTIPAGE_SKIN_FRAME_BOTTOM)
N
N#define MULTIPAGE_SKINFLEX_PI_ENABLED   0
N#define MULTIPAGE_SKINFLEX_PI_SELECTED  1
N#define MULTIPAGE_SKINFLEX_PI_DISABLED  2
N
N#define SCROLLBAR_SIZE                 32 // Defines the space for the scrollbar arrows
N
N#define MULTIPAGE_BI_SELECTED           0
N#define MULTIPAGE_BI_UNSELECTED         1
N#define MULTIPAGE_BI_DISABLED           2
N#define MULTIPAGE_BI_MAX                3  // The defines above are used as array indices.
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM MULTIPAGE_Handle;
Xtypedef signed long MULTIPAGE_Handle;
N
Ntypedef struct {
N  GUI_COLOR BkColor;
N  GUI_COLOR aBkUpper[2];
N  GUI_COLOR aBkLower[2];
N  GUI_COLOR FrameColor;
N  GUI_COLOR TextColor;
N} MULTIPAGE_SKINFLEX_PROPS;
N
Ntypedef struct {
N  U8  SelSideBorderInc;         // Number of pixels to add on both sides when drawing the selected item.
X  unsigned char  SelSideBorderInc;         
N  U8  SelTopBorderInc;          // Number of pixels to add on top of selected items.
X  unsigned char  SelTopBorderInc;          
N} MULTIPAGE_SKIN_PROPS;
N
Ntypedef struct {
N  #if GUI_SUPPORT_ROTATION
X  #if 1
N    GUI_ROTATION  * pRotation;
X    tLCD_APIList  * pRotation;
N  #endif
N  unsigned          Align;
N  int               Sel;
N  U16               State;
X  unsigned short               State;
N  U8                FrameFlags;    // Flags to let the drawing function know which parts of the frame to display.
X  unsigned char                FrameFlags;    
N  U8                PageStatus;
X  unsigned char                PageStatus;
N  GUI_DRAW_HANDLE * pDrawObj;
N} MULTIPAGE_SKIN_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NMULTIPAGE_Handle MULTIPAGE_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, int SpecialFlags);
XMULTIPAGE_Handle MULTIPAGE_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, int SpecialFlags);
NMULTIPAGE_Handle MULTIPAGE_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XMULTIPAGE_Handle MULTIPAGE_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NMULTIPAGE_Handle MULTIPAGE_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XMULTIPAGE_Handle MULTIPAGE_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NMULTIPAGE_Handle MULTIPAGE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XMULTIPAGE_Handle MULTIPAGE_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid MULTIPAGE_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid             MULTIPAGE_AddEmptyPage   (MULTIPAGE_Handle hObj, WM_HWIN hWin ,const char * pText);
Xvoid             MULTIPAGE_AddEmptyPage   (MULTIPAGE_Handle hObj, GUI_HWIN hWin ,const char * pText);
Nvoid             MULTIPAGE_AddPage        (MULTIPAGE_Handle hObj, WM_HWIN hWin ,const char * pText);
Xvoid             MULTIPAGE_AddPage        (MULTIPAGE_Handle hObj, GUI_HWIN hWin ,const char * pText);
NWM_HWIN          MULTIPAGE_AttachWindow   (MULTIPAGE_Handle hObj, unsigned Index, WM_HWIN hWin);
XGUI_HWIN          MULTIPAGE_AttachWindow   (MULTIPAGE_Handle hObj, unsigned Index, GUI_HWIN hWin);
Nvoid             MULTIPAGE_DeletePage     (MULTIPAGE_Handle hObj, unsigned Index, int Delete);
Nvoid             MULTIPAGE_DisablePage    (MULTIPAGE_Handle hObj, unsigned Index);
Nvoid             MULTIPAGE_EnablePage     (MULTIPAGE_Handle hObj, unsigned Index);
Nvoid             MULTIPAGE_EnableScrollbar(MULTIPAGE_Handle hObj, unsigned OnOff);
NGUI_COLOR        MULTIPAGE_GetBkColor     (MULTIPAGE_Handle hObj, unsigned Index);
Nconst GUI_FONT * MULTIPAGE_GetFont        (MULTIPAGE_Handle hObj);
Nint              MULTIPAGE_GetSelection   (MULTIPAGE_Handle hObj);
Nint              MULTIPAGE_GetPageText    (MULTIPAGE_Handle hObj, unsigned Index, char * pBuffer, int MaxLen);
NGUI_COLOR        MULTIPAGE_GetTextColor   (MULTIPAGE_Handle hObj, unsigned Index);
Nint              MULTIPAGE_GetUserData    (MULTIPAGE_Handle hObj, void * pDest, int NumBytes);
NWM_HWIN          MULTIPAGE_GetWindow      (MULTIPAGE_Handle hObj, unsigned Index);
XGUI_HWIN          MULTIPAGE_GetWindow      (MULTIPAGE_Handle hObj, unsigned Index);
Nint              MULTIPAGE_IsPageEnabled  (MULTIPAGE_Handle hObj, unsigned Index);
Nvoid             MULTIPAGE_SelectPage     (MULTIPAGE_Handle hObj, unsigned Index);
Nvoid             MULTIPAGE_SetAlign       (MULTIPAGE_Handle hObj, unsigned Align);
Nint              MULTIPAGE_SetBitmapEx    (MULTIPAGE_Handle hObj, const GUI_BITMAP * pBitmap, int x, int y, int Index, int State);
Nint              MULTIPAGE_SetBitmap      (MULTIPAGE_Handle hObj, const GUI_BITMAP * pBitmap, int Index, int State);
Nvoid             MULTIPAGE_SetBkColor     (MULTIPAGE_Handle hObj, GUI_COLOR Color, unsigned Index);
Nvoid             MULTIPAGE_SetFont        (MULTIPAGE_Handle hObj, const GUI_FONT * pFont);
Nvoid             MULTIPAGE_SetRotation    (MULTIPAGE_Handle hObj, unsigned Rotation);
Nvoid             MULTIPAGE_SetTabWidth    (MULTIPAGE_Handle hObj, int Width, int Index);
Nvoid             MULTIPAGE_SetTabHeight   (MULTIPAGE_Handle hObj, int Height);
Nvoid             MULTIPAGE_SetTextAlign   (MULTIPAGE_Handle hObj, unsigned Align);
Nvoid             MULTIPAGE_SetText        (MULTIPAGE_Handle hObj, const char * pText, unsigned Index);
Nvoid             MULTIPAGE_SetTextColor   (MULTIPAGE_Handle hObj, GUI_COLOR Color, unsigned Index);
Nint              MULTIPAGE_SetUserData    (MULTIPAGE_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
Nunsigned         MULTIPAGE_GetDefaultAlign      (void);
NGUI_COLOR        MULTIPAGE_GetDefaultBkColor    (unsigned Index);
Nconst GUI_FONT * MULTIPAGE_GetDefaultFont       (void);
NGUI_COLOR        MULTIPAGE_GetDefaultTextColor  (unsigned Index);
N
Nvoid             MULTIPAGE_SetDefaultAlign      (unsigned Align);
Nvoid             MULTIPAGE_SetDefaultBkColor    (GUI_COLOR Color, unsigned Index);
Nvoid             MULTIPAGE_SetDefaultBorderSizeX(unsigned Size);
Nvoid             MULTIPAGE_SetDefaultBorderSizeY(unsigned Size);
Nvoid             MULTIPAGE_SetDefaultFont       (const GUI_FONT * pFont);
Nvoid             MULTIPAGE_SetDefaultTextColor  (GUI_COLOR Color, unsigned Index);
N
Nvoid             MULTIPAGE_SetEffectColor       (unsigned Index, GUI_COLOR Color);
NGUI_COLOR        MULTIPAGE_GetEffectColor       (unsigned Index);
Nint              MULTIPAGE_GetNumEffectColors   (void);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nint                     MULTIPAGE_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid                    MULTIPAGE_GetSkinFlexProps     (MULTIPAGE_SKINFLEX_PROPS * pProps, int Index);
NWIDGET_DRAW_ITEM_FUNC * MULTIPAGE_SetDefaultSkin       (WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nvoid                    MULTIPAGE_SetDefaultSkinClassic(void);
Nvoid                    MULTIPAGE_SetSkinClassic       (MULTIPAGE_Handle hObj);
Nvoid                    MULTIPAGE_SetSkin              (MULTIPAGE_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nvoid                    MULTIPAGE_SetSkinFlexProps     (const MULTIPAGE_SKINFLEX_PROPS * pProps, int Index);
N
N#define MULTIPAGE_SKIN_FLEX MULTIPAGE_DrawSkinFlex
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // MULTIPAGE_H
N
N/*************************** End of file ****************************/
L 68 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "PROGBAR.h"
L 1 "..\..\..\ThirdParty\emWin\Include\PROGBAR.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : PROGBAR.h
NPurpose     : Progressbar include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef PROGBAR_H        /* Avoid multiple inclusion  */
N#define PROGBAR_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Create flags
N*/
N#define PROGBAR_CF_HORIZONTAL (0 << 0)
N#define PROGBAR_CF_VERTICAL   (1 << 0)
N#define PROGBAR_CF_USER       (1 << 1)
N
N/*********************************************************************
N*
N*       Skinning constants
N*/
N#define PROGBAR_SKINFLEX_L 0
N#define PROGBAR_SKINFLEX_R 1
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM PROGBAR_Handle;
Xtypedef signed long PROGBAR_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorUpperL[2];
N  GUI_COLOR aColorLowerL[2];
N  GUI_COLOR aColorUpperR[2];
N  GUI_COLOR aColorLowerR[2];
N  GUI_COLOR ColorFrame;
N  GUI_COLOR ColorText;
N} PROGBAR_SKINFLEX_PROPS;
N
Ntypedef struct {
N  int IsVertical;
N  int Index;
N  const char * pText;
N} PROGBAR_SKINFLEX_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
N
NPROGBAR_Handle PROGBAR_Create        (int x0, int y0, int xSize, int ySize, int Flags);
NPROGBAR_Handle PROGBAR_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags);
XPROGBAR_Handle PROGBAR_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags);
NPROGBAR_Handle PROGBAR_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XPROGBAR_Handle PROGBAR_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NPROGBAR_Handle PROGBAR_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XPROGBAR_Handle PROGBAR_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NPROGBAR_Handle PROGBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XPROGBAR_Handle PROGBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid PROGBAR_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Individual member functions
N*
N**********************************************************************
N*/
NGUI_COLOR        PROGBAR_GetBarColor(PROGBAR_Handle hObj, unsigned int Index);
Nconst GUI_FONT * PROGBAR_GetFont     (PROGBAR_Handle hObj);
Nvoid             PROGBAR_GetMinMax   (PROGBAR_Handle hObj, int * pMin, int * pMax);
Nint              PROGBAR_GetUserData (PROGBAR_Handle hObj, void * pDest, int NumBytes);
NGUI_COLOR        PROGBAR_GetTextColor(PROGBAR_Handle hObj, unsigned int Index);
Nint              PROGBAR_GetValue    (PROGBAR_Handle hObj);
Nvoid             PROGBAR_SetBarColor (PROGBAR_Handle hObj, unsigned int index, GUI_COLOR color);
Nvoid             PROGBAR_SetFont     (PROGBAR_Handle hObj, const GUI_FONT * pfont);
Nvoid             PROGBAR_SetMinMax   (PROGBAR_Handle hObj, int Min, int Max);
Nvoid             PROGBAR_SetText     (PROGBAR_Handle hObj, const char* s);
Nvoid             PROGBAR_SetTextAlign(PROGBAR_Handle hObj, int Align);
Nvoid             PROGBAR_SetTextColor(PROGBAR_Handle hObj, unsigned int index, GUI_COLOR color);
Nvoid             PROGBAR_SetTextPos  (PROGBAR_Handle hObj, int XOff, int YOff);
Nvoid             PROGBAR_SetValue    (PROGBAR_Handle hObj, int v);
Nint              PROGBAR_SetUserData (PROGBAR_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid PROGBAR_GetSkinFlexProps     (PROGBAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid PROGBAR_SetSkinClassic       (PROGBAR_Handle hObj);
Nvoid PROGBAR_SetSkin              (PROGBAR_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  PROGBAR_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid PROGBAR_SetSkinFlexProps     (const PROGBAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid PROGBAR_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * PROGBAR_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define PROGBAR_SKIN_FLEX    PROGBAR_DrawSkinFlex
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // PROGBAR_H
N
N/*************************** End of file ****************************/
L 69 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "RADIO.h"
L 1 "..\..\..\ThirdParty\emWin\Include\RADIO.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : RADIO.h
NPurpose     : RADIO include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef RADIO_H
N#define RADIO_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Bitmap indices
N*/
N#define RADIO_BI_INACTIV 0
N#define RADIO_BI_ACTIV   1
N#define RADIO_BI_CHECK   2
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define RADIO_SKINFLEX_PI_PRESSED     0
N#define RADIO_SKINFLEX_PI_UNPRESSED   1
N
N/*********************************************************************
N*
N*       Defaults for public configuration switches
N*
N**********************************************************************
N
NThe following are defaults for config switches which affect the
Ninterface specified in this module
N*/
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define RADIO_TEXTPOS_RIGHT       0
N#define RADIO_TEXTPOS_LEFT        WIDGET_STATE_USER0  /* Not implemented, TBD */
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM RADIO_Handle;
Xtypedef signed long RADIO_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorButton[4];
N  int       ButtonSize;
N} RADIO_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
N
NRADIO_Handle RADIO_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, unsigned Para);
XRADIO_Handle RADIO_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, unsigned Para);
NRADIO_Handle RADIO_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumItems, int Spacing);
XRADIO_Handle RADIO_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumItems, int Spacing);
NRADIO_Handle RADIO_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumItems, int Spacing, int NumExtraBytes);
XRADIO_Handle RADIO_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumItems, int Spacing, int NumExtraBytes);
NRADIO_Handle RADIO_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XRADIO_Handle RADIO_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid RADIO_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
Nvoid             RADIO_SetDefaultFont      (const GUI_FONT * pFont);
NGUI_COLOR        RADIO_SetDefaultFocusColor(GUI_COLOR Color);
Nvoid             RADIO_SetDefaultImage     (const GUI_BITMAP * pBitmap, unsigned int Index);
Nvoid             RADIO_SetDefaultTextColor (GUI_COLOR TextColor);
Nconst GUI_FONT * RADIO_GetDefaultFont      (void);
NGUI_COLOR        RADIO_GetDefaultTextColor (void);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
Nvoid               RADIO_AddValue     (RADIO_Handle hObj, int Add);
Nvoid               RADIO_Dec          (RADIO_Handle hObj);
NGUI_COLOR          RADIO_GetBkColor   (RADIO_Handle hObj);
NGUI_COLOR          RADIO_GetFocusColor(RADIO_Handle hObj);
Nconst GUI_FONT *   RADIO_GetFont      (RADIO_Handle hObj);
Nconst GUI_BITMAP * RADIO_GetImage     (RADIO_Handle hObj, unsigned int Index);
Nint                RADIO_GetNumItems  (RADIO_Handle hObj);
Nint                RADIO_GetText      (RADIO_Handle hObj, unsigned Index, char * pBuffer, int MaxLen);
NGUI_COLOR          RADIO_GetTextColor (RADIO_Handle hObj);
Nint                RADIO_GetUserData  (RADIO_Handle hObj, void * pDest, int NumBytes);
Nvoid               RADIO_Inc          (RADIO_Handle hObj);
Nvoid               RADIO_SetBkColor   (RADIO_Handle hObj, GUI_COLOR Color);
NGUI_COLOR          RADIO_SetFocusColor(RADIO_Handle hObj, GUI_COLOR Color);
Nvoid               RADIO_SetFont      (RADIO_Handle hObj, const GUI_FONT * pFont);
Nvoid               RADIO_SetGroupId   (RADIO_Handle hObj, U8 GroupId);
Xvoid               RADIO_SetGroupId   (RADIO_Handle hObj, unsigned char GroupId);
Nvoid               RADIO_SetImage     (RADIO_Handle hObj, const GUI_BITMAP * pBitmap, unsigned int Index);
Nvoid               RADIO_SetText      (RADIO_Handle hObj, const char* pText, unsigned Index);
Nvoid               RADIO_SetTextColor (RADIO_Handle hObj, GUI_COLOR Color);
Nvoid               RADIO_SetValue     (RADIO_Handle hObj, int v);
Nint                RADIO_SetUserData  (RADIO_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid RADIO_GetSkinFlexProps     (RADIO_SKINFLEX_PROPS * pProps, int Index);
Nvoid RADIO_SetSkinClassic       (RADIO_Handle hObj);
Nvoid RADIO_SetSkin              (RADIO_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  RADIO_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid RADIO_SetSkinFlexProps     (const RADIO_SKINFLEX_PROPS * pProps, int Index);
Nvoid RADIO_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * RADIO_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define RADIO_SKIN_FLEX    RADIO_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Query state
N*
N**********************************************************************
N*/
Nint RADIO_GetValue(RADIO_Handle hObj);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // RADIO_H
N
N/*************************** End of file ****************************/
L 70 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "SCROLLBAR.h"
N#include "SLIDER.h"
L 1 "..\..\..\ThirdParty\emWin\Include\SLIDER.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : SLIDER.h
NPurpose     : SLIDER include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef SLIDER_H
N#define SLIDER_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/************************************************************
N*
N*       Defines
N*
N*************************************************************
N*/
N/************************************************************
N*
N*       States
N*/
N#define SLIDER_STATE_PRESSED    WIDGET_STATE_USER0
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define SLIDER_CF_HORIZONTAL 0
N#define SLIDER_CF_VERTICAL   WIDGET_CF_VERTICAL
N
N/************************************************************
N*
N*       Skinning property indices
N*/
N#define SLIDER_SKINFLEX_PI_PRESSED   0
N#define SLIDER_SKINFLEX_PI_UNPRESSED 1
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM SLIDER_Handle;
Xtypedef signed long SLIDER_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[2];
N  GUI_COLOR aColorInner[2];
N  GUI_COLOR aColorShaft[3];
N  GUI_COLOR ColorTick;
N  GUI_COLOR ColorFocus;
N  int TickSize;
N  int ShaftSize;
N} SLIDER_SKINFLEX_PROPS;
N
Ntypedef struct {
N  int Width;
N  int NumTicks;
N  int Size;
N  int IsPressed;
N  int IsVertical;
N} SLIDER_SKINFLEX_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NSLIDER_Handle SLIDER_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
XSLIDER_Handle SLIDER_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
NSLIDER_Handle SLIDER_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XSLIDER_Handle SLIDER_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NSLIDER_Handle SLIDER_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XSLIDER_Handle SLIDER_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NSLIDER_Handle SLIDER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XSLIDER_Handle SLIDER_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid SLIDER_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
Nvoid      SLIDER_Dec            (SLIDER_Handle hObj);
Nvoid      SLIDER_EnableFocusRect(SLIDER_Handle hObj, int OnOff);
NGUI_COLOR SLIDER_GetBarColor    (SLIDER_Handle hObj);
NGUI_COLOR SLIDER_GetBkColor     (SLIDER_Handle hObj);
NU8        SLIDER_GetFlag        (SLIDER_Handle hObj, U8 Flag);
Xunsigned char        SLIDER_GetFlag        (SLIDER_Handle hObj, unsigned char Flag);
NGUI_COLOR SLIDER_GetFocusColor  (SLIDER_Handle hObj);
Nvoid      SLIDER_GetRange       (SLIDER_Handle hObj, int * pMin, int * pMax);
NGUI_COLOR SLIDER_GetTickColor   (SLIDER_Handle hObj);
Nint       SLIDER_GetUserData    (SLIDER_Handle hObj, void * pDest, int NumBytes);
Nint       SLIDER_GetValue       (SLIDER_Handle hObj);
Nvoid      SLIDER_Inc            (SLIDER_Handle hObj);
Nvoid      SLIDER_SetBarColor    (SLIDER_Handle hObj, GUI_COLOR Color);
Nvoid      SLIDER_SetBkColor     (SLIDER_Handle hObj, GUI_COLOR Color);
NGUI_COLOR SLIDER_SetFocusColor  (SLIDER_Handle hObj, GUI_COLOR Color);
Nvoid      SLIDER_SetNumTicks    (SLIDER_Handle hObj, int NumTicks);
Nvoid      SLIDER_SetRange       (SLIDER_Handle hObj, int Min, int Max);
Nvoid      SLIDER_SetTickColor   (SLIDER_Handle hObj, GUI_COLOR Color);
Nint       SLIDER_SetUserData    (SLIDER_Handle hObj, const void * pSrc, int NumBytes);
Nvoid      SLIDER_SetValue       (SLIDER_Handle hObj, int v);
Nvoid      SLIDER_SetWidth       (SLIDER_Handle hObj, int Width);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid SLIDER_GetSkinFlexProps     (SLIDER_SKINFLEX_PROPS * pProps, int Index);
Nvoid SLIDER_SetSkinClassic       (SLIDER_Handle hObj);
Nvoid SLIDER_SetSkin              (SLIDER_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  SLIDER_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid SLIDER_SetSkinFlexProps     (const SLIDER_SKINFLEX_PROPS * pProps, int Index);
Nvoid SLIDER_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * SLIDER_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define SLIDER_SKIN_FLEX    SLIDER_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR SLIDER_GetDefaultBkColor   (void);
NGUI_COLOR SLIDER_GetDefaultBarColor  (void);
NGUI_COLOR SLIDER_GetDefaultFocusColor(void);
NGUI_COLOR SLIDER_GetDefaultTickColor (void);
Nvoid      SLIDER_SetDefaultBkColor   (GUI_COLOR Color);
Nvoid      SLIDER_SetDefaultBarColor  (GUI_COLOR Color);
NGUI_COLOR SLIDER_SetDefaultFocusColor(GUI_COLOR Color);
Nvoid      SLIDER_SetDefaultTickColor (GUI_COLOR Color);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // SLIDER_H
N
N/*************************** End of file ****************************/
L 72 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "SPINBOX.h"
L 1 "..\..\..\ThirdParty\emWin\Include\SPINBOX.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : SPINBOX.h
NPurpose     : SPINBOX header file
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef SPINBOX_H
N#define SPINBOX_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h" // Required for Create indirect data structure
N#include "WIDGET.h"
N#include "GUI_Debug.h"
N#include "EDIT.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {             // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       States
N*/
N#define SPINBOX_STATE_PRESSED(x)     (U8)(1 << (U8)x)    // These flags are stored in (SPINBOX_OBJ->State)        | x must be 0 or 1
N#define SPINBOX_STATE_FOCUS          WIDGET_STATE_FOCUS  // This is read from         (SPINBOX_OBJ->Widget.State)
N
N#define SPINBOX_EDGE_RIGHT           0
N#define SPINBOX_EDGE_LEFT            1
N#define SPINBOX_EDGE_CENTER          2
N
N#define SPINBOX_EM_STEP              0
N#define SPINBOX_EM_EDIT              1
N
N#ifndef SPINBOX_EM_DEFAULT
N  #define SPINBOX_EM_DEFAULT         SPINBOX_EM_STEP
N#endif
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define SPINBOX_CI_DISABLED          EDIT_CI_DISABLED
N#define SPINBOX_CI_ENABLED           EDIT_CI_ENABLED
N#define SPINBOX_CI_PRESSED           2
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define SPINBOX_SKIN_FLEX            SPINBOX_DrawSkinFlex
N
N#define SPINBOX_SKINFLEX_PI_PRESSED  0
N#define SPINBOX_SKINFLEX_PI_FOCUSED  1
N#define SPINBOX_SKINFLEX_PI_ENABLED  2
N#define SPINBOX_SKINFLEX_PI_DISABLED 3
N#define SPINBOX_SKIN_FLEX_RADIUS     2
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM SPINBOX_Handle;
Xtypedef signed long SPINBOX_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[2];   // [0] Outer color of surrounding frame.         [1] Inner color of surrounding frame.
N  GUI_COLOR aColorUpper[2];   // [0] Upper color of gradient for upper button. [1] Lower color of gradient for upper button.
N  GUI_COLOR aColorLower[2];   // [0] Upper color of gradient for lower button. [1] Lower color of gradient for lower button.
N  GUI_COLOR ColorArrow;       // Color of the button arrow.
N  GUI_COLOR ColorBk;          // Color of the background.                      // See WIDGET_ITEM_CREATE in SPINBOX_DrawSkinFlex()
N  GUI_COLOR ColorText;        // Color of the text.                            // See WIDGET_ITEM_CREATE in SPINBOX_DrawSkinFlex()
N  GUI_COLOR ColorButtonFrame; // Color of the button frame.
N} SPINBOX_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Prototypes
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Creation
N*/
NSPINBOX_Handle SPINBOX_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int Id, int Min, int Max);
XSPINBOX_Handle SPINBOX_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int Id, int Min, int Max);
NSPINBOX_Handle SPINBOX_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int Id, int Min, int Max, int NumExtraBytes);
XSPINBOX_Handle SPINBOX_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int Id, int Min, int Max, int NumExtraBytes);
NSPINBOX_Handle SPINBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XSPINBOX_Handle SPINBOX_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       Callback, should be called only from within a custom callback.
N*/
Nvoid           SPINBOX_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Get / Set properties
N*/
Nvoid             SPINBOX_EnableBlink     (SPINBOX_Handle hObj, int Period, int OnOff);
NGUI_COLOR        SPINBOX_GetBkColor      (SPINBOX_Handle hObj, unsigned int Index);
NGUI_COLOR        SPINBOX_GetButtonBkColor(SPINBOX_Handle hObj, unsigned int Index);
NEDIT_Handle      SPINBOX_GetEditHandle   (SPINBOX_Handle hObj);
Nconst GUI_FONT * SPINBOX_GetFont         (SPINBOX_Handle hObj);
NGUI_COLOR        SPINBOX_GetTextColor    (SPINBOX_Handle hObj, unsigned int Index);
Nint              SPINBOX_GetUserData     (SPINBOX_Handle hObj, void * pDest, int NumBytes);
NI32              SPINBOX_GetValue        (SPINBOX_Handle hObj);
Xsigned long              SPINBOX_GetValue        (SPINBOX_Handle hObj);
Nvoid             SPINBOX_SetBkColor      (SPINBOX_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid             SPINBOX_SetButtonBkColor(SPINBOX_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nvoid             SPINBOX_SetButtonSize   (SPINBOX_Handle hObj, unsigned ButtonSize);
Nvoid             SPINBOX_SetEdge         (SPINBOX_Handle hObj, U8 Edge);
Xvoid             SPINBOX_SetEdge         (SPINBOX_Handle hObj, unsigned char Edge);
Nvoid             SPINBOX_SetEditMode     (SPINBOX_Handle hObj, U8 EditMode);
Xvoid             SPINBOX_SetEditMode     (SPINBOX_Handle hObj, unsigned char EditMode);
Nvoid             SPINBOX_SetFont         (SPINBOX_Handle hObj, const GUI_FONT * pFont);
Nvoid             SPINBOX_SetRange        (SPINBOX_Handle hObj, I32 Min, I32 Max);
Xvoid             SPINBOX_SetRange        (SPINBOX_Handle hObj, signed long Min, signed long Max);
NU16              SPINBOX_SetStep         (SPINBOX_Handle hObj, U16 Step);
Xunsigned short              SPINBOX_SetStep         (SPINBOX_Handle hObj, unsigned short Step);
Nvoid             SPINBOX_SetTextColor    (SPINBOX_Handle hObj, unsigned int Index, GUI_COLOR Color);
Nint              SPINBOX_SetUserData     (SPINBOX_Handle hObj, const void * pSrc, int NumBytes);
Nvoid             SPINBOX_SetValue        (SPINBOX_Handle hObj, I32 Value);
Xvoid             SPINBOX_SetValue        (SPINBOX_Handle hObj, signed long Value);
N
N/*********************************************************************
N*
N*       Managing default values
N*/
NU16  SPINBOX_GetDefaultButtonSize(void);
Xunsigned short  SPINBOX_GetDefaultButtonSize(void);
Nvoid SPINBOX_SetDefaultButtonSize(U16 ButtonSize);
Xvoid SPINBOX_SetDefaultButtonSize(unsigned short ButtonSize);
N
N/*********************************************************************
N*
N*       Skinning
N*/
Nvoid                    SPINBOX_GetSkinFlexProps     (SPINBOX_SKINFLEX_PROPS * pProps, int Index);
Nvoid                    SPINBOX_SetSkinClassic       (SPINBOX_Handle hObj);
Nvoid                    SPINBOX_SetSkin              (SPINBOX_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint                     SPINBOX_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid                    SPINBOX_SetSkinFlexProps     (const SPINBOX_SKINFLEX_PROPS * pProps, int Index);
Nvoid                    SPINBOX_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * SPINBOX_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // SPINBOX_H
N
N/*************************** End of file ****************************/
L 73 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "SWIPELIST.h"
L 1 "..\..\..\ThirdParty\emWin\Include\SWIPELIST.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : SWIPELIST.h
NPurpose     : SWIPELIST include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef SWIPELIST_H
N#define SWIPELIST_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      // Req. for Create indirect data structure
N#include "WIDGET.h"
N#include "GUI_Debug.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {                  // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Create flags
N*
N**********************************************************************
N*/
N#define SWIPELIST_CF_HORIZONTAL (0 << 0)
N#define SWIPELIST_CF_VERTICAL   (1 << 0)
N
N/*********************************************************************
N*
N*       Getting border size
N*/
N#define SWIPELIST_BI_LEFT   0
N#define SWIPELIST_BI_RIGHT  1
N#define SWIPELIST_BI_TOP    2
N#define SWIPELIST_BI_BOTTOM 3
N
N/*********************************************************************
N*
N*       Getting font
N*/
N#define SWIPELIST_FI_SEP_ITEM    0
N#define SWIPELIST_FI_ITEM_HEADER 1
N#define SWIPELIST_FI_ITEM_TEXT   2
N
N/*********************************************************************
N*
N*       Getting color
N*/
N#define SWIPELIST_CI_ITEM_HEADER_UNSEL 0
N#define SWIPELIST_CI_ITEM_HEADER_SEL   1
N#define SWIPELIST_CI_ITEM_TEXT_UNSEL   2
N#define SWIPELIST_CI_ITEM_TEXT_SEL     3
N#define SWIPELIST_CI_SEP_ITEM_TEXT     4
N
N#define SWIPELIST_CI_BK_ITEM_UNSEL     0
N#define SWIPELIST_CI_BK_ITEM_SEL       1
N#define SWIPELIST_CI_BK_SEP_ITEM       2
N
N/*********************************************************************
N*
N*       Bitmap align
N*/
N#define SWIPELIST_BA_LEFT      (0<<0)
N#define SWIPELIST_BA_RIGHT	   (1<<0)
N#define SWIPELIST_BA_HCENTER	 (2<<0)
N
N#define SWIPELIST_BA_VCENTER   (3<<2)
N#define SWIPELIST_BA_TOP	     (0<<2)
N#define SWIPELIST_BA_BOTTOM	   (1<<2)
N
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM SWIPELIST_Handle;
Xtypedef signed long SWIPELIST_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NSWIPELIST_Handle SWIPELIST_CreateAsChild  (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags);
XSWIPELIST_Handle SWIPELIST_CreateAsChild  (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags);
NSWIPELIST_Handle SWIPELIST_CreateEx       (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XSWIPELIST_Handle SWIPELIST_CreateEx       (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NSWIPELIST_Handle SWIPELIST_CreateIndirect (const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XSWIPELIST_Handle SWIPELIST_CreateIndirect (const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
NSWIPELIST_Handle SWIPELIST_CreateUser     (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XSWIPELIST_Handle SWIPELIST_CreateUser     (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid SWIPELIST_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
N
Nint                SWIPELIST_AddItem                 (SWIPELIST_Handle hObj, const char * sText, int ItemSize);
Nint                SWIPELIST_AddItemText             (SWIPELIST_Handle hObj, unsigned ItemIndex, const char * sText);
Nint                SWIPELIST_AddSepItem              (SWIPELIST_Handle hObj, const char * sText, int ItemSize);
Nvoid               SWIPELIST_DeleteItem              (SWIPELIST_Handle hObj, unsigned ItemIndex);
N
Nconst GUI_BITMAP * SWIPELIST_GetBitmap               (SWIPELIST_Handle hObj, unsigned ItemIndex);
Nint                SWIPELIST_GetBitmapSpace          (SWIPELIST_Handle hObj);
NGUI_COLOR          SWIPELIST_GetBkColor              (SWIPELIST_Handle hObj, unsigned Index);
Nint                SWIPELIST_GetBorderSize           (SWIPELIST_Handle hObj, unsigned Index);
Nconst GUI_FONT *   SWIPELIST_GetFont                 (SWIPELIST_Handle hObj, unsigned Index);
Nint                SWIPELIST_GetItemSize             (SWIPELIST_Handle hObj, unsigned ItemIndex);
NU32                SWIPELIST_GetItemUserData         (SWIPELIST_Handle hObj, unsigned ItemIndex);
Xunsigned long                SWIPELIST_GetItemUserData         (SWIPELIST_Handle hObj, unsigned ItemIndex);
Nint                SWIPELIST_GetNumItems             (SWIPELIST_Handle hObj);
Nint                SWIPELIST_GetNumText              (SWIPELIST_Handle hObj, unsigned ItemIndex);
Nint                SWIPELIST_GetReleasedItem         (SWIPELIST_Handle hObj);
Nint                SWIPELIST_GetScrollPos            (SWIPELIST_Handle hObj);
Nint                SWIPELIST_GetSelItem              (SWIPELIST_Handle hObj);
NGUI_COLOR          SWIPELIST_GetSepColor             (SWIPELIST_Handle hObj, unsigned ItemIndex);
Nint                SWIPELIST_GetSepSize              (SWIPELIST_Handle hObj, unsigned ItemIndex);
Nvoid               SWIPELIST_GetText                 (SWIPELIST_Handle hObj, unsigned ItemIndex, unsigned TextIndex, char * pBuffer, int MaxSize);
Nint                SWIPELIST_GetTextAlign            (SWIPELIST_Handle hObj, unsigned ItemIndex);
NGUI_COLOR          SWIPELIST_GetTextColor            (SWIPELIST_Handle hObj, unsigned Index);
Nint                SWIPELIST_GetThreshold            (SWIPELIST_Handle hObj);
Nint                SWIPELIST_GetUserData             (SWIPELIST_Handle hObj, void * pDest, int NumBytes);
N
Nint                SWIPELIST_ItemAttachWindow        (SWIPELIST_Handle hObj, unsigned ItemIndex, WM_HWIN hWin, int x0, int y0);
Xint                SWIPELIST_ItemAttachWindow        (SWIPELIST_Handle hObj, unsigned ItemIndex, GUI_HWIN hWin, int x0, int y0);
Nvoid               SWIPELIST_ItemDetachWindow        (SWIPELIST_Handle hObj, WM_HWIN hWin);
Xvoid               SWIPELIST_ItemDetachWindow        (SWIPELIST_Handle hObj, GUI_HWIN hWin);
Nint                SWIPELIST_OwnerDraw               (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
N
Nvoid               SWIPELIST_SetAttachedWindowPos    (SWIPELIST_Handle hObj, WM_HWIN hWin, int x0, int y0);
Xvoid               SWIPELIST_SetAttachedWindowPos    (SWIPELIST_Handle hObj, GUI_HWIN hWin, int x0, int y0);
Nvoid               SWIPELIST_SetBitmap               (SWIPELIST_Handle hObj, unsigned ItemIndex, int Align, const GUI_BITMAP * pBitmap);
Nvoid               SWIPELIST_SetBitmapEx             (SWIPELIST_Handle hObj, unsigned ItemIndex, int Align, const GUI_BITMAP * pBitmap, int x, int y);
Nvoid               SWIPELIST_SetBitmapSpace          (SWIPELIST_Handle hObj, unsigned Size);
Nvoid               SWIPELIST_SetBkColor              (SWIPELIST_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid               SWIPELIST_SetBorderSize           (SWIPELIST_Handle hObj, unsigned Index, unsigned Size);
Nvoid               SWIPELIST_SetFont                 (SWIPELIST_Handle hObj, unsigned Index, const GUI_FONT * pFont);
Nvoid               SWIPELIST_SetItemSize             (SWIPELIST_Handle hObj, unsigned ItemIndex, unsigned Size);
Nvoid               SWIPELIST_SetItemUserData         (SWIPELIST_Handle hObj, unsigned ItemIndex, U32 UserData);
Xvoid               SWIPELIST_SetItemUserData         (SWIPELIST_Handle hObj, unsigned ItemIndex, unsigned long UserData);
Nvoid               SWIPELIST_SetOwnerDraw            (SWIPELIST_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid               SWIPELIST_SetScrollPos            (SWIPELIST_Handle hObj, int Pos);
Nvoid               SWIPELIST_SetScrollPosItem        (SWIPELIST_Handle hObj, unsigned ItemIndex);
Nvoid               SWIPELIST_SetSepColor             (SWIPELIST_Handle hObj, unsigned ItemIndex, GUI_COLOR Color);
Nvoid               SWIPELIST_SetSepSize              (SWIPELIST_Handle hObj, unsigned ItemIndex, int Size);
Nvoid               SWIPELIST_SetText                 (SWIPELIST_Handle hObj, unsigned ItemIndex, unsigned TextIndex, char * sText);
Nvoid               SWIPELIST_SetTextAlign            (SWIPELIST_Handle hObj, unsigned ItemIndex, int Align);
Nvoid               SWIPELIST_SetTextColor            (SWIPELIST_Handle hObj, unsigned Index, GUI_COLOR Color);
Nint                SWIPELIST_SetThreshold            (SWIPELIST_Handle hObj, int Threshold);
Nint                SWIPELIST_SetUserData             (SWIPELIST_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Global functions
N*
N**********************************************************************
N*/
Nint              SWIPELIST_GetDefaultBitmapSpace     (void);
NGUI_COLOR        SWIPELIST_GetDefaultBkColor         (unsigned Index);
Nint              SWIPELIST_GetDefaultBorderSize      (unsigned Index);
Nconst GUI_FONT * SWIPELIST_GetDefaultFont            (unsigned Index);
NGUI_COLOR        SWIPELIST_GetDefaultSepColor        (void);
Nunsigned         SWIPELIST_GetDefaultSepSize         (void);
NGUI_COLOR        SWIPELIST_GetDefaultTextColor       (unsigned Index);
Nint              SWIPELIST_GetDefaultTextAlign       (void);
Nint              SWIPELIST_GetDefaultThreshold       (void);
N
Nvoid             SWIPELIST_SetDefaultBitmapSpace     (unsigned Size);
Nvoid             SWIPELIST_SetDefaultBkColor         (unsigned Index, GUI_COLOR Color);
Nvoid             SWIPELIST_SetDefaultBorderSize      (unsigned Index, unsigned Size);
Nvoid             SWIPELIST_SetDefaultFont            (unsigned Index, const GUI_FONT * pFont);
Nvoid             SWIPELIST_SetDefaultSepColor        (GUI_COLOR Color);
Nvoid             SWIPELIST_SetDefaultSepSize         (unsigned Size);
Nvoid             SWIPELIST_SetDefaultTextColor       (unsigned Index, GUI_COLOR Color);
Nvoid             SWIPELIST_SetDefaultTextAlign       (int Align);
Nvoid             SWIPELIST_SetDefaultThreshold       (int Threshold);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // SWIPELIST_H
N
N/*************************** End of file ****************************/
L 74 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "TEXT.h"
L 1 "..\..\..\ThirdParty\emWin\Include\TEXT.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : TEXT.h
NPurpose     : TEXT include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef TEXT_H
N#define TEXT_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N#include "GUI_Debug.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/************************************************************
N*
N*       #defines
N*
N*************************************************************
N*/
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define TEXT_CF_LEFT    GUI_TA_LEFT
N#define TEXT_CF_RIGHT   GUI_TA_RIGHT
N#define TEXT_CF_HCENTER GUI_TA_HCENTER
N
N#define TEXT_CF_VCENTER GUI_TA_VCENTER
N#define TEXT_CF_TOP     GUI_TA_TOP
N#define TEXT_CF_BOTTOM  GUI_TA_BOTTOM
N
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N
N*/
Ntypedef WM_HMEM TEXT_Handle;
Xtypedef signed long TEXT_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NTEXT_Handle TEXT_Create        (int x0, int y0, int xSize, int ySize, int Id, int Flags, const char * s, int Align);
NTEXT_Handle TEXT_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, const char * s, int Align);
XTEXT_Handle TEXT_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, const char * s, int Align);
NTEXT_Handle TEXT_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText);
XTEXT_Handle TEXT_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText);
NTEXT_Handle TEXT_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText, int NumExtraBytes);
XTEXT_Handle TEXT_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText, int NumExtraBytes);
NTEXT_Handle TEXT_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XTEXT_Handle TEXT_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid TEXT_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
N/* Methods changing properties */
N
NGUI_COLOR        TEXT_GetBkColor  (TEXT_Handle hObj); 
Nconst GUI_FONT * TEXT_GetFont     (TEXT_Handle hObj);
Nint              TEXT_GetNumLines (TEXT_Handle hObj);
Nint              TEXT_GetText     (TEXT_Handle hObj, char * pDest, U32 BufferSize);
Xint              TEXT_GetText     (TEXT_Handle hObj, char * pDest, unsigned long BufferSize);
Nint              TEXT_GetTextAlign(TEXT_Handle hObj);
NGUI_COLOR        TEXT_GetTextColor(TEXT_Handle hObj);
Nint              TEXT_GetUserData (TEXT_Handle hObj, void * pDest, int NumBytes);
NGUI_WRAPMODE     TEXT_GetWrapMode (TEXT_Handle hObj);
Nvoid             TEXT_SetBkColor  (TEXT_Handle hObj, GUI_COLOR Color);
Nvoid             TEXT_SetFont     (TEXT_Handle hObj, const GUI_FONT * pFont);
Nint              TEXT_SetDec      (TEXT_Handle hObj, I32 v, U8 Len, U8 Shift, U8 Signed, U8 Space);
Xint              TEXT_SetDec      (TEXT_Handle hObj, signed long v, unsigned char Len, unsigned char Shift, unsigned char Signed, unsigned char Space);
Nint              TEXT_SetText     (TEXT_Handle hObj, const char * s);
Nvoid             TEXT_SetTextAlign(TEXT_Handle hObj, int Align);
Nvoid             TEXT_SetTextColor(TEXT_Handle hObj, GUI_COLOR Color);
Nint              TEXT_SetUserData (TEXT_Handle hObj, const void * pSrc, int NumBytes);
Nvoid             TEXT_SetWrapMode (TEXT_Handle hObj, GUI_WRAPMODE WrapMode);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
Nconst GUI_FONT * TEXT_GetDefaultFont     (void);
NGUI_COLOR        TEXT_GetDefaultTextColor(void);
NGUI_WRAPMODE     TEXT_GetDefaultWrapMode (void);
Nvoid             TEXT_SetDefaultFont     (const GUI_FONT * pFont);
Nvoid             TEXT_SetDefaultTextColor(GUI_COLOR Color);
NGUI_WRAPMODE     TEXT_SetDefaultWrapMode (GUI_WRAPMODE WrapMode);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // TEXT_H
N
N/*************************** End of file ****************************/
L 75 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N#include "TREEVIEW.h"
L 1 "..\..\..\ThirdParty\emWin\Include\TREEVIEW.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : TREEVIEW.h
NPurpose     : TREEVIEW include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef TREEVIEW_H
N#define TREEVIEW_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/* Status- and create flags */
N#define TREEVIEW_CF_HIDELINES       (1 << 0)
N#define TREEVIEW_CF_ROWSELECT       (1 << 1)
N#define TREEVIEW_CF_AUTOSCROLLBAR_H (1 << 2)
N#define TREEVIEW_CF_AUTOSCROLLBAR_V (1 << 3)
N#define TREEVIEW_SF_HIDELINES       TREEVIEW_CF_HIDELINES
N#define TREEVIEW_SF_ROWSELECT       TREEVIEW_CF_ROWSELECT
N#define TREEVIEW_SF_AUTOSCROLLBAR_H TREEVIEW_CF_AUTOSCROLLBAR_H
N#define TREEVIEW_SF_AUTOSCROLLBAR_V TREEVIEW_CF_AUTOSCROLLBAR_V
N
N/* Bitmap indices */
N#define TREEVIEW_BI_CLOSED 0
N#define TREEVIEW_BI_OPEN   1
N#define TREEVIEW_BI_LEAF   2
N#define TREEVIEW_BI_PLUS   3
N#define TREEVIEW_BI_MINUS  4
N#define TREEVIEW_BI_PM     5
N
N/* Color indices */
N#define TREEVIEW_CI_UNSEL    0
N#define TREEVIEW_CI_SEL      1
N#define TREEVIEW_CI_DISABLED 2
N
N/* Relative positions (create) */
N#define TREEVIEW_INSERT_ABOVE       0
N#define TREEVIEW_INSERT_BELOW       1
N#define TREEVIEW_INSERT_FIRST_CHILD 2
N
N/* Relative positions (retrieve) */
N#define TREEVIEW_GET_FIRST        0
N#define TREEVIEW_GET_LAST         1
N#define TREEVIEW_GET_NEXT_SIBLING 2
N#define TREEVIEW_GET_PREV_SIBLING 3
N#define TREEVIEW_GET_FIRST_CHILD  4
N#define TREEVIEW_GET_PARENT       5
N
N/* Item flags */
N#define TREEVIEW_ITEM_TYPE_LEAF (0 << 0)
N#define TREEVIEW_ITEM_TYPE_NODE (1 << 0)
N
N/* Selection mode */
N#define TREEVIEW_SELMODE_ROW  1
N#define TREEVIEW_SELMODE_TEXT 0
N
N/************************************************************
N*
N*       Types
N*
N*************************************************************
N*/
Ntypedef WM_HMEM TREEVIEW_Handle;
Xtypedef signed long TREEVIEW_Handle;
Ntypedef WM_HMEM TREEVIEW_ITEM_Handle;
Xtypedef signed long TREEVIEW_ITEM_Handle;
N
Ntypedef struct {
N  int IsNode;
N  int IsExpanded;
N  int HasLines;
N  int HasRowSelect;
N  int Level;
N} TREEVIEW_ITEM_INFO;
N
Ntypedef struct {
N  GUI_COLOR ColorBk;
N  GUI_COLOR ColorText;
N  GUI_COLOR ColorTextBk;
N  GUI_COLOR ColorLines;
N  GUI_RECT rText;
N  TREEVIEW_ITEM_Handle hItem;
N  const GUI_FONT * pFont;
N  char * pText;
N  U8 NumLines;
X  unsigned char NumLines;
N  I16 ax0[3];
X  signed short ax0[3];
N  I16 ay0[3];
X  signed short ay0[3];
N  I16 ax1[3];
X  signed short ax1[3];
N  I16 ay1[3];
X  signed short ay1[3];
N  U8 NumConnectors;
X  unsigned char NumConnectors;
N  I16 axc[16];
X  signed short axc[16];
N  const GUI_BITMAP * pBmPM;
N  const GUI_BITMAP * pBmOCL;
N  I16 xPosPM, xPosOCL;
X  signed short xPosPM, xPosOCL;
N  U8 IndexPM;
X  unsigned char IndexPM;
N  U8 IndexOCL;
X  unsigned char IndexOCL;
N} TREEVIEW_ITEM_DRAW_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NTREEVIEW_Handle      TREEVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XTREEVIEW_Handle      TREEVIEW_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NTREEVIEW_Handle      TREEVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XTREEVIEW_Handle      TREEVIEW_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NTREEVIEW_Handle      TREEVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XTREEVIEW_Handle      TREEVIEW_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid TREEVIEW_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Common functions
N*
N**********************************************************************
N*/
Nint                  TREEVIEW_AttachItem     (TREEVIEW_Handle hObj, TREEVIEW_ITEM_Handle hItem, TREEVIEW_ITEM_Handle hItemAt, int Position);
Nvoid                 TREEVIEW_DecSel         (TREEVIEW_Handle hObj);
NTREEVIEW_ITEM_Handle TREEVIEW_GetItem        (TREEVIEW_Handle hObj, TREEVIEW_ITEM_Handle hItem, int Flags);
NTREEVIEW_ITEM_Handle TREEVIEW_GetSel         (TREEVIEW_Handle hObj);
Nint                  TREEVIEW_GetUserData    (TREEVIEW_Handle hObj, void * pDest, int NumBytes);
Nvoid                 TREEVIEW_IncSel         (TREEVIEW_Handle hObj);
NTREEVIEW_ITEM_Handle TREEVIEW_InsertItem     (TREEVIEW_Handle hObj, int IsNode, TREEVIEW_ITEM_Handle hItemPrev, int Position, const char * s);
Nint                  TREEVIEW_OwnerDraw      (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid                 TREEVIEW_ScrollToSel    (TREEVIEW_Handle hObj);
Nvoid                 TREEVIEW_SetAutoScrollH (TREEVIEW_Handle hObj, int State);
Nvoid                 TREEVIEW_SetAutoScrollV (TREEVIEW_Handle hObj, int State);
Nvoid                 TREEVIEW_SetBitmapOffset(TREEVIEW_Handle hObj, int Index, int xOff, int yOff);
Nvoid                 TREEVIEW_SetBkColor     (TREEVIEW_Handle hObj, int Index, GUI_COLOR Color);
Nvoid                 TREEVIEW_SetFont        (TREEVIEW_Handle hObj, const GUI_FONT * pFont);
Nvoid                 TREEVIEW_SetHasLines    (TREEVIEW_Handle hObj, int State);
Nvoid                 TREEVIEW_SetImage       (TREEVIEW_Handle hObj, int Index, const GUI_BITMAP * pBitmap);
Nint                  TREEVIEW_SetIndent      (TREEVIEW_Handle hObj, int Indent);
Nvoid                 TREEVIEW_SetLineColor   (TREEVIEW_Handle hObj, int Index, GUI_COLOR Color);
Nvoid                 TREEVIEW_SetOwnerDraw   (TREEVIEW_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid                 TREEVIEW_SetSel         (TREEVIEW_Handle hObj, TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_SetSelMode     (TREEVIEW_Handle hObj, int Mode);
Nvoid                 TREEVIEW_SetTextColor   (TREEVIEW_Handle hObj, int Index, GUI_COLOR Color);
Nint                  TREEVIEW_SetTextIndent  (TREEVIEW_Handle hObj, int TextIndent);
Nint                  TREEVIEW_SetUserData    (TREEVIEW_Handle hObj, const void * pSrc, int NumBytes);
N
N
N/*********************************************************************
N*
N*       Treeview item related functions
N*
N**********************************************************************
N*/
Nvoid                 TREEVIEW_ITEM_Collapse   (TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_CollapseAll(TREEVIEW_ITEM_Handle hItem);
NTREEVIEW_ITEM_Handle TREEVIEW_ITEM_Create     (int IsNode, const char * s, U32 UserData);
XTREEVIEW_ITEM_Handle TREEVIEW_ITEM_Create     (int IsNode, const char * s, unsigned long UserData);
Nvoid                 TREEVIEW_ITEM_Delete     (TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_Detach     (TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_Expand     (TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_ExpandAll  (TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_GetInfo    (TREEVIEW_ITEM_Handle hItem, TREEVIEW_ITEM_INFO * pInfo);
Nvoid                 TREEVIEW_ITEM_GetText    (TREEVIEW_ITEM_Handle hItem, U8 * pBuffer, int MaxNumBytes);
Xvoid                 TREEVIEW_ITEM_GetText    (TREEVIEW_ITEM_Handle hItem, unsigned char * pBuffer, int MaxNumBytes);
NU32                  TREEVIEW_ITEM_GetUserData(TREEVIEW_ITEM_Handle hItem);
Xunsigned long                  TREEVIEW_ITEM_GetUserData(TREEVIEW_ITEM_Handle hItem);
Nvoid                 TREEVIEW_ITEM_SetImage   (TREEVIEW_ITEM_Handle hItem, int Index, const GUI_BITMAP * pBitmap);
NTREEVIEW_ITEM_Handle TREEVIEW_ITEM_SetText    (TREEVIEW_ITEM_Handle hItem, const char * s);
Nvoid                 TREEVIEW_ITEM_SetUserData(TREEVIEW_ITEM_Handle hItem, U32 UserData);
Xvoid                 TREEVIEW_ITEM_SetUserData(TREEVIEW_ITEM_Handle hItem, unsigned long UserData);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR        TREEVIEW_GetDefaultBkColor  (int Index);
Nconst GUI_FONT * TREEVIEW_GetDefaultFont     (void);
NGUI_COLOR        TREEVIEW_GetDefaultLineColor(int Index);
NGUI_COLOR        TREEVIEW_GetDefaultTextColor(int Index);
Nvoid             TREEVIEW_SetDefaultBkColor  (int Index, GUI_COLOR Color);
Nvoid             TREEVIEW_SetDefaultFont     (const GUI_FONT * pFont);
Nvoid             TREEVIEW_SetDefaultLineColor(int Index, GUI_COLOR Color);
Nvoid             TREEVIEW_SetDefaultTextColor(int Index, GUI_COLOR Color);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // TREEVIEW_H
N
N/*************************** End of file ****************************/
L 76 "..\..\..\ThirdParty\emWin\Include\DIALOG.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       WINDOW API
N*/
NWM_HWIN   WINDOW_CreateEx         (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb);
XGUI_HWIN   WINDOW_CreateEx         (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb);
NWM_HWIN   WINDOW_CreateUser       (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb, int NumExtraBytes);
XGUI_HWIN   WINDOW_CreateUser       (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, WM_CALLBACK * cb, int NumExtraBytes);
NWM_HWIN   WINDOW_CreateIndirect   (const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XGUI_HWIN   WINDOW_CreateIndirect   (const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
NGUI_COLOR WINDOW_GetDefaultBkColor(void);
Nint       WINDOW_GetUserData      (WM_HWIN hObj, void * pDest, int NumBytes);
Xint       WINDOW_GetUserData      (GUI_HWIN hObj, void * pDest, int NumBytes);
Nvoid      WINDOW_SetBkColor       (WM_HWIN hObj, GUI_COLOR Color);
Xvoid      WINDOW_SetBkColor       (GUI_HWIN hObj, GUI_COLOR Color);
Nvoid      WINDOW_SetDefaultBkColor(GUI_COLOR Color);
Nint       WINDOW_SetUserData      (WM_HWIN hObj, const void * pSrc, int NumBytes);
Xint       WINDOW_SetUserData      (GUI_HWIN hObj, const void * pSrc, int NumBytes);
N
Nvoid WINDOW_Callback(WM_MESSAGE * pMsg);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // DIALOG_H
N
N/*************************** End of file ****************************/
L 28 "..\Application\FramewinDLG.c" 2
N//#include "wbio.h"
N//#include "wbtypes.h"
N//#include "wblib.h"
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define ID_FRAMEWIN_0  (GUI_ID_USER + 0x00)
N#define ID_BUTTON_0  (GUI_ID_USER + 0x05)
N#define ID_BUTTON_1  (GUI_ID_USER + 0x06)
N#define ID_BUTTON_2  (GUI_ID_USER + 0x07)
N#define ID_BUTTON_3  (GUI_ID_USER + 0x08)
N#define ID_EDIT_0  (GUI_ID_USER + 0x09)
N#define ID_TEXT_0  (GUI_ID_USER + 0x0B)
N
N
N// USER START (Optionally insert additional defines)
N// USER END
N
N/*********************************************************************
N*
N*       Static data
N*
N**********************************************************************
N*/
N
N// USER START (Optionally insert additional static data)
N// USER END
N
N/*********************************************************************
N*
N*       _aDialogCreate
N*/
Nstatic const GUI_WIDGET_CREATE_INFO _aDialogCreate[7] = {
N  { FRAMEWIN_CreateIndirect, "Framewin", ID_FRAMEWIN_0, 0, 0, 800, 480, 0, 0x0  },
X  { FRAMEWIN_CreateIndirect, "Framewin", (0x800 + 0x00), 0, 0, 800, 480, 0, 0x0  },
N  { BUTTON_CreateIndirect, "+ 1", ID_BUTTON_0, 43, 38, 80, 20, 0, 0x0  },
X  { BUTTON_CreateIndirect, "+ 1", (0x800 + 0x05), 43, 38, 80, 20, 0, 0x0  },
N  { BUTTON_CreateIndirect, "+ 10", ID_BUTTON_1, 43, 77, 80, 20, 0, 0x0 },
X  { BUTTON_CreateIndirect, "+ 10", (0x800 + 0x06), 43, 77, 80, 20, 0, 0x0 },
N  { BUTTON_CreateIndirect, "- 1", ID_BUTTON_2, 45, 116, 80, 20, 0, 0x0 },
X  { BUTTON_CreateIndirect, "- 1", (0x800 + 0x07), 45, 116, 80, 20, 0, 0x0 },
N  { BUTTON_CreateIndirect, "- 10", ID_BUTTON_3, 46, 158, 80, 20, 0, 0x0 },
X  { BUTTON_CreateIndirect, "- 10", (0x800 + 0x08), 46, 158, 80, 20, 0, 0x0 },
N  { EDIT_CreateIndirect, "Edit", ID_EDIT_0, 204, 72, 80, 20, 0, 0x64 },
X  { EDIT_CreateIndirect, "Edit", (0x800 + 0x09), 204, 72, 80, 20, 0, 0x64 },
N  { TEXT_CreateIndirect, "Result :", ID_TEXT_0, 151, 74, 50, 20, 0, 0x0 },
X  { TEXT_CreateIndirect, "Result :", (0x800 + 0x0B), 151, 74, 50, 20, 0, 0x0 },
N  // USER START (Optionally insert additional widgets)
N  // USER END
N};
N
N/*********************************************************************
N*
N*       Static code
N*
N**********************************************************************
N*/
N
N// USER START (Optionally insert additional static code)
N// USER END
N
Nint value;
Nchar sBuf[20];
N/*********************************************************************
N*
N*       _cbDialog
N*/
Nstatic void _cbDialog(WM_MESSAGE * pMsg) {
N  WM_HWIN hItem;
X  GUI_HWIN hItem;
N  int     NCode;
N  int     Id;
N  // USER START (Optionally insert additional variables)
N  // USER END
N
N  switch (pMsg->MsgId) {
N  case WM_INIT_DIALOG:
X  case 29:
N    //
N    // Initialization of 'Edit'
N    //
N	  value = 30;
N	  sprintf(sBuf,"%d    ", value);
N    hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
X    hItem = WM_GetDialogItem(pMsg->hWin, (0x800 + 0x09));
N    EDIT_SetText(hItem, sBuf);
N
N    // USER START (Optionally insert additional code for further widget initialization)
N    // USER END
N    break;
N  case WM_NOTIFY_PARENT:
X  case 38:
N    Id    = WM_GetId(pMsg->hWinSrc);
N    NCode = pMsg->Data.v;
N    switch(Id) {
N    case ID_BUTTON_0: // Notifications sent by '+ 1'
X    case (0x800 + 0x05): 
N      switch(NCode) {
N      case WM_NOTIFICATION_CLICKED:
X      case 1:
N        // USER START (Optionally insert code for reacting on notification message)
N        // USER END
N//		sysprintf("clicked\n");
N        break;
N      case WM_NOTIFICATION_RELEASED:
X      case 2:
N        // USER START (Optionally insert code for reacting on notification message)
N			  value += 1;
N			  sprintf(sBuf,"%d    ", value);
N				hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
X				hItem = WM_GetDialogItem(pMsg->hWin, (0x800 + 0x09));
N				EDIT_SetText(hItem, sBuf);
N//		sysprintf("released\n");
N        		sysprintf("released + 1\n");
N
N        // USER END
N        break;
N      // USER START (Optionally insert additional code for further notification handling)
N      // USER END
N      }
N      break;
N    case ID_BUTTON_1: // Notifications sent by '+ 10'
X    case (0x800 + 0x06): 
N      switch(NCode) {
N      case WM_NOTIFICATION_CLICKED:
X      case 1:
N        // USER START (Optionally insert code for reacting on notification message)
N        // USER END
N
N        break;
N      case WM_NOTIFICATION_RELEASED:
X      case 2:
N        // USER START (Optionally insert code for reacting on notification message)
N			  value += 10;
N			  sprintf(sBuf,"%d    ", value);
N				hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
X				hItem = WM_GetDialogItem(pMsg->hWin, (0x800 + 0x09));
N				EDIT_SetText(hItem, sBuf);
N
N        		sysprintf("released + 10\n");				
N        // USER END
N        break;
N      // USER START (Optionally insert additional code for further notification handling)
N      // USER END
N      }
N      break;
N    case ID_BUTTON_2: // Notifications sent by '- 1'
X    case (0x800 + 0x07): 
N      switch(NCode) {
N      case WM_NOTIFICATION_CLICKED:
X      case 1:
N        // USER START (Optionally insert code for reacting on notification message)
N        // USER END
N
N        break;
N      case WM_NOTIFICATION_RELEASED:
X      case 2:
N        // USER START (Optionally insert code for reacting on notification message)
N			  value -= 1;
N			  sprintf(sBuf,"%d    ", value);
N				hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
X				hItem = WM_GetDialogItem(pMsg->hWin, (0x800 + 0x09));
N				EDIT_SetText(hItem, sBuf);
N				
N        		sysprintf("released -1\n");				
N        // USER END
N        break;
N      // USER START (Optionally insert additional code for further notification handling)
N      // USER END
N      }
N      break;
N    case ID_BUTTON_3: // Notifications sent by '- 10'
X    case (0x800 + 0x08): 
N      switch(NCode) {
N      case WM_NOTIFICATION_CLICKED:
X      case 1:
N        // USER START (Optionally insert code for reacting on notification message)
N        // USER END
N        break;
N      case WM_NOTIFICATION_RELEASED:
X      case 2:
N        // USER START (Optionally insert code for reacting on notification message)
N			  value -= 10;
N			  sprintf(sBuf,"%d    ", value);
N				hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
X				hItem = WM_GetDialogItem(pMsg->hWin, (0x800 + 0x09));
N				EDIT_SetText(hItem, sBuf);
N
N        		sysprintf("released -10\n");					
N        // USER END
N        break;
N      // USER START (Optionally insert additional code for further notification handling)
N      // USER END
N      }
N      break;
N    case ID_EDIT_0: // Notifications sent by 'Edit'
X    case (0x800 + 0x09): 
N      switch(NCode) {
N      case WM_NOTIFICATION_CLICKED:
X      case 1:
N        // USER START (Optionally insert code for reacting on notification message)
N        // USER END
N        break;
N      case WM_NOTIFICATION_RELEASED:
X      case 2:
N        // USER START (Optionally insert code for reacting on notification message)
N        // USER END
N        break;
N      case WM_NOTIFICATION_VALUE_CHANGED:
X      case 5:
N        // USER START (Optionally insert code for reacting on notification message)
N        // USER END
N        break;
N      // USER START (Optionally insert additional code for further notification handling)
N      // USER END
N      }
N      break;
N    // USER START (Optionally insert additional code for further Ids)
N    // USER END
N    }
N    break;
N  // USER START (Optionally insert additional message handling)
N  // USER END
N  default:
N    WM_DefaultProc(pMsg);
N    break;
N  }
N}
N
N/*********************************************************************
N*
N*       Public code
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       CreateFramewin
N*/
NWM_HWIN CreateFramewin(void);
XGUI_HWIN CreateFramewin(void);
NWM_HWIN CreateFramewin(void) {
XGUI_HWIN CreateFramewin(void) {
N  WM_HWIN hWin;
X  GUI_HWIN hWin;
N
N  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
X  hWin = GUI_CreateDialogBox(_aDialogCreate, (sizeof(_aDialogCreate) / sizeof(_aDialogCreate[0])), _cbDialog, WM_GetDesktopWindow(), 0, 0);
N  return hWin;
N}
N
N// USER START (Optionally insert additional public code)
N// USER END
N
N/*************************** End of file ****************************/
