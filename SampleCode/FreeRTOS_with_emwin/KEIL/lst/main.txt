; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931 -I..\..\..\Driver\Source -I..\..\..\Driver\Include -I..\..\..\ThirdParty\FATFS\src -I..\..\..\ThirdParty\emWin\Config -I..\..\..\ThirdParty\emWin\Include -I..\..\FreeRTOS_with_emwin -I..\tslib -I..\Application -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\portable\RVDS\ARM9_N9H30 -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Demo\Common\include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Toshiba -D__UVISION_VERSION=526 -D_PANEL_E50A2V1_16BPP_ --omf_browse=.\obj\main.crf ..\main.c]
                          ARM

                          AREA ||i.LCD_initial||, CODE, READONLY, ALIGN=2

                  LCD_initial PROC
;;;96     
;;;97     void LCD_initial(void)
000000  e92d4008          PUSH     {r3,lr}
;;;98     {
;;;99         // Configure multi-function pin for LCD interface
;;;100        //GPG6 (CLK), GPG7 (HSYNC)
;;;101        outpw(REG_SYS_GPG_MFPL, (inpw(REG_SYS_GPG_MFPL)& ~0xFF000000) | 0x22000000);
000004  e3a0020b          MOV      r0,#0xb0000000
000008  e59010a0          LDR      r1,[r0,#0xa0]
00000c  e3c114ff          BIC      r1,r1,#0xff000000
000010  e3811422          ORR      r1,r1,#0x22000000
000014  e58010a0          STR      r1,[r0,#0xa0]
;;;102        //GPG8 (VSYNC), GPG9 (DEN)
;;;103        outpw(REG_SYS_GPG_MFPH, (inpw(REG_SYS_GPG_MFPH)& ~0xFF) | 0x22);
000018  e59010a4          LDR      r1,[r0,#0xa4]
00001c  e3c110ff          BIC      r1,r1,#0xff
000020  e3811022          ORR      r1,r1,#0x22
000024  e58010a4          STR      r1,[r0,#0xa4]
;;;104    
;;;105        //DATA pin
;;;106        //GPA0 ~ GPA7 (DATA0~7)
;;;107        outpw(REG_SYS_GPA_MFPL, 0x22222222);
000028  e59f1088          LDR      r1,|L1.184|
00002c  e5801070          STR      r1,[r0,#0x70]
;;;108        //GPA8 ~ GPA15 (DATA8~15)
;;;109        outpw(REG_SYS_GPA_MFPH, 0x22222222);
000030  e5801074          STR      r1,[r0,#0x74]
;;;110    #ifdef _PANEL_FW070TFT_24BPP_
;;;111        //GPD8 ~ GPD15 (DATA16~23)
;;;112        outpw(REG_SYS_GPD_MFPH, 0x22222222);
;;;113    #endif
;;;114    
;;;115    #ifdef _PANEL_E50A2V1_16BPP_
;;;116        // LCD clock is selected from UPLL and divide to 20MHz
;;;117        outpw(REG_CLK_DIVCTL1, (inpw(REG_CLK_DIVCTL1) & ~0xff1f) | 0xe18);
000034  e5901224          LDR      r1,[r0,#0x224]
000038  e3c11cff          BIC      r1,r1,#0xff00
00003c  e3c1101f          BIC      r1,r1,#0x1f
000040  e3811b03          ORR      r1,r1,#0xc00
000044  e3811f86          ORR      r1,r1,#0x218
000048  e5801224          STR      r1,[r0,#0x224]
;;;118    #endif
;;;119    #ifdef _PANEL_FW070TFT_24BPP_
;;;120        // LCD clock is selected from UPLL and divide to 30MHz
;;;121        outpw(REG_CLK_DIVCTL1, (inpw(REG_CLK_DIVCTL1) & ~0xff1f) | 0x918);
;;;122    #endif
;;;123    
;;;124    #ifdef _PANEL_E50A2V1_16BPP_
;;;125        // Init LCD interface for E50A2V1 LCD module
;;;126        vpostLCMInit(DIS_PANEL_E50A2V1);
00004c  e3a00000          MOV      r0,#0
000050  ebfffffe          BL       vpostLCMInit
;;;127    #endif
;;;128    #ifdef _PANEL_FW070TFT_24BPP_
;;;129        // Init LCD interface for FW070TFT LCD module
;;;130        vpostLCMInit(DIS_PANEL_FW070TFT);
;;;131    #endif
;;;132        // Set scale to 1:1
;;;133        vpostVAScalingCtrl(1, 0, 1, 0, VA_SCALE_INTERPOLATION);
000054  e3a00000          MOV      r0,#0
000058  e1a03000          MOV      r3,r0
00005c  e3a02001          MOV      r2,#1
000060  e1a01000          MOV      r1,r0
000064  e58d0000          STR      r0,[sp,#0]
000068  e1a00002          MOV      r0,r2
00006c  ebfffffe          BL       vpostVAScalingCtrl
;;;134    
;;;135        // Set display color depth
;;;136    #ifdef _PANEL_E50A2V1_16BPP_
;;;137        vpostSetVASrc(VA_SRC_RGB565);
000070  e3a00b01          MOV      r0,#0x400
000074  ebfffffe          BL       vpostSetVASrc
;;;138    #endif
;;;139    #ifdef _PANEL_FW070TFT_24BPP_
;;;140        vpostSetVASrc(VA_SRC_RGB888);
;;;141    #endif
;;;142    
;;;143        // Get pointer of video frame buffer
;;;144        // Note: before get pointer of frame buffer, must set display color depth first
;;;145        g_VAFrameBuf = vpostGetFrameBuffer();
000078  ebfffffe          BL       vpostGetFrameBuffer
00007c  e59f1038          LDR      r1,|L1.188|
;;;146        if(g_VAFrameBuf == NULL)
000080  e3500000          CMP      r0,#0
000084  e5810018          STR      r0,[r1,#0x18]         ;145  ; g_VAFrameBuf
000088  0a000004          BEQ      |L1.160|
;;;147        {
;;;148            sysprintf("Get buffer error !!\n");
;;;149            while(1);
;;;150        }
;;;151    
;;;152        if((UINT32)g_VAFrameBuf == BIT31)
00008c  e3500102          CMP      r0,#0x80000000
000090  0a000005          BEQ      |L1.172|
;;;153        {
;;;154            sysprintf("Get buffer error !!\n");
;;;155            while(1);
;;;156        }
;;;157    
;;;158    #ifdef _PANEL_E50A2V1_16BPP_
;;;159        memset((void *)g_VAFrameBuf, 0, LCD_XSIZE*LCD_YSIZE*2);
000094  e8bd4008          POP      {r3,lr}
000098  e59f1020          LDR      r1,|L1.192|
00009c  eafffffe          B        __aeabi_memclr
                  |L1.160|
0000a0  e28f001c          ADR      r0,|L1.196|
0000a4  ebfffffe          BL       sysprintf
                  |L1.168|
0000a8  eafffffe          B        |L1.168|
                  |L1.172|
0000ac  e28f0010          ADR      r0,|L1.196|
0000b0  ebfffffe          BL       sysprintf
                  |L1.180|
0000b4  eafffffe          B        |L1.180|
;;;160    #endif
;;;161    #ifdef _PANEL_FW070TFT_24BPP_
;;;162        memset((void *)g_VAFrameBuf, 0, LCD_XSIZE*LCD_YSIZE*4);
;;;163    #endif
;;;164    
;;;165        // Start video
;;;166        //vpostVAStartTrigger();
;;;167    }
;;;168    
                          ENDP

                  |L1.184|
                          DCD      0x22222222
                  |L1.188|
                          DCD      ||.data||
                  |L1.192|
                          DCD      0x000bb800
                  |L1.196|
0000c4  47657420          DCB      "Get buffer error !!\n",0
0000c8  62756666
0000cc  65722065
0000d0  72726f72
0000d4  2021210a
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0

                          AREA ||i.MainTask||, CODE, READONLY, ALIGN=2

                  MainTask PROC
;;;387    WM_HWIN CreateFramewin(void);
;;;388    void MainTask(void)
000000  e24dd028          SUB      sp,sp,#0x28
;;;389    {
;;;390        WM_HWIN hWin;
;;;391        char     acVersion[40] = "Framewin: Version of emWin: ";
000004  e59f103c          LDR      r1,|L2.72|
000008  e3a02028          MOV      r2,#0x28
00000c  e1a0000d          MOV      r0,sp
000010  ebfffffe          BL       __aeabi_memcpy4
;;;392    //	static uint32_t cnt = 0;
;;;393    
;;;394        GUI_Init();
000014  ebfffffe          BL       GUI_Init
;;;395        hWin = CreateFramewin();
000018  ebfffffe          BL       CreateFramewin
00001c  e1a04000          MOV      r4,r0
;;;396        strcat(acVersion, GUI_GetVersionString());
000020  ebfffffe          BL       GUI_GetVersionString
000024  e1a01000          MOV      r1,r0
000028  e1a0000d          MOV      r0,sp
00002c  ebfffffe          BL       strcat
;;;397        FRAMEWIN_SetText(hWin, acVersion);
000030  e1a0100d          MOV      r1,sp
000034  e1a00004          MOV      r0,r4
000038  ebfffffe          BL       FRAMEWIN_SetText
                  |L2.60|
;;;398    
;;;399        while (1)
;;;400        {
;;;401    		//Below API both work
;;;402            GUI_Delay(100);
00003c  e3a00064          MOV      r0,#0x64
000040  ebfffffe          BL       GUI_Delay
000044  eafffffc          B        |L2.60|
;;;403    //		GUI_Exec();
;;;404    
;;;405    //		sysprintf("MainTask:%d (%4d)\r\n" ,eTaskGetState(xTaskemWinHandle),cnt++);
;;;406    
;;;407        }
;;;408    }
;;;409    
                          ENDP

                  |L2.72|
                          DCD      ||.constdata||

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;307    
;;;308    void SYS_Init(void)
000000  e12fff1e          BX       lr
;;;309    {
;;;310    #ifdef __USE_SD__
;;;311        /* enable SDH */
;;;312        outpw(REG_CLK_HCLKEN, inpw(REG_CLK_HCLKEN) | 0x40000000);
;;;313    
;;;314        /* select multi-function-pin */
;;;315        /* SD Port 0 -> PD0~7 */
;;;316        outpw(REG_SYS_GPD_MFPL, 0x66666666);
;;;317        SD_Drv = 0;
;;;318    #endif
;;;319    
;;;320    #if 0 // port 1
;;;321        /* initial SD1 pin -> PI5~10, 12~13 */
;;;322        outpw(REG_SYS_GPI_MFPL, inpw(REG_SYS_GPI_MFPL) & ~0xfff00000 | 0x44400000);
;;;323        outpw(REG_SYS_GPI_MFPH, inpw(REG_SYS_GPI_MFPH) & ~0x00ff0fff | 0x00440444);
;;;324        SD_Drv = 1;
;;;325    #endif
;;;326    
;;;327    }
;;;328    
                          ENDP


                          AREA ||i.TMR0_IRQHandler_TouchTask||, CODE, READONLY, ALIGN=2

                  TMR0_IRQHandler_TouchTask PROC
;;;176    
;;;177    void TMR0_IRQHandler_TouchTask(void)
000000  e59f000c          LDR      r0,|L4.20|
;;;178    {
;;;179        //sysprintf("g_enable_Touch=%d\n", g_enable_Touch);
;;;180        if ( g_enable_Touch == 1 )
000004  e5900020          LDR      r0,[r0,#0x20]  ; g_enable_Touch
000008  e3500001          CMP      r0,#1
;;;181        {
;;;182            //sysprintf("enable_Touch=%d\n", g_enable_Touch);
;;;183            TouchTask();
;;;184        }
;;;185    }
00000c  112fff1e          BXNE     lr
000010  eafffffe          B        TouchTask
;;;186    
                          ENDP

                  |L4.20|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;545    
;;;546    int main(void)
000000  e92d401c          PUSH     {r2-r4,lr}
;;;547    {
;;;548    	prvSetupHardware();
000004  ebfffffe          BL       prvSetupHardware
;;;549    
;;;550        xTaskCreate( vTaskemWin, "emWin", configMINIMAL_STACK_SIZE*8 , NULL, setMEDIUM_PRIORITY, &xTaskemWinHandle );
000008  e59f0084          LDR      r0,|L5.148|
00000c  e3a04002          MOV      r4,#2
000010  e58d0004          STR      r0,[sp,#4]
000014  e59f0084          LDR      r0,|L5.160|
000018  e3a03000          MOV      r3,#0
00001c  e3a02a02          MOV      r2,#0x2000
000020  e28f1070          ADR      r1,|L5.152|
000024  e58d4000          STR      r4,[sp,#0]
000028  ebfffffe          BL       xTaskCreate
;;;551        xTaskCreate( vTaskLogMsg1s, "LogMsg1s", configMINIMAL_STACK_SIZE , NULL, setMEDIUM_PRIORITY, &xTaskLogMsg1sHandle );
00002c  e59f0070          LDR      r0,|L5.164|
000030  e3a03000          MOV      r3,#0
000034  e58d0004          STR      r0,[sp,#4]
000038  e59f0074          LDR      r0,|L5.180|
00003c  e3a02b01          MOV      r2,#0x400
000040  e28f1060          ADR      r1,|L5.168|
000044  e58d4000          STR      r4,[sp,#0]
000048  ebfffffe          BL       xTaskCreate
;;;552        xTaskCreate( vTaskLogMsg5s, "LogMsg5s", configMINIMAL_STACK_SIZE , NULL, setMEDIUM_PRIORITY, &xTaskLogMsg5sHandle );
00004c  e59f0064          LDR      r0,|L5.184|
000050  e3a03000          MOV      r3,#0
000054  e58d0004          STR      r0,[sp,#4]
000058  e59f0068          LDR      r0,|L5.200|
00005c  e3a02b01          MOV      r2,#0x400
000060  e28f1054          ADR      r1,|L5.188|
000064  e58d4000          STR      r4,[sp,#0]
000068  ebfffffe          BL       xTaskCreate
;;;553        xTaskCreate( vTaskLogMsg500ms, "LogMsg500ms", configMINIMAL_STACK_SIZE , NULL, setMEDIUM_PRIORITY, NULL );
00006c  e3a00000          MOV      r0,#0
000070  e1a03000          MOV      r3,r0
000074  e58d0004          STR      r0,[sp,#4]
000078  e59f0058          LDR      r0,|L5.216|
00007c  e3a02b01          MOV      r2,#0x400
000080  e28f1044          ADR      r1,|L5.204|
000084  e58d4000          STR      r4,[sp,#0]
000088  ebfffffe          BL       xTaskCreate
;;;554    	
;;;555        vTaskStartScheduler();
00008c  ebfffffe          BL       vTaskStartScheduler
                  |L5.144|
;;;556    
;;;557        for( ;; );
000090  eafffffe          B        |L5.144|
;;;558    	
;;;559    //    return 0;
;;;560    }
                          ENDP

                  |L5.148|
                          DCD      ||.data||+0xc
                  |L5.152|
000098  656d5769          DCB      "emWin",0
00009c  6e00    
00009e  00                DCB      0
00009f  00                DCB      0
                  |L5.160|
                          DCD      vTaskemWin
                  |L5.164|
                          DCD      ||.data||+0x10
                  |L5.168|
0000a8  4c6f674d          DCB      "LogMsg1s",0
0000ac  73673173
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L5.180|
                          DCD      vTaskLogMsg1s
                  |L5.184|
                          DCD      ||.data||+0x14
                  |L5.188|
0000bc  4c6f674d          DCB      "LogMsg5s",0
0000c0  73673573
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L5.200|
                          DCD      vTaskLogMsg5s
                  |L5.204|
0000cc  4c6f674d          DCB      "LogMsg500ms",0
0000d0  73673530
0000d4  306d7300
                  |L5.216|
                          DCD      vTaskLogMsg500ms

                          AREA ||i.prvSetupHardware||, CODE, READONLY, ALIGN=2

                  prvSetupHardware PROC
;;;410    
;;;411    void prvSetupHardware( void )
000000  e59f0134          LDR      r0,|L6.316|
;;;412    {
000004  e92d4010          PUSH     {r4,lr}
;;;413        /* Perform the hardware setup required.  This is minimal as most of the
;;;414        setup is managed by the settings in the project file. */
;;;415    
;;;416    #ifdef __USE_SD__
;;;417        FRESULT     res;
;;;418    #else
;;;419        uint16_t u16ID;
;;;420    #endif
;;;421    
;;;422        *((volatile unsigned int *)REG_AIC_MDCR)=0xFFFFFFFF;  // disable all interrupt channel
000008  e3e01000          MVN      r1,#0
00000c  e5801138          STR      r1,[r0,#0x138]
;;;423        *((volatile unsigned int *)REG_AIC_MDCRH)=0xFFFFFFFF;  // disable all interrupt channel
000010  e580113c          STR      r1,[r0,#0x13c]
;;;424        *(volatile unsigned int *)(CLK_BA+0x18) |= (1<<16); /* Enable UART0 */
000014  e3a0020b          MOV      r0,#0xb0000000
000018  e5901218          LDR      r1,[r0,#0x218]
00001c  e3811801          ORR      r1,r1,#0x10000
000020  e5801218          STR      r1,[r0,#0x218]
;;;425        *(volatile unsigned int *)(CLK_BA+0x18) |= (1<<3); /* Enable GPIO */
000024  e5901218          LDR      r1,[r0,#0x218]
000028  e3811008          ORR      r1,r1,#8
00002c  e5801218          STR      r1,[r0,#0x218]
;;;426        sysDisableCache();
000030  ebfffffe          BL       sysDisableCache
;;;427        sysFlushCache(I_D_CACHE);
000034  e3a00008          MOV      r0,#8
000038  ebfffffe          BL       sysFlushCache
;;;428        sysEnableCache(CACHE_WRITE_BACK);
00003c  e3a00000          MOV      r0,#0
000040  ebfffffe          BL       sysEnableCache
;;;429        sysInitializeUART();
000044  ebfffffe          BL       sysInitializeUART
;;;430    
;;;431    #ifdef GUI_SUPPORT_TOUCH
;;;432        g_enable_Touch = 0;
000048  e59f40f0          LDR      r4,|L6.320|
00004c  e3a00000          MOV      r0,#0
000050  e5840020          STR      r0,[r4,#0x20]  ; g_enable_Touch
;;;433    #endif
;;;434    
;;;435    //    OS_TimeMS = 0;
;;;436    
;;;437        SYS_Init();
;;;438    
;;;439        sysSetTimerReferenceClock(TIMER0, 12000000);
000054  e59f10e8          LDR      r1,|L6.324|
000058  ebfffffe          BL       sysSetTimerReferenceClock
;;;440        sysStartTimer(TIMER0, 1000, PERIODIC_MODE);         /* 1000 ticks/per sec ==> 1tick/1ms */
00005c  e3a02001          MOV      r2,#1
000060  e3a01ffa          MOV      r1,#0x3e8
000064  e3a00000          MOV      r0,#0
000068  ebfffffe          BL       sysStartTimer
;;;441    //    sysSetTimerEvent(TIMER0,  1, (PVOID)TMR0_IRQHandler);           /*  1 tick  per call back */
;;;442        sysSetTimerEvent(TIMER0, 10, (PVOID)TMR0_IRQHandler_TouchTask); /* 10 ticks per call back */
00006c  e59f20d4          LDR      r2,|L6.328|
000070  e3a0100a          MOV      r1,#0xa
000074  e3a00000          MOV      r0,#0
000078  ebfffffe          BL       sysSetTimerEvent
;;;443    
;;;444    #ifdef __USE_SD__
;;;445        sysInstallISR(HIGH_LEVEL_SENSITIVE|IRQ_LEVEL_1, SDH_IRQn, (PVOID)SDH_IRQHandler);
;;;446        sysEnableInterrupt(SDH_IRQn);
;;;447    #endif
;;;448    
;;;449        sysSetLocalInterrupt(ENABLE_IRQ);
00007c  e3a0007f          MOV      r0,#0x7f
000080  ebfffffe          BL       sysSetLocalInterrupt
;;;450    
;;;451        sysprintf("+-------------------------------------------------+\n");
000084  e28f00c0          ADR      r0,|L6.332|
000088  ebfffffe          BL       sysprintf
;;;452        sysprintf("|                 Tslib Sample Code               |\n");
00008c  e28f00f0          ADR      r0,|L6.388|
000090  ebfffffe          BL       sysprintf
;;;453        sysprintf("+-------------------------------------------------+\n\n");
000094  e28f0e12          ADR      r0,|L6.444|
000098  ebfffffe          BL       sysprintf
;;;454        LCD_initial();
00009c  ebfffffe          BL       LCD_initial
;;;455    
;;;456    #ifdef GUI_SUPPORT_TOUCH
;;;457        Init_TouchPanel();
0000a0  ebfffffe          BL       Init_TouchPanel
;;;458    
;;;459    #ifdef __USE_SD__
;;;460        SD_SetReferenceClock(300000);
;;;461        SD_Open_Disk(SD_PORT0 | CardDetect_From_GPIO);
;;;462        if (gCardInit)
;;;463        {
;;;464            gCardInit = 0;
;;;465            SD_Open_Disk(SD_PORT0 | CardDetect_From_GPIO);
;;;466        }
;;;467    
;;;468        if(!(SD_CardDetection(SD_Drv)))
;;;469            while(1);
;;;470        sysprintf("rc=%d\n", (WORD)disk_initialize(0));
;;;471        disk_read(0, Buff, 2, 1);
;;;472        f_mount(&FatFs[0], "", 0);  // for FATFS v0.11
;;;473    #endif
;;;474    
;;;475        GUI_Init();
0000a4  ebfffffe          BL       GUI_Init
;;;476    
;;;477    #ifdef __USE_SD__
;;;478        res = f_open(&hFile, "0:\\ts_calib", FA_OPEN_EXISTING | FA_READ);
;;;479        if (res)
;;;480        {
;;;481            // file does not exists, so do calibration
;;;482            res = f_open(&hFile, "0:\\ts_calib", FA_CREATE_ALWAYS | FA_WRITE);
;;;483            if ( res )
;;;484            {
;;;485                f_close(&hFile);
;;;486                GUI_DispStringAt("CANNOT create the calibration file.\nPlease insert a SD card then reboot.", 0, 0);
;;;487                while(1);
;;;488            }
;;;489    
;;;490            ts_calibrate(__DEMO_TS_WIDTH__, __DEMO_TS_HEIGHT__);
;;;491            //GUI_SetDrawMode(GUI_DRAWMODE_NORMAL);
;;;492            ts_writefile();
;;;493        }
;;;494        else
;;;495        {
;;;496            ts_readfile();
;;;497        }
;;;498        f_close(&hFile);
;;;499    #else
;;;500        _DemoSpiInit();
0000a8  ebfffffe          BL       _DemoSpiInit
;;;501    
;;;502        // check flash id
;;;503        if((u16ID = SpiFlash_ReadMidDid()) == 0xEF17)
0000ac  ebfffffe          BL       SpiFlash_ReadMidDid
0000b0  e2401cef          SUB      r1,r0,#0xef00
0000b4  e2511017          SUBS     r1,r1,#0x17
0000b8  0a00001c          BEQ      |L6.304|
;;;504            sysprintf("Flash found: W25Q128BV ...\n");
;;;505        else
;;;506            sysprintf("Flash ID, 0x%x\n", u16ID);
0000bc  e1a01000          MOV      r1,r0
0000c0  e28f0f4b          ADR      r0,|L6.500|
0000c4  ebfffffe          BL       sysprintf
                  |L6.200|
;;;507    
;;;508        SpiFlash_NormalRead(__DEMO_TSFILE_ADDR__, DestArray, 32);
0000c8  e59f1134          LDR      r1,|L6.516|
0000cc  e3a02020          MOV      r2,#0x20
0000d0  e3a00706          MOV      r0,#0x180000
0000d4  ebfffffe          BL       SpiFlash_NormalRead
;;;509        g_pu32Res = (uint32_t *)DestArray;
0000d8  e59f0124          LDR      r0,|L6.516|
;;;510        sysprintf("%x\n", g_pu32Res[7]);
0000dc  e584001c          STR      r0,[r4,#0x1c]  ; g_pu32Res
0000e0  e590101c          LDR      r1,[r0,#0x1c]
0000e4  e28f0f45          ADR      r0,|L6.512|
0000e8  ebfffffe          BL       sysprintf
;;;511        if (g_pu32Res[7] != 0x55AAA55A)
0000ec  e594001c          LDR      r0,[r4,#0x1c]  ; g_pu32Res
0000f0  e59f1110          LDR      r1,|L6.520|
0000f4  e590001c          LDR      r0,[r0,#0x1c]
0000f8  e1500001          CMP      r0,r1
0000fc  0a000050          BEQ      |L6.580|
;;;512        {
;;;513            ts_calibrate(XSIZE_PHYS, YSIZE_PHYS);
000100  e3a01e1e          MOV      r1,#0x1e0
000104  e3a00e32          MOV      r0,#0x320
000108  ebfffffe          BL       ts_calibrate
;;;514            //GUI_SetDrawMode(GUI_DRAWMODE_NORMAL);
;;;515            sysprintf("Sector Erase ...");
00010c  e28f00f8          ADR      r0,|L6.524|
000110  ebfffffe          BL       sysprintf
;;;516    
;;;517            /* Sector erase SPI flash */
;;;518            SpiFlash_SectorErase(__DEMO_TSFILE_ADDR__);
000114  e3a00706          MOV      r0,#0x180000
000118  ebfffffe          BL       SpiFlash_SectorErase
;;;519    
;;;520            /* Wait ready */
;;;521            SpiFlash_WaitReady();
00011c  ebfffffe          BL       SpiFlash_WaitReady
;;;522    
;;;523            ts_writefile();
000120  ebfffffe          BL       ts_writefile
;;;524            sysprintf("[OK]\n");
000124  e28f00f4          ADR      r0,|L6.544|
000128  ebfffffe          BL       sysprintf
00012c  ea000045          B        |L6.584|
                  |L6.304|
000130  e28f00f0          ADR      r0,|L6.552|
000134  ebfffffe          BL       sysprintf
000138  eaffffe2          B        |L6.200|
                  |L6.316|
                          DCD      0xb8002000
                  |L6.320|
                          DCD      ||.data||
                  |L6.324|
                          DCD      0x00b71b00
                  |L6.328|
                          DCD      TMR0_IRQHandler_TouchTask
                  |L6.332|
00014c  2b2d2d2d          DCB      "+-------------------------------------------------+\n",0
000150  2d2d2d2d
000154  2d2d2d2d
000158  2d2d2d2d
00015c  2d2d2d2d
000160  2d2d2d2d
000164  2d2d2d2d
000168  2d2d2d2d
00016c  2d2d2d2d
000170  2d2d2d2d
000174  2d2d2d2d
000178  2d2d2d2d
00017c  2d2d2b0a
000180  00      
000181  00                DCB      0
000182  00                DCB      0
000183  00                DCB      0
                  |L6.388|
000184  7c202020          DCB      "|                 Tslib Sample Code               |\n",0
000188  20202020
00018c  20202020
000190  20202020
000194  20205473
000198  6c696220
00019c  53616d70
0001a0  6c652043
0001a4  6f646520
0001a8  20202020
0001ac  20202020
0001b0  20202020
0001b4  20207c0a
0001b8  00      
0001b9  00                DCB      0
0001ba  00                DCB      0
0001bb  00                DCB      0
                  |L6.444|
0001bc  2b2d2d2d          DCB      "+-------------------------------------------------+\n\n"
0001c0  2d2d2d2d
0001c4  2d2d2d2d
0001c8  2d2d2d2d
0001cc  2d2d2d2d
0001d0  2d2d2d2d
0001d4  2d2d2d2d
0001d8  2d2d2d2d
0001dc  2d2d2d2d
0001e0  2d2d2d2d
0001e4  2d2d2d2d
0001e8  2d2d2d2d
0001ec  2d2d2b0a
0001f0  0a      
0001f1  00                DCB      0
0001f2  00                DCB      0
0001f3  00                DCB      0
                  |L6.500|
0001f4  466c6173          DCB      "Flash ID, 0x"
0001f8  68204944
0001fc  2c203078
                  |L6.512|
000200  25780a00          DCB      "%x\n",0
                  |L6.516|
                          DCD      ||.bss||
                  |L6.520|
                          DCD      0x55aaa55a
                  |L6.524|
00020c  53656374          DCB      "Sector Erase ...",0
000210  6f722045
000214  72617365
000218  202e2e2e
00021c  00      
00021d  00                DCB      0
00021e  00                DCB      0
00021f  00                DCB      0
                  |L6.544|
000220  5b4f4b5d          DCB      "[OK]\n",0
000224  0a00    
000226  00                DCB      0
000227  00                DCB      0
                  |L6.552|
000228  466c6173          DCB      "Flash found: W25Q128BV ...\n",0
00022c  6820666f
000230  756e643a
000234  20573235
000238  51313238
00023c  4256202e
000240  2e2e0a00
                  |L6.580|
;;;525        }
;;;526        else
;;;527            ts_readfile();
000244  ebfffffe          BL       ts_readfile
                  |L6.584|
;;;528    #endif
;;;529    
;;;530    //    ts_test(__DEMO_TS_WIDTH__, __DEMO_TS_HEIGHT__);
;;;531    
;;;532        g_enable_Touch = 1;
000248  e3a00001          MOV      r0,#1
00024c  e5840020          STR      r0,[r4,#0x20]  ; g_enable_Touch
;;;533    #endif
;;;534    
;;;535    }
000250  e8bd8010          POP      {r4,pc}
;;;536    
                          ENDP


                          AREA ||i.vTaskLogMsg1s||, CODE, READONLY, ALIGN=2

                  vTaskLogMsg1s PROC
;;;366    
;;;367    void vTaskLogMsg1s( void *pvParameters )
000000  e59f403c          LDR      r4,|L7.68|
;;;368    {	
000004  e92d4008          PUSH     {r3,lr}
;;;369    	static uint32_t Cnt_LogMsg = 0;
;;;370    	uint32_t millisec = 1000;
000008  e3a06ffa          MOV      r6,#0x3e8
                  |L7.12|
;;;371    
;;;372    //	portTickType xLastWakeTime;
;;;373    //	xLastWakeTime = xTaskGetTickCount();
;;;374    
;;;375    	(void) pvParameters;
;;;376    	for( ;; )
;;;377    	{
;;;378    //        vTaskDelayUntil( &xLastWakeTime, ( millisec *configTICK_RATE_HZ / ( ( TickType_t ) 1000 ) ));
;;;379    		GUI_X_Delay(millisec);		
00000c  e1a00006          MOV      r0,r6
000010  ebfffffe          BL       GUI_X_Delay
;;;380    		sysprintf("vTaskLogMsg1s:Log(%4dms):%4d (%4d bytes,%4d bytes)\r\n" ,millisec ,++Cnt_LogMsg,xPortGetFreeHeapSize(),GUI_ALLOC_GetNumFreeBytes());
000014  ebfffffe          BL       GUI_ALLOC_GetNumFreeBytes
000018  e1a05000          MOV      r5,r0
00001c  ebfffffe          BL       xPortGetFreeHeapSize
000020  e1a03000          MOV      r3,r0
000024  e58d5000          STR      r5,[sp,#0]
000028  e5940008          LDR      r0,[r4,#8]  ; Cnt_LogMsg
00002c  e1a01006          MOV      r1,r6
000030  e2802001          ADD      r2,r0,#1
000034  e28f000c          ADR      r0,|L7.72|
000038  e5842008          STR      r2,[r4,#8]  ; Cnt_LogMsg
00003c  ebfffffe          BL       sysprintf
000040  eafffff1          B        |L7.12|
;;;381    
;;;382    	}
;;;383      
;;;384    }
;;;385    
                          ENDP

                  |L7.68|
                          DCD      ||.data||
                  |L7.72|
000048  76546173          DCB      "vTaskLogMsg1s:Log(%4dms):%4d (%4d bytes,%4d bytes)\r\n",0
00004c  6b4c6f67
000050  4d736731
000054  733a4c6f
000058  67282534
00005c  646d7329
000060  3a253464
000064  20282534
000068  64206279
00006c  7465732c
000070  25346420
000074  62797465
000078  73290d0a
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.vTaskLogMsg500ms||, CODE, READONLY, ALIGN=2

                  vTaskLogMsg500ms PROC
;;;328    
;;;329    void vTaskLogMsg500ms( void *pvParameters )
000000  e59f403c          LDR      r4,|L8.68|
;;;330    {	
000004  e92d4008          PUSH     {r3,lr}
;;;331    	static uint32_t Cnt_LogMsg = 0;
;;;332    	uint32_t millisec = 500;
000008  e3a06f7d          MOV      r6,#0x1f4
                  |L8.12|
;;;333    
;;;334    //	portTickType xLastWakeTime;
;;;335    //	xLastWakeTime = xTaskGetTickCount();
;;;336    
;;;337    	(void) pvParameters;
;;;338    	for( ;; )
;;;339    	{
;;;340    //        vTaskDelayUntil( &xLastWakeTime, ( millisec *configTICK_RATE_HZ / ( ( TickType_t ) 1000 ) ));
;;;341    		GUI_X_Delay(millisec);			
00000c  e1a00006          MOV      r0,r6
000010  ebfffffe          BL       GUI_X_Delay
;;;342    		sysprintf("vTaskLogMsg500ms:Log(%4dms):%4d (%4d bytes,%4d bytes)\r\n" ,millisec ,++Cnt_LogMsg,xPortGetFreeHeapSize(),GUI_ALLOC_GetNumFreeBytes());
000014  ebfffffe          BL       GUI_ALLOC_GetNumFreeBytes
000018  e1a05000          MOV      r5,r0
00001c  ebfffffe          BL       xPortGetFreeHeapSize
000020  e1a03000          MOV      r3,r0
000024  e58d5000          STR      r5,[sp,#0]
000028  e5940000          LDR      r0,[r4,#0]  ; Cnt_LogMsg
00002c  e1a01006          MOV      r1,r6
000030  e2802001          ADD      r2,r0,#1
000034  e28f000c          ADR      r0,|L8.72|
000038  e5842000          STR      r2,[r4,#0]  ; Cnt_LogMsg
00003c  ebfffffe          BL       sysprintf
000040  eafffff1          B        |L8.12|
;;;343    
;;;344    	}
;;;345      
;;;346    }
;;;347    
                          ENDP

                  |L8.68|
                          DCD      ||.data||
                  |L8.72|
000048  76546173          DCB      "vTaskLogMsg500ms:Log(%4dms):%4d (%4d bytes,%4d bytes)\r"
00004c  6b4c6f67
000050  4d736735
000054  30306d73
000058  3a4c6f67
00005c  28253464
000060  6d73293a
000064  25346420
000068  28253464
00006c  20627974
000070  65732c25
000074  34642062
000078  79746573
00007c  290d    
00007e  0a00              DCB      "\n",0

                          AREA ||i.vTaskLogMsg5s||, CODE, READONLY, ALIGN=2

                  vTaskLogMsg5s PROC
;;;347    
;;;348    void vTaskLogMsg5s( void *pvParameters )
000000  e59f603c          LDR      r6,|L9.68|
;;;349    {	
;;;350    	static uint32_t Cnt_LogMsg = 0;
;;;351    	uint32_t millisec = 5000;
;;;352    
;;;353    //	portTickType xLastWakeTime;
;;;354    //	xLastWakeTime = xTaskGetTickCount();
;;;355    
;;;356    	(void) pvParameters;
;;;357    	for( ;; )
;;;358    	{
;;;359    //        vTaskDelayUntil( &xLastWakeTime, ( millisec *configTICK_RATE_HZ / ( ( TickType_t ) 1000 ) ));
;;;360    		GUI_X_Delay(millisec);			
;;;361    		sysprintf("vTaskLogMsg5s:Log(%4dms):%4d (%4d bytes,%4d bytes)\r\n" ,millisec ,++Cnt_LogMsg,xPortGetFreeHeapSize(),GUI_ALLOC_GetNumFreeBytes());
000004  e59f403c          LDR      r4,|L9.72|
000008  e92d4008          PUSH     {r3,lr}               ;349
                  |L9.12|
00000c  e1a00006          MOV      r0,r6                 ;360
000010  ebfffffe          BL       GUI_X_Delay
000014  ebfffffe          BL       GUI_ALLOC_GetNumFreeBytes
000018  e1a05000          MOV      r5,r0
00001c  ebfffffe          BL       xPortGetFreeHeapSize
000020  e1a03000          MOV      r3,r0
000024  e58d5000          STR      r5,[sp,#0]
000028  e5940004          LDR      r0,[r4,#4]  ; Cnt_LogMsg
00002c  e1a01006          MOV      r1,r6
000030  e2802001          ADD      r2,r0,#1
000034  e28f0010          ADR      r0,|L9.76|
000038  e5842004          STR      r2,[r4,#4]  ; Cnt_LogMsg
00003c  ebfffffe          BL       sysprintf
000040  eafffff1          B        |L9.12|
;;;362    
;;;363    	}
;;;364      
;;;365    }
;;;366    
                          ENDP

                  |L9.68|
                          DCD      0x00001388
                  |L9.72|
                          DCD      ||.data||
                  |L9.76|
00004c  76546173          DCB      "vTaskLogMsg5s:Log(%4dms):%4d (%4d bytes,%4d bytes)\r\n",0
000050  6b4c6f67
000054  4d736735
000058  733a4c6f
00005c  67282534
000060  646d7329
000064  3a253464
000068  20282534
00006c  64206279
000070  7465732c
000074  25346420
000078  62797465
00007c  73290d0a
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0

                          AREA ||i.vTaskemWin||, CODE, READONLY, ALIGN=2

                  vTaskemWin PROC
;;;536    
;;;537    void vTaskemWin( void *pvParameters )
000000  ebfffffe          BL       MainTask
;;;538    {
;;;539    
;;;540        /* Parameters are not used. */
;;;541        ( void ) pvParameters;
;;;542    	MainTask();
;;;543    	
;;;544    }
;;;545    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  DestArray
                          %        1024

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  4672616d          DCB      0x46,0x72,0x61,0x6d
000004  6577696e          DCB      0x65,0x77,0x69,0x6e
000008  3a205665          DCB      0x3a,0x20,0x56,0x65
00000c  7273696f          DCB      0x72,0x73,0x69,0x6f
000010  6e206f66          DCB      0x6e,0x20,0x6f,0x66
000014  20656d57          DCB      0x20,0x65,0x6d,0x57
000018  696e3a20          DCB      0x69,0x6e,0x3a,0x20
00001c  00000000          DCB      0x00,0x00,0x00,0x00
                          %        8

                          AREA ||.data||, DATA, ALIGN=2

                  Cnt_LogMsg
                          DCD      0x00000000
                  |symbol_number.36|
                          DCD      0x00000000
                  |symbol_number.37|
                          DCD      0x00000000
                  xTaskemWinHandle
                          DCD      0x00000000
                  xTaskLogMsg1sHandle
                          DCD      0x00000000
                  xTaskLogMsg5sHandle
                          DCD      0x00000000
                  g_VAFrameBuf
                          DCD      0x00000000
                  g_pu32Res
                          DCD      0x00000000
                  g_enable_Touch
                          DCD      0x00000000

                  __ARM_use_no_argv EQU 0
