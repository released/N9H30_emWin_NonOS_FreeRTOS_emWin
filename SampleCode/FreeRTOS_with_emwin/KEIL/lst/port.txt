; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\port.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\port.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931 -I..\..\..\Driver\Source -I..\..\..\Driver\Include -I..\..\..\ThirdParty\FATFS\src -I..\..\..\ThirdParty\emWin\Config -I..\..\..\ThirdParty\emWin\Include -I..\..\FreeRTOS_with_emwin -I..\tslib -I..\Application -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\portable\RVDS\ARM9_N9H30 -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Demo\Common\include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Toshiba -D__UVISION_VERSION=526 -D_PANEL_E50A2V1_16BPP_ --omf_browse=.\obj\port.crf ..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\portable\RVDS\ARM9_N9H30\port.c]
                          ARM

                          AREA ||i.pxPortInitialiseStack||, CODE, READONLY, ALIGN=2

                  pxPortInitialiseStack PROC
;;;114     */
;;;115    StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
000000  e281c004          ADD      r12,r1,#4
;;;116    {
;;;117    StackType_t *pxOriginalTOS;
;;;118    
;;;119    	/* Setup the initial stack of the task.  The stack is set exactly as 
;;;120    	expected by the portRESTORE_CONTEXT() macro.
;;;121    
;;;122    	Remember where the top of the (simulated) stack is before we place 
;;;123    	anything on it. */
;;;124    	pxOriginalTOS = pxTopOfStack;
;;;125    	
;;;126    	/* To ensure asserts in tasks.c don't fail, although in this case the assert
;;;127    	is not really required. */
;;;128    	pxTopOfStack--;
;;;129    
;;;130    	/* First on the stack is the return address - which in this case is the
;;;131    	start of the task.  The offset is added to make the return address appear
;;;132    	as it would within an IRQ ISR. */
;;;133    	*pxTopOfStack = ( StackType_t ) pxCode + portINSTRUCTION_SIZE;		
000004  e500c004          STR      r12,[r0,#-4]
;;;134    	pxTopOfStack--;
;;;135    
;;;136    	*pxTopOfStack = ( StackType_t ) 0xaaaaaaaa;	/* R14 */
000008  e59fc088          LDR      r12,|L1.152|
;;;137    	pxTopOfStack--;	
;;;138    	*pxTopOfStack = ( StackType_t ) pxOriginalTOS; /* Stack used when task starts goes in R13. */
;;;139    	pxTopOfStack--;
;;;140    	*pxTopOfStack = ( StackType_t ) 0x12121212;	/* R12 */
;;;141    	pxTopOfStack--;	
;;;142    	*pxTopOfStack = ( StackType_t ) 0x11111111;	/* R11 */
;;;143    	pxTopOfStack--;	
;;;144    	*pxTopOfStack = ( StackType_t ) 0x10101010;	/* R10 */
;;;145    	pxTopOfStack--;	
;;;146    	*pxTopOfStack = ( StackType_t ) 0x09090909;	/* R9 */
;;;147    	pxTopOfStack--;	
;;;148    	*pxTopOfStack = ( StackType_t ) 0x08080808;	/* R8 */
;;;149    	pxTopOfStack--;	
;;;150    	*pxTopOfStack = ( StackType_t ) 0x07070707;	/* R7 */
;;;151    	pxTopOfStack--;	
;;;152    	*pxTopOfStack = ( StackType_t ) 0x06060606;	/* R6 */
;;;153    	pxTopOfStack--;	
;;;154    	*pxTopOfStack = ( StackType_t ) 0x05050505;	/* R5 */
;;;155    	pxTopOfStack--;	
;;;156    	*pxTopOfStack = ( StackType_t ) 0x04040404;	/* R4 */
;;;157    	pxTopOfStack--;	
;;;158    	*pxTopOfStack = ( StackType_t ) 0x03030303;	/* R3 */
;;;159    	pxTopOfStack--;	
;;;160    	*pxTopOfStack = ( StackType_t ) 0x02020202;	/* R2 */
;;;161    	pxTopOfStack--;	
;;;162    	*pxTopOfStack = ( StackType_t ) 0x01010101;	/* R1 */
;;;163    	pxTopOfStack--;	
;;;164    	*pxTopOfStack = ( StackType_t ) pvParameters; /* R0 */
;;;165    	pxTopOfStack--;
;;;166    
;;;167    	/* The last thing onto the stack is the status register, which is set for
;;;168    	system mode, with interrupts enabled. */
;;;169    	*pxTopOfStack = ( StackType_t ) portINITIAL_SPSR;
;;;170    
;;;171    	if( ( ( uint32_t ) pxCode & 0x01UL ) != 0x00UL )
00000c  e3110001          TST      r1,#1
000010  e500c008          STR      r12,[r0,#-8]          ;138
000014  e59fc080          LDR      r12,|L1.156|
000018  e500000c          STR      r0,[r0,#-0xc]         ;138
00001c  e500c010          STR      r12,[r0,#-0x10]       ;140
000020  e59fc078          LDR      r12,|L1.160|
;;;172    	{
;;;173    		/* We want the task to start in thumb mode. */
;;;174    		*pxTopOfStack |= portTHUMB_MODE_BIT;
000024  13a0103f          MOVNE    r1,#0x3f
000028  e500c014          STR      r12,[r0,#-0x14]       ;142
00002c  e59fc070          LDR      r12,|L1.164|
000030  e500c018          STR      r12,[r0,#-0x18]       ;144
000034  e59fc06c          LDR      r12,|L1.168|
000038  e500c01c          STR      r12,[r0,#-0x1c]       ;146
00003c  e1ccc1cc          BIC      r12,r12,r12,ASR #3    ;148
000040  e500c020          STR      r12,[r0,#-0x20]       ;148
000044  e04cc1cc          SUB      r12,r12,r12,ASR #3    ;150
000048  e500c024          STR      r12,[r0,#-0x24]       ;150
00004c  e1ccc14c          BIC      r12,r12,r12,ASR #2    ;152
000050  e500c028          STR      r12,[r0,#-0x28]       ;152
000054  e02cc0cc          EOR      r12,r12,r12,ASR #1    ;154
000058  e500c02c          STR      r12,[r0,#-0x2c]       ;154
00005c  e1ccc14c          BIC      r12,r12,r12,ASR #2    ;156
000060  e500c030          STR      r12,[r0,#-0x30]       ;156
000064  e04cc14c          SUB      r12,r12,r12,ASR #2    ;158
000068  e500c034          STR      r12,[r0,#-0x34]       ;158
00006c  e1ccc0cc          BIC      r12,r12,r12,ASR #1    ;160
000070  e500c038          STR      r12,[r0,#-0x38]       ;160
000074  e5002040          STR      r2,[r0,#-0x40]        ;164
000078  e1a0c0cc          ASR      r12,r12,#1            ;162
00007c  e3a0201f          MOV      r2,#0x1f              ;169
000080  e500c03c          STR      r12,[r0,#-0x3c]       ;164
000084  e5202044          STR      r2,[r0,#-0x44]!       ;171
000088  15801000          STRNE    r1,[r0,#0]
;;;175    	}
;;;176    
;;;177    	pxTopOfStack--;
;;;178    
;;;179    	/* The code generated by the Keil compiler does not maintain separate
;;;180    	stack and frame pointers. The portENTER_CRITICAL macro cannot therefore
;;;181    	use the stack as per other ports.  Instead a variable is used to keep
;;;182    	track of the critical section nesting.  This variable has to be stored
;;;183    	as part of the task context and is initially set to zero. */
;;;184    	*pxTopOfStack = portNO_CRITICAL_SECTION_NESTING;
00008c  e3a01000          MOV      r1,#0
000090  e5201004          STR      r1,[r0,#-4]!
;;;185    
;;;186    	return pxTopOfStack;
;;;187    }
000094  e12fff1e          BX       lr
;;;188    /*-----------------------------------------------------------*/
                          ENDP

                  |L1.152|
                          DCD      0xaaaaaaaa
                  |L1.156|
                          DCD      0x12121212
                  |L1.160|
                          DCD      0x11111111
                  |L1.164|
                          DCD      0x10101010
                  |L1.168|
                          DCD      0x09090909

                          AREA ||i.systemIrqHandler||, CODE, READONLY, ALIGN=2

                  systemIrqHandler PROC
;;;212    /* Interrupt Handler */
;;;213    void systemIrqHandler(UINT32 _mIPER, UINT32 _mISNR)
000000  e1a00c00          LSL      r0,r0,#24
;;;214    {		
000004  e92d4010          PUSH     {r4,lr}
;;;215        _mIPER = (_mIPER >> 2) & 0x3f;
;;;216    		
;;;217        if (_mISNR != 0)
000008  e3510000          CMP      r1,#0
00000c  e1a00d20          LSR      r0,r0,#26             ;215
000010  0a000003          BEQ      |L2.36|
;;;218            if (_mIPER == _mISNR)
000014  e1500001          CMP      r0,r1
;;;219                (*sysIrqHandlerTable[_mIPER])();
000018  059f1014          LDREQ    r1,|L2.52|
00001c  07910100          LDREQ    r0,[r1,r0,LSL #2]
000020  012fff30          BLXEQ    r0
                  |L2.36|
;;;220    		
;;;221        outpw(REG_AIC_EOSCR, 1);
000024  e3a00001          MOV      r0,#1
000028  e59f1008          LDR      r1,|L2.56|
00002c  e5810150          STR      r0,[r1,#0x150]
;;;222    }
000030  e8bd8010          POP      {r4,pc}
;;;223    
                          ENDP

                  |L2.52|
                          DCD      sysIrqHandlerTable
                  |L2.56|
                          DCD      0xb8002000

                          AREA ||i.vPortEndScheduler||, CODE, READONLY, ALIGN=2

                  vPortEndScheduler PROC
;;;203    
;;;204    void vPortEndScheduler( void )
000000  e12fff1e          BX       lr
;;;205    {
;;;206    	/* It is unlikely that the ARM port will require this function as there
;;;207    	is nothing to return to.  If this is required - stop the tick ISR then
;;;208    	return back to main. */
;;;209    }
;;;210    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vPortEnterCritical||, CODE, READONLY, ALIGN=2

                  vPortEnterCritical PROC
;;;314    
;;;315    void vPortEnterCritical( void )
000000  e10f0000          MRS      r0,APSR ; formerly CPSR
;;;316    {
;;;317    	/* Disable interrupts as per portDISABLE_INTERRUPTS(); 							*/
;;;318    	__disable_irq();
000004  e3800080          ORR      r0,r0,#0x80
000008  e121f000          MSR      CPSR_c,r0
;;;319    
;;;320    	/* Now interrupts are disabled ulCriticalNesting can be accessed 
;;;321    	directly.  Increment ulCriticalNesting to keep a count of how many times
;;;322    	portENTER_CRITICAL() has been called. */
;;;323    	ulCriticalNesting++;
00000c  e59f000c          LDR      r0,|L4.32|
000010  e5901000          LDR      r1,[r0,#0]  ; ulCriticalNesting
000014  e2811001          ADD      r1,r1,#1
000018  e5801000          STR      r1,[r0,#0]  ; ulCriticalNesting
;;;324    }
00001c  e12fff1e          BX       lr
;;;325    /*-----------------------------------------------------------*/
                          ENDP

                  |L4.32|
                          DCD      ||.data||

                          AREA ||i.vPortExitCritical||, CODE, READONLY, ALIGN=2

                  vPortExitCritical PROC
;;;326    
;;;327    void vPortExitCritical( void )
000000  e59f002c          LDR      r0,|L5.52|
;;;328    {
;;;329    	if( ulCriticalNesting > portNO_CRITICAL_NESTING )
000004  e5901000          LDR      r1,[r0,#0]  ; ulCriticalNesting
000008  e3510000          CMP      r1,#0
;;;330    	{
;;;331    		/* Decrement the nesting count as we are leaving a critical section. */
;;;332    		ulCriticalNesting--;
;;;333    
;;;334    		/* If the nesting level has reached zero then interrupts should be
;;;335    		re-enabled. */
;;;336    		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
;;;337    		{
;;;338    			/* Enable interrupts as per portEXIT_CRITICAL(). */
;;;339    			__enable_irq();
;;;340    		}
;;;341    	}
;;;342    }
00000c  012fff1e          BXEQ     lr
000010  e5901000          LDR      r1,[r0,#0]            ;332  ; ulCriticalNesting
000014  e2411001          SUB      r1,r1,#1              ;332
000018  e5801000          STR      r1,[r0,#0]            ;332  ; ulCriticalNesting
00001c  e5900000          LDR      r0,[r0,#0]            ;336  ; ulCriticalNesting
000020  e3500000          CMP      r0,#0                 ;336
000024  010f0000          MRSEQ    r0,APSR ; formerly CPSR;339
000028  03c00080          BICEQ    r0,r0,#0x80           ;339
00002c  0121f000          MSREQ    CPSR_c,r0             ;339
000030  e12fff1e          BX       lr
;;;343    /*-----------------------------------------------------------*/
                          ENDP

                  |L5.52|
                          DCD      ||.data||

                          AREA ||i.xPortStartScheduler||, CODE, READONLY, ALIGN=2

                  xPortStartScheduler PROC
;;;189    
;;;190    BaseType_t xPortStartScheduler( void )
000000  e92d4010          PUSH     {r4,lr}
;;;191    {
000004  e3a0020b          MOV      r0,#0xb0000000
000008  e5901218          LDR      r1,[r0,#0x218]
00000c  e3811c02          ORR      r1,r1,#0x200
000010  e5801218          STR      r1,[r0,#0x218]
000014  e5901064          LDR      r1,[r0,#0x64]
000018  e3811c02          ORR      r1,r1,#0x200
00001c  e5801064          STR      r1,[r0,#0x64]
000020  e5901064          LDR      r1,[r0,#0x64]
000024  e3c11c02          BIC      r1,r1,#0x200
000028  e5801064          STR      r1,[r0,#0x64]
00002c  e59f1044          LDR      r1,|L6.120|
000030  e59f403c          LDR      r4,|L6.116|
000034  e3a00001          MOV      r0,#1
000038  e5c10000          STRB     r0,[r1,#0]  ; _sys_bIsAICInitial
00003c  e59f0038          LDR      r0,|L6.124|
000040  ebfffffe          BL       sysInstallIrqHandler
000044  e3a00011          MOV      r0,#0x11
000048  ebfffffe          BL       sysEnableInterrupt
00004c  e59f002c          LDR      r0,|L6.128|
000050  e5804014          STR      r4,[r0,#0x14]
000054  e5901010          LDR      r1,[r0,#0x10]
000058  e3c1147e          BIC      r1,r1,#0x7e000000
00005c  e3c110ff          BIC      r1,r1,#0xff
000060  e381131a          ORR      r1,r1,#0x68000000
000064  e5801010          STR      r1,[r0,#0x10]
;;;192    	/* Start the timer that generates the tick ISR. */
;;;193    	prvSetupTimerInterrupt();
;;;194    
;;;195    	/* Start the first task.  This is done from portISR.c as ARM mode must be
;;;196    	used. */
;;;197    	vPortStartFirstTask();
000068  ebfffffe          BL       vPortStartFirstTask
;;;198    
;;;199    	/* Should not get here! */
;;;200    	return 0;
00006c  e3a00000          MOV      r0,#0
;;;201    }
000070  e8bd8010          POP      {r4,pc}
;;;202    /*-----------------------------------------------------------*/
                          ENDP

                  |L6.116|
                          DCD      0x00002ee0
                  |L6.120|
                          DCD      _sys_bIsAICInitial
                  |L6.124|
                          DCD      vPreemptiveTick
                  |L6.128|
                          DCD      0xb8001000

                          AREA ||.data||, DATA, ALIGN=2

                  ulCriticalNesting
                          DCD      0x0000270f
