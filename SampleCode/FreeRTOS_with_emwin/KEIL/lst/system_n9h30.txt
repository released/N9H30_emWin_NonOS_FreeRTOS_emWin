; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\system_n9h30.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\system_n9h30.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931 -I..\..\..\Driver\Source -I..\..\..\Driver\Include -I..\..\..\ThirdParty\FATFS\src -I..\..\..\ThirdParty\emWin\Config -I..\..\..\ThirdParty\emWin\Include -I..\..\FreeRTOS_with_emwin -I..\tslib -I..\Application -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\portable\RVDS\ARM9_N9H30 -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Demo\Common\include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Toshiba -D__UVISION_VERSION=526 -D_PANEL_E50A2V1_16BPP_ --omf_browse=.\obj\system_n9h30.crf ..\..\..\Driver\Source\system_N9H30.c]
                          ARM

                          AREA ||i._sysLockCode||, CODE, READONLY, ALIGN=2

                  _sysLockCode PROC
;;;394    
;;;395    INT32 _sysLockCode(UINT32 addr, INT32 size)
000000  ee192f30          MRC      p15,#0x0,r2,c9,c0,#1
;;;396    {
;;;397        int i, cnt, temp;
;;;398    
;;;399        __asm {
;;;400            /* use way3 to lock instructions */
;;;401            MRC p15, 0, temp, c9, c0, 1 ;
;;;402            ORR temp, temp, 0x07 ;
000004  e3822007          ORR      r2,r2,#7
;;;403            MCR p15, 0, temp, c9, c0, 1 ;
000008  ee092f30          MCR      p15,#0x0,r2,c9,c0,#1
;;;404        }
;;;405    
;;;406        if (size % 16)  cnt = (size/16) + 1;
00000c  e311000f          TST      r1,#0xf
000010  e1a02fc1          ASR      r2,r1,#31
000014  e0811e22          ADD      r1,r1,r2,LSR #28
000018  13a02001          MOVNE    r2,#1
00001c  10822241          ADDNE    r2,r2,r1,ASR #4
;;;407        else            cnt = size / 16;
000020  01a02241          ASREQ    r2,r1,#4
;;;408    
;;;409        for (i=0; i<cnt; i++) {
000024  e3a01000          MOV      r1,#0
                  |L1.40|
000028  e1510002          CMP      r1,r2
;;;410            __asm {
;;;411                MCR p15, 0, addr, c7, c13, 1;
00002c  be070f3d          MCRLT    p15,#0x0,r0,c7,c13,#1
000030  b2800010          ADDLT    r0,r0,#0x10
000034  b2811001          ADDLT    r1,r1,#1
;;;412            }
;;;413    
;;;414            addr += 16;
;;;415        }
;;;416    
;;;417    
;;;418        __asm {
;;;419            /* use way3 to lock instructions */
;;;420            MRC p15, 0, temp, c9, c0, 1 ;
000038  ae190f30          MRCGE    p15,#0x0,r0,c9,c0,#1
;;;421            BIC temp, temp, 0x07 ;
00003c  a3c00007          BICGE    r0,r0,#7
;;;422            ORR temp, temp, 0x08 ;
000040  a3800008          ORRGE    r0,r0,#8
;;;423            MCR p15, 0, temp, c9, c0, 1 ;
000044  ae090f30          MCRGE    p15,#0x0,r0,c9,c0,#1
;;;424        }
;;;425    
;;;426        return 0;
000048  a3a00000          MOVGE    r0,#0
00004c  bafffff5          BLT      |L1.40|
;;;427    
;;;428    }
000050  e12fff1e          BX       lr
;;;429    
                          ENDP


                          AREA ||i._sysUnLockCode||, CODE, READONLY, ALIGN=2

                  _sysUnLockCode PROC
;;;430    
;;;431    INT32 _sysUnLockCode()
000000  ee190f30          MRC      p15,#0x0,r0,c9,c0,#1
;;;432    {
;;;433        int temp;
;;;434    
;;;435        /* unlock I-cache way 3 */
;;;436        __asm {
;;;437            MRC p15, 0, temp, c9, c0, 1;
;;;438            BIC temp, temp, 0x08 ;
000004  e3c00008          BIC      r0,r0,#8
;;;439            MCR p15, 0, temp, c9, c0, 1;
000008  ee090f30          MCR      p15,#0x0,r0,c9,c0,#1
;;;440    
;;;441        }
;;;442    
;;;443        return 0;
00000c  e3a00000          MOV      r0,#0
;;;444    }
000010  e12fff1e          BX       lr
;;;445    
                          ENDP


                          AREA ||i.sysDisableCache||, CODE, READONLY, ALIGN=2

                  sysDisableCache PROC
;;;469     */
;;;470    void sysDisableCache(void)
000000  e92d4010          PUSH     {r4,lr}
;;;471    {
;;;472        int temp;
;;;473    
;;;474        sys_flush_and_clean_dcache();
000004  ebfffffe          BL       sys_flush_and_clean_dcache
;;;475        __asm {
;;;476            /*----- flush I, D cache & write buffer -----*/
;;;477            MOV temp, 0x0
000008  e3a00000          MOV      r0,#0
;;;478            MCR p15, 0, temp, c7, c5, 0 /* flush I cache */
00000c  ee070f15          MCR      p15,#0x0,r0,c7,c5,#0
;;;479            MCR p15, 0, temp, c7, c6, 0 /* flush D cache */
000010  ee070f16          MCR      p15,#0x0,r0,c7,c6,#0
;;;480            MCR p15, 0, temp, c7, c10,4 /* drain write buffer */
000014  ee070f9a          MCR      p15,#0x0,r0,c7,c10,#4
;;;481    
;;;482            /*----- disable Protection Unit -----*/
;;;483            MRC p15, 0, temp, c1, c0, 0     /* read Control register */
000018  ee110f10          MRC      p15,#0x0,r0,c1,c0,#0
;;;484            BIC temp, temp, 0x01
00001c  e3c00001          BIC      r0,r0,#1
;;;485            MCR p15, 0, temp, c1, c0, 0     /* write Control register */
000020  ee010f10          MCR      p15,#0x0,r0,c1,c0,#0
;;;486        }
;;;487        _sys_IsCacheOn = FALSE;
000024  e59f0010          LDR      r0,|L3.60|
000028  e3a01000          MOV      r1,#0
00002c  e5c01000          STRB     r1,[r0,#0]  ; _sys_IsCacheOn
;;;488        _sys_CacheMode = CACHE_DISABLE;
000030  e3e01000          MVN      r1,#0
000034  e5801008          STR      r1,[r0,#8]  ; _sys_CacheMode
;;;489    
;;;490    }
000038  e8bd8010          POP      {r4,pc}
;;;491    
                          ENDP

                  |L3.60|
                          DCD      ||.data||

                          AREA ||i.sysEnableCache||, CODE, READONLY, ALIGN=2

                  sysEnableCache PROC
;;;455     */
;;;456    INT32 sysEnableCache(UINT32 uCacheOpMode)
000000  e92d4010          PUSH     {r4,lr}
;;;457    {
000004  e1a04000          MOV      r4,r0
;;;458        sysInitMMUTable(uCacheOpMode);
000008  ebfffffe          BL       sysInitMMUTable
;;;459        _sys_IsCacheOn = TRUE;
00000c  e59f1010          LDR      r1,|L4.36|
000010  e3a02001          MOV      r2,#1
000014  e5c12000          STRB     r2,[r1,#0]  ; _sys_IsCacheOn
;;;460        _sys_CacheMode = uCacheOpMode;
000018  e5814008          STR      r4,[r1,#8]  ; _sys_CacheMode
;;;461    
;;;462        return 0;
00001c  e3a00000          MOV      r0,#0
;;;463    }
000020  e8bd8010          POP      {r4,pc}
;;;464    
                          ENDP

                  |L4.36|
                          DCD      ||.data||

                          AREA ||i.sysFlushCache||, CODE, READONLY, ALIGN=2

                  sysFlushCache PROC
;;;335    
;;;336    void sysFlushCache(INT32 nCacheType)
000000  e3500006          CMP      r0,#6
;;;337    {
000004  e92d4010          PUSH     {r4,lr}
;;;338        int temp;
;;;339    
;;;340        switch (nCacheType) {
;;;341            case I_CACHE:
;;;342                __asm {
;;;343                    /*----- flush I-cache -----*/
;;;344                    MOV temp, 0x0
000008  03a00000          MOVEQ    r0,#0
;;;345                    MCR p15, 0, temp, c7, c5, 0 /* invalidate I cache */
00000c  0e070f15          MCREQ    p15,#0x0,r0,c7,c5,#0
;;;346                }
;;;347                break;
;;;348    
;;;349            case D_CACHE:
;;;350                sys_flush_and_clean_dcache();
;;;351                __asm {
;;;352                    /*----- flush D-cache & write buffer -----*/
;;;353                    MOV temp, 0x0
;;;354                    MCR p15, 0, temp, c7, c10, 4 /* drain write buffer */
;;;355                }
;;;356                break;
;;;357    
;;;358            case I_D_CACHE:
;;;359                sys_flush_and_clean_dcache();
;;;360                __asm {
;;;361                    /*----- flush I, D cache & write buffer -----*/
;;;362                    MOV temp, 0x0
;;;363                    MCR p15, 0, temp, c7, c5, 0 /* invalidate I cache */
;;;364                    MCR p15, 0, temp, c7, c10, 4 /* drain write buffer */
;;;365                }
;;;366                break;
;;;367    
;;;368            default:
;;;369                ;
;;;370        }
;;;371    }
000010  08bd8010          POPEQ    {r4,pc}
000014  e3500007          CMP      r0,#7                 ;340
000018  0a000006          BEQ      |L5.56|
00001c  e3500008          CMP      r0,#8                 ;340
000020  18bd8010          POPNE    {r4,pc}
000024  ebfffffe          BL       sys_flush_and_clean_dcache
000028  e3a00000          MOV      r0,#0                 ;362
00002c  ee070f15          MCR      p15,#0x0,r0,c7,c5,#0  ;363
000030  ee070f9a          MCR      p15,#0x0,r0,c7,c10,#4 ;364
000034  e8bd8010          POP      {r4,pc}
                  |L5.56|
000038  ebfffffe          BL       sys_flush_and_clean_dcache
00003c  e3a00000          MOV      r0,#0                 ;353
000040  ee070f9a          MCR      p15,#0x0,r0,c7,c10,#4 ;354
000044  e8bd8010          POP      {r4,pc}
;;;372    
                          ENDP


                          AREA ||i.sysGetCacheMode||, CODE, READONLY, ALIGN=2

                  sysGetCacheMode PROC
;;;388    
;;;389    INT32 sysGetCacheMode()
000000  e59f0004          LDR      r0,|L6.12|
;;;390    {
;;;391        return _sys_CacheMode;
000004  e5900008          LDR      r0,[r0,#8]  ; _sys_CacheMode
;;;392    }
000008  e12fff1e          BX       lr
;;;393    
                          ENDP

                  |L6.12|
                          DCD      ||.data||

                          AREA ||i.sysGetCacheState||, CODE, READONLY, ALIGN=2

                  sysGetCacheState PROC
;;;382    
;;;383    BOOL sysGetCacheState()
000000  e59f0004          LDR      r0,|L7.12|
;;;384    {
;;;385        return _sys_IsCacheOn;
000004  e5d00000          LDRB     r0,[r0,#0]  ; _sys_IsCacheOn
;;;386    }
000008  e12fff1e          BX       lr
;;;387    
                          ENDP

                  |L7.12|
                          DCD      ||.data||

                          AREA ||i.sysGetPhyPageAddr||, CODE, READONLY, ALIGN=2

                  sysGetPhyPageAddr PROC
;;;36     
;;;37     unsigned int sysGetPhyPageAddr(unsigned int vaddr)
000000  e59f204c          LDR      r2,|L8.84|
;;;38     {
;;;39         int table_num, page_num;
;;;40         unsigned int base_addr, page_base, page_offset, phy_addr;
;;;41         volatile _CTable *PageTabPtr;
;;;42     
;;;43         if (vaddr & 0x80000000)
000004  e3100102          TST      r0,#0x80000000
000008  e5d22000          LDRB     r2,[r2,#0]  ; _sys_IsCacheOn
;;;44             PageTabPtr = (_CTable *) _mmuCoarsePageTable_NonCache; //non-cacheable virtual address
00000c  159f1038          LDRNE    r1,|L8.76|
;;;45         else
;;;46             PageTabPtr = (_CTable *) _mmuCoarsePageTable;   //cache-able virtual address
000010  059f1038          LDREQ    r1,|L8.80|
;;;47     
;;;48         if (sysGetCacheState() == TRUE)
000014  e3520001          CMP      r2,#1
;;;49             PageTabPtr = (_CTable *) ((unsigned int)PageTabPtr | 0x80000000); //If cache is enable, must write page tables directly into SDRAM
;;;50     
;;;51         base_addr = vaddr & 0x7FFFF000;
;;;52         table_num = base_addr / 0x100000;
;;;53         page_num = (base_addr & 0xFF000) >> 12;
;;;54     
;;;55         page_base = (*(PageTabPtr+table_num)).page[page_num] & 0xFFFFF000;
;;;56         page_offset = vaddr & 0xFFF;
;;;57         phy_addr = page_base + page_offset;
;;;58     
;;;59         return phy_addr;
;;;60     
;;;61     } /* end sysGetPHYAddr */
000018  e59f2038          LDR      r2,|L8.88|
00001c  03811102          ORREQ    r1,r1,#0x80000000     ;49
000020  e0022a20          AND      r2,r2,r0,LSR #20
000024  e3a030ff          MOV      r3,#0xff
000028  e0033620          AND      r3,r3,r0,LSR #12
00002c  e0811502          ADD      r1,r1,r2,LSL #10      ;55
000030  e7911103          LDR      r1,[r1,r3,LSL #2]     ;55
000034  e1a00a00          LSL      r0,r0,#20             ;56
000038  e1a01621          LSR      r1,r1,#12             ;55
00003c  e1a01601          LSL      r1,r1,#12             ;55
000040  e1a00a20          LSR      r0,r0,#20             ;56
000044  e0800001          ADD      r0,r0,r1              ;57
000048  e12fff1e          BX       lr
;;;62     
                          ENDP

                  |L8.76|
                          DCD      ||.bss||+0x14000
                  |L8.80|
                          DCD      ||.bss||+0x4000
                  |L8.84|
                          DCD      ||.data||
                  |L8.88|
                          DCD      0x000007ff

                          AREA ||i.sysGetSdramSizebyMB||, CODE, READONLY, ALIGN=2

                  sysGetSdramSizebyMB PROC
;;;263    
;;;264    INT32 sysGetSdramSizebyMB()
000000  e92d400c          PUSH     {r2,r3,lr}
;;;265    {
;;;266        unsigned int volatile reg, totalsize=0;
000004  e3a00000          MOV      r0,#0
000008  e58d0000          STR      r0,[sp,#0]
;;;267    
;;;268        reg = inpw(SDIC_BA+0x10) & 0x07;
00000c  e59f010c          LDR      r0,|L9.288|
000010  e5900000          LDR      r0,[r0,#0]
000014  e2000007          AND      r0,r0,#7
;;;269        switch(reg) {
000018  e3500008          CMP      r0,#8
00001c  e58d0004          STR      r0,[sp,#4]            ;268
000020  308ff100          ADDCC    pc,pc,r0,LSL #2
000024  ea00000b          B        |L9.88|
000028  ea00000a          B        |L9.88|
00002c  ea000005          B        |L9.72|
000030  ea000006          B        |L9.80|
000034  ea000016          B        |L9.148|
000038  ea000017          B        |L9.156|
00003c  ea000018          B        |L9.164|
000040  ea000019          B        |L9.172|
000044  ea00001a          B        |L9.180|
                  |L9.72|
;;;270            case 1:
;;;271                totalsize += 2;
000048  e3a00002          MOV      r0,#2
;;;272                break;
00004c  ea000000          B        |L9.84|
                  |L9.80|
;;;273    
;;;274            case 2:
;;;275                totalsize += 4;
000050  e3a00004          MOV      r0,#4
                  |L9.84|
000054  e58d0000          STR      r0,[sp,#0]            ;271
                  |L9.88|
;;;276                break;
;;;277    
;;;278            case 3:
;;;279                totalsize += 8;
;;;280                break;
;;;281    
;;;282            case 4:
;;;283                totalsize += 16;
;;;284                break;
;;;285    
;;;286            case 5:
;;;287                totalsize += 32;
;;;288                break;
;;;289    
;;;290            case 6:
;;;291                totalsize += 64;
;;;292                break;
;;;293    
;;;294            case 7:
;;;295                totalsize += 128;
;;;296                break;
;;;297        }
;;;298    
;;;299        reg = inpw(SDIC_BA+0x14) & 0x07;
000058  e59f00c4          LDR      r0,|L9.292|
00005c  e5900000          LDR      r0,[r0,#0]
000060  e2000007          AND      r0,r0,#7
;;;300        switch(reg) {
000064  e3500008          CMP      r0,#8
000068  e58d0004          STR      r0,[sp,#4]            ;299
00006c  308ff100          ADDCC    pc,pc,r0,LSL #2
000070  ea000017          B        |L9.212|
000074  ea000016          B        |L9.212|
000078  ea00000f          B        |L9.188|
00007c  ea000011          B        |L9.200|
000080  ea000017          B        |L9.228|
000084  ea000019          B        |L9.240|
000088  ea00001b          B        |L9.252|
00008c  ea00001d          B        |L9.264|
000090  ea00001f          B        |L9.276|
                  |L9.148|
000094  e3a00008          MOV      r0,#8                 ;279
000098  eaffffed          B        |L9.84|
                  |L9.156|
00009c  e3a00010          MOV      r0,#0x10              ;283
0000a0  eaffffeb          B        |L9.84|
                  |L9.164|
0000a4  e3a00020          MOV      r0,#0x20              ;287
0000a8  eaffffe9          B        |L9.84|
                  |L9.172|
0000ac  e3a00040          MOV      r0,#0x40              ;291
0000b0  eaffffe7          B        |L9.84|
                  |L9.180|
0000b4  e3a00080          MOV      r0,#0x80              ;295
0000b8  eaffffe5          B        |L9.84|
                  |L9.188|
;;;301            case 1:
;;;302                totalsize += 2;
0000bc  e59d0000          LDR      r0,[sp,#0]
0000c0  e2800002          ADD      r0,r0,#2
;;;303                break;
0000c4  ea000001          B        |L9.208|
                  |L9.200|
;;;304    
;;;305            case 2:
;;;306                totalsize += 4;
0000c8  e59d0000          LDR      r0,[sp,#0]
0000cc  e2800004          ADD      r0,r0,#4
                  |L9.208|
0000d0  e58d0000          STR      r0,[sp,#0]            ;302
                  |L9.212|
;;;307                break;
;;;308    
;;;309            case 3:
;;;310                totalsize += 8;
;;;311                break;
;;;312    
;;;313            case 4:
;;;314                totalsize += 16;
;;;315                break;
;;;316    
;;;317            case 5:
;;;318                totalsize += 32;
;;;319                break;
;;;320    
;;;321            case 6:
;;;322                totalsize += 64;
;;;323                break;
;;;324    
;;;325            case 7:
;;;326                totalsize += 128;
;;;327                break;
;;;328        }
;;;329    
;;;330        if (totalsize != 0)
0000d4  e59d0000          LDR      r0,[sp,#0]
0000d8  e3500000          CMP      r0,#0
;;;331            return totalsize;
;;;332        else
;;;333            return 1;
0000dc  03a00001          MOVEQ    r0,#1
;;;334    }
0000e0  e8bd800c          POP      {r2,r3,pc}
                  |L9.228|
0000e4  e59d0000          LDR      r0,[sp,#0]            ;310
0000e8  e2800008          ADD      r0,r0,#8              ;310
0000ec  eafffff7          B        |L9.208|
                  |L9.240|
0000f0  e59d0000          LDR      r0,[sp,#0]            ;314
0000f4  e2800010          ADD      r0,r0,#0x10           ;314
0000f8  eafffff4          B        |L9.208|
                  |L9.252|
0000fc  e59d0000          LDR      r0,[sp,#0]            ;318
000100  e2800020          ADD      r0,r0,#0x20           ;318
000104  eafffff1          B        |L9.208|
                  |L9.264|
000108  e59d0000          LDR      r0,[sp,#0]            ;322
00010c  e2800040          ADD      r0,r0,#0x40           ;322
000110  eaffffee          B        |L9.208|
                  |L9.276|
000114  e59d0000          LDR      r0,[sp,#0]            ;326
000118  e2800080          ADD      r0,r0,#0x80           ;326
00011c  eaffffeb          B        |L9.208|
;;;335    
                          ENDP

                  |L9.288|
                          DCD      0xb0001810
                  |L9.292|
                          DCD      0xb0001814

                          AREA ||i.sysInitMMUTable||, CODE, READONLY, ALIGN=2

                  sysInitMMUTable PROC
;;;181    
;;;182    int sysInitMMUTable(int cache_mode)
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;183    {
;;;184        unsigned volatile int temp;
;;;185        int i, size, ramsize;
;;;186    
;;;187        if (_IsInitMMUTable == FALSE) {
000004  e59f917c          LDR      r9,|L10.392|
000008  e24dd008          SUB      sp,sp,#8              ;183
00000c  e5d90001          LDRB     r0,[r9,#1]  ; _IsInitMMUTable
000010  e3500000          CMP      r0,#0
000014  0a000003          BEQ      |L10.40|
                  |L10.24|
;;;188            ramsize = sysGetSdramSizebyMB();
;;;189    
;;;190            //flat mapping for 4GB, 4096 section table, each size is 1MB
;;;191            temp = 0xC00;   /* (11:10) access permission, R/W */
;;;192            temp |= 0x1E0;  /* (8:5) domain 15 */
;;;193            temp |= 0x10;   /* bit 4 must be 1 */
;;;194            temp |= 0x00;   /* bit 3:2 for cache control bits, cache disabled */
;;;195            temp |= 0x02;   /* set as 1Mb section */
;;;196    
;;;197            for (i=0; i<4096; i++) {
;;;198                _mmuSectionTable[i] = (unsigned int)(temp | (i << 20));
;;;199            }
;;;200    
;;;201            //Inside SDRAM, divide each section into 256 small pages, each page size is 4KB
;;;202            if (ramsize > _CoarsePageSize) size = _CoarsePageSize;  //maximum 64MB
;;;203            else                           size = ramsize;
;;;204    
;;;205            /* first 1M always direct mapping */
;;;206            sysInitPageTable(0, 0, 0x100000, cache_mode, MMU_DIRECT_MAPPING);
;;;207            temp = ((unsigned int)_mmuCoarsePageTable  & 0xFFFFFC00); /*  coarse table base address */
;;;208            temp |= 0x1E0;  /* (8:5) domain 15 */
;;;209            temp |= 0x10;   /* bit 4 must be 1 */
;;;210            temp |= 0x01;   /* Coarse page table */
;;;211            _mmuSectionTable[0] = temp;
;;;212    
;;;213            /* Create a shadow area at 0x80000000 for non-cacheable region */
;;;214            sysInitPageTable(0x80000000, 0x0, 0x100000, CACHE_DISABLE, MMU_DIRECT_MAPPING);
;;;215            temp = ((unsigned int)_mmuCoarsePageTable_NonCache  & 0xFFFFFC00); /*  coarse table base address */
;;;216            temp |= 0x1E0;  /* (8:5) domain 15 */
;;;217            temp |= 0x10;   /* bit 4 must be 1 */
;;;218            temp |= 0x01;   /* Coarse page table */
;;;219            _mmuSectionTable[0x800] = temp;
;;;220    
;;;221            /* Mapping the other memory */
;;;222            for (i=1; i< size; i++) {
;;;223                temp = (((unsigned int)_mmuCoarsePageTable + (unsigned int)i*1024) & 0xFFFFFC00); /*  coarse table base address */
;;;224                //temp = ((unsigned int)(0x604000 + i*1024) & 0xFFFFFC00); /* coarse table base address */
;;;225                temp |= 0x1E0;  /* (8:5) domain 15 */
;;;226                temp |= 0x10;   /* bit 4 must be 1 */
;;;227                temp |= 0x01;   /* Coarse page table */
;;;228    
;;;229                if (_MMUMappingMode == MMU_DIRECT_MAPPING)
;;;230                    sysInitPageTable((i << 20), (i << 20), 0x100000, cache_mode, MMU_DIRECT_MAPPING); /* direct mapping */
;;;231                else
;;;232                    sysInitPageTable((i << 20), (i << 20), 0x100000, cache_mode, MMU_INVERSE_MAPPING); /* inverse mapping for each 1MB area */
;;;233    
;;;234                _mmuSectionTable[i] = temp;
;;;235            }
;;;236    
;;;237            //Create shadow non-cacheable region
;;;238            for (i=1; i< size; i++) {
;;;239                temp = (((unsigned int)_mmuCoarsePageTable_NonCache + (unsigned int)i*1024) & 0xFFFFFC00); /*  coarse table base address */
;;;240                //temp = ((unsigned int)(0x604000 + i*1024) & 0xFFFFFC00); /* coarse table base address */
;;;241                temp |= 0x1E0;  /* (8:5) domain 15 */
;;;242                temp |= 0x10;   /* bit 4 must be 1 */
;;;243                temp |= 0x01;   /* Coarse page table */
;;;244    
;;;245                if (_MMUMappingMode == MMU_DIRECT_MAPPING)
;;;246                    sysInitPageTable(((i << 20) | 0x80000000), (i << 20), 0x100000, CACHE_DISABLE, MMU_DIRECT_MAPPING); /* direct mapping */
;;;247                else
;;;248                    sysInitPageTable(((i << 20) | 0x80000000), (i << 20), 0x100000, CACHE_DISABLE, MMU_INVERSE_MAPPING); /* inverse mapping for each 1MB area */
;;;249    
;;;250                _mmuSectionTable[0x800+i] = temp;
;;;251            }
;;;252    
;;;253            _IsInitMMUTable = TRUE;
;;;254        }
;;;255    
;;;256        //moved here by cmn [2007/01/27]
;;;257        //set CP15 registers
;;;258        sysSetupCP15((unsigned int)_mmuSectionTable);
000018  e59f016c          LDR      r0,|L10.396|
00001c  ebfffffe          BL       sysSetupCP15
;;;259    
;;;260        return 0;
000020  e3a00000          MOV      r0,#0
;;;261    
;;;262    } /* end sysInitMMUTable */
000024  e8bd8ffe          POP      {r1-r11,pc}
                  |L10.40|
000028  ebfffffe          BL       sysGetSdramSizebyMB
00002c  e59f115c          LDR      r1,|L10.400|
000030  e59f6154          LDR      r6,|L10.396|
000034  e58d1004          STR      r1,[sp,#4]            ;195
000038  e3a01000          MOV      r1,#0                 ;197
                  |L10.60|
00003c  e59d2004          LDR      r2,[sp,#4]            ;198
000040  e1822a01          ORR      r2,r2,r1,LSL #20      ;198
000044  e7862101          STR      r2,[r6,r1,LSL #2]     ;198
000048  e2811001          ADD      r1,r1,#1              ;198
00004c  e3510a01          CMP      r1,#0x1000            ;197
000050  bafffff9          BLT      |L10.60|
000054  e3500040          CMP      r0,#0x40              ;202
000058  e3a07000          MOV      r7,#0                 ;206
00005c  d1a05000          MOVLE    r5,r0                 ;203
000060  e59d3008          LDR      r3,[sp,#8]            ;206
000064  c3a05040          MOVGT    r5,#0x40              ;202
000068  e3a02601          MOV      r2,#0x100000          ;206
00006c  e1a01007          MOV      r1,r7                 ;206
000070  e1a00007          MOV      r0,r7                 ;206
000074  e58d7000          STR      r7,[sp,#0]            ;206
000078  ebfffffe          BL       sysInitPageTable
00007c  e59fb110          LDR      r11,|L10.404|
000080  e3e03000          MVN      r3,#0                 ;214
000084  e38b0e1e          ORR      r0,r11,#0x1e0         ;208
000088  e3800010          ORR      r0,r0,#0x10           ;209
00008c  e3800001          ORR      r0,r0,#1              ;210
000090  e58d0004          STR      r0,[sp,#4]            ;211
000094  e5860000          STR      r0,[r6,#0]            ;214  ; _mmuSectionTable
000098  e3a02601          MOV      r2,#0x100000          ;214
00009c  e3a01000          MOV      r1,#0                 ;214
0000a0  e3a00102          MOV      r0,#0x80000000        ;214
0000a4  e58d7000          STR      r7,[sp,#0]            ;214
0000a8  ebfffffe          BL       sysInitPageTable
0000ac  e28ba801          ADD      r10,r11,#0x10000      ;215
0000b0  e38a0e1e          ORR      r0,r10,#0x1e0         ;216
0000b4  e3800010          ORR      r0,r0,#0x10           ;217
0000b8  e3800001          ORR      r0,r0,#1              ;218
0000bc  e1a01000          MOV      r1,r0                 ;219
0000c0  e58d0004          STR      r0,[sp,#4]            ;218
0000c4  e24b0a02          SUB      r0,r11,#0x2000        ;219
0000c8  e3a04001          MOV      r4,#1                 ;222
0000cc  e1a08004          MOV      r8,r4                 ;222
0000d0  e5801000          STR      r1,[r0,#0]            ;222  ; _mmuSectionTable
                  |L10.212|
0000d4  e1540005          CMP      r4,r5                 ;222
0000d8  a3a04001          MOVGE    r4,#1                 ;238
0000dc  a3a0b102          MOVGE    r11,#0x80000000       ;214
0000e0  aa000024          BGE      |L10.376|
0000e4  e08b0504          ADD      r0,r11,r4,LSL #10     ;223
0000e8  e3800e1e          ORR      r0,r0,#0x1e0          ;225
0000ec  e3800010          ORR      r0,r0,#0x10           ;226
0000f0  e3800001          ORR      r0,r0,#1              ;227
0000f4  e58d0004          STR      r0,[sp,#4]            ;229
0000f8  e5990004          LDR      r0,[r9,#4]            ;229  ; _MMUMappingMode
0000fc  e59d3008          LDR      r3,[sp,#8]            ;232
000100  e3500000          CMP      r0,#0                 ;229
000104  e1a00a04          LSL      r0,r4,#20             ;232
000108  058d7000          STREQ    r7,[sp,#0]            ;230
00010c  e3a02601          MOV      r2,#0x100000          ;232
000110  e1a01000          MOV      r1,r0                 ;232
000114  158d8000          STRNE    r8,[sp,#0]            ;232
000118  ebfffffe          BL       sysInitPageTable
00011c  e59d0004          LDR      r0,[sp,#4]            ;234
000120  e7860104          STR      r0,[r6,r4,LSL #2]     ;234
000124  e2844001          ADD      r4,r4,#1              ;234
000128  eaffffe9          B        |L10.212|
                  |L10.300|
00012c  e08a0504          ADD      r0,r10,r4,LSL #10     ;239
000130  e3800e1e          ORR      r0,r0,#0x1e0          ;241
000134  e3800010          ORR      r0,r0,#0x10           ;242
000138  e3800001          ORR      r0,r0,#1              ;243
00013c  e58d0004          STR      r0,[sp,#4]            ;245
000140  e5990004          LDR      r0,[r9,#4]            ;245  ; _MMUMappingMode
000144  e1a01a04          LSL      r1,r4,#20             ;248
000148  e3500000          CMP      r0,#0                 ;245
00014c  058d7000          STREQ    r7,[sp,#0]            ;246
000150  e18b0a04          ORR      r0,r11,r4,LSL #20     ;248
000154  e3e03000          MVN      r3,#0                 ;248
000158  e3a02601          MOV      r2,#0x100000          ;248
00015c  158d8000          STRNE    r8,[sp,#0]            ;248
000160  ebfffffe          BL       sysInitPageTable
000164  e0860104          ADD      r0,r6,r4,LSL #2       ;250
000168  e59d1004          LDR      r1,[sp,#4]            ;250
00016c  e2800a02          ADD      r0,r0,#0x2000         ;250
000170  e2844001          ADD      r4,r4,#1              ;250
000174  e5801000          STR      r1,[r0,#0]            ;250
                  |L10.376|
000178  e1540005          CMP      r4,r5                 ;238
00017c  a5c98001          STRBGE   r8,[r9,#1]            ;253  ; _IsInitMMUTable
000180  baffffe9          BLT      |L10.300|
000184  eaffffa3          B        |L10.24|
;;;263    
                          ENDP

                  |L10.392|
                          DCD      ||.data||
                  |L10.396|
                          DCD      ||.bss||
                  |L10.400|
                          DCD      0x00000df2
                  |L10.404|
                          DCD      ||.bss||+0x4000

                          AREA ||i.sysInitPageTable||, CODE, READONLY, ALIGN=2

                  sysInitPageTable PROC
;;;112    
;;;113    int sysInitPageTable(unsigned int vaddr, unsigned int phy_addr, int size, int cache_flag, int rev_flag)
000000  e92d43fc          PUSH     {r2-r9,lr}
;;;114    {
000004  e59f40dc          LDR      r4,|L11.232|
;;;115        int i, cnt, table_num, page_num, cache_mode, addr_offset;
;;;116        unsigned volatile int phy_base_addr, vbase_addr, temp;
;;;117        volatile _CTable *PageTabPtr;
;;;118    
;;;119        if (vaddr & 0x80000000)
000008  e3100102          TST      r0,#0x80000000
00000c  e5d44000          LDRB     r4,[r4,#0]  ; _sys_IsCacheOn
000010  e59d6024          LDR      r6,[sp,#0x24]
;;;120            PageTabPtr = (_CTable *) _mmuCoarsePageTable_NonCache; //non-cacheable virtual address
000014  159fc0c4          LDRNE    r12,|L11.224|
;;;121        else
;;;122            PageTabPtr = (_CTable *) _mmuCoarsePageTable;   //cache-able virtual address
000018  059fc0c4          LDREQ    r12,|L11.228|
;;;123    
;;;124        if (sysGetCacheState() == TRUE)
00001c  e3540001          CMP      r4,#1
;;;125            PageTabPtr = (_CTable *) ((unsigned int)PageTabPtr | 0x80000000); //If cache is enable, must write page tables directly into SDRAM
;;;126    
;;;127        //if ( _IsInitMMUTable == FALSE ) return -1;
;;;128        vaddr &= 0x7FFFFFFF;    //ignore the non-cacheable bit 31
000020  e3c04102          BIC      r4,r0,#0x80000000
000024  038cc102          ORREQ    r12,r12,#0x80000000   ;125
;;;129        if ((vaddr + size) > (_CoarsePageSize << 20)) return -1;
000028  e0840002          ADD      r0,r4,r2
00002c  e3500301          CMP      r0,#0x4000000
;;;130        if (vaddr & 0xFFFFF)    return -1;  /* MUST 1M Boundary */
000030  91b00604          LSLSLS   r0,r4,#12
;;;131        if (size % 4096)        return -1;  /* MUST 4K multiple size */
000034  01b00a02          LSLSEQ   r0,r2,#20
000038  13e00000          MVNNE    r0,#0
00003c  1a000026          BNE      |L11.220|
;;;132    
;;;133        /* Pages count */
;;;134        cnt = size / 4096;
000040  e1a00fc2          ASR      r0,r2,#31
;;;135    
;;;136        if (cache_flag == CACHE_WRITE_BACK) /* write back mode */
000044  e3530000          CMP      r3,#0
000048  e0820a20          ADD      r0,r2,r0,LSR #20      ;134
00004c  e1a07640          ASR      r7,r0,#12             ;134
;;;137            cache_mode = 0x0C;
000050  03a0300c          MOVEQ    r3,#0xc
000054  0a000002          BEQ      |L11.100|
;;;138        else if (cache_flag == CACHE_WRITE_THROUGH) /* write through mode */
000058  e3530001          CMP      r3,#1
;;;139            cache_mode = 0x08;
00005c  03a03008          MOVEQ    r3,#8
;;;140        else
;;;141            cache_mode = 0; /* Non-cacheable, non-buffered */
000060  13a03000          MOVNE    r3,#0
                  |L11.100|
;;;142    
;;;143    
;;;144        if (rev_flag == MMU_DIRECT_MAPPING)
000064  e3560000          CMP      r6,#0
;;;145            phy_base_addr = phy_addr;
;;;146        else
;;;147            phy_base_addr = phy_addr + size - 4096;
000068  10810002          ADDNE    r0,r1,r2
00006c  058d1004          STREQ    r1,[sp,#4]            ;145
000070  12400a01          SUBNE    r0,r0,#0x1000
000074  158d0004          STRNE    r0,[sp,#4]
;;;148    
;;;149        addr_offset = 4096;
000078  e3a01a01          MOV      r1,#0x1000
;;;150        for (i=0; i<cnt; i++) {
00007c  e3a00000          MOV      r0,#0
;;;151            vbase_addr = vaddr + i * 4096;
;;;152            table_num = vbase_addr / 0x100000;
;;;153            page_num =  (vbase_addr & 0xFF000) >> 12; /* bits [19:12] for level two table index */
;;;154    
;;;155            temp = phy_base_addr & 0xFFFFF000;
;;;156            temp |= 0xFF0; /* access permission, 11 for read/write */
;;;157            temp |= cache_mode; /* cache mode */
;;;158            temp |= 0x02;  /* small page */
;;;159    
;;;160            (*(PageTabPtr+table_num)).page[page_num] = temp;
;;;161    
;;;162            if (rev_flag == MMU_DIRECT_MAPPING)
;;;163                phy_base_addr += addr_offset;
;;;164            else
;;;165                phy_base_addr -= addr_offset;
;;;166        }
;;;167    
;;;168        return 0;
;;;169    
;;;170    } /* end sysInitPageTable */
000080  e3a080ff          MOV      r8,#0xff
                  |L11.132|
000084  e1500007          CMP      r0,r7                 ;150
000088  a3a00000          MOVGE    r0,#0                 ;168
00008c  aa000012          BGE      |L11.220|
000090  e59d9004          LDR      r9,[sp,#4]            ;155
000094  e0842600          ADD      r2,r4,r0,LSL #12      ;151
000098  e1a09629          LSR      r9,r9,#12             ;155
00009c  e1a09609          LSL      r9,r9,#12             ;155
0000a0  e3899eff          ORR      r9,r9,#0xff0          ;156
0000a4  e1a05a22          LSR      r5,r2,#20             ;152
0000a8  e1899003          ORR      r9,r9,r3              ;157
0000ac  e3899002          ORR      r9,r9,#2              ;158
0000b0  e0082622          AND      r2,r8,r2,LSR #12
0000b4  e08c5505          ADD      r5,r12,r5,LSL #10     ;160
0000b8  e58d9000          STR      r9,[sp,#0]            ;160
0000bc  e7859102          STR      r9,[r5,r2,LSL #2]     ;160
0000c0  e59d2004          LDR      r2,[sp,#4]            ;165
0000c4  e3560000          CMP      r6,#0                 ;162
0000c8  00822001          ADDEQ    r2,r2,r1              ;163
0000cc  10422001          SUBNE    r2,r2,r1              ;165
0000d0  e2800001          ADD      r0,r0,#1              ;165
0000d4  e58d2004          STR      r2,[sp,#4]            ;165
0000d8  eaffffe9          B        |L11.132|
                  |L11.220|
0000dc  e8bd83fc          POP      {r2-r9,pc}
;;;171    
                          ENDP

                  |L11.224|
                          DCD      ||.bss||+0x14000
                  |L11.228|
                          DCD      ||.bss||+0x4000
                  |L11.232|
                          DCD      ||.data||

                          AREA ||i.sysInvalidCache||, CODE, READONLY, ALIGN=2

                  sysInvalidCache PROC
;;;372    
;;;373    void sysInvalidCache()
000000  e3a00000          MOV      r0,#0
;;;374    {
;;;375        int temp;
;;;376    
;;;377        __asm {
;;;378            MOV temp, 0x0
;;;379            MCR p15, 0, temp, c7, c7, 0 /* invalidate I and D cache */
000004  ee070f17          MCR      p15,#0x0,r0,c7,c7,#0
;;;380        }
;;;381    }
000008  e12fff1e          BX       lr
;;;382    
                          ENDP


                          AREA ||i.sysSetCachePages||, CODE, READONLY, ALIGN=2

                  sysSetCachePages PROC
;;;63     
;;;64     int sysSetCachePages(unsigned int vaddr, int size, int cache_flag)
000000  e92d40f8          PUSH     {r3-r7,lr}
;;;65     {
000004  e59fc0a4          LDR      r12,|L13.176|
;;;66         int i, cnt, table_num, page_num, cache_mode;
;;;67         unsigned volatile int baseaddr, temp;
;;;68         volatile _CTable *PageTabPtr;
;;;69     
;;;70         if (vaddr & 0x80000000)
000008  e3100102          TST      r0,#0x80000000
00000c  e5dcc000          LDRB     r12,[r12,#0]  ; _sys_IsCacheOn
;;;71             PageTabPtr = (_CTable *) _mmuCoarsePageTable_NonCache; //non-cacheable virtual address
000010  159f3090          LDRNE    r3,|L13.168|
;;;72         else
;;;73             PageTabPtr = (_CTable *) _mmuCoarsePageTable;   //cache-able virtual address
000014  059f3090          LDREQ    r3,|L13.172|
;;;74     
;;;75         if (sysGetCacheState() == TRUE)
000018  e35c0001          CMP      r12,#1
;;;76             PageTabPtr = (_CTable *) ((unsigned int)PageTabPtr | 0x80000000); //If cache is enable, must write page tables directly into SDRAM
;;;77     
;;;78         vaddr &= 0x7FFFFFFF;    //ignore the non-cacheable bit 31
00001c  e3c0c102          BIC      r12,r0,#0x80000000
000020  03833102          ORREQ    r3,r3,#0x80000000     ;76
;;;79         //if ( _IsInitMMUTable == FALSE ) return -1;
;;;80         if ((vaddr + size) > (_CoarsePageSize << 20)) return -1;
000024  e08c0001          ADD      r0,r12,r1
000028  e3500301          CMP      r0,#0x4000000
;;;81     
;;;82         if (vaddr & 0xFFF)  return -1;  /* MUST 4K Boundary */
00002c  91b00a0c          LSLSLS   r0,r12,#20
;;;83         if (size % 4096)    return -1;  /* MUST 4K multiple size */
000030  01b00a01          LSLSEQ   r0,r1,#20
000034  13e00000          MVNNE    r0,#0
000038  1a000019          BNE      |L13.164|
;;;84     
;;;85         /* for flat mapping address */
;;;86         cnt = size / 4096;
00003c  e1a00fc1          ASR      r0,r1,#31
;;;87     
;;;88         if (cache_flag == CACHE_WRITE_BACK) /* write back mode */
000040  e3520000          CMP      r2,#0
000044  e0810a20          ADD      r0,r1,r0,LSR #20      ;86
000048  e1a05640          ASR      r5,r0,#12             ;86
;;;89             cache_mode = 0x0C;
00004c  03a0400c          MOVEQ    r4,#0xc
000050  0a000002          BEQ      |L13.96|
;;;90         else if (cache_flag == CACHE_WRITE_THROUGH) /* write through mode */
000054  e3520001          CMP      r2,#1
;;;91             cache_mode = 0x08;
000058  03a04008          MOVEQ    r4,#8
;;;92         else
;;;93             cache_mode = 0; /* Non-cacheable, non-buffered */
00005c  13a04000          MOVNE    r4,#0
                  |L13.96|
;;;94     
;;;95         for (i=0; i<cnt; i++) {
000060  e3a00000          MOV      r0,#0
;;;96             baseaddr = vaddr + i * 4096;
;;;97             table_num = baseaddr / 0x100000;
;;;98             page_num =  (baseaddr & 0xFF000) >> 12; /* bits [19:12] for level two table index */
;;;99     
;;;100            temp = (*(PageTabPtr+table_num)).page[page_num] & 0xFFFFFFF3;
;;;101            temp |= cache_mode; /* cache mode */
;;;102            (*(PageTabPtr+table_num)).page[page_num] = temp;
;;;103        }
;;;104    
;;;105        //sysFlushCache(D_CACHE);
;;;106    
;;;107        return 0;
;;;108    
;;;109    } /* end sysSetCachePages */
000064  e3a060ff          MOV      r6,#0xff
000068  ea00000a          B        |L13.152|
                  |L13.108|
00006c  e08c1600          ADD      r1,r12,r0,LSL #12     ;96
000070  e1a02a21          LSR      r2,r1,#20             ;97
000074  e58d1000          STR      r1,[sp,#0]            ;96
000078  e0061621          AND      r1,r6,r1,LSR #12
00007c  e0832502          ADD      r2,r3,r2,LSL #10      ;100
000080  e7927101          LDR      r7,[r2,r1,LSL #2]     ;100
000084  e3c7700c          BIC      r7,r7,#0xc            ;100
000088  e1877004          ORR      r7,r7,r4              ;101
00008c  e58d7000          STR      r7,[sp,#0]            ;101
000090  e7827101          STR      r7,[r2,r1,LSL #2]     ;102
000094  e2800001          ADD      r0,r0,#1              ;102
                  |L13.152|
000098  e1500005          CMP      r0,r5                 ;95
00009c  a3a00000          MOVGE    r0,#0                 ;107
0000a0  bafffff1          BLT      |L13.108|
                  |L13.164|
0000a4  e8bd80f8          POP      {r3-r7,pc}
;;;110    
                          ENDP

                  |L13.168|
                          DCD      ||.bss||+0x14000
                  |L13.172|
                          DCD      ||.bss||+0x4000
                  |L13.176|
                          DCD      ||.data||

                          AREA ||i.sysSetMMUMappingMethod||, CODE, READONLY, ALIGN=2

                  sysSetMMUMappingMethod PROC
;;;172    
;;;173    int sysSetMMUMappingMethod(int mode)
000000  e59f1008          LDR      r1,|L14.16|
;;;174    {
;;;175        _MMUMappingMode = mode;
000004  e5810004          STR      r0,[r1,#4]  ; _MMUMappingMode
;;;176    
;;;177        return 0;
000008  e3a00000          MOV      r0,#0
;;;178    
;;;179    } /* end sysSetMMUMappingMethod */
00000c  e12fff1e          BX       lr
;;;180    
                          ENDP

                  |L14.16|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=14

                  _mmuSectionTable
                          %        16384
                  _mmuCoarsePageTable
                          %        65536
                  _mmuCoarsePageTable_NonCache
                          %        65536

                          AREA ||.data||, DATA, ALIGN=2

                  _sys_IsCacheOn
000000  00                DCB      0x00
                  _IsInitMMUTable
000001  000000            DCB      0x00,0x00,0x00
                  _MMUMappingMode
                          DCD      0x00000000
                  _sys_CacheMode
                          DCD      0x00000000
