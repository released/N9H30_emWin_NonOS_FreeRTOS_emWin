; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\testutils.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\testutils.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931 -I..\..\..\Driver\Source -I..\..\..\Driver\Include -I..\..\..\ThirdParty\FATFS\src -I..\..\..\ThirdParty\emWin\Config -I..\..\..\ThirdParty\emWin\Include -I..\..\FreeRTOS_with_emwin -I..\tslib -I..\Application -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\portable\RVDS\ARM9_N9H30 -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Demo\Common\include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Toshiba -D__UVISION_VERSION=526 -D_PANEL_E50A2V1_16BPP_ --omf_browse=.\obj\testutils.crf ..\tslib\testutils.c]
                          ARM

                          AREA ||i.button_draw||, CODE, READONLY, ALIGN=2

                  button_draw PROC
;;;147    
;;;148    void button_draw (struct ts_button *button)
000000  e92d40f8          PUSH     {r3-r7,lr}
;;;149    {
000004  e1a04000          MOV      r4,r0
;;;150        int s = (button->flags & BUTTON_ACTIVE) ? 3 : 0;
000008  e5d00014          LDRB     r0,[r0,#0x14]
;;;151    
;;;152        rect(button->x, button->y, button->x + button->w,
00000c  e59f60a0          LDR      r6,|L1.180|
000010  e3100001          TST      r0,#1                 ;150
000014  13a05003          MOVNE    r5,#3                 ;150
000018  03a05000          MOVEQ    r5,#0                 ;150
00001c  e7960105          LDR      r0,[r6,r5,LSL #2]
000020  e58d0000          STR      r0,[sp,#0]
000024  e594000c          LDR      r0,[r4,#0xc]
000028  e5941004          LDR      r1,[r4,#4]
00002c  e5942008          LDR      r2,[r4,#8]
000030  e0813000          ADD      r3,r1,r0
000034  e5940000          LDR      r0,[r4,#0]
000038  e0822000          ADD      r2,r2,r0
00003c  ebfffffe          BL       rect
;;;153             button->y + button->h, button_palette [s]);
;;;154        fillrect(button->x + 1, button->y + 1,
000040  e0865105          ADD      r5,r6,r5,LSL #2
000044  e5950004          LDR      r0,[r5,#4]
000048  e58d0000          STR      r0,[sp,#0]
00004c  e5940004          LDR      r0,[r4,#4]
000050  e594100c          LDR      r1,[r4,#0xc]
000054  e594c000          LDR      r12,[r4,#0]
000058  e0811000          ADD      r1,r1,r0
00005c  e2413002          SUB      r3,r1,#2
000060  e5941008          LDR      r1,[r4,#8]
000064  e081100c          ADD      r1,r1,r12
000068  e2412002          SUB      r2,r1,#2
00006c  e2801001          ADD      r1,r0,#1
000070  e28c0001          ADD      r0,r12,#1
000074  ebfffffe          BL       fillrect
;;;155                 button->x + button->w - 2,
;;;156                 button->y + button->h - 2, button_palette [s + 1]);
;;;157    //    put_string_center(button->x + button->w / 2,
;;;158    //                      button->y + button->h / 2,
;;;159    //                      button->text, button_palette [s + 2]);
;;;160    
;;;161        GUI_SetColor(palette[button_palette [s + 2]]);
000078  e5950008          LDR      r0,[r5,#8]
00007c  e2461034          SUB      r1,r6,#0x34
000080  e7910100          LDR      r0,[r1,r0,LSL #2]
000084  ebfffffe          BL       GUI_SetColor
;;;162        GUI_DispStringHCenterAt(button->text, button->x + button->w / 2, button->y + button->h / 2);
000088  e594100c          LDR      r1,[r4,#0xc]
00008c  e5942004          LDR      r2,[r4,#4]
000090  e0811fa1          ADD      r1,r1,r1,LSR #31
000094  e5940008          LDR      r0,[r4,#8]
000098  e08220c1          ADD      r2,r2,r1,ASR #1
00009c  e5941000          LDR      r1,[r4,#0]
0000a0  e0800fa0          ADD      r0,r0,r0,LSR #31
0000a4  e08110c0          ADD      r1,r1,r0,ASR #1
0000a8  e5940010          LDR      r0,[r4,#0x10]
0000ac  e8bd40f8          POP      {r3-r7,lr}
0000b0  eafffffe          B        GUI_DispStringHCenterAt
;;;163    }
;;;164    
                          ENDP

                  |L1.180|
                          DCD      ||.data||+0x34

                          AREA ||i.button_handle||, CODE, READONLY, ALIGN=2

                  button_handle PROC
;;;164    
;;;165    int button_handle (struct ts_button *button, int x, int y, unsigned int p)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;166    {
;;;167        int inside = (x >= button->x) && (y >= button->y) &&
000004  e590c000          LDR      r12,[r0,#0]
000008  e15c0001          CMP      r12,r1
00000c  d5904004          LDRLE    r4,[r0,#4]
000010  d1540002          CMPLE    r4,r2
000014  ca000007          BGT      |L2.56|
;;;168                     (x < button->x + button->w) &&
000018  e5905008          LDR      r5,[r0,#8]
00001c  e08cc005          ADD      r12,r12,r5
000020  e151000c          CMP      r1,r12
;;;169                     (y < button->y + button->h);
000024  b590100c          LDRLT    r1,[r0,#0xc]
000028  b0811004          ADDLT    r1,r1,r4
00002c  b1520001          CMPLT    r2,r1
000030  b3a02001          MOVLT    r2,#1                 ;167
000034  ba000000          BLT      |L2.60|
                  |L2.56|
000038  e3a02000          MOV      r2,#0                 ;167
                  |L2.60|
;;;170    
;;;171        if (p > 0)
00003c  e5901014          LDR      r1,[r0,#0x14]
000040  e3530000          CMP      r3,#0
000044  0a00000c          BEQ      |L2.124|
;;;172        {
;;;173            if (inside)
000048  e3520000          CMP      r2,#0
;;;174            {
;;;175                if (!(button->flags & BUTTON_ACTIVE))
;;;176                {
;;;177                    button->flags |= BUTTON_ACTIVE;
;;;178                    button_draw (button);
;;;179                }
;;;180            }
;;;181            else if (button->flags & BUTTON_ACTIVE)
00004c  e2012001          AND      r2,r1,#1
000050  0a000003          BEQ      |L2.100|
000054  e3520000          CMP      r2,#0                 ;175
000058  03811001          ORREQ    r1,r1,#1              ;177
00005c  0a000003          BEQ      |L2.112|
000060  ea00000c          B        |L2.152|
                  |L2.100|
000064  e3520000          CMP      r2,#0
;;;182            {
;;;183                button->flags &= ~BUTTON_ACTIVE;
000068  13c11001          BICNE    r1,r1,#1
00006c  0a000009          BEQ      |L2.152|
                  |L2.112|
000070  e5801014          STR      r1,[r0,#0x14]
;;;184                button_draw (button);
000074  ebfffffe          BL       button_draw
000078  ea000006          B        |L2.152|
                  |L2.124|
;;;185            }
;;;186        }
;;;187        else if (button->flags & BUTTON_ACTIVE)
00007c  e3110001          TST      r1,#1
000080  0a000004          BEQ      |L2.152|
;;;188        {
;;;189            button->flags &= ~BUTTON_ACTIVE;
000084  e3c11001          BIC      r1,r1,#1
000088  e5801014          STR      r1,[r0,#0x14]
;;;190            button_draw (button);
00008c  ebfffffe          BL       button_draw
;;;191            return 1;
000090  e3a00001          MOV      r0,#1
;;;192        }
;;;193    
;;;194        return 0;
;;;195    }
000094  e8bd8070          POP      {r4-r6,pc}
                  |L2.152|
000098  e3a00000          MOV      r0,#0                 ;194
00009c  e8bd8070          POP      {r4-r6,pc}
;;;196    
                          ENDP


                          AREA ||i.getxy||, CODE, READONLY, ALIGN=2

                  getxy PROC
;;;36     
;;;37     void getxy(int *x, int *y)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;38     {
000004  e1a07000          MOV      r7,r0
000008  e24dde61          SUB      sp,sp,#0x610
00000c  e1a06001          MOV      r6,r1
;;;39     #define MAX_SAMPLES 128
;;;40         struct ts_sample samp[MAX_SAMPLES];
;;;41         int index, middle;
;;;42         int sumx, sumy;
;;;43     
;;;44         sysprintf("getxy\n");
000010  e28f0f59          ADR      r0,|L3.380|
000014  ebfffffe          BL       sysprintf
;;;45     again:
;;;46         do
;;;47         {
;;;48             if ( Read_TouchPanel(&sumx, &sumy) > 0 )
000018  e28dab01          ADD      r10,sp,#0x400
00001c  e28aaf81          ADD      r10,r10,#0x204
000020  e28dbc06          ADD      r11,sp,#0x600
000024  e1a0800d          MOV      r8,sp                 ;40
                  |L3.40|
000028  e1a0100a          MOV      r1,r10
00002c  e1a0000b          MOV      r0,r11
000030  ebfffffe          BL       Read_TouchPanel
000034  e3500000          CMP      r0,#0
000038  dafffffa          BLE      |L3.40|
;;;49             {
;;;50                 if ( (sumx < 0) || ( sumy < 0 ) )
00003c  e59d0600          LDR      r0,[sp,#0x600]
000040  e3500000          CMP      r0,#0
000044  a59d0604          LDRGE    r0,[sp,#0x604]
000048  a3500000          CMPGE    r0,#0
;;;51                     continue;
;;;52                 break;
;;;53             }
;;;54         }
;;;55         while (1);
;;;56     
;;;57         /* Now collect up to MAX_SAMPLES touches into the samp array. */
;;;58         index = 0;
00004c  a3a04000          MOVGE    r4,#0
;;;59         do
;;;60         {
;;;61             if (index < MAX_SAMPLES-1)
;;;62                 index++;
;;;63             if ( Read_TouchPanel(&sumx, &sumy) > 0)
;;;64             {
;;;65                 samp[index].x = sumx;
;;;66                 samp[index].y = sumy;
;;;67                 samp[index].pressure = 1000;
000050  a3a09ffa          MOVGE    r9,#0x3e8
000054  bafffff3          BLT      |L3.40|
                  |L3.88|
000058  e2844001          ADD      r4,r4,#1              ;61
00005c  e0845084          ADD      r5,r4,r4,LSL #1       ;65
                  |L3.96|
000060  e1a0100a          MOV      r1,r10                ;63
000064  e1a0000b          MOV      r0,r11                ;63
000068  ebfffffe          BL       Read_TouchPanel
00006c  e3500000          CMP      r0,#0                 ;63
000070  da000007          BLE      |L3.148|
000074  e59d0600          LDR      r0,[sp,#0x600]        ;65
000078  e354007f          CMP      r4,#0x7f              ;61
00007c  e7880105          STR      r0,[r8,r5,LSL #2]     ;65
000080  e59d1604          LDR      r1,[sp,#0x604]        ;66
000084  e0880105          ADD      r0,r8,r5,LSL #2       ;66
000088  e9800202          STMIB    r0,{r1,r9}            ;61
00008c  aafffff3          BGE      |L3.96|
000090  eafffff0          B        |L3.88|
                  |L3.148|
;;;68             }
;;;69             else
;;;70             {
;;;71                 samp[index].x = samp[index-1].x;
000094  e0840084          ADD      r0,r4,r4,LSL #1
000098  e0880100          ADD      r0,r8,r0,LSL #2
00009c  e510100c          LDR      r1,[r0,#-0xc]
0000a0  e1a09008          MOV      r9,r8
0000a4  e7881105          STR      r1,[r8,r5,LSL #2]
;;;72                 samp[index].y = samp[index-1].y;
0000a8  e5101008          LDR      r1,[r0,#-8]
0000ac  e5801004          STR      r1,[r0,#4]
;;;73                 samp[index].pressure = 0;
0000b0  e3a01000          MOV      r1,#0
0000b4  e5801008          STR      r1,[r0,#8]
;;;74             }
;;;75     
;;;76     //      sysprintf("%d %d %d\n", samp[index].x, samp[index].y , samp[index].pressure);
;;;77         }
;;;78         while (samp[index].pressure > 0);
;;;79         sysprintf("Took %d samples...\n",index);
0000b8  e1a01004          MOV      r1,r4
0000bc  e28f00c0          ADR      r0,|L3.388|
0000c0  ebfffffe          BL       sysprintf
;;;80     
;;;81         /*
;;;82          * At this point, we have samples in indices zero to (index-1)
;;;83          * which means that we have (index) number of samples.  We want
;;;84          * to calculate the median of the samples so that wild outliers
;;;85          * don't skew the result.  First off, let's assume that arrays
;;;86          * are one-based instead of zero-based.  If this were the case
;;;87          * and index was odd, we would need sample number ((index+1)/2)
;;;88          * of a sorted array; if index was even, we would need the
;;;89          * average of sample number (index/2) and sample number
;;;90          * ((index/2)+1).  To turn this into something useful for the
;;;91          * real world, we just need to subtract one off of the sample
;;;92          * numbers.  So for when index is odd, we need sample number
;;;93          * (((index+1)/2)-1).  Due to integer division truncation, we
;;;94          * can simplify this to just (index/2).  When index is even, we
;;;95          * need the average of sample number ((index/2)-1) and sample
;;;96          * number (index/2).  Calculate (index/2) now and we'll handle
;;;97          * the even odd stuff after we sort.
;;;98          */
;;;99         middle = index/2;
0000c4  e0840fa4          ADD      r0,r4,r4,LSR #31
;;;100        if (x)
0000c8  e3570000          CMP      r7,#0
0000cc  e1a050c0          ASR      r5,r0,#1              ;99
0000d0  0a000010          BEQ      |L3.280|
;;;101        {
;;;102            qsort(samp, index, sizeof(struct ts_sample), sort_by_x);
0000d4  e59f30bc          LDR      r3,|L3.408|
0000d8  e3a0200c          MOV      r2,#0xc
0000dc  e1a01004          MOV      r1,r4
0000e0  e1a00009          MOV      r0,r9
0000e4  ebfffffe          BL       qsort
;;;103            if (index & 1)
0000e8  e3140001          TST      r4,#1
;;;104                *x = samp[middle].x;
0000ec  10851085          ADDNE    r1,r5,r5,LSL #1
0000f0  17990101          LDRNE    r0,[r9,r1,LSL #2]
0000f4  1a000006          BNE      |L3.276|
;;;105            else
;;;106                *x = (samp[middle-1].x + samp[middle].x) / 2;
0000f8  e0850085          ADD      r0,r5,r5,LSL #1
0000fc  e0892100          ADD      r2,r9,r0,LSL #2
000100  e512200c          LDR      r2,[r2,#-0xc]
000104  e7990100          LDR      r0,[r9,r0,LSL #2]
000108  e0800002          ADD      r0,r0,r2
00010c  e0800fa0          ADD      r0,r0,r0,LSR #31
000110  e1a000c0          ASR      r0,r0,#1
                  |L3.276|
000114  e5870000          STR      r0,[r7,#0]            ;104
                  |L3.280|
;;;107        }
;;;108        if (y)
000118  e3560000          CMP      r6,#0
00011c  0a00000d          BEQ      |L3.344|
;;;109        {
;;;110            qsort(samp, index, sizeof(struct ts_sample), sort_by_y);
000120  e59f3074          LDR      r3,|L3.412|
000124  e3a0200c          MOV      r2,#0xc
000128  e1a01004          MOV      r1,r4
00012c  e1a00009          MOV      r0,r9
000130  ebfffffe          BL       qsort
;;;111            if (index & 1)
;;;112                *y = samp[middle].y;
;;;113            else
;;;114                *y = (samp[middle-1].y + samp[middle].y) / 2;
000134  e0850085          ADD      r0,r5,r5,LSL #1
000138  e3140001          TST      r4,#1                 ;111
00013c  e0890100          ADD      r0,r9,r0,LSL #2
000140  05101008          LDREQ    r1,[r0,#-8]
000144  e5900004          LDR      r0,[r0,#4]            ;112
000148  00800001          ADDEQ    r0,r0,r1
00014c  00800fa0          ADDEQ    r0,r0,r0,LSR #31
000150  01a000c0          ASREQ    r0,r0,#1
000154  e5860000          STR      r0,[r6,#0]            ;112
                  |L3.344|
;;;115        }
;;;116        if ( (index <= 3) || ( *x < 0) || ( *y < 0 ) )
000158  e3540003          CMP      r4,#3
00015c  daffffb1          BLE      |L3.40|
000160  e5970000          LDR      r0,[r7,#0]
000164  e3500000          CMP      r0,#0
000168  a5960000          LDRGE    r0,[r6,#0]
00016c  a3500000          CMPGE    r0,#0
000170  baffffac          BLT      |L3.40|
;;;117            goto again;
;;;118    }
000174  e28dde61          ADD      sp,sp,#0x610
000178  e8bd9ff0          POP      {r4-r12,pc}
;;;119    
                          ENDP

                  |L3.380|
00017c  67657478          DCB      "getxy\n",0
000180  790a00  
000183  00                DCB      0
                  |L3.388|
000184  546f6f6b          DCB      "Took %d samples...\n",0
000188  20256420
00018c  73616d70
000190  6c65732e
000194  2e2e0a00
                  |L3.408|
                          DCD      sort_by_x
                  |L3.412|
                          DCD      sort_by_y

                          AREA ||i.refresh_screen||, CODE, READONLY, ALIGN=2

                  refresh_screen PROC
;;;196    
;;;197    static void refresh_screen(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;198    {
;;;199        int i;
;;;200    
;;;201        //fillrect (0, 0, xres - 1, yres - 1, 0);
;;;202        GUI_Clear();
000004  ebfffffe          BL       GUI_Clear
;;;203    //    put_string_center (xres/2, yres/4,   "Touchscreen test program", 1);
;;;204    //    put_string_center (xres/2, yres/4+20,"Touch screen to move crosshair", 2);
;;;205    
;;;206        GUI_SetColor(palette[1]);
000008  e59f506c          LDR      r5,|L4.124|
00000c  e5950004          LDR      r0,[r5,#4]  ; palette
000010  ebfffffe          BL       GUI_SetColor
;;;207        GUI_DispStringHCenterAt("Touchscreen test program", xres / 2, yres / 4);
000014  e59f6064          LDR      r6,|L4.128|
000018  e59f4064          LDR      r4,|L4.132|
00001c  e5960000          LDR      r0,[r6,#0]  ; yres
000020  e1a02120          LSR      r2,r0,#2
000024  e5940000          LDR      r0,[r4,#0]  ; xres
000028  e1a010a0          LSR      r1,r0,#1
00002c  e28f0054          ADR      r0,|L4.136|
000030  ebfffffe          BL       GUI_DispStringHCenterAt
;;;208    
;;;209        GUI_SetColor(palette[2]);
000034  e5950008          LDR      r0,[r5,#8]  ; palette
000038  ebfffffe          BL       GUI_SetColor
;;;210        GUI_DispStringHCenterAt("Touch screen to move crosshair", xres / 2, yres / 4 + 20);
00003c  e5960000          LDR      r0,[r6,#0]  ; yres
000040  e3a01014          MOV      r1,#0x14
000044  e0812120          ADD      r2,r1,r0,LSR #2
000048  e5940000          LDR      r0,[r4,#0]  ; xres
00004c  e1a010a0          LSR      r1,r0,#1
000050  e28f004c          ADR      r0,|L4.164|
000054  ebfffffe          BL       GUI_DispStringHCenterAt
;;;211    
;;;212        for (i = 0; i < NR_BUTTONS; i++)
;;;213            button_draw (&buttons [i]);
000058  e59f5064          LDR      r5,|L4.196|
00005c  e3a04000          MOV      r4,#0                 ;212
                  |L4.96|
000060  e0840084          ADD      r0,r4,r4,LSL #1
000064  e0850180          ADD      r0,r5,r0,LSL #3
000068  ebfffffe          BL       button_draw
00006c  e2844001          ADD      r4,r4,#1
000070  e3540003          CMP      r4,#3                 ;212
000074  bafffff9          BLT      |L4.96|
;;;214    }
000078  e8bd8070          POP      {r4-r6,pc}
;;;215    
                          ENDP

                  |L4.124|
                          DCD      ||.data||
                  |L4.128|
                          DCD      yres
                  |L4.132|
                          DCD      xres
                  |L4.136|
000088  546f7563          DCB      "Touchscreen test program",0
00008c  68736372
000090  65656e20
000094  74657374
000098  2070726f
00009c  6772616d
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L4.164|
0000a4  546f7563          DCB      "Touch screen to move crosshair",0
0000a8  68207363
0000ac  7265656e
0000b0  20746f20
0000b4  6d6f7665
0000b8  2063726f
0000bc  73736861
0000c0  697200  
0000c3  00                DCB      0
                  |L4.196|
                          DCD      ||.bss||

                          AREA ||i.sort_by_x||, CODE, READONLY, ALIGN=2

                  sort_by_x PROC
;;;26     
;;;27     static int sort_by_x(const void* a, const void *b)
000000  e5900000          LDR      r0,[r0,#0]
;;;28     {
;;;29         return (((struct ts_sample *)a)->x - ((struct ts_sample *)b)->x);
000004  e5911000          LDR      r1,[r1,#0]
000008  e0400001          SUB      r0,r0,r1
;;;30     }
00000c  e12fff1e          BX       lr
;;;31     
                          ENDP


                          AREA ||i.sort_by_y||, CODE, READONLY, ALIGN=2

                  sort_by_y PROC
;;;31     
;;;32     static int sort_by_y(const void* a, const void *b)
000000  e5900004          LDR      r0,[r0,#4]
;;;33     {
;;;34         return (((struct ts_sample *)a)->y - ((struct ts_sample *)b)->y);
000004  e5911004          LDR      r1,[r1,#4]
000008  e0400001          SUB      r0,r0,r1
;;;35     }
00000c  e12fff1e          BX       lr
;;;36     
                          ENDP


                          AREA ||i.ts_test||, CODE, READONLY, ALIGN=2

                  ts_test PROC
;;;215    
;;;216    int ts_test(int xsize, int ysize)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;217    {
;;;218        int sumx, sumy;
;;;219        int x, y;
;;;220        unsigned int i;
;;;221        unsigned int mode = 0;
;;;222        int quit_pressed = 0;
;;;223    
;;;224        xres = xsize;
000004  e59f71c8          LDR      r7,|L7.468|
;;;225        yres = ysize;
000008  e59f21c8          LDR      r2,|L7.472|
00000c  e3a04000          MOV      r4,#0                 ;221
;;;226    
;;;227        x = xres/2;
;;;228        y = yres/2;
;;;229    
;;;230        for (i = 0; i < NR_COLORS; i++)
;;;231            setcolor (i, palette [i]);
000010  e59f61c4          LDR      r6,|L7.476|
000014  e5870000          STR      r0,[r7,#0]            ;225  ; xres
000018  e1a09004          MOV      r9,r4                 ;222
00001c  e1a0b0a0          LSR      r11,r0,#1             ;227
000020  e1a0a0a1          LSR      r10,r1,#1             ;228
000024  e1a05004          MOV      r5,r4                 ;230
000028  e5821000          STR      r1,[r2,#0]            ;227  ; yres
                  |L7.44|
00002c  e7961105          LDR      r1,[r6,r5,LSL #2]
000030  e1a00005          MOV      r0,r5
000034  ebfffffe          BL       setcolor
000038  e2855001          ADD      r5,r5,#1
00003c  e355000d          CMP      r5,#0xd               ;230
000040  3afffff9          BCC      |L7.44|
;;;232    
;;;233        /* Initialize buttons */
;;;234        //memset (&buttons, 0, sizeof (buttons));
;;;235        buttons [0].w = buttons [1].w = buttons [2].w = xres / 4;
000044  e5971000          LDR      r1,[r7,#0]  ; xres
000048  e59f5190          LDR      r5,|L7.480|
00004c  e1a00121          LSR      r0,r1,#2
000050  e5850038          STR      r0,[r5,#0x38]  ; buttons
000054  e5850020          STR      r0,[r5,#0x20]  ; buttons
000058  e5850008          STR      r0,[r5,#8]  ; buttons
;;;236        buttons [0].h = buttons [1].h = buttons [2].h = 20;
00005c  e3a00014          MOV      r0,#0x14
000060  e585003c          STR      r0,[r5,#0x3c]  ; buttons
000064  e5850024          STR      r0,[r5,#0x24]  ; buttons
000068  e585000c          STR      r0,[r5,#0xc]  ; buttons
;;;237        buttons [0].x = 0;
00006c  e3a00000          MOV      r0,#0
000070  e5850000          STR      r0,[r5,#0]  ; buttons
;;;238        buttons [1].x = (3 * xres) / 8;
000074  e0810081          ADD      r0,r1,r1,LSL #1
000078  e1a011a0          LSR      r1,r0,#3
00007c  e5851018          STR      r1,[r5,#0x18]  ; buttons
;;;239        buttons [2].x = (3 * xres) / 4 - 1;
000080  e3e01000          MVN      r1,#0
000084  e0810120          ADD      r0,r1,r0,LSR #2
000088  e5850030          STR      r0,[r5,#0x30]  ; buttons
;;;240        buttons [0].y = buttons [1].y = buttons [2].y = 10;
00008c  e3a0000a          MOV      r0,#0xa
000090  e5850034          STR      r0,[r5,#0x34]  ; buttons
000094  e585001c          STR      r0,[r5,#0x1c]  ; buttons
000098  e5850004          STR      r0,[r5,#4]  ; buttons
;;;241        buttons [0].text = "Drag";
00009c  e28f0d05          ADR      r0,|L7.484|
0000a0  e5850010          STR      r0,[r5,#0x10]  ; buttons
;;;242        buttons [1].text = "Draw";
0000a4  e28f0d05          ADR      r0,|L7.492|
0000a8  e5850028          STR      r0,[r5,#0x28]  ; buttons
;;;243        buttons [2].text = "Quit";
0000ac  e28f0d05          ADR      r0,|L7.500|
0000b0  e5850040          STR      r0,[r5,#0x40]  ; buttons
;;;244    
;;;245        refresh_screen ();
0000b4  ebfffffe          BL       refresh_screen
                  |L7.184|
;;;246    
;;;247        while (1)
;;;248        {
;;;249            struct ts_sample samp;
;;;250    
;;;251            /* Show the cross */
;;;252            if ((mode & 15) != 1)
0000b8  e204500f          AND      r5,r4,#0xf
0000bc  e3550001          CMP      r5,#1
0000c0  0a000003          BEQ      |L7.212|
;;;253                put_cross(x, y, 2 | XORMODE);
0000c4  e3a0210a          MOV      r2,#0x80000002
0000c8  e1a0100a          MOV      r1,r10
0000cc  e1a0000b          MOV      r0,r11
0000d0  ebfffffe          BL       put_cross
                  |L7.212|
;;;254    
;;;255            if ( Read_TouchPanel(&sumx, &sumy) > 0)
0000d4  e28d1008          ADD      r1,sp,#8
0000d8  e28d0004          ADD      r0,sp,#4
0000dc  ebfffffe          BL       Read_TouchPanel
0000e0  e3500000          CMP      r0,#0
;;;256            {
;;;257                ts_phy2log(&sumx, &sumy);
;;;258                samp.x = sumx;
;;;259                samp.y = sumy;
;;;260                samp.pressure = 1000;
;;;261            }
;;;262            else
;;;263            {
;;;264                samp.x = x;
0000e4  d1a0600b          MOVLE    r6,r11
;;;265                samp.y = y;
0000e8  d1a0700a          MOVLE    r7,r10
;;;266                samp.pressure = 0;
0000ec  d3a08000          MOVLE    r8,#0
0000f0  da000004          BLE      |L7.264|
0000f4  e28d1008          ADD      r1,sp,#8              ;257
0000f8  e28d0004          ADD      r0,sp,#4              ;257
0000fc  ebfffffe          BL       ts_phy2log
000100  e99d00c0          LDMIB    sp,{r6,r7}            ;260
000104  e3a08ffa          MOV      r8,#0x3e8             ;260
                  |L7.264|
;;;267            }
;;;268            GUI_Delay(10);
000108  e3a0000a          MOV      r0,#0xa
00010c  ebfffffe          BL       GUI_Delay
;;;269    
;;;270            /* Hide it */
;;;271            if ((mode & 15) != 1)
000110  e3550001          CMP      r5,#1
000114  0a000003          BEQ      |L7.296|
;;;272                put_cross(x, y, 2 | XORMODE);
000118  e3a0210a          MOV      r2,#0x80000002
00011c  e1a0100a          MOV      r1,r10
000120  e1a0000b          MOV      r0,r11
000124  ebfffffe          BL       put_cross
                  |L7.296|
;;;273    
;;;274            for (i = 0; i < NR_BUTTONS; i++)
000128  e3a05000          MOV      r5,#0
                  |L7.300|
;;;275                if (button_handle(&buttons [i], samp.x, samp.y, samp.pressure))
00012c  e59f00ac          LDR      r0,|L7.480|
000130  e085c085          ADD      r12,r5,r5,LSL #1
000134  e1a03008          MOV      r3,r8
000138  e1a02007          MOV      r2,r7
00013c  e1a01006          MOV      r1,r6
000140  e080018c          ADD      r0,r0,r12,LSL #3
000144  ebfffffe          BL       button_handle
000148  e3500000          CMP      r0,#0
00014c  0a000009          BEQ      |L7.376|
;;;276                    switch (i)
000150  e3550000          CMP      r5,#0
;;;277                    {
;;;278                    case 0:
;;;279                        mode = 0;
000154  03a04000          MOVEQ    r4,#0
000158  0a000005          BEQ      |L7.372|
00015c  e3550001          CMP      r5,#1                 ;276
;;;280                        refresh_screen ();
;;;281                        break;
;;;282                    case 1:
;;;283                        mode = 1;
000160  03a04001          MOVEQ    r4,#1
000164  0a000002          BEQ      |L7.372|
000168  e3550002          CMP      r5,#2                 ;276
;;;284                        refresh_screen ();
;;;285                        break;
;;;286                    case 2:
;;;287                        quit_pressed = 1;
00016c  03a09001          MOVEQ    r9,#1
000170  ea000000          B        |L7.376|
                  |L7.372|
000174  ebfffffe          BL       refresh_screen
                  |L7.376|
000178  e2855001          ADD      r5,r5,#1              ;281
00017c  e3550003          CMP      r5,#3                 ;274
000180  3affffe9          BCC      |L7.300|
;;;288                    }
;;;289    
;;;290            if (samp.pressure > 0)
000184  e3580000          CMP      r8,#0
;;;291            {
;;;292                if (mode == 0x80000001)
;;;293                    line (x, y, samp.x, samp.y, 2);
;;;294                //pixel(x, y, 2);
;;;295                x = samp.x;
;;;296                y = samp.y;
;;;297                mode |= 0x80000000;
;;;298            }
;;;299            else
;;;300                mode &= ~0x80000000;
000188  03c44102          BICEQ    r4,r4,#0x80000000
00018c  0a00000b          BEQ      |L7.448|
000190  e3540106          CMP      r4,#0x80000001        ;292
000194  1a000006          BNE      |L7.436|
000198  e3a00002          MOV      r0,#2                 ;293
00019c  e58d0000          STR      r0,[sp,#0]            ;293
0001a0  e1a03007          MOV      r3,r7                 ;293
0001a4  e1a02006          MOV      r2,r6                 ;293
0001a8  e1a0100a          MOV      r1,r10                ;293
0001ac  e1a0000b          MOV      r0,r11                ;293
0001b0  ebfffffe          BL       line
                  |L7.436|
0001b4  e1a0b006          MOV      r11,r6                ;295
0001b8  e1a0a007          MOV      r10,r7                ;296
0001bc  e3844102          ORR      r4,r4,#0x80000000     ;297
                  |L7.448|
;;;301            if (quit_pressed)
0001c0  e3590000          CMP      r9,#0
0001c4  0affffbb          BEQ      |L7.184|
;;;302                break;
;;;303        }
;;;304        //fillrect(0, 0, xres - 1, yres - 1, 0);
;;;305        GUI_Clear();
0001c8  ebfffffe          BL       GUI_Clear
;;;306    
;;;307        return 0;
0001cc  e3a00000          MOV      r0,#0
;;;308    }
0001d0  e8bd8ffe          POP      {r1-r11,pc}
                          ENDP

                  |L7.468|
                          DCD      xres
                  |L7.472|
                          DCD      yres
                  |L7.476|
                          DCD      ||.data||
                  |L7.480|
                          DCD      ||.bss||
                  |L7.484|
0001e4  44726167          DCB      "Drag",0
0001e8  00      
0001e9  00                DCB      0
0001ea  00                DCB      0
0001eb  00                DCB      0
                  |L7.492|
0001ec  44726177          DCB      "Draw",0
0001f0  00      
0001f1  00                DCB      0
0001f2  00                DCB      0
0001f3  00                DCB      0
                  |L7.500|
0001f4  51756974          DCB      "Quit",0
0001f8  00      
0001f9  00                DCB      0
0001fa  00                DCB      0
0001fb  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  buttons
                          %        72

                          AREA ||.data||, DATA, ALIGN=2

                  palette
                          DCD      0xff000000
                          DCD      0xffffe080
                          DCD      0xffffffff
                          DCD      0xffe0c0a0
                          DCD      0xff304050
                          DCD      0xff80b8c0
                          DCD      0xff001f7f
                          DCD      0xff1f2020
                          DCD      0xff1f3f5f
                          DCD      0xffcfbfaf
                          DCD      0xffd080f0
                          DCD      0xff7f473f
                          DCD      0xff207820
                  button_palette
                          DCD      0x00000001
                          DCD      0x00000004
                          DCD      0x00000002
                          DCD      0x00000001
                          DCD      0x00000005
                          DCD      0x00000000
