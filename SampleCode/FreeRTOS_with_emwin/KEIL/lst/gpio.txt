; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\gpio.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\gpio.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931 -I..\..\..\Driver\Source -I..\..\..\Driver\Include -I..\..\..\ThirdParty\FATFS\src -I..\..\..\ThirdParty\emWin\Config -I..\..\..\ThirdParty\emWin\Include -I..\..\FreeRTOS_with_emwin -I..\tslib -I..\Application -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\portable\RVDS\ARM9_N9H30 -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Demo\Common\include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Toshiba -D__UVISION_VERSION=526 -D_PANEL_E50A2V1_16BPP_ --omf_browse=.\obj\gpio.crf ..\..\..\Driver\Source\gpio.c]
                          ARM

                          AREA ||i.GPIO_BitIsUsed||, CODE, READONLY, ALIGN=2

                  GPIO_BitIsUsed PROC
;;;628     */
;;;629    BOOL GPIO_BitIsUsed(GPIO_PORT port, UINT32 bit)
000000  e59f2014          LDR      r2,|L1.28|
;;;630    {
;;;631        UINT32 mask;
;;;632        INT32 portIndex;
;;;633    
;;;634        portIndex = (port / 0x40);
000004  e1a00320          LSR      r0,r0,#6
;;;635        mask = (UINT32)bit;
;;;636        
;;;637        return ((gpioCfg.bitBusyFlag[portIndex] & mask)?TRUE:FALSE);
000008  e0820080          ADD      r0,r2,r0,LSL #1
00000c  e1d000b0          LDRH     r0,[r0,#0]
000010  e0100001          ANDS     r0,r0,r1
000014  13a00001          MOVNE    r0,#1
;;;638    }
000018  e12fff1e          BX       lr
;;;639    
                          ENDP

                  |L1.28|
                          DCD      ||.bss||

                          AREA ||i.GPIO_Close||, CODE, READONLY, ALIGN=2

                  GPIO_Close PROC
;;;246     */
;;;247    INT32 GPIO_Close(GPIO_PORT port)
000000  e59f3020          LDR      r3,|L2.40|
;;;248    {
;;;249        INT32 offset;
;;;250        INT32 portIndex;
;;;251    
;;;252        offset = (INT32)port;    
;;;253        portIndex = (port / 0x40);
000004  e1a02320          LSR      r2,r0,#6
;;;254        
;;;255        /* Clean the busy flag */
;;;256        gpioCfg.bitBusyFlag[portIndex] = 0;
000008  e3a01000          MOV      r1,#0
00000c  e0832082          ADD      r2,r3,r2,LSL #1
000010  e1c210b0          STRH     r1,[r2,#0]
;;;257        
;;;258        /* Reset to input */
;;;259        outpw(REG_GPIOA_DIR + offset, 0);
000014  e59f2010          LDR      r2,|L2.44|
000018  e7a01002          STR      r1,[r0,r2]!
;;;260    
;;;261        /* Reset to pull-up */
;;;262        outpw(REG_GPIOA_PUEN + offset, 0); 
00001c  e5801020          STR      r1,[r0,#0x20]
;;;263    
;;;264        return SUCCESSFUL;
000020  e1a00001          MOV      r0,r1
;;;265    }
000024  e12fff1e          BX       lr
;;;266    
                          ENDP

                  |L2.40|
                          DCD      ||.bss||
                  |L2.44|
                          DCD      0xb8003000

                          AREA ||i.GPIO_CloseBit||, CODE, READONLY, ALIGN=2

                  GPIO_CloseBit PROC
;;;436     */
;;;437    INT32 GPIO_CloseBit(GPIO_PORT port, UINT32 bit)
000000  e59f3034          LDR      r3,|L3.60|
;;;438    {
;;;439        UINT32 reg;
;;;440        UINT32 mask;
;;;441        INT32 portIndex;
;;;442        INT32 offset;
;;;443        
;;;444        offset = (INT32)port;
;;;445        portIndex = (port / 0x40);
000004  e1a02320          LSR      r2,r0,#6
;;;446        mask = (UINT32)bit;
;;;447        
;;;448        gpioCfg.bitBusyFlag[portIndex] = gpioCfg.bitBusyFlag[portIndex] & (~mask);
000008  e0832082          ADD      r2,r3,r2,LSL #1
00000c  e1d230b0          LDRH     r3,[r2,#0]
000010  e1c33001          BIC      r3,r3,r1
000014  e1c230b0          STRH     r3,[r2,#0]
;;;449        
;;;450        reg = inpw(REG_GPIOA_DIR + offset);
000018  e59f2020          LDR      r2,|L3.64|
00001c  e7b02002          LDR      r2,[r0,r2]!
;;;451        reg = reg & (~mask);
000020  e1c22001          BIC      r2,r2,r1
;;;452        outpw(REG_GPIOA_DIR + offset, reg);
000024  e5802000          STR      r2,[r0,#0]
;;;453    
;;;454        reg = inpw(REG_GPIOA_PUEN + offset);
000028  e5902020          LDR      r2,[r0,#0x20]
;;;455        reg = reg & (~mask);
00002c  e1c21001          BIC      r1,r2,r1
;;;456        outpw(REG_GPIOA_PUEN + offset, reg);
000030  e5801020          STR      r1,[r0,#0x20]
;;;457    
;;;458        return SUCCESSFUL;
000034  e3a00000          MOV      r0,#0
;;;459    }
000038  e12fff1e          BX       lr
;;;460    
                          ENDP

                  |L3.60|
                          DCD      ||.bss||
                  |L3.64|
                          DCD      0xb8003000

                          AREA ||i.GPIO_Clr||, CODE, READONLY, ALIGN=2

                  GPIO_Clr PROC
;;;302     */
;;;303    INT32 GPIO_Clr(GPIO_PORT port, UINT32 bitMap)
000000  e59f2014          LDR      r2,|L4.28|
;;;304    {
;;;305        INT32 offset;
;;;306        INT32 reg;
;;;307        
;;;308        offset = (INT32)port;
;;;309        
;;;310        reg = inpw(REG_GPIOA_DATAOUT + offset);
000004  e0800002          ADD      r0,r0,r2
000008  e5902004          LDR      r2,[r0,#4]
;;;311        reg = reg & (~bitMap);
00000c  e1c21001          BIC      r1,r2,r1
;;;312        outpw(REG_GPIOA_DATAOUT + offset, reg);
000010  e5801004          STR      r1,[r0,#4]
;;;313    
;;;314        return SUCCESSFUL;
000014  e3a00000          MOV      r0,#0
;;;315    }
000018  e12fff1e          BX       lr
;;;316    
                          ENDP

                  |L4.28|
                          DCD      0xb8003000

                          AREA ||i.GPIO_ClrBit||, CODE, READONLY, ALIGN=2

                  GPIO_ClrBit PROC
;;;545     */
;;;546    INT32 GPIO_ClrBit(GPIO_PORT port, UINT32 bit)
000000  e59f2014          LDR      r2,|L5.28|
;;;547    {
;;;548        UINT32 bitMap;
;;;549        INT32 offset;
;;;550        INT32 reg;
;;;551        
;;;552        offset = (INT32)port;
;;;553        bitMap = (UINT32)bit;
;;;554        
;;;555        reg = inpw(REG_GPIOA_DATAOUT + offset);
000004  e0800002          ADD      r0,r0,r2
000008  e5902004          LDR      r2,[r0,#4]
;;;556        reg = reg & (~bitMap);
00000c  e1c21001          BIC      r1,r2,r1
;;;557        outpw(REG_GPIOA_DATAOUT + offset, reg);
000010  e5801004          STR      r1,[r0,#4]
;;;558    
;;;559        return SUCCESSFUL;
000014  e3a00000          MOV      r0,#0
;;;560    }
000018  e12fff1e          BX       lr
;;;561    
                          ENDP

                  |L5.28|
                          DCD      0xb8003000

                          AREA ||i.GPIO_ClrISR||, CODE, READONLY, ALIGN=2

                  GPIO_ClrISR PROC
;;;499     */
;;;500    INT32 GPIO_ClrISR(GPIO_PORT port, UINT32 bitMap)
000000  e59f200c          LDR      r2,|L6.20|
;;;501    {
;;;502        INT32 offset;
;;;503    
;;;504        offset = (INT32)port;
;;;505    
;;;506        outpw(REG_GPIOA_ISR + offset, bitMap);
000004  e0800002          ADD      r0,r0,r2
000008  e5801018          STR      r1,[r0,#0x18]
;;;507    
;;;508        return SUCCESSFUL;
00000c  e3a00000          MOV      r0,#0
;;;509    }
000010  e12fff1e          BX       lr
;;;510    
                          ENDP

                  |L6.20|
                          DCD      0xb8003000

                          AREA ||i.GPIO_ClrISRBit||, CODE, READONLY, ALIGN=2

                  GPIO_ClrISRBit PROC
;;;521     */
;;;522    INT32 GPIO_ClrISRBit(GPIO_PORT port, UINT32 bit)
000000  e59f200c          LDR      r2,|L7.20|
;;;523    {
;;;524        UINT32 bitMap;
;;;525        INT32 offset;
;;;526    
;;;527        offset = (INT32)port;
;;;528        bitMap = (UINT32)bit;
;;;529    
;;;530        outpw(REG_GPIOA_ISR + offset, bitMap);
000004  e0800002          ADD      r0,r0,r2
000008  e5801018          STR      r1,[r0,#0x18]
;;;531    
;;;532        return SUCCESSFUL;
00000c  e3a00000          MOV      r0,#0
;;;533    }
000010  e12fff1e          BX       lr
;;;534    
                          ENDP

                  |L7.20|
                          DCD      0xb8003000

                          AREA ||i.GPIO_DisableDebounce||, CODE, READONLY, ALIGN=2

                  GPIO_DisableDebounce PROC
;;;931     */
;;;932    INT32 GPIO_DisableDebounce(void)
000000  e59f1014          LDR      r1,|L8.28|
;;;933    {
;;;934        UINT32 reg;
;;;935    
;;;936        reg = inpw(REG_GPIO_DBNCECON);
000004  e59103f0          LDR      r0,[r1,#0x3f0]
;;;937    
;;;938        /* Setting the debounce timing */
;;;939        reg = ((reg & ~0xf));
000008  e3c0000f          BIC      r0,r0,#0xf
;;;940    
;;;941        /* Enable the debounce function */
;;;942        reg = reg | 0x20;
00000c  e3800020          ORR      r0,r0,#0x20
;;;943        outpw(REG_GPIO_DBNCECON, reg);
000010  e58103f0          STR      r0,[r1,#0x3f0]
;;;944        
;;;945        return SUCCESSFUL;
000014  e3a00000          MOV      r0,#0
;;;946    }
000018  e12fff1e          BX       lr
;;;947    
                          ENDP

                  |L8.28|
                          DCD      0xb8003000

                          AREA ||i.GPIO_DisableEINT||, CODE, READONLY, ALIGN=2

                  GPIO_DisableEINT PROC
;;;873     */
;;;874    INT32 GPIO_DisableEINT(GPIO_NIRQ nIrq)
000000  e92d4010          PUSH     {r4,lr}
;;;875    {
000004  e1a04000          MOV      r4,r0
;;;876        sysDisableInterrupt((IRQn_Type)(nIrq+4));
000008  e2800004          ADD      r0,r0,#4
00000c  e20000ff          AND      r0,r0,#0xff
000010  ebfffffe          BL       sysDisableInterrupt
;;;877        gpioCfg.IRQCallback[nIrq] = NULL;
000014  e59f0014          LDR      r0,|L9.48|
000018  e3a01000          MOV      r1,#0
00001c  e0800104          ADD      r0,r0,r4,LSL #2
;;;878        gpioCfg.IRQUserData[nIrq] = 0;
000020  e5801014          STR      r1,[r0,#0x14]
000024  e580103c          STR      r1,[r0,#0x3c]
;;;879        return SUCCESSFUL;
000028  e1a00001          MOV      r0,r1
;;;880    }
00002c  e8bd8010          POP      {r4,pc}
;;;881    
                          ENDP

                  |L9.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_DisableInt||, CODE, READONLY, ALIGN=2

                  GPIO_DisableInt PROC
;;;676     */
;;;677    INT32 GPIO_DisableInt(GPIO_PORT port)
000000  e59f1048          LDR      r1,|L10.80|
;;;678    {
;;;679        INT32 i,portIndex;
;;;680        portIndex = (INT32)port/0x40;
000004  e1a00320          LSR      r0,r0,#6
000008  e92d4010          PUSH     {r4,lr}               ;678
;;;681    
;;;682        gpioCfg.IRQCallback[portIndex] = NULL;
00000c  e3a02000          MOV      r2,#0
000010  e0810100          ADD      r0,r1,r0,LSL #2
;;;683        gpioCfg.IRQUserData[portIndex] = 0;
000014  e5802014          STR      r2,[r0,#0x14]
000018  e580203c          STR      r2,[r0,#0x3c]
;;;684    
;;;685        for(i=0;i<MAX_PORT;i++)
00001c  e1a00002          MOV      r0,r2
                  |L10.32|
;;;686          if(gpioCfg.IRQCallback[i]!=0) 
000020  e0812100          ADD      r2,r1,r0,LSL #2
000024  e5922014          LDR      r2,[r2,#0x14]
000028  e3520000          CMP      r2,#0
00002c  0a000001          BEQ      |L10.56|
                  |L10.48|
;;;687            return SUCCESSFUL;
000030  e3a00000          MOV      r0,#0
;;;688        sysDisableInterrupt(GPIO_IRQn);
;;;689        return SUCCESSFUL;
;;;690    }
000034  e8bd8010          POP      {r4,pc}
                  |L10.56|
000038  e2800001          ADD      r0,r0,#1              ;687
00003c  e350000a          CMP      r0,#0xa               ;685
000040  bafffff6          BLT      |L10.32|
000044  e3a00039          MOV      r0,#0x39              ;688
000048  ebfffffe          BL       sysDisableInterrupt
00004c  eafffff7          B        |L10.48|
;;;691    
                          ENDP

                  |L10.80|
                          DCD      ||.bss||

                          AREA ||i.GPIO_DisableTriggerType||, CODE, READONLY, ALIGN=2

                  GPIO_DisableTriggerType PROC
;;;844     */
;;;845    INT32 GPIO_DisableTriggerType(GPIO_PORT port, UINT32 bitMap)
000000  e59f202c          LDR      r2,|L11.52|
;;;846    {
;;;847        UINT32 reg;
;;;848        INT32 offset;
;;;849        
;;;850        offset = (INT32)port;
;;;851    
;;;852        reg = inpw(REG_GPIOA_IMD+offset);
000004  e0800002          ADD      r0,r0,r2
000008  e590200c          LDR      r2,[r0,#0xc]
;;;853        outpw(REG_GPIOA_IMD +offset,reg & ~bitMap);
00000c  e1c22001          BIC      r2,r2,r1
000010  e580200c          STR      r2,[r0,#0xc]
;;;854    
;;;855        reg = inpw(REG_GPIOA_IREN+offset);
000014  e5902010          LDR      r2,[r0,#0x10]
;;;856        outpw(REG_GPIOA_IREN+offset,reg & ~bitMap);
000018  e1c22001          BIC      r2,r2,r1
00001c  e5802010          STR      r2,[r0,#0x10]
;;;857    
;;;858        reg = inpw(REG_GPIOA_IFEN+offset);
000020  e5902014          LDR      r2,[r0,#0x14]
;;;859        outpw(REG_GPIOA_IFEN+offset,reg & ~bitMap);
000024  e1c21001          BIC      r1,r2,r1
000028  e5801014          STR      r1,[r0,#0x14]
;;;860    
;;;861        return SUCCESSFUL;
00002c  e3a00000          MOV      r0,#0
;;;862    }
000030  e12fff1e          BX       lr
;;;863    
                          ENDP

                  |L11.52|
                          DCD      0xb8003000

                          AREA ||i.GPIO_EnableDebounce||, CODE, READONLY, ALIGN=2

                  GPIO_EnableDebounce PROC
;;;907     */
;;;908    INT32 GPIO_EnableDebounce(INT32 debounceClkSel)
000000  e59f2018          LDR      r2,|L12.32|
;;;909    {
;;;910        UINT32 reg;
;;;911    
;;;912        reg = inpw(REG_GPIO_DBNCECON);
000004  e59213f0          LDR      r1,[r2,#0x3f0]
;;;913    
;;;914        /* Setting the debounce timing */
;;;915        reg = ((reg & ~0xf) | debounceClkSel);
000008  e3c1100f          BIC      r1,r1,#0xf
00000c  e1800001          ORR      r0,r0,r1
;;;916    
;;;917        /* Enable the debounce function */
;;;918        reg = reg | 0x20;
000010  e3800020          ORR      r0,r0,#0x20
;;;919        outpw(REG_GPIO_DBNCECON, reg);
000014  e58203f0          STR      r0,[r2,#0x3f0]
;;;920        
;;;921        return SUCCESSFUL;
000018  e3a00000          MOV      r0,#0
;;;922    }
00001c  e12fff1e          BX       lr
;;;923    
                          ENDP

                  |L12.32|
                          DCD      0xb8003000

                          AREA ||i.GPIO_EnableEINT||, CODE, READONLY, ALIGN=2

                  GPIO_EnableEINT PROC
;;;703     */
;;;704    INT32 GPIO_EnableEINT(GPIO_NIRQ nIrq, GPIO_CALLBACK callback, UINT32 userData)
000000  e92d4010          PUSH     {r4,lr}
;;;705    {
;;;706        if(callback != NULL)
000004  e3510000          CMP      r1,#0
000008  e1a04000          MOV      r4,r0                 ;705
00000c  0a000003          BEQ      |L13.32|
;;;707        {
;;;708            gpioCfg.EINTIRQCallback[nIrq] = (GPIO_CALLBACK)callback;
000010  e59f010c          LDR      r0,|L13.292|
000014  e0803104          ADD      r3,r0,r4,LSL #2
;;;709            gpioCfg.EINTIRQUserData[nIrq] = userData;
000018  e5a31064          STR      r1,[r3,#0x64]!
00001c  e5832020          STR      r2,[r3,#0x20]
                  |L13.32|
;;;710        }
;;;711        sysSetLocalInterrupt(ENABLE_IRQ);
000020  e3a0007f          MOV      r0,#0x7f
000024  ebfffffe          BL       sysSetLocalInterrupt
;;;712        switch(nIrq)
000028  e3540008          CMP      r4,#8
00002c  308ff104          ADDCC    pc,pc,r4,LSL #2
000030  ea000013          B        |L13.132|
000034  ea000006          B        |L13.84|
000038  ea00000b          B        |L13.108|
00003c  ea000014          B        |L13.148|
000040  ea000019          B        |L13.172|
000044  ea00001e          B        |L13.196|
000048  ea000023          B        |L13.220|
00004c  ea000028          B        |L13.244|
000050  ea00002d          B        |L13.268|
                  |L13.84|
;;;713        {
;;;714        case 0:
;;;715          sysInstallISR(IRQ_LEVEL_7, EINT0_IRQn, (PVOID)GPIO_IRQHandler0);
000054  e59f20cc          LDR      r2,|L13.296|
000058  e3a01004          MOV      r1,#4
00005c  e3a00007          MOV      r0,#7
000060  ebfffffe          BL       sysInstallISR
;;;716          sysEnableInterrupt(EINT0_IRQn);
000064  e3a00004          MOV      r0,#4
;;;717        break;
000068  ea000004          B        |L13.128|
                  |L13.108|
;;;718    
;;;719        case 1:
;;;720          sysInstallISR(IRQ_LEVEL_7, EINT1_IRQn, (PVOID)GPIO_IRQHandler1);
00006c  e59f20b8          LDR      r2,|L13.300|
000070  e3a01005          MOV      r1,#5
000074  e3a00007          MOV      r0,#7
000078  ebfffffe          BL       sysInstallISR
;;;721          sysEnableInterrupt(EINT1_IRQn);
00007c  e3a00005          MOV      r0,#5
                  |L13.128|
000080  ebfffffe          BL       sysEnableInterrupt
                  |L13.132|
;;;722        break;
;;;723    
;;;724        case 2:
;;;725          sysInstallISR(IRQ_LEVEL_7, EINT2_IRQn, (PVOID)GPIO_IRQHandler2);
;;;726          sysEnableInterrupt(EINT2_IRQn);
;;;727        break;
;;;728    
;;;729        case 3:
;;;730          sysInstallISR(IRQ_LEVEL_7, EINT3_IRQn, (PVOID)GPIO_IRQHandler3);
;;;731          sysEnableInterrupt(EINT3_IRQn);
;;;732        break;
;;;733    
;;;734        case 4:
;;;735          sysInstallISR(IRQ_LEVEL_7, EINT4_IRQn, (PVOID)GPIO_IRQHandler4);
;;;736          sysEnableInterrupt(EINT4_IRQn);
;;;737        break;
;;;738    
;;;739        case 5:
;;;740          sysInstallISR(IRQ_LEVEL_7, EINT5_IRQn, (PVOID)GPIO_IRQHandler5);
;;;741          sysEnableInterrupt(EINT5_IRQn);
;;;742        break;
;;;743    
;;;744        case 6:
;;;745          sysInstallISR(IRQ_LEVEL_7, EINT6_IRQn, (PVOID)GPIO_IRQHandler6);
;;;746          sysEnableInterrupt(EINT6_IRQn);
;;;747        break;
;;;748    
;;;749        case 7:
;;;750          sysInstallISR(IRQ_LEVEL_7, EINT7_IRQn, (PVOID)GPIO_IRQHandler7);
;;;751          sysEnableInterrupt(EINT7_IRQn);
;;;752        break;
;;;753       };
;;;754        sysSetLocalInterrupt(ENABLE_IRQ);
000084  e3a0007f          MOV      r0,#0x7f
000088  ebfffffe          BL       sysSetLocalInterrupt
;;;755        return SUCCESSFUL;
00008c  e3a00000          MOV      r0,#0
;;;756    }
000090  e8bd8010          POP      {r4,pc}
                  |L13.148|
000094  e59f2094          LDR      r2,|L13.304|
000098  e3a01006          MOV      r1,#6                 ;725
00009c  e3a00007          MOV      r0,#7                 ;725
0000a0  ebfffffe          BL       sysInstallISR
0000a4  e3a00006          MOV      r0,#6                 ;726
0000a8  eafffff4          B        |L13.128|
                  |L13.172|
0000ac  e3a01007          MOV      r1,#7                 ;730
0000b0  e59f207c          LDR      r2,|L13.308|
0000b4  e1a00001          MOV      r0,r1                 ;730
0000b8  ebfffffe          BL       sysInstallISR
0000bc  e3a00007          MOV      r0,#7                 ;731
0000c0  eaffffee          B        |L13.128|
                  |L13.196|
0000c4  e59f206c          LDR      r2,|L13.312|
0000c8  e3a01008          MOV      r1,#8                 ;735
0000cc  e3a00007          MOV      r0,#7                 ;735
0000d0  ebfffffe          BL       sysInstallISR
0000d4  e3a00008          MOV      r0,#8                 ;736
0000d8  eaffffe8          B        |L13.128|
                  |L13.220|
0000dc  e59f2058          LDR      r2,|L13.316|
0000e0  e3a01009          MOV      r1,#9                 ;740
0000e4  e3a00007          MOV      r0,#7                 ;740
0000e8  ebfffffe          BL       sysInstallISR
0000ec  e3a00009          MOV      r0,#9                 ;741
0000f0  eaffffe2          B        |L13.128|
                  |L13.244|
0000f4  e59f2044          LDR      r2,|L13.320|
0000f8  e3a0100a          MOV      r1,#0xa               ;745
0000fc  e3a00007          MOV      r0,#7                 ;745
000100  ebfffffe          BL       sysInstallISR
000104  e3a0000a          MOV      r0,#0xa               ;746
000108  eaffffdc          B        |L13.128|
                  |L13.268|
00010c  e59f2030          LDR      r2,|L13.324|
000110  e3a0100b          MOV      r1,#0xb               ;750
000114  e3a00007          MOV      r0,#7                 ;750
000118  ebfffffe          BL       sysInstallISR
00011c  e3a0000b          MOV      r0,#0xb               ;751
000120  eaffffd6          B        |L13.128|
;;;757    
                          ENDP

                  |L13.292|
                          DCD      ||.bss||
                  |L13.296|
                          DCD      GPIO_IRQHandler0
                  |L13.300|
                          DCD      GPIO_IRQHandler1
                  |L13.304|
                          DCD      GPIO_IRQHandler2
                  |L13.308|
                          DCD      GPIO_IRQHandler3
                  |L13.312|
                          DCD      GPIO_IRQHandler4
                  |L13.316|
                          DCD      GPIO_IRQHandler5
                  |L13.320|
                          DCD      GPIO_IRQHandler6
                  |L13.324|
                          DCD      GPIO_IRQHandler7

                          AREA ||i.GPIO_EnableInt||, CODE, READONLY, ALIGN=2

                  GPIO_EnableInt PROC
;;;651     */
;;;652    INT32 GPIO_EnableInt(GPIO_PORT port, GPIO_CALLBACK callback, UINT32 userData)
000000  e92d4010          PUSH     {r4,lr}
;;;653    {
;;;654        INT32 portIndex;
;;;655        portIndex = (INT32)port/0x40;
;;;656        if(callback != NULL)
000004  e3510000          CMP      r1,#0
000008  e1a00320          LSR      r0,r0,#6              ;655
00000c  0a000003          BEQ      |L14.32|
;;;657        {
;;;658            gpioCfg.IRQCallback[portIndex] = (GPIO_CALLBACK)callback;
000010  e59f3030          LDR      r3,|L14.72|
000014  e0830100          ADD      r0,r3,r0,LSL #2
;;;659            gpioCfg.IRQUserData[portIndex] = userData;
000018  e5a01014          STR      r1,[r0,#0x14]!
00001c  e5802028          STR      r2,[r0,#0x28]
                  |L14.32|
;;;660        }
;;;661        sysInstallISR(IRQ_LEVEL_7, GPIO_IRQn, (PVOID)GPIO_IRQHandler);
000020  e59f2024          LDR      r2,|L14.76|
000024  e3a01039          MOV      r1,#0x39
000028  e3a00007          MOV      r0,#7
00002c  ebfffffe          BL       sysInstallISR
;;;662        sysEnableInterrupt(GPIO_IRQn);
000030  e3a00039          MOV      r0,#0x39
000034  ebfffffe          BL       sysEnableInterrupt
;;;663        sysSetLocalInterrupt(ENABLE_IRQ);
000038  e3a0007f          MOV      r0,#0x7f
00003c  ebfffffe          BL       sysSetLocalInterrupt
;;;664        return SUCCESSFUL;
000040  e3a00000          MOV      r0,#0
;;;665    }
000044  e8bd8010          POP      {r4,pc}
;;;666    
                          ENDP

                  |L14.72|
                          DCD      ||.bss||
                  |L14.76|
                          DCD      GPIO_IRQHandler

                          AREA ||i.GPIO_EnableTriggerType||, CODE, READONLY, ALIGN=2

                  GPIO_EnableTriggerType PROC
;;;770     */
;;;771    INT32 GPIO_EnableTriggerType(GPIO_PORT port, UINT32 bitMap, GPIO_TRIGGER_TYPE triggerType)
000000  e59f30a4          LDR      r3,|L15.172|
;;;772    {
;;;773        UINT32 reg;
;;;774        INT32 offset;
;;;775        
;;;776        offset = (INT32)port;
;;;777    
;;;778        switch(triggerType)
000004  e3520005          CMP      r2,#5
;;;779        {
;;;780           case LOW:
;;;781             reg = inpw(REG_GPIOA_IMD+offset);
000008  e0800003          ADD      r0,r0,r3
00000c  308ff102          ADDCC    pc,pc,r2,LSL #2       ;778
000010  ea00000b          B        |L15.68|
000014  ea000003          B        |L15.40|
000018  ea000005          B        |L15.52|
00001c  ea00000a          B        |L15.76|
000020  ea00000f          B        |L15.100|
000024  ea000017          B        |L15.136|
                  |L15.40|
000028  e590200c          LDR      r2,[r0,#0xc]
;;;782             outpw(REG_GPIOA_IMD+offset,reg | bitMap);
00002c  e1822001          ORR      r2,r2,r1
;;;783    
;;;784             reg = inpw(REG_GPIOA_IREN+offset);
;;;785             outpw(REG_GPIOA_IREN+offset,reg & ~bitMap);
;;;786    
;;;787             reg = inpw(REG_GPIOA_IFEN+offset);
;;;788             outpw(REG_GPIOA_IFEN+offset,reg  | bitMap);
;;;789           break;
000030  ea000007          B        |L15.84|
                  |L15.52|
;;;790           case HIGH:
;;;791             reg = inpw(REG_GPIOA_IMD+offset);
000034  e590200c          LDR      r2,[r0,#0xc]
;;;792             outpw(REG_GPIOA_IMD+offset,reg | bitMap);
000038  e1822001          ORR      r2,r2,r1
;;;793    
;;;794             reg = inpw(REG_GPIOA_IREN+offset);
;;;795             outpw(REG_GPIOA_IREN+offset,reg | bitMap);
;;;796    
;;;797             reg = inpw(REG_GPIOA_IFEN+offset);
;;;798             outpw(REG_GPIOA_IFEN+offset,reg & ~bitMap);
;;;799           break;
00003c  ea00000a          B        |L15.108|
                  |L15.64|
000040  e5801014          STR      r1,[r0,#0x14]         ;788
                  |L15.68|
;;;800           case FALLING:
;;;801             reg = inpw(REG_GPIOA_IMD+offset);
;;;802             outpw(REG_GPIOA_IMD+offset,reg & ~bitMap);
;;;803    
;;;804             reg = inpw(REG_GPIOA_IREN+offset);
;;;805             outpw(REG_GPIOA_IREN+offset,reg & ~bitMap);
;;;806    
;;;807             reg = inpw(REG_GPIOA_IFEN+offset);
;;;808             outpw(REG_GPIOA_IFEN+offset,reg  | bitMap);
;;;809           break;
;;;810           case RISING:
;;;811             reg = inpw(REG_GPIOA_IMD+offset);
;;;812             outpw(REG_GPIOA_IMD+offset,reg & ~bitMap);
;;;813    
;;;814             reg = inpw(REG_GPIOA_IREN+offset);
;;;815             outpw(REG_GPIOA_IREN+offset,reg | bitMap);
;;;816    
;;;817             reg = inpw(REG_GPIOA_IFEN+offset);
;;;818             outpw(REG_GPIOA_IFEN+offset,reg & ~bitMap);
;;;819           break;
;;;820           case BOTH_EDGE:
;;;821             reg = inpw(REG_GPIOA_IMD+offset);
;;;822             outpw(REG_GPIOA_IMD+offset,reg & ~bitMap);
;;;823    
;;;824             reg = inpw(REG_GPIOA_IREN+offset);
;;;825             outpw(REG_GPIOA_IREN+offset,reg | bitMap);
;;;826    
;;;827             reg = inpw(REG_GPIOA_IFEN+offset);
;;;828             outpw(REG_GPIOA_IFEN+offset,reg | bitMap);
;;;829           break;
;;;830        }
;;;831        return SUCCESSFUL;
000044  e3a00000          MOV      r0,#0
;;;832    }
000048  e12fff1e          BX       lr
                  |L15.76|
00004c  e590200c          LDR      r2,[r0,#0xc]          ;801
000050  e1c22001          BIC      r2,r2,r1              ;802
                  |L15.84|
000054  e580200c          STR      r2,[r0,#0xc]          ;782
000058  e5902010          LDR      r2,[r0,#0x10]         ;784
00005c  e1c22001          BIC      r2,r2,r1              ;785
000060  ea00000d          B        |L15.156|
                  |L15.100|
000064  e590200c          LDR      r2,[r0,#0xc]          ;811
000068  e1c22001          BIC      r2,r2,r1              ;812
                  |L15.108|
00006c  e580200c          STR      r2,[r0,#0xc]          ;812
000070  e5902010          LDR      r2,[r0,#0x10]         ;814
000074  e1822001          ORR      r2,r2,r1              ;815
000078  e5802010          STR      r2,[r0,#0x10]         ;815
00007c  e5902014          LDR      r2,[r0,#0x14]         ;817
000080  e1c21001          BIC      r1,r2,r1              ;818
000084  eaffffed          B        |L15.64|
                  |L15.136|
000088  e590200c          LDR      r2,[r0,#0xc]          ;821
00008c  e1c22001          BIC      r2,r2,r1              ;822
000090  e580200c          STR      r2,[r0,#0xc]          ;822
000094  e5902010          LDR      r2,[r0,#0x10]         ;824
000098  e1822001          ORR      r2,r2,r1              ;825
                  |L15.156|
00009c  e5802010          STR      r2,[r0,#0x10]         ;825
0000a0  e5902014          LDR      r2,[r0,#0x14]         ;827
0000a4  e1811002          ORR      r1,r1,r2              ;828
0000a8  eaffffe4          B        |L15.64|
;;;833    
                          ENDP

                  |L15.172|
                          DCD      0xb8003000

                          AREA ||i.GPIO_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler PROC
;;;33      */
;;;34     void GPIO_IRQHandler(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;35     {
;;;36         UINT32 reg; 
;;;37         INT32 i,mask;
;;;38         reg = inpw(REG_AIC_ISRH); 
000004  e59f8054          LDR      r8,|L16.96|
000008  e5980114          LDR      r0,[r8,#0x114]
;;;39         mask = 0x02000000; /* INT56 */
00000c  e3a06402          MOV      r6,#0x2000000
;;;40         reg = inpw(REG_GPIO_ISR);
000010  e18876c6          ORR      r7,r8,r6,ASR #13
000014  e59753fc          LDR      r5,[r7,#0x3fc]
;;;41         for(i=0;i<MAX_PORT;i++)
;;;42         if( gpioCfg.IRQCallback[i] != NULL && (reg & (1<<i)) ){
000018  e59f9044          LDR      r9,|L16.100|
00001c  e3a04000          MOV      r4,#0                 ;41
000020  e3a0a001          MOV      r10,#1
                  |L16.36|
000024  e0890104          ADD      r0,r9,r4,LSL #2
000028  e5902014          LDR      r2,[r0,#0x14]
00002c  e3520000          CMP      r2,#0
000030  11a0141a          LSLNE    r1,r10,r4
000034  11110005          TSTNE    r1,r5
000038  0a000003          BEQ      |L16.76|
;;;43           gpioCfg.IRQCallback[i](inpw(REG_GPIOA_ISR+i*0x40), gpioCfg.IRQUserData[i]);
00003c  e590103c          LDR      r1,[r0,#0x3c]
000040  e0870304          ADD      r0,r7,r4,LSL #6
000044  e5900018          LDR      r0,[r0,#0x18]
000048  e12fff32          BLX      r2
                  |L16.76|
00004c  e2844001          ADD      r4,r4,#1
000050  e354000a          CMP      r4,#0xa               ;41
;;;44         }
;;;45         outpw(REG_AIC_SCCRH, mask);   /* Clear interrupt */
000054  a588614c          STRGE    r6,[r8,#0x14c]
000058  bafffff1          BLT      |L16.36|
;;;46     }
00005c  e8bd87f0          POP      {r4-r10,pc}
;;;47     
                          ENDP

                  |L16.96|
                          DCD      0xb8002000
                  |L16.100|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler0||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler0 PROC
;;;52      */
;;;53     void GPIO_IRQHandler0(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;54     {
;;;55         UINT32 reg;    
;;;56         INT32 mask;
;;;57         reg = inpw(REG_AIC_ISR);
000004  e59f5020          LDR      r5,|L17.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;58         mask = 0x10;
;;;59         if(gpioCfg.EINTIRQCallback[0] != NULL){
00000c  e59f101c          LDR      r1,|L17.48|
000010  e3a04010          MOV      r4,#0x10              ;58
000014  e5912064          LDR      r2,[r1,#0x64]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;60           gpioCfg.EINTIRQCallback[0](reg, gpioCfg.EINTIRQUserData[0]);
00001c  15911084          LDRNE    r1,[r1,#0x84]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;61         }
;;;62         outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;63     }
000028  e8bd8070          POP      {r4-r6,pc}
;;;64     
                          ENDP

                  |L17.44|
                          DCD      0xb8002000
                  |L17.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler1||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler1 PROC
;;;69      */
;;;70     void GPIO_IRQHandler1(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;71     {
;;;72         UINT32 reg;    
;;;73         INT32 mask;
;;;74         reg = inpw(REG_AIC_ISR); 
000004  e59f5020          LDR      r5,|L18.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;75         mask = 0x20;
;;;76         if(gpioCfg.EINTIRQCallback[1] != NULL){
00000c  e59f101c          LDR      r1,|L18.48|
000010  e3a04020          MOV      r4,#0x20              ;75
000014  e5912068          LDR      r2,[r1,#0x68]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;77           gpioCfg.EINTIRQCallback[1](reg, gpioCfg.EINTIRQUserData[1]);
00001c  15911088          LDRNE    r1,[r1,#0x88]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;78         }
;;;79         outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;80     }
000028  e8bd8070          POP      {r4-r6,pc}
;;;81     
                          ENDP

                  |L18.44|
                          DCD      0xb8002000
                  |L18.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler2||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler2 PROC
;;;86      */
;;;87     void GPIO_IRQHandler2(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;88     {
;;;89         UINT32 reg;    
;;;90         INT32 mask;
;;;91         reg = inpw(REG_AIC_ISR); 
000004  e59f5020          LDR      r5,|L19.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;92         mask = 0x40;
;;;93         if(gpioCfg.EINTIRQCallback[2] != NULL){
00000c  e59f101c          LDR      r1,|L19.48|
000010  e3a04040          MOV      r4,#0x40              ;92
000014  e591206c          LDR      r2,[r1,#0x6c]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;94           gpioCfg.EINTIRQCallback[2](reg, gpioCfg.EINTIRQUserData[2]);
00001c  1591108c          LDRNE    r1,[r1,#0x8c]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;95         }
;;;96         outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;97     }
000028  e8bd8070          POP      {r4-r6,pc}
;;;98     
                          ENDP

                  |L19.44|
                          DCD      0xb8002000
                  |L19.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler3||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler3 PROC
;;;103     */
;;;104    void GPIO_IRQHandler3(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;105    {
;;;106        UINT32 reg;    
;;;107        INT32 mask;
;;;108        reg = inpw(REG_AIC_ISR); 
000004  e59f5020          LDR      r5,|L20.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;109        mask = 0x80;
;;;110        if(gpioCfg.EINTIRQCallback[3] != NULL){
00000c  e59f101c          LDR      r1,|L20.48|
000010  e3a04080          MOV      r4,#0x80              ;109
000014  e5912070          LDR      r2,[r1,#0x70]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;111          gpioCfg.EINTIRQCallback[3](reg, gpioCfg.EINTIRQUserData[3]);
00001c  15911090          LDRNE    r1,[r1,#0x90]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;112        }
;;;113        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;114    }
000028  e8bd8070          POP      {r4-r6,pc}
;;;115    
                          ENDP

                  |L20.44|
                          DCD      0xb8002000
                  |L20.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler4||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler4 PROC
;;;120     */
;;;121    void GPIO_IRQHandler4(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;122    {
;;;123        UINT32 reg;    
;;;124        INT32 mask;
;;;125        reg = inpw(REG_AIC_ISR); 
000004  e59f5020          LDR      r5,|L21.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;126        mask = 0x100;
;;;127        if(gpioCfg.EINTIRQCallback[4] != NULL){
00000c  e59f101c          LDR      r1,|L21.48|
000010  e3a04c01          MOV      r4,#0x100             ;126
000014  e5912074          LDR      r2,[r1,#0x74]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;128          gpioCfg.EINTIRQCallback[4](reg, gpioCfg.EINTIRQUserData[4]);
00001c  15911094          LDRNE    r1,[r1,#0x94]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;129        }
;;;130        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;131    }
000028  e8bd8070          POP      {r4-r6,pc}
;;;132    
                          ENDP

                  |L21.44|
                          DCD      0xb8002000
                  |L21.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler5||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler5 PROC
;;;137     */
;;;138    void GPIO_IRQHandler5(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;139    {
;;;140        UINT32 reg;    
;;;141        INT32 mask;
;;;142        reg = inpw(REG_AIC_ISR); 
000004  e59f5020          LDR      r5,|L22.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;143        mask = 0x200;
;;;144        if(gpioCfg.EINTIRQCallback[5] != NULL){
00000c  e59f101c          LDR      r1,|L22.48|
000010  e3a04c02          MOV      r4,#0x200             ;143
000014  e5912078          LDR      r2,[r1,#0x78]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;145          gpioCfg.EINTIRQCallback[5](reg, gpioCfg.EINTIRQUserData[5]);
00001c  15911098          LDRNE    r1,[r1,#0x98]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;146        }
;;;147        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;148    }
000028  e8bd8070          POP      {r4-r6,pc}
;;;149    
                          ENDP

                  |L22.44|
                          DCD      0xb8002000
                  |L22.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler6||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler6 PROC
;;;154     */
;;;155    void GPIO_IRQHandler6(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;156    {
;;;157        UINT32 reg;    
;;;158        INT32 mask;
;;;159        reg = inpw(REG_AIC_ISR); 
000004  e59f5020          LDR      r5,|L23.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;160        mask = 0x400;
;;;161        if(gpioCfg.EINTIRQCallback[6] != NULL){
00000c  e59f101c          LDR      r1,|L23.48|
000010  e3a04b01          MOV      r4,#0x400             ;160
000014  e591207c          LDR      r2,[r1,#0x7c]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;162          gpioCfg.EINTIRQCallback[6](reg, gpioCfg.EINTIRQUserData[6]);
00001c  1591109c          LDRNE    r1,[r1,#0x9c]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;163        }
;;;164        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;165    }
000028  e8bd8070          POP      {r4-r6,pc}
;;;166    
                          ENDP

                  |L23.44|
                          DCD      0xb8002000
                  |L23.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_IRQHandler7||, CODE, READONLY, ALIGN=2

                  GPIO_IRQHandler7 PROC
;;;171     */
;;;172    void GPIO_IRQHandler7(void)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;173    {
;;;174        UINT32 reg;    
;;;175        INT32 mask;
;;;176        reg = inpw(REG_AIC_ISR); 
000004  e59f5020          LDR      r5,|L24.44|
000008  e5950110          LDR      r0,[r5,#0x110]
;;;177        mask = 0x800;
;;;178        if(gpioCfg.EINTIRQCallback[7] != NULL){
00000c  e59f101c          LDR      r1,|L24.48|
000010  e3a04b02          MOV      r4,#0x800             ;177
000014  e5912080          LDR      r2,[r1,#0x80]  ; gpioCfg
000018  e3520000          CMP      r2,#0
;;;179          gpioCfg.EINTIRQCallback[7](reg, gpioCfg.EINTIRQUserData[7]);
00001c  159110a0          LDRNE    r1,[r1,#0xa0]  ; gpioCfg
000020  112fff32          BLXNE    r2
;;;180        }
;;;181        outpw(REG_AIC_SCCR, mask);   /* Clear interrupt */
000024  e5854148          STR      r4,[r5,#0x148]
;;;182    }
000028  e8bd8070          POP      {r4-r6,pc}
;;;183    
                          ENDP

                  |L24.44|
                          DCD      0xb8002000
                  |L24.48|
                          DCD      ||.bss||

                          AREA ||i.GPIO_Open||, CODE, READONLY, ALIGN=2

                  GPIO_Open PROC
;;;195     */
;;;196    INT32 GPIO_Open(GPIO_PORT port, GPIO_DIR direction, GPIO_PULL pull)
000000  e92d4010          PUSH     {r4,lr}
;;;197    {
;;;198        UINT32 mask;
;;;199        INT32 portIndex;
;;;200        INT32 offset;
;;;201        
;;;202        outpw(REG_CLK_PCLKEN0,inpw(REG_CLK_PCLKEN0) | (1<<3)); //Enable GPIO engin clock.
000004  e3a0320b          MOV      r3,#0xb0000000
000008  e593c218          LDR      r12,[r3,#0x218]
00000c  e38cc008          ORR      r12,r12,#8
000010  e583c218          STR      r12,[r3,#0x218]
;;;203        offset = (INT32)port;
;;;204        portIndex = port / 0x40;
;;;205        mask = maskTbl[portIndex];    
000014  e59f304c          LDR      r3,|L25.104|
;;;206        
;;;207        if(gpioCfg.bitBusyFlag[portIndex] != 0)
000018  e59f404c          LDR      r4,|L25.108|
00001c  e1a0c320          LSR      r12,r0,#6             ;204
000020  e793310c          LDR      r3,[r3,r12,LSL #2]    ;205
000024  e084c08c          ADD      r12,r4,r12,LSL #1
000028  e1dc40b0          LDRH     r4,[r12,#0]
00002c  e3540000          CMP      r4,#0
;;;208        {
;;;209            return GPIO_ERR_PORT_BUSY;
000030  13e00000          MVNNE    r0,#0
;;;210        }
;;;211        
;;;212        /* Set all bits in the port to busy */
;;;213        gpioCfg.bitBusyFlag[portIndex] = mask;
;;;214        
;;;215        /* Set port direction */
;;;216        if(direction == DIR_OUTPUT)
;;;217        {
;;;218            outpw(REG_GPIOA_DIR + offset , mask);
;;;219        }
;;;220        else
;;;221        {
;;;222            outpw(REG_GPIOA_DIR + offset , 0); 
;;;223        }
;;;224    
;;;225        if(pull == PULL_UP)
;;;226        {
;;;227            outpw(REG_GPIOA_PUEN + offset , mask);
;;;228        }
;;;229        else
;;;230        {
;;;231            outpw(REG_GPIOA_PUEN + offset , 0);
;;;232        }
;;;233    
;;;234        return SUCCESSFUL;
;;;235    }
000034  18bd8010          POPNE    {r4,pc}
000038  e1cc30b0          STRH     r3,[r12,#0]           ;213
00003c  e59f402c          LDR      r4,|L25.112|
000040  e3510001          CMP      r1,#1                 ;216
000044  e0800004          ADD      r0,r0,r4              ;218
000048  e3a0c000          MOV      r12,#0                ;213
00004c  05803000          STREQ    r3,[r0,#0]            ;218
000050  1580c000          STRNE    r12,[r0,#0]           ;222
000054  e3520001          CMP      r2,#1                 ;225
000058  05803020          STREQ    r3,[r0,#0x20]         ;227
00005c  1580c020          STRNE    r12,[r0,#0x20]        ;231
000060  e3a00000          MOV      r0,#0                 ;234
000064  e8bd8010          POP      {r4,pc}
;;;236    
                          ENDP

                  |L25.104|
                          DCD      ||.data||
                  |L25.108|
                          DCD      ||.bss||
                  |L25.112|
                          DCD      0xb8003000

                          AREA ||i.GPIO_OpenBit||, CODE, READONLY, ALIGN=2

                  GPIO_OpenBit PROC
;;;383     */
;;;384    INT32 GPIO_OpenBit(GPIO_PORT port, UINT32 bit, GPIO_DIR direction, GPIO_PULL pull)
000000  e92d4030          PUSH     {r4,r5,lr}
;;;385    {
;;;386        UINT32 reg;
;;;387        UINT32 mask;
;;;388        INT32 portIndex;
;;;389        INT32 offset;
;;;390    
;;;391        outpw(REG_CLK_PCLKEN0,inpw(REG_CLK_PCLKEN0) | (1<<3)); //Enable GPIO engin clock.
000004  e3a0c20b          MOV      r12,#0xb0000000
000008  e59c4218          LDR      r4,[r12,#0x218]
00000c  e3844008          ORR      r4,r4,#8
000010  e58c4218          STR      r4,[r12,#0x218]
;;;392        offset = (INT32)port;
;;;393        portIndex = (port / 0x040);
;;;394        mask = (UINT32)bit;
;;;395        
;;;396        if((gpioCfg.bitBusyFlag[portIndex]&mask) != 0)
000014  e59f4050          LDR      r4,|L26.108|
000018  e1a0c320          LSR      r12,r0,#6             ;393
00001c  e084c08c          ADD      r12,r4,r12,LSL #1
000020  e1dc40b0          LDRH     r4,[r12,#0]
000024  e1140001          TST      r4,r1
;;;397        {
;;;398            return GPIO_ERR_BIT_BUSY;
000028  13e00002          MVNNE    r0,#2
;;;399        }
;;;400    
;;;401        gpioCfg.bitBusyFlag[portIndex] = gpioCfg.bitBusyFlag[portIndex] | mask;
;;;402        
;;;403        reg = inpw(REG_GPIOA_DIR + offset);
;;;404        reg = reg & (~mask);
;;;405    
;;;406        if(direction == DIR_OUTPUT)
;;;407        {
;;;408            reg = reg | mask;
;;;409        }
;;;410        
;;;411        outpw(REG_GPIOA_DIR + offset, reg);
;;;412    
;;;413        reg = inpw(REG_GPIOA_PUEN + offset);
;;;414        reg = reg & (~mask);
;;;415    
;;;416        if(pull == PULL_UP)
;;;417        {
;;;418            reg = reg | mask;
;;;419        }
;;;420    
;;;421        outpw(REG_GPIOA_PUEN + offset, reg);
;;;422    
;;;423        return SUCCESSFUL;
;;;424    }
00002c  18bd8030          POPNE    {r4,r5,pc}
000030  e1844001          ORR      r4,r4,r1              ;401
000034  e1cc40b0          STRH     r4,[r12,#0]           ;401
000038  e59fc030          LDR      r12,|L26.112|
00003c  e7b0c00c          LDR      r12,[r0,r12]!         ;403
000040  e3520001          CMP      r2,#1                 ;406
000044  e1ccc001          BIC      r12,r12,r1            ;404
000048  018cc001          ORREQ    r12,r12,r1            ;408
00004c  e580c000          STR      r12,[r0,#0]           ;411
000050  e5902020          LDR      r2,[r0,#0x20]         ;413
000054  e3530001          CMP      r3,#1                 ;416
000058  e1c22001          BIC      r2,r2,r1              ;414
00005c  01822001          ORREQ    r2,r2,r1              ;418
000060  e5802020          STR      r2,[r0,#0x20]         ;421
000064  e3a00000          MOV      r0,#0                 ;423
000068  e8bd8030          POP      {r4,r5,pc}
;;;425    
                          ENDP

                  |L26.108|
                          DCD      ||.bss||
                  |L26.112|
                          DCD      0xb8003000

                          AREA ||i.GPIO_ReadBit||, CODE, READONLY, ALIGN=2

                  GPIO_ReadBit PROC
;;;571     */
;;;572    INT32 GPIO_ReadBit(GPIO_PORT port, UINT32 bit)
000000  e59f2010          LDR      r2,|L27.24|
;;;573    {
;;;574        UINT32 reg;
;;;575        UINT32 bitMap;
;;;576        INT32 offset;
;;;577    
;;;578        offset = (INT32)port;
;;;579        bitMap = (UINT32)bit;
;;;580        
;;;581        reg = inpw(REG_GPIOA_DATAIN + offset);
000004  e0800002          ADD      r0,r0,r2
000008  e5900008          LDR      r0,[r0,#8]
;;;582        
;;;583        return ((reg & bitMap)?1:0);
00000c  e0100001          ANDS     r0,r0,r1
000010  13a00001          MOVNE    r0,#1
;;;584    }
000014  e12fff1e          BX       lr
;;;585    
                          ENDP

                  |L27.24|
                          DCD      0xb8003000

                          AREA ||i.GPIO_ReadPort||, CODE, READONLY, ALIGN=2

                  GPIO_ReadPort PROC
;;;326     */
;;;327    UINT32 GPIO_ReadPort(GPIO_PORT port)
000000  e59f1008          LDR      r1,|L28.16|
;;;328    {
;;;329        UINT32 reg;
;;;330        INT32 offset;
;;;331        
;;;332        offset = (INT32)port;
;;;333        
;;;334        reg = inpw(REG_GPIOA_DATAIN + offset);
000004  e0800001          ADD      r0,r0,r1
000008  e5900008          LDR      r0,[r0,#8]
;;;335    
;;;336        return reg;
;;;337    }
00000c  e12fff1e          BX       lr
;;;338    
                          ENDP

                  |L28.16|
                          DCD      0xb8003000

                          AREA ||i.GPIO_Set||, CODE, READONLY, ALIGN=2

                  GPIO_Set PROC
;;;277     */
;;;278    INT32 GPIO_Set(GPIO_PORT port, UINT32 bitMap)
000000  e59f2014          LDR      r2,|L29.28|
;;;279    {
;;;280        INT32 offset;
;;;281        INT32 reg;
;;;282        
;;;283        offset = (INT32)port;
;;;284        
;;;285        reg = inpw(REG_GPIOA_DATAOUT + offset);
000004  e0800002          ADD      r0,r0,r2
000008  e5902004          LDR      r2,[r0,#4]
;;;286        reg = reg | bitMap;
00000c  e1811002          ORR      r1,r1,r2
;;;287        outpw(REG_GPIOA_DATAOUT + offset, reg);
000010  e5801004          STR      r1,[r0,#4]
;;;288    
;;;289        return SUCCESSFUL;
000014  e3a00000          MOV      r0,#0
;;;290    }
000018  e12fff1e          BX       lr
;;;291    
                          ENDP

                  |L29.28|
                          DCD      0xb8003000

                          AREA ||i.GPIO_SetBit||, CODE, READONLY, ALIGN=2

                  GPIO_SetBit PROC
;;;472     */
;;;473    INT32 GPIO_SetBit(GPIO_PORT port, UINT32 bit)
000000  e59f2014          LDR      r2,|L30.28|
;;;474    {
;;;475        UINT32 bitMap;
;;;476        INT32 offset;
;;;477        INT32 reg;
;;;478        
;;;479        offset = (INT32)port;
;;;480        bitMap = (UINT32)bit;
;;;481        
;;;482        reg = inpw(REG_GPIOA_DATAOUT + offset);
000004  e0800002          ADD      r0,r0,r2
000008  e5902004          LDR      r2,[r0,#4]
;;;483        reg = reg | bitMap;
00000c  e1811002          ORR      r1,r1,r2
;;;484        outpw(REG_GPIOA_DATAOUT + offset, reg);
000010  e5801004          STR      r1,[r0,#4]
;;;485    
;;;486        return SUCCESSFUL;
000014  e3a00000          MOV      r0,#0
;;;487    }
000018  e12fff1e          BX       lr
;;;488    
                          ENDP

                  |L30.28|
                          DCD      0xb8003000

                          AREA ||i.GPIO_SetBitDir||, CODE, READONLY, ALIGN=2

                  GPIO_SetBitDir PROC
;;;597     */
;;;598    INT32 GPIO_SetBitDir(GPIO_PORT port, UINT32 bit, GPIO_DIR direction)
000000  e59f301c          LDR      r3,|L31.36|
;;;599    {
;;;600        UINT32 reg;
;;;601        UINT32 bitMap;
;;;602        INT32 offset;
;;;603        
;;;604        offset = (INT32)port;
;;;605        bitMap = (UINT32)bit;
;;;606        
;;;607        reg = inpw(REG_GPIOA_DIR + offset);
000004  e0833000          ADD      r3,r3,r0
000008  e5930000          LDR      r0,[r3,#0]
;;;608        reg = reg & (~bitMap);
;;;609        
;;;610        if(direction == DIR_OUTPUT)
00000c  e3520001          CMP      r2,#1
000010  e1c00001          BIC      r0,r0,r1              ;608
;;;611        {
;;;612            reg = reg | bitMap;
000014  01800001          ORREQ    r0,r0,r1
;;;613        }
;;;614    
;;;615        outpw(REG_GPIOA_DIR + offset, reg);
000018  e5830000          STR      r0,[r3,#0]
;;;616    
;;;617        return SUCCESSFUL;
00001c  e3a00000          MOV      r0,#0
;;;618    }
000020  e12fff1e          BX       lr
;;;619    
                          ENDP

                  |L31.36|
                          DCD      0xb8003000

                          AREA ||i.GPIO_SetPortDir||, CODE, READONLY, ALIGN=2

                  GPIO_SetPortDir PROC
;;;348     */
;;;349    INT32 GPIO_SetPortDir(GPIO_PORT port, GPIO_DIR direction)
000000  e59f3024          LDR      r3,|L32.44|
;;;350    {
;;;351        INT32 offset;
;;;352        INT32 mask;
;;;353        INT32 portIndex;
;;;354        
;;;355        offset = (INT32)port;
;;;356        portIndex = (port / 0x40);
000004  e1a02320          LSR      r2,r0,#6
;;;357        mask = maskTbl[portIndex];
000008  e7932102          LDR      r2,[r3,r2,LSL #2]
;;;358        
;;;359        if(direction == DIR_OUTPUT)
;;;360        {
;;;361            outpw(REG_GPIOA_DIR + offset, mask);
00000c  e59f301c          LDR      r3,|L32.48|
000010  e3510001          CMP      r1,#1                 ;359
000014  e0800003          ADD      r0,r0,r3
000018  05802000          STREQ    r2,[r0,#0]
;;;362        }
;;;363        else
;;;364        {
;;;365            outpw(REG_GPIOA_DIR + offset, 0x0);
00001c  13a01000          MOVNE    r1,#0
000020  15801000          STRNE    r1,[r0,#0]
;;;366        }
;;;367    
;;;368        return SUCCESSFUL;
000024  e3a00000          MOV      r0,#0
;;;369    }
000028  e12fff1e          BX       lr
;;;370    
                          ENDP

                  |L32.44|
                          DCD      ||.data||
                  |L32.48|
                          DCD      0xb8003000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  gpioCfg
                          %        164

                          AREA ||.data||, DATA, ALIGN=2

                  maskTbl
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x00007fff
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x0000003f
