; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\lcd.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\lcd.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931 -I..\..\..\Driver\Source -I..\..\..\Driver\Include -I..\..\..\ThirdParty\FATFS\src -I..\..\..\ThirdParty\emWin\Config -I..\..\..\ThirdParty\emWin\Include -I..\..\FreeRTOS_with_emwin -I..\tslib -I..\Application -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\portable\RVDS\ARM9_N9H30 -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Demo\Common\include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Toshiba -D__UVISION_VERSION=526 -D_PANEL_E50A2V1_16BPP_ --omf_browse=.\obj\lcd.crf ..\..\..\Driver\Source\lcd.c]
                          ARM

                          AREA ||i.shift_pointer||, CODE, READONLY, ALIGN=2

                  shift_pointer PROC
;;;118    /* For align 32 */
;;;119    static uint32_t shift_pointer(uint32_t ptr, uint32_t align)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;120    {
000004  e1a04001          MOV      r4,r1
000008  e1a05000          MOV      r5,r0
;;;121        uint32_t alignedPTR;
;;;122        uint32_t remain;
;;;123    
;;;124        //printf("pointer position is %x\n",ptr);
;;;125        if( (ptr%align)!=0) {
00000c  ebfffffe          BL       __aeabi_uidivmod
000010  e3510000          CMP      r1,#0
;;;126            remain = ptr % align;
;;;127            alignedPTR = ptr + (align - remain);
000014  10440001          SUBNE    r0,r4,r1
000018  10800005          ADDNE    r0,r0,r5
;;;128            return alignedPTR;
;;;129        }
;;;130        return ptr;
00001c  01a00005          MOVEQ    r0,r5
;;;131    }
000020  e8bd8070          POP      {r4-r6,pc}
;;;132    
                          ENDP


                          AREA ||i.vpostGetFrameBuffer||, CODE, READONLY, ALIGN=2

                  vpostGetFrameBuffer PROC
;;;183      */
;;;184    uint8_t* vpostGetFrameBuffer(void)
000000  e59f0064          LDR      r0,|L2.108|
;;;185    {
000004  e92d4010          PUSH     {r4,lr}
;;;186        uint8_t* u8BufPtr;
;;;187        uint8_t u32BytePerPixel;
;;;188    
;;;189        if((curDisplayDev.u32DevWidth == 0) || (curDisplayDev.u32DevHeight == 0))
000008  e5901000          LDR      r1,[r0,#0]  ; curDisplayDev
00000c  e3510000          CMP      r1,#0
000010  15902004          LDRNE    r2,[r0,#4]  ; curDisplayDev
000014  13520000          CMPNE    r2,#0
;;;190            return NULL;
000018  03a00000          MOVEQ    r0,#0
;;;191    
;;;192        switch(curVADev.ucVASrcFormat) {
;;;193            case VA_SRC_YUV422:
;;;194            case VA_SRC_YCBCR422:
;;;195            case VA_SRC_RGB565:
;;;196                u32BytePerPixel = 2;
;;;197                break;
;;;198    
;;;199            case VA_SRC_RGB666:
;;;200            case VA_SRC_RGB888:
;;;201                u32BytePerPixel = 4;
;;;202                break;
;;;203    
;;;204            default:
;;;205                u32BytePerPixel = 2;
;;;206        }
;;;207    
;;;208        u8BufPtr = (uint8_t *)malloc((curDisplayDev.u32DevWidth * curDisplayDev.u32DevHeight * u32BytePerPixel)+32);
;;;209        u8BufPtr = (uint8_t *)shift_pointer((uint32_t)u8BufPtr, 32);
;;;210    
;;;211        outpw(REG_LCM_VA_BADDR0, (uint32_t)((uint32_t)u8BufPtr | 0x80000000));
;;;212        outpw(REG_LCM_VA_FBCTRL, inpw(REG_LCM_VA_FBCTRL) & ~(1<<30) & ~VPOSTB_DB_EN);
;;;213    
;;;214        return (uint8_t *)((uint32_t)u8BufPtr | 0x80000000);
;;;215    }
00001c  08bd8010          POPEQ    {r4,pc}
000020  e0010192          MUL      r1,r2,r1              ;208
000024  e59f0044          LDR      r0,|L2.112|
000028  e5900000          LDR      r0,[r0,#0]            ;192  ; curVADev
00002c  e3500c02          CMP      r0,#0x200             ;192
000030  c3500c03          CMPGT    r0,#0x300             ;192
000034  03a00004          MOVEQ    r0,#4                 ;201
000038  13a00002          MOVNE    r0,#2                 ;196
00003c  e0000091          MUL      r0,r1,r0              ;208
000040  e2800020          ADD      r0,r0,#0x20           ;208
000044  ebfffffe          BL       malloc
000048  e3a01020          MOV      r1,#0x20              ;209
00004c  ebfffffe          BL       shift_pointer
000050  e59f101c          LDR      r1,|L2.116|
000054  e3800102          ORR      r0,r0,#0x80000000     ;211
000058  e5810024          STR      r0,[r1,#0x24]         ;211
00005c  e591202c          LDR      r2,[r1,#0x2c]         ;212
000060  e3c22103          BIC      r2,r2,#0xc0000000     ;212
000064  e581202c          STR      r2,[r1,#0x2c]         ;212
000068  e8bd8010          POP      {r4,pc}
;;;216    
                          ENDP

                  |L2.108|
                          DCD      ||.bss||+0x30
                  |L2.112|
                          DCD      ||.bss||+0x1c
                  |L2.116|
                          DCD      0xb0008000

                          AREA ||i.vpostGetMultiFrameBuffer||, CODE, READONLY, ALIGN=2

                  vpostGetMultiFrameBuffer PROC
;;;224      */
;;;225    uint8_t* vpostGetMultiFrameBuffer(uint32_t u32Cnt)
000000  e59f106c          LDR      r1,|L3.116|
;;;226    {
000004  e92d4010          PUSH     {r4,lr}
;;;227        uint8_t* u8BufPtr;
;;;228        uint8_t u32BytePerPixel;
;;;229    
;;;230        if((curDisplayDev.u32DevWidth == 0) || (curDisplayDev.u32DevHeight == 0) || (u32Cnt == 0))
000008  e5912000          LDR      r2,[r1,#0]  ; curDisplayDev
00000c  e3520000          CMP      r2,#0
000010  15913004          LDRNE    r3,[r1,#4]  ; curDisplayDev
000014  13530000          CMPNE    r3,#0
000018  13500000          CMPNE    r0,#0
;;;231            return NULL;
00001c  03a00000          MOVEQ    r0,#0
;;;232    
;;;233        switch(curVADev.ucVASrcFormat) {
;;;234            case VA_SRC_YUV422:
;;;235            case VA_SRC_YCBCR422:
;;;236            case VA_SRC_RGB565:
;;;237                u32BytePerPixel = 2;
;;;238                break;
;;;239    
;;;240            case VA_SRC_RGB666:
;;;241            case VA_SRC_RGB888:
;;;242                u32BytePerPixel = 4;
;;;243                break;
;;;244    
;;;245            default:
;;;246                u32BytePerPixel = 2;
;;;247        }
;;;248    
;;;249        u8BufPtr = (uint8_t *)malloc((curDisplayDev.u32DevWidth * curDisplayDev.u32DevHeight * u32BytePerPixel) * u32Cnt + 32);
;;;250        u8BufPtr = (uint8_t *)shift_pointer((uint32_t)u8BufPtr, 32);
;;;251    
;;;252        outpw(REG_LCM_VA_BADDR0, (uint32_t)((uint32_t)u8BufPtr | 0x80000000));
;;;253        outpw(REG_LCM_VA_FBCTRL, inpw(REG_LCM_VA_FBCTRL) & ~(1<<30) & ~VPOSTB_DB_EN);
;;;254    
;;;255        return (uint8_t *)((uint32_t)u8BufPtr | 0x80000000);
;;;256    }
000020  08bd8010          POPEQ    {r4,pc}
000024  e0020293          MUL      r2,r3,r2              ;249
000028  e59f1048          LDR      r1,|L3.120|
00002c  e5911000          LDR      r1,[r1,#0]            ;233  ; curVADev
000030  e3510c02          CMP      r1,#0x200             ;233
000034  c3510c03          CMPGT    r1,#0x300             ;233
000038  03a01004          MOVEQ    r1,#4                 ;242
00003c  13a01002          MOVNE    r1,#2                 ;237
000040  e0010192          MUL      r1,r2,r1              ;249
000044  e0000091          MUL      r0,r1,r0              ;249
000048  e2800020          ADD      r0,r0,#0x20           ;249
00004c  ebfffffe          BL       malloc
000050  e3a01020          MOV      r1,#0x20              ;250
000054  ebfffffe          BL       shift_pointer
000058  e59f101c          LDR      r1,|L3.124|
00005c  e3800102          ORR      r0,r0,#0x80000000     ;252
000060  e5810024          STR      r0,[r1,#0x24]         ;252
000064  e591202c          LDR      r2,[r1,#0x2c]         ;253
000068  e3c22103          BIC      r2,r2,#0xc0000000     ;253
00006c  e581202c          STR      r2,[r1,#0x2c]         ;253
000070  e8bd8010          POP      {r4,pc}
;;;257    
                          ENDP

                  |L3.116|
                          DCD      ||.bss||+0x30
                  |L3.120|
                          DCD      ||.bss||+0x1c
                  |L3.124|
                          DCD      0xb0008000

                          AREA ||i.vpostGetOSDBuffer||, CODE, READONLY, ALIGN=2

                  vpostGetOSDBuffer PROC
;;;475      */
;;;476    uint8_t* vpostGetOSDBuffer(void)
000000  e59f0054          LDR      r0,|L4.92|
;;;477    {
000004  e92d4010          PUSH     {r4,lr}
;;;478        uint32_t u32BytePerPixel;
;;;479        uint8_t* u8BufPtr;
;;;480    
;;;481        if ((curOSDDev.nOSDWidth == 0) || (curOSDDev.nOSDHeight == 0)) {
000008  e590200c          LDR      r2,[r0,#0xc]  ; curOSDDev
00000c  e3520000          CMP      r2,#0
000010  15901010          LDRNE    r1,[r0,#0x10]  ; curOSDDev
000014  13510000          CMPNE    r1,#0
;;;482            return NULL;
000018  03a00000          MOVEQ    r0,#0
;;;483        }
;;;484    
;;;485        switch(curOSDDev.ucOSDSrcFormat) {
;;;486            case OSD_SRC_YUV422:
;;;487            case OSD_SRC_YCBCR422:
;;;488            case OSD_SRC_RGB565:
;;;489                u32BytePerPixel = 2;
;;;490                break;
;;;491    
;;;492            case OSD_SRC_RGB666:
;;;493            case OSD_SRC_RGB888:
;;;494                u32BytePerPixel = 4;
;;;495                break;
;;;496    
;;;497            default:
;;;498                u32BytePerPixel = 2;
;;;499        }
;;;500    
;;;501        u8BufPtr = (uint8_t *)malloc((curOSDDev.nOSDWidth * curOSDDev.nOSDHeight * u32BytePerPixel)+32);
;;;502        u8BufPtr = (uint8_t *)shift_pointer((uint32_t)u8BufPtr, 32);
;;;503    
;;;504        outpw(REG_LCM_OSD_BADDR, (uint32_t)((uint32_t)u8BufPtr | 0x80000000));
;;;505    
;;;506        return (uint8_t *)((uint32_t)u8BufPtr | 0x80000000);
;;;507    }
00001c  08bd8010          POPEQ    {r4,pc}
000020  e5900000          LDR      r0,[r0,#0]            ;485  ; curOSDDev
000024  e0010192          MUL      r1,r2,r1              ;501
000028  e3500a02          CMP      r0,#0x2000            ;485
00002c  c3500a03          CMPGT    r0,#0x3000            ;485
000030  03a00004          MOVEQ    r0,#4                 ;494
000034  13a00002          MOVNE    r0,#2                 ;489
000038  e0000091          MUL      r0,r1,r0              ;501
00003c  e2800020          ADD      r0,r0,#0x20           ;501
000040  ebfffffe          BL       malloc
000044  e3a01020          MOV      r1,#0x20              ;502
000048  ebfffffe          BL       shift_pointer
00004c  e59f100c          LDR      r1,|L4.96|
000050  e3800102          ORR      r0,r0,#0x80000000     ;504
000054  e5810048          STR      r0,[r1,#0x48]         ;504
000058  e8bd8010          POP      {r4,pc}
;;;508    
                          ENDP

                  |L4.92|
                          DCD      ||.bss||
                  |L4.96|
                          DCD      0xb0008000

                          AREA ||i.vpostHCInit||, CODE, READONLY, ALIGN=2

                  vpostHCInit PROC
;;;565      */
;;;566    void vpostHCInit(uint32_t *u32CursorBMPBuff, VA_HCMODE_E ucMode)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;567    {
;;;568        int bpp=2;
;;;569        int BlockWidth=32;
;;;570        int bpw=32;
;;;571    
;;;572        outpw(REG_LCM_HC_CTRL, inpw(REG_LCM_HC_CTRL) &~0x003f3f00 | (0x00<<8) | (0x00<<16));//set TIP
000004  e59f4104          LDR      r4,|L5.272|
000008  e1a05000          MOV      r5,r0                 ;567
00000c  e594c06c          LDR      r12,[r4,#0x6c]
000010  e3a00020          MOV      r0,#0x20              ;569
000014  e3a02002          MOV      r2,#2                 ;568
000018  e1a03000          MOV      r3,r0                 ;570
00001c  e3ccc83f          BIC      r12,r12,#0x3f0000
000020  e3cccc3f          BIC      r12,r12,#0x3f00
000024  e584c06c          STR      r12,[r4,#0x6c]
;;;573        if (ucMode == HC_MODE0) {
000028  e3510000          CMP      r1,#0
;;;574            bpp=2;
;;;575            BlockWidth=32;
;;;576            outpw(REG_LCM_HC_CTRL, inpw(REG_LCM_HC_CTRL) &~0x7);//set mode 0 32X32X2bpp 4 color
00002c  0594106c          LDREQ    r1,[r4,#0x6c]
000030  03c11007          BICEQ    r1,r1,#7
000034  0a000022          BEQ      |L5.196|
;;;577    
;;;578        } else if (ucMode == HC_MODE1) {
000038  e3510001          CMP      r1,#1
;;;579            bpp=2;
;;;580            BlockWidth=32;
;;;581            outpw(REG_LCM_HC_CTRL, inpw(REG_LCM_HC_CTRL) &~0x7 | 0x1);//set mode 1 32X32X2bpp 3 color and 1 transparent
00003c  0594106c          LDREQ    r1,[r4,#0x6c]
000040  03c11007          BICEQ    r1,r1,#7
000044  03811001          ORREQ    r1,r1,#1
000048  0a00001d          BEQ      |L5.196|
;;;582        } else if (ucMode == HC_MODE2) {
00004c  e3510002          CMP      r1,#2
000050  0a000006          BEQ      |L5.112|
;;;583            bpp=2;
;;;584            BlockWidth=64;
;;;585            outpw(REG_LCM_HC_CTRL, inpw(REG_LCM_HC_CTRL) &~0x7 | 0x2);//set mode 2 64X64X2bpp 4 color
;;;586        } else if (ucMode == HC_MODE3) {
000054  e3510003          CMP      r1,#3
000058  0a000009          BEQ      |L5.132|
;;;587            bpp=2;
;;;588            BlockWidth=64;
;;;589            outpw(REG_LCM_HC_CTRL, inpw(REG_LCM_HC_CTRL) &~0x7 | 0x3);//set mode 3 64X64X2bpp 3 color and 1 transparent
;;;590        } else if (ucMode == HC_MODE4) {
00005c  e3510004          CMP      r1,#4
000060  0a00000c          BEQ      |L5.152|
;;;591            bpp=1;
;;;592            BlockWidth=128;
;;;593            outpw(REG_LCM_HC_CTRL, inpw(REG_LCM_HC_CTRL) &~0x7 | 0x4);//set mode 4 128X128X1bpp 2 color
;;;594        } else if (ucMode == HC_MODE5) {
000064  e3510005          CMP      r1,#5
000068  0a000010          BEQ      |L5.176|
00006c  ea000015          B        |L5.200|
                  |L5.112|
000070  e594106c          LDR      r1,[r4,#0x6c]         ;585
000074  e3a00040          MOV      r0,#0x40              ;584
000078  e3c11007          BIC      r1,r1,#7              ;585
00007c  e3811002          ORR      r1,r1,#2              ;585
000080  ea00000f          B        |L5.196|
                  |L5.132|
000084  e594106c          LDR      r1,[r4,#0x6c]         ;589
000088  e3a00040          MOV      r0,#0x40              ;588
00008c  e3c11007          BIC      r1,r1,#7              ;589
000090  e3811003          ORR      r1,r1,#3              ;589
000094  ea00000a          B        |L5.196|
                  |L5.152|
000098  e594106c          LDR      r1,[r4,#0x6c]         ;593
00009c  e3a02001          MOV      r2,#1                 ;591
0000a0  e3a00080          MOV      r0,#0x80              ;592
0000a4  e3c11007          BIC      r1,r1,#7              ;593
0000a8  e3811004          ORR      r1,r1,#4              ;593
0000ac  ea000004          B        |L5.196|
                  |L5.176|
;;;595            bpp=1;
;;;596            BlockWidth=128;
;;;597            outpw(REG_LCM_HC_CTRL, inpw(REG_LCM_HC_CTRL) &~0x7 | 0x5);//set mode 5 128X128X1bpp 1 color and 1 transparent
0000b0  e594106c          LDR      r1,[r4,#0x6c]
0000b4  e3a02001          MOV      r2,#1                 ;595
0000b8  e3a00080          MOV      r0,#0x80              ;596
0000bc  e3c11007          BIC      r1,r1,#7
0000c0  e3811005          ORR      r1,r1,#5
                  |L5.196|
0000c4  e584106c          STR      r1,[r4,#0x6c]
                  |L5.200|
;;;598        }
;;;599    
;;;600        outpw(REG_LCM_HC_WBCTRL,((bpp*BlockWidth/bpw)<<16) | (bpp*BlockWidth/bpw) );
0000c8  e1600082          SMULBB   r0,r2,r0
0000cc  e1a01003          MOV      r1,r3
0000d0  ebfffffe          BL       __aeabi_idivmod
0000d4  e1800800          ORR      r0,r0,r0,LSL #16
0000d8  e5840074          STR      r0,[r4,#0x74]
;;;601        outpw(REG_LCM_HC_BADDR,(uint32_t)u32CursorBMPBuff);
0000dc  e5845078          STR      r5,[r4,#0x78]
;;;602        outpw(REG_LCM_HC_COLOR0, 0x00ff0000);       // RED color
0000e0  e3a008ff          MOV      r0,#0xff0000
0000e4  e584007c          STR      r0,[r4,#0x7c]
;;;603        outpw(REG_LCM_HC_COLOR1, 0x0000ff00);       // GREEN color
0000e8  e3a00cff          MOV      r0,#0xff00
0000ec  e5840080          STR      r0,[r4,#0x80]
;;;604        outpw(REG_LCM_HC_COLOR2, 0x000000ff);       // BLUE color
0000f0  e3a000ff          MOV      r0,#0xff
0000f4  e5840084          STR      r0,[r4,#0x84]
;;;605        outpw(REG_LCM_HC_COLOR3, 0x00ffff00);       // YELLOW color
0000f8  e59f0014          LDR      r0,|L5.276|
0000fc  e5840088          STR      r0,[r4,#0x88]
;;;606        outpw(REG_LCM_DCCS,inpw(REG_LCM_DCCS) | VPOSTB_HC_EN);
000100  e5940000          LDR      r0,[r4,#0]
000104  e3800102          ORR      r0,r0,#0x80000000
000108  e5840000          STR      r0,[r4,#0]
;;;607    }
00010c  e8bd8070          POP      {r4-r6,pc}
;;;608    
                          ENDP

                  |L5.272|
                          DCD      0xb0008000
                  |L5.276|
                          DCD      0x00ffff00

                          AREA ||i.vpostHCPosCtrl||, CODE, READONLY, ALIGN=2

                  vpostHCPosCtrl PROC
;;;614      */
;;;615    void vpostHCPosCtrl(uint32_t u32CursorX, uint32_t u32CursorY)
000000  e1800801          ORR      r0,r0,r1,LSL #16
;;;616    {
;;;617        outpw(REG_LCM_HC_POS, (u32CursorY <<16) | u32CursorX);  //set Cursor position
000004  e59f1004          LDR      r1,|L6.16|
000008  e5810070          STR      r0,[r1,#0x70]
;;;618    }
00000c  e12fff1e          BX       lr
;;;619    
                          ENDP

                  |L6.16|
                          DCD      0xb0008000

                          AREA ||i.vpostLCMDeinit||, CODE, READONLY, ALIGN=2

                  vpostLCMDeinit PROC
;;;168      */
;;;169    void vpostLCMDeinit(void)
000000  e3a0020b          MOV      r0,#0xb0000000
;;;170    {
;;;171        // disable lcd engine clock
;;;172        outpw(REG_CLK_HCLKEN, inpw(REG_CLK_HCLKEN) & ~(1<<25));
000004  e5901210          LDR      r1,[r0,#0x210]
000008  e3c11402          BIC      r1,r1,#0x2000000
00000c  e5801210          STR      r1,[r0,#0x210]
;;;173    
;;;174        sysDisableInterrupt(LCD_IRQn);
000010  e3a0000d          MOV      r0,#0xd
000014  eafffffe          B        sysDisableInterrupt
;;;175    }
;;;176    
                          ENDP


                          AREA ||i.vpostLCMInit||, CODE, READONLY, ALIGN=2

                  vpostLCMInit PROC
;;;139      */
;;;140    void vpostLCMInit(uint32_t u32DisplayPanelID)
000000  e92d4010          PUSH     {r4,lr}
;;;141    {
;;;142        // enable lcd engine clock
;;;143        outpw(REG_CLK_HCLKEN, inpw(REG_CLK_HCLKEN) | (1<<25));
000004  e3a0120b          MOV      r1,#0xb0000000
000008  e5912210          LDR      r2,[r1,#0x210]
00000c  e1a04000          MOV      r4,r0                 ;141
000010  e3822402          ORR      r2,r2,#0x2000000
000014  e5812210          STR      r2,[r1,#0x210]
;;;144    
;;;145        memset((void *)&curDisplayDev, 0, sizeof(curDisplayDev));
000018  e59f0084          LDR      r0,|L8.164|
00001c  e3a01038          MOV      r1,#0x38
000020  ebfffffe          BL       __aeabi_memclr4
;;;146        memcpy((void *)&curDisplayDev, DisplayDevList[u32DisplayPanelID], sizeof(curDisplayDev));
000024  e59f107c          LDR      r1,|L8.168|
000028  e59f0074          LDR      r0,|L8.164|
00002c  e7911104          LDR      r1,[r1,r4,LSL #2]
000030  e3a02038          MOV      r2,#0x38
000034  ebfffffe          BL       __aeabi_memcpy4
;;;147    
;;;148        outpw(REG_LCM_DEV_CTRL,   curDisplayDev.u32CmdLow
000038  e59f0064          LDR      r0,|L8.164|
00003c  e5901008          LDR      r1,[r0,#8]  ; curDisplayDev, curDisplayDev
000040  e590200c          LDR      r2,[r0,#0xc]
000044  e1811002          ORR      r1,r1,r2
000048  e5902010          LDR      r2,[r0,#0x10]  ; curDisplayDev
00004c  e1811002          ORR      r1,r1,r2
000050  e5902014          LDR      r2,[r0,#0x14]  ; curDisplayDev
000054  e1811002          ORR      r1,r1,r2
000058  e5902018          LDR      r2,[r0,#0x18]  ; curDisplayDev
00005c  e1811002          ORR      r1,r1,r2
000060  e590201c          LDR      r2,[r0,#0x1c]  ; curDisplayDev
000064  e1811002          ORR      r1,r1,r2
000068  e5902020          LDR      r2,[r0,#0x20]  ; curDisplayDev
00006c  e1822001          ORR      r2,r2,r1
000070  e59f1034          LDR      r1,|L8.172|
000074  e5812004          STR      r2,[r1,#4]
;;;149              | curDisplayDev.u32Cmd16t18
;;;150              | curDisplayDev.u32CmdBusWidth
;;;151              | curDisplayDev.u32DataBusWidth
;;;152              | curDisplayDev.u32MPU_Mode
;;;153              | curDisplayDev.u32DisplayColors
;;;154              | curDisplayDev.u32DevType );
;;;155    
;;;156        outpw(REG_LCM_CRTC_SIZE,    curDisplayDev.u32Reg_CRTCSIZE);
000078  e5902024          LDR      r2,[r0,#0x24]  ; curDisplayDev
00007c  e5812010          STR      r2,[r1,#0x10]
;;;157        outpw(REG_LCM_CRTC_DEND,    curDisplayDev.u32Reg_CRTCDEND);
000080  e5902028          LDR      r2,[r0,#0x28]  ; curDisplayDev
000084  e5812014          STR      r2,[r1,#0x14]
;;;158        outpw(REG_LCM_CRTC_HR,      curDisplayDev.u32Reg_CRTCHR);
000088  e590202c          LDR      r2,[r0,#0x2c]  ; curDisplayDev
00008c  e5812018          STR      r2,[r1,#0x18]
;;;159        outpw(REG_LCM_CRTC_HSYNC,   curDisplayDev.u32Reg_CRTCHSYNC);
000090  e5902030          LDR      r2,[r0,#0x30]  ; curDisplayDev
000094  e581201c          STR      r2,[r1,#0x1c]
;;;160        outpw(REG_LCM_CRTC_VR,      curDisplayDev.u32Reg_CRTCVR);
000098  e5900034          LDR      r0,[r0,#0x34]  ; curDisplayDev
00009c  e5810020          STR      r0,[r1,#0x20]
;;;161    
;;;162    }
0000a0  e8bd8010          POP      {r4,pc}
;;;163    
                          ENDP

                  |L8.164|
                          DCD      ||.bss||+0x30
                  |L8.168|
                          DCD      ||area_number.34||
                  |L8.172|
                          DCD      0xb0008000

                          AREA ||i.vpostMPUReadData||, CODE, READONLY, ALIGN=2

                  vpostMPUReadData PROC
;;;689      */
;;;690    uint32_t vpostMPUReadData(void)
000000  e59f1048          LDR      r1,|L9.80|
;;;691    {
;;;692        uint32_t udata;
;;;693    
;;;694        outpw(REG_LCM_MPU_CMD,inpw(REG_LCM_MPU_CMD) | (1<<30));         //RS=1
000004  e5910008          LDR      r0,[r1,#8]
000008  e3800101          ORR      r0,r0,#0x40000000
00000c  e5810008          STR      r0,[r1,#8]
;;;695        outpw(REG_LCM_DCCS,(inpw(REG_LCM_DCCS) | (1<<5)));              //CMD ON
000010  e5910000          LDR      r0,[r1,#0]
000014  e3800020          ORR      r0,r0,#0x20
000018  e5810000          STR      r0,[r1,#0]
;;;696        outpw(REG_LCM_MPU_CMD,inpw(REG_LCM_MPU_CMD) | (1<<29));         //r
00001c  e5910008          LDR      r0,[r1,#8]
000020  e3800202          ORR      r0,r0,#0x20000000
000024  e5810008          STR      r0,[r1,#8]
                  |L9.40|
;;;697        while(inpw(REG_LCM_MPU_CMD) & (1UL<<31));
000028  e5910008          LDR      r0,[r1,#8]
00002c  e3100102          TST      r0,#0x80000000
000030  1afffffc          BNE      |L9.40|
;;;698        udata = inpw(REG_LCM_MPU_CMD) & 0xffff;
000034  e5910008          LDR      r0,[r1,#8]
;;;699        outpw(REG_LCM_DCCS,(inpw(REG_LCM_DCCS) & ~(1<<5)));             //CMD OFF
000038  e5912000          LDR      r2,[r1,#0]
00003c  e1a00800          LSL      r0,r0,#16             ;698
000040  e1a00820          LSR      r0,r0,#16             ;698
000044  e3c22020          BIC      r2,r2,#0x20
000048  e5812000          STR      r2,[r1,#0]
;;;700    
;;;701        return udata;
;;;702    }
00004c  e12fff1e          BX       lr
;;;703    
                          ENDP

                  |L9.80|
                          DCD      0xb0008000

                          AREA ||i.vpostMPUWriteAddr||, CODE, READONLY, ALIGN=2

                  vpostMPUWriteAddr PROC
;;;658      */
;;;659    void vpostMPUWriteAddr(uint16_t uscmd)
000000  e59f1050          LDR      r1,|L10.88|
;;;660    {
;;;661        outpw(REG_LCM_MPU_CMD,inpw(REG_LCM_MPU_CMD) & ~(1<<30));        //RS=0
000004  e5912008          LDR      r2,[r1,#8]
000008  e3c22101          BIC      r2,r2,#0x40000000
00000c  e5812008          STR      r2,[r1,#8]
;;;662        outpw(REG_LCM_MPU_CMD,inpw(REG_LCM_MPU_CMD) & ~(1<<29));        //w
000010  e5912008          LDR      r2,[r1,#8]
000014  e3c22202          BIC      r2,r2,#0x20000000
000018  e5812008          STR      r2,[r1,#8]
;;;663    
;;;664        outpw(REG_LCM_DCCS,(inpw(REG_LCM_DCCS) | (1<<5)));              //CMD ON
00001c  e5912000          LDR      r2,[r1,#0]
000020  e3822020          ORR      r2,r2,#0x20
000024  e5812000          STR      r2,[r1,#0]
;;;665        outpw(REG_LCM_MPU_CMD,(inpw(REG_LCM_MPU_CMD) & 0xffff0000 | uscmd));
000028  e5912008          LDR      r2,[r1,#8]
00002c  e1a02822          LSR      r2,r2,#16
000030  e1a02802          LSL      r2,r2,#16
000034  e1800002          ORR      r0,r0,r2
000038  e5810008          STR      r0,[r1,#8]
                  |L10.60|
;;;666        while(inpw(REG_LCM_MPU_CMD) & (1UL<<31));
00003c  e5910008          LDR      r0,[r1,#8]
000040  e3100102          TST      r0,#0x80000000
;;;667        outpw(REG_LCM_DCCS,(inpw(REG_LCM_DCCS) & ~(1<<5)));             //CMD OFF
000044  05910000          LDREQ    r0,[r1,#0]
000048  03c00020          BICEQ    r0,r0,#0x20
00004c  05810000          STREQ    r0,[r1,#0]
000050  1afffff9          BNE      |L10.60|
;;;668    }
000054  e12fff1e          BX       lr
;;;669    
                          ENDP

                  |L10.88|
                          DCD      0xb0008000

                          AREA ||i.vpostMPUWriteData||, CODE, READONLY, ALIGN=2

                  vpostMPUWriteData PROC
;;;674      */
;;;675    void vpostMPUWriteData(uint16_t usdata)
000000  e59f1050          LDR      r1,|L11.88|
;;;676    {
;;;677        outpw(REG_LCM_MPU_CMD,inpw(REG_LCM_MPU_CMD) | (1<<30));         //RS=1
000004  e5912008          LDR      r2,[r1,#8]
000008  e3822101          ORR      r2,r2,#0x40000000
00000c  e5812008          STR      r2,[r1,#8]
;;;678        outpw(REG_LCM_MPU_CMD,inpw(REG_LCM_MPU_CMD) & ~(1<<29));        //w
000010  e5912008          LDR      r2,[r1,#8]
000014  e3c22202          BIC      r2,r2,#0x20000000
000018  e5812008          STR      r2,[r1,#8]
;;;679        outpw(REG_LCM_DCCS,(inpw(REG_LCM_DCCS) | (1<<5)));              //CMD ON
00001c  e5912000          LDR      r2,[r1,#0]
000020  e3822020          ORR      r2,r2,#0x20
000024  e5812000          STR      r2,[r1,#0]
;;;680        outpw(REG_LCM_MPU_CMD,inpw(REG_LCM_MPU_CMD) & 0xffff0000 |usdata);
000028  e5912008          LDR      r2,[r1,#8]
00002c  e1a02822          LSR      r2,r2,#16
000030  e1a02802          LSL      r2,r2,#16
000034  e1800002          ORR      r0,r0,r2
000038  e5810008          STR      r0,[r1,#8]
                  |L11.60|
;;;681        while(inpw(REG_LCM_MPU_CMD) & (1UL<<31));
00003c  e5910008          LDR      r0,[r1,#8]
000040  e3100102          TST      r0,#0x80000000
;;;682        outpw(REG_LCM_DCCS,(inpw(REG_LCM_DCCS) & ~(1<<5)));             //CMD OFF
000044  05910000          LDREQ    r0,[r1,#0]
000048  03c00020          BICEQ    r0,r0,#0x20
00004c  05810000          STREQ    r0,[r1,#0]
000050  1afffff9          BNE      |L11.60|
;;;683    }
000054  e12fff1e          BX       lr
;;;684    
                          ENDP

                  |L11.88|
                          DCD      0xb0008000

                          AREA ||i.vpostOSDDisableBlinking||, CODE, READONLY, ALIGN=2

                  vpostOSDDisableBlinking PROC
;;;421      */
;;;422    void vpostOSDDisableBlinking(void)
000000  e59f000c          LDR      r0,|L12.20|
;;;423    {
;;;424        outpw(REG_LCM_OSD_OVERLAY, inpw(REG_LCM_OSD_OVERLAY) &~ VPOSTB_BLI_ON);
000004  e5901050          LDR      r1,[r0,#0x50]
000008  e3c11c02          BIC      r1,r1,#0x200
00000c  e5801050          STR      r1,[r0,#0x50]
;;;425    }
000010  e12fff1e          BX       lr
;;;426    
                          ENDP

                  |L12.20|
                          DCD      0xb0008000

                          AREA ||i.vpostOSDEnable||, CODE, READONLY, ALIGN=2

                  vpostOSDEnable PROC
;;;513      */
;;;514    void vpostOSDEnable(void)
000000  e59f000c          LDR      r0,|L13.20|
;;;515    {
;;;516        outpw(REG_LCM_DCCS,inpw(REG_LCM_DCCS) | VPOSTB_OSD_EN);//OSD enable
000004  e5901000          LDR      r1,[r0,#0]
000008  e3811004          ORR      r1,r1,#4
00000c  e5801000          STR      r1,[r0,#0]
;;;517    }
000010  e12fff1e          BX       lr
;;;518    
                          ENDP

                  |L13.20|
                          DCD      0xb0008000

                          AREA ||i.vpostOSDScalingCtrl||, CODE, READONLY, ALIGN=2

                  vpostOSDScalingCtrl PROC
;;;528      */
;;;529    void vpostOSDScalingCtrl(uint8_t u8HIntegral, uint16_t u16HDecimal,uint8_t u8VScall)
000000  e92d4070          PUSH     {r4-r6,lr}
;;;530    {
;;;531        outpw(REG_LCM_DCCS, inpw(REG_LCM_DCCS)&0xfff0ffff); //clear OSD scaling setting
000004  e59f4048          LDR      r4,|L14.84|
000008  e1a05000          MOV      r5,r0                 ;530
00000c  e5940000          LDR      r0,[r4,#0]
000010  e3c0080f          BIC      r0,r0,#0xf0000
000014  e5840000          STR      r0,[r4,#0]
;;;532        if (u8VScall!=0)
000018  e3520000          CMP      r2,#0
;;;533            outpw(REG_LCM_DCCS, inpw(REG_LCM_DCCS) | (u8VScall<<16));
00001c  15940000          LDRNE    r0,[r4,#0]
000020  11800802          ORRNE    r0,r0,r2,LSL #16
000024  15840000          STRNE    r0,[r4,#0]
;;;534        outpw(REG_LCM_OSD_SCALE, ((uint32_t)u8HIntegral<<10) | ((uint32_t)ceil((double)1024/10*u16HDecimal))<<6);
000028  e1a00001          MOV      r0,r1
00002c  ebfffffe          BL       __aeabi_ui2d
000030  e59f2020          LDR      r2,|L14.88|
000034  e59f3020          LDR      r3,|L14.92|
000038  ebfffffe          BL       __aeabi_dmul
00003c  ebfffffe          BL       ceil
000040  ebfffffe          BL       __aeabi_d2uiz
000044  e1a00300          LSL      r0,r0,#6
000048  e1800505          ORR      r0,r0,r5,LSL #10
00004c  e5840064          STR      r0,[r4,#0x64]
;;;535    }
000050  e8bd8070          POP      {r4-r6,pc}
;;;536    
                          ENDP

                  |L14.84|
                          DCD      0xb0008000
                  |L14.88|
                          DCD      0x9999999a
                  |L14.92|
                          DCD      0x40599999

                          AREA ||i.vpostOSDSetBlinking||, CODE, READONLY, ALIGN=2

                  vpostOSDSetBlinking PROC
;;;409      */
;;;410    void vpostOSDSetBlinking(uint8_t u8OSDBlinkVcnt)
000000  e59f1024          LDR      r1,|L15.44|
;;;411    {
;;;412        outpw(REG_LCM_OSD_OVERLAY, inpw(REG_LCM_OSD_OVERLAY) & ~(VPOSTB_BLI_ON | VPOSTB_CKEY_ON));  //blinking disable, color-key disable
000004  e5912050          LDR      r2,[r1,#0x50]
000008  e3c22c03          BIC      r2,r2,#0x300
00000c  e5812050          STR      r2,[r1,#0x50]
;;;413        outpw(REG_LCM_OSD_OVERLAY, inpw(REG_LCM_OSD_OVERLAY) | VPOSTB_BLI_ON);
000010  e5912050          LDR      r2,[r1,#0x50]
000014  e3822c02          ORR      r2,r2,#0x200
000018  e5812050          STR      r2,[r1,#0x50]
;;;414        outpw(REG_LCM_OSD_OVERLAY, inpw(REG_LCM_OSD_OVERLAY) | ((uint32_t)(u8OSDBlinkVcnt)<<16));
00001c  e5912050          LDR      r2,[r1,#0x50]
000020  e1820800          ORR      r0,r2,r0,LSL #16
000024  e5810050          STR      r0,[r1,#0x50]
;;;415    }
000028  e12fff1e          BX       lr
;;;416    
                          ENDP

                  |L15.44|
                          DCD      0xb0008000

                          AREA ||i.vpostOSDSetColKey||, CODE, READONLY, ALIGN=2

                  vpostOSDSetColKey PROC
;;;385      */
;;;386    void vpostOSDSetColKey(uint8_t u8CKeyColorR, uint8_t u8CKeyColorG, uint8_t u8CKeyColorB)
000000  e59f3028          LDR      r3,|L16.48|
;;;387    {
;;;388        outpw(REG_LCM_OSD_OVERLAY, inpw(REG_LCM_OSD_OVERLAY) & ~(VPOSTB_BLI_ON | VPOSTB_CKEY_ON) );//blinking disable, color-key disable
000004  e593c050          LDR      r12,[r3,#0x50]
000008  e3cccc03          BIC      r12,r12,#0x300
00000c  e583c050          STR      r12,[r3,#0x50]
;;;389        outpw(REG_LCM_OSD_OVERLAY, inpw(REG_LCM_OSD_OVERLAY) | VPOSTB_CKEY_ON);//color-key enable
000010  e593c050          LDR      r12,[r3,#0x50]
000014  e38ccc01          ORR      r12,r12,#0x100
000018  e583c050          STR      r12,[r3,#0x50]
;;;390        outpw(REG_LCM_OSD_CKEY, ((uint32_t)(u8CKeyColorR << 16) | (uint32_t)(u8CKeyColorG << 8) | u8CKeyColorB));
00001c  e1a00800          LSL      r0,r0,#16
000020  e1800401          ORR      r0,r0,r1,LSL #8
000024  e1800002          ORR      r0,r0,r2
000028  e5830054          STR      r0,[r3,#0x54]
;;;391    }
00002c  e12fff1e          BX       lr
;;;392    
                          ENDP

                  |L16.48|
                          DCD      0xb0008000

                          AREA ||i.vpostOSDSetColMask||, CODE, READONLY, ALIGN=2

                  vpostOSDSetColMask PROC
;;;399      */
;;;400    void vpostOSDSetColMask(uint8_t u8MaskColorR, uint8_t u8MaskColorG, uint8_t u8MaskColorB)
000000  e1a00800          LSL      r0,r0,#16
;;;401    {
;;;402        outpw(REG_LCM_OSD_CMASK, ((u8MaskColorR << 16) | (u8MaskColorG << 8) | u8MaskColorB));
000004  e1800401          ORR      r0,r0,r1,LSL #8
000008  e59f1008          LDR      r1,|L17.24|
00000c  e1800002          ORR      r0,r0,r2
000010  e5810058          STR      r0,[r1,#0x58]
;;;403    }
000014  e12fff1e          BX       lr
;;;404    
                          ENDP

                  |L17.24|
                          DCD      0xb0008000

                          AREA ||i.vpostOSDSetOverlay||, CODE, READONLY, ALIGN=2

                  vpostOSDSetOverlay PROC
;;;632      */
;;;633    void vpostOSDSetOverlay(uint8_t u8OSDDisplayMatch, uint8_t u8OSDDisplayUnMatch, uint8_t u8OSDSynW)
000000  e59f3040          LDR      r3,|L18.72|
;;;634    {
;;;635        /* clear OCR0 and OCR1 */
;;;636        outpw(REG_LCM_OSD_OVERLAY,inpw(REG_LCM_OSD_OVERLAY)&0xfffffff0);
000004  e593c050          LDR      r12,[r3,#0x50]
000008  e3ccc00f          BIC      r12,r12,#0xf
00000c  e583c050          STR      r12,[r3,#0x50]
;;;637    
;;;638        /* match condition */
;;;639        if (u8OSDDisplayMatch != 0) {
000010  e3500000          CMP      r0,#0
;;;640            outpw(REG_LCM_OSD_OVERLAY,inpw(REG_LCM_OSD_OVERLAY) | (u8OSDDisplayMatch<<2));
000014  1593c050          LDRNE    r12,[r3,#0x50]
000018  118cc100          ORRNE    r12,r12,r0,LSL #2
00001c  1583c050          STRNE    r12,[r3,#0x50]
;;;641        }
;;;642    
;;;643        /* unmatch condition */
;;;644        if (u8OSDDisplayUnMatch != 0) {
000020  e3510000          CMP      r1,#0
;;;645            outpw(REG_LCM_OSD_OVERLAY,inpw(REG_LCM_OSD_OVERLAY) | (u8OSDDisplayUnMatch));
000024  1593c050          LDRNE    r12,[r3,#0x50]
000028  118cc001          ORRNE    r12,r12,r1
00002c  1583c050          STRNE    r12,[r3,#0x50]
;;;646        }
;;;647    
;;;648        /* synthesized weight */
;;;649        if (u8OSDDisplayMatch == DISPLAY_SYNTHESIZED || u8OSDDisplayUnMatch == DISPLAY_SYNTHESIZED) {
000030  e3500002          CMP      r0,#2
000034  13510002          CMPNE    r1,#2
;;;650            outpw(REG_LCM_OSD_OVERLAY,inpw(REG_LCM_OSD_OVERLAY) | (u8OSDSynW<<4));
000038  05930050          LDREQ    r0,[r3,#0x50]
00003c  01800202          ORREQ    r0,r0,r2,LSL #4
000040  05830050          STREQ    r0,[r3,#0x50]
;;;651        }
;;;652    }
000044  e12fff1e          BX       lr
;;;653    
                          ENDP

                  |L18.72|
                          DCD      0xb0008000

                          AREA ||i.vpostOSDSetWindow||, CODE, READONLY, ALIGN=2

                  vpostOSDSetWindow PROC
;;;544      */
;;;545    void vpostOSDSetWindow(uint32_t u32XStart,uint32_t u32YStart,uint32_t u32Width,uint32_t u32Height)
000000  e92d4010          PUSH     {r4,lr}
;;;546    {
;;;547        outpw(REG_LCM_OSD_WINS,((u32YStart+1)<<16) | (u32XStart+1));
000004  e280c001          ADD      r12,r0,#1
000008  e2814001          ADD      r4,r1,#1
00000c  e18c4804          ORR      r4,r12,r4,LSL #16
000010  e59fc020          LDR      r12,|L19.56|
000014  e58c4040          STR      r4,[r12,#0x40]
;;;548        outpw(REG_LCM_OSD_WINE,((u32YStart+u32Height)<<16) | (u32XStart+u32Width));
000018  e0800002          ADD      r0,r0,r2
00001c  e0811003          ADD      r1,r1,r3
000020  e1800801          ORR      r0,r0,r1,LSL #16
000024  e58c0044          STR      r0,[r12,#0x44]
;;;549    
;;;550        curOSDDev.nOSDWidth = u32Width;
000028  e59f000c          LDR      r0,|L19.60|
;;;551        curOSDDev.nOSDHeight = u32Height;
00002c  e580200c          STR      r2,[r0,#0xc]  ; curOSDDev, curOSDDev
000030  e5803010          STR      r3,[r0,#0x10]
;;;552    }
000034  e8bd8010          POP      {r4,pc}
;;;553    
                          ENDP

                  |L19.56|
                          DCD      0xb0008000
                  |L19.60|
                          DCD      ||.bss||

                          AREA ||i.vpostSetActiveWindow||, CODE, READONLY, ALIGN=2

                  vpostSetActiveWindow PROC
;;;266      */
;;;267    void vpostSetActiveWindow(uint16_t u16StartY, uint16_t u16EndY, uint8_t u8BGColorR, uint8_t u8BGColorG, uint8_t u8BGColorB)
000000  e1811800          ORR      r1,r1,r0,LSL #16
;;;268    {
;;;269        outpw(REG_LCM_VA_WIN, (u16StartY << 16) | u16EndY);
000004  e59f0018          LDR      r0,|L20.36|
000008  e59dc000          LDR      r12,[sp,#0]
00000c  e5801038          STR      r1,[r0,#0x38]
;;;270        outpw(REG_LCM_VA_STUFF, (u8BGColorR << 16) | (u8BGColorG << 8) | u8BGColorB);
000010  e1a01802          LSL      r1,r2,#16
000014  e1811403          ORR      r1,r1,r3,LSL #8
000018  e181100c          ORR      r1,r1,r12
00001c  e580103c          STR      r1,[r0,#0x3c]
;;;271    }
000020  e12fff1e          BX       lr
;;;272    
                          ENDP

                  |L20.36|
                          DCD      0xb0008000

                          AREA ||i.vpostSetDisplayMode||, CODE, READONLY, ALIGN=2

                  vpostSetDisplayMode PROC
;;;279      */
;;;280    void vpostSetDisplayMode(uint8_t u8DisplayMode)
000000  e59f1018          LDR      r1,|L21.32|
;;;281    {
;;;282        if (u8DisplayMode==0)
000004  e3500000          CMP      r0,#0
;;;283            outpw(REG_LCM_DCCS, inpw(REG_LCM_DCCS) & ~(1<<7));//clear setting
000008  05910000          LDREQ    r0,[r1,#0]
;;;284        else
;;;285            outpw(REG_LCM_DCCS, inpw(REG_LCM_DCCS) | (u8DisplayMode) << 7);
00000c  15912000          LDRNE    r2,[r1,#0]
000010  03c00080          BICEQ    r0,r0,#0x80           ;283
000014  11820380          ORRNE    r0,r2,r0,LSL #7
000018  e5810000          STR      r0,[r1,#0]            ;283
;;;286    }
00001c  e12fff1e          BX       lr
;;;287    
                          ENDP

                  |L21.32|
                          DCD      0xb0008000

                          AREA ||i.vpostSetOSDSrc||, CODE, READONLY, ALIGN=2

                  vpostSetOSDSrc PROC
;;;439      */
;;;440    void vpostSetOSDSrc(uint32_t u32OSDSrcType)
000000  e59f104c          LDR      r1,|L22.84|
;;;441    {
;;;442        uint32_t u32BytePerPixel, VA_FF, VA_Sride;
;;;443    
;;;444        outpw(REG_LCM_DCCS, inpw(REG_LCM_DCCS) &~(7<<12) | u32OSDSrcType);
000004  e5912000          LDR      r2,[r1,#0]
000008  e3c22a07          BIC      r2,r2,#0x7000
00000c  e1822000          ORR      r2,r2,r0
000010  e5812000          STR      r2,[r1,#0]
;;;445        curOSDDev.ucOSDSrcFormat = u32OSDSrcType;
000014  e59f203c          LDR      r2,|L22.88|
;;;446    
;;;447        switch(u32OSDSrcType) {
000018  e3500a02          CMP      r0,#0x2000
00001c  e5820000          STR      r0,[r2,#0]            ;445  ; curOSDDev
000020  c3500a03          CMPGT    r0,#0x3000
;;;448            case OSD_SRC_YUV422:
;;;449            case OSD_SRC_YCBCR422:
;;;450            case OSD_SRC_RGB565:
;;;451                u32BytePerPixel = 2;
;;;452                break;
;;;453    
;;;454            case OSD_SRC_RGB666:
;;;455            case OSD_SRC_RGB888:
;;;456                u32BytePerPixel = 4;
;;;457                break;
;;;458    
;;;459            default:
;;;460                u32BytePerPixel = 2;
;;;461        }
;;;462    
;;;463        /* set video stream frame buffer control */
;;;464        VA_FF = curOSDDev.nOSDWidth * u32BytePerPixel / 4;
000024  e592200c          LDR      r2,[r2,#0xc]  ; curOSDDev
000028  03a00004          MOVEQ    r0,#4                 ;456
00002c  13a00002          MOVNE    r0,#2                 ;451
000030  e0000092          MUL      r0,r2,r0
;;;465        VA_Sride = curOSDDev.nOSDWidth * u32BytePerPixel / 4;
;;;466        outpw(REG_LCM_OSD_FBCTRL, inpw(REG_LCM_OSD_FBCTRL) &~0x7ff07ff | (VA_FF<<16) | VA_Sride);
000034  e591204c          LDR      r2,[r1,#0x4c]
000038  e1a00120          LSR      r0,r0,#2              ;464
00003c  e59f3018          LDR      r3,|L22.92|
000040  e0022003          AND      r2,r2,r3
000044  e1822800          ORR      r2,r2,r0,LSL #16
000048  e1800002          ORR      r0,r0,r2
00004c  e581004c          STR      r0,[r1,#0x4c]
;;;467    }
000050  e12fff1e          BX       lr
;;;468    
                          ENDP

                  |L22.84|
                          DCD      0xb0008000
                  |L22.88|
                          DCD      ||.bss||
                  |L22.92|
                          DCD      0xf800f800

                          AREA ||i.vpostSetVASrc||, CODE, READONLY, ALIGN=2

                  vpostSetVASrc PROC
;;;299      */
;;;300    void vpostSetVASrc(uint32_t u32VASrcType)
000000  e59f10a4          LDR      r1,|L23.172|
;;;301    {
000004  e92d4010          PUSH     {r4,lr}
;;;302        uint32_t u32BytePerPixel, VA_FF, VA_Sride;
;;;303    
;;;304        curVADev.ucVASrcFormat = u32VASrcType;
;;;305    
;;;306        outpw(REG_LCM_DCCS, inpw(REG_LCM_DCCS) & ~(7<<8));
000008  e59f20a0          LDR      r2,|L23.176|
00000c  e5810000          STR      r0,[r1,#0]  ; curVADev
000010  e5921000          LDR      r1,[r2,#0]
000014  e3c11c07          BIC      r1,r1,#0x700
000018  e5821000          STR      r1,[r2,#0]
;;;307        if (u32VASrcType != 0)
;;;308            outpw(REG_LCM_DCCS, inpw(REG_LCM_DCCS) | u32VASrcType);
;;;309        else
;;;310            outpw(REG_LCM_DCCS, inpw(REG_LCM_DCCS) & ~(7<<8));
;;;311    
;;;312        if ((u32VASrcType==VA_SRC_RGB888)||(u32VASrcType==VA_SRC_RGB666))
;;;313            outpw(REG_LCM_VA_FBCTRL,inpw(REG_LCM_VA_FBCTRL) &~0x7ff07ff | (curDisplayDev.u32DevWidth << 16) | curDisplayDev.u32DevWidth);
00001c  e59f1094          LDR      r1,|L23.184|
000020  e59f308c          LDR      r3,|L23.180|
000024  e5911000          LDR      r1,[r1,#0]
000028  e592c000          LDR      r12,[r2,#0]           ;310
00002c  e3500000          CMP      r0,#0                 ;307
000030  03cccc07          BICEQ    r12,r12,#0x700        ;310
000034  0582c000          STREQ    r12,[r2,#0]           ;310
000038  0a000004          BEQ      |L23.80|
00003c  e18cc000          ORR      r12,r12,r0            ;308
000040  e582c000          STR      r12,[r2,#0]           ;308
000044  e3500c02          CMP      r0,#0x200             ;312
000048  13500c03          CMPNE    r0,#0x300             ;312
00004c  0a000011          BEQ      |L23.152|
                  |L23.80|
;;;314        else
;;;315            outpw(REG_LCM_VA_FBCTRL,inpw(REG_LCM_VA_FBCTRL) &~0x7ff07ff | ((curDisplayDev.u32DevWidth/2) << 16) | (curDisplayDev.u32DevWidth/2));
000050  e592c02c          LDR      r12,[r2,#0x2c]
000054  e00c4003          AND      r4,r12,r3
000058  e1a0c0a1          LSR      r12,r1,#1
00005c  e184c80c          ORR      r12,r4,r12,LSL #16
000060  e18cc0a1          ORR      r12,r12,r1,LSR #1
                  |L23.100|
000064  e582c02c          STR      r12,[r2,#0x2c]
;;;316    
;;;317        switch(u32VASrcType) {
000068  e3500c02          CMP      r0,#0x200
00006c  c3500c03          CMPGT    r0,#0x300
;;;318            case VA_SRC_YUV422:
;;;319            case VA_SRC_YCBCR422:
;;;320            case VA_SRC_RGB565:
;;;321                u32BytePerPixel = 2;
;;;322                break;
;;;323    
;;;324            case VA_SRC_RGB666:
;;;325            case VA_SRC_RGB888:
;;;326                u32BytePerPixel = 4;
000070  03a00004          MOVEQ    r0,#4
000074  13a00002          MOVNE    r0,#2                 ;321
;;;327                break;
;;;328    
;;;329            default:
;;;330                u32BytePerPixel = 2;
;;;331        }
;;;332    
;;;333        /* set video stream frame buffer control */
;;;334        VA_FF = curDisplayDev.u32DevWidth * u32BytePerPixel / 4;
000078  e0000091          MUL      r0,r1,r0
;;;335        VA_Sride = curDisplayDev.u32DevWidth * u32BytePerPixel / 4;
;;;336        outpw(REG_LCM_VA_FBCTRL,inpw(REG_LCM_VA_FBCTRL) &~0x7ff07ff | (VA_FF<<16) | VA_Sride);
00007c  e592102c          LDR      r1,[r2,#0x2c]
000080  e1a00120          LSR      r0,r0,#2              ;334
000084  e0011003          AND      r1,r1,r3
000088  e1811800          ORR      r1,r1,r0,LSL #16
00008c  e1800001          ORR      r0,r0,r1
000090  e582002c          STR      r0,[r2,#0x2c]
;;;337    }
000094  e8bd8010          POP      {r4,pc}
                  |L23.152|
000098  e592c02c          LDR      r12,[r2,#0x2c]        ;313
00009c  e00cc003          AND      r12,r12,r3            ;313
0000a0  e18cc801          ORR      r12,r12,r1,LSL #16    ;313
0000a4  e18cc001          ORR      r12,r12,r1            ;313
0000a8  eaffffed          B        |L23.100|
;;;338    
                          ENDP

                  |L23.172|
                          DCD      ||.bss||+0x1c
                  |L23.176|
                          DCD      0xb0008000
                  |L23.180|
                          DCD      0xf800f800
                  |L23.184|
                          DCD      ||.bss||+0x30

                          AREA ||i.vpostVAScalingCtrl||, CODE, READONLY, ALIGN=2

                  vpostVAScalingCtrl PROC
;;;372      */
;;;373    void vpostVAScalingCtrl(uint8_t u8HIntegral, uint16_t u16HDecimal, uint8_t u8VIntegral, uint16_t u16VDecimal, uint32_t u32Mode)
000000  e92d4010          PUSH     {r4,lr}
;;;374    {
;;;375        outpw(REG_LCM_VA_SCALE,((((uint32_t)u8VIntegral << 10) + ((uint32_t)ceil((double)1024/10)*u16VDecimal)) << 16)
000004  e3a04067          MOV      r4,#0x67
000008  e0010194          MUL      r1,r4,r1
00000c  e59dc008          LDR      r12,[sp,#8]
000010  e0810500          ADD      r0,r1,r0,LSL #10
000014  e0010493          MUL      r1,r3,r4
000018  e0811502          ADD      r1,r1,r2,LSL #10
00001c  e1800801          ORR      r0,r0,r1,LSL #16
000020  e59f1008          LDR      r1,|L24.48|
000024  e180000c          ORR      r0,r0,r12
000028  e5810030          STR      r0,[r1,#0x30]
;;;376              | (((uint32_t)u8HIntegral << 10) + ((uint32_t)ceil((double)1024/10)*u16HDecimal)) | u32Mode);
;;;377    }
00002c  e8bd8010          POP      {r4,pc}
;;;378    
                          ENDP

                  |L24.48|
                          DCD      0xb0008000

                          AREA ||i.vpostVAStartTrigger||, CODE, READONLY, ALIGN=2

                  vpostVAStartTrigger PROC
;;;343      */
;;;344    void vpostVAStartTrigger(void)
000000  e59f0030          LDR      r0,|L25.56|
;;;345    {
;;;346        if((inpw(REG_LCM_DCCS) & VPOSTB_SINGLE) == VPOSTB_SINGLE)
000004  e5901000          LDR      r1,[r0,#0]
000008  e3110080          TST      r1,#0x80
00000c  0a000002          BEQ      |L25.28|
                  |L25.16|
;;;347            while((inpw(REG_LCM_DCCS) & VPOSTB_VA_EN) == VPOSTB_VA_EN);//wait VA_EN low
000010  e5901000          LDR      r1,[r0,#0]
000014  e3110002          TST      r1,#2
000018  1afffffc          BNE      |L25.16|
                  |L25.28|
;;;348        outpw(REG_LCM_DCCS,inpw(REG_LCM_DCCS) | VPOSTB_DISP_OUT_EN); //display_out-enable
00001c  e5901000          LDR      r1,[r0,#0]
000020  e3811008          ORR      r1,r1,#8
000024  e5801000          STR      r1,[r0,#0]
;;;349        outpw(REG_LCM_DCCS,inpw(REG_LCM_DCCS) | VPOSTB_VA_EN); //va-enable
000028  e5901000          LDR      r1,[r0,#0]
00002c  e3811002          ORR      r1,r1,#2
000030  e5801000          STR      r1,[r0,#0]
;;;350    }
000034  e12fff1e          BX       lr
;;;351    
                          ENDP

                  |L25.56|
                          DCD      0xb0008000

                          AREA ||i.vpostVAStopTrigger||, CODE, READONLY, ALIGN=2

                  vpostVAStopTrigger PROC
;;;356      */
;;;357    void vpostVAStopTrigger(void)
000000  e59f000c          LDR      r0,|L26.20|
;;;358    {
;;;359        outpw(REG_LCM_DCCS,inpw(REG_LCM_DCCS) & ~(VPOSTB_DISP_OUT_EN | VPOSTB_VA_EN));//OSD disable
000004  e5901000          LDR      r1,[r0,#0]
000008  e3c1100a          BIC      r1,r1,#0xa
00000c  e5801000          STR      r1,[r0,#0]
;;;360    }
000010  e12fff1e          BX       lr
;;;361    
                          ENDP

                  |L26.20|
                          DCD      0xb0008000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  curOSDDev
                          %        28
                  curVADev
                          %        20
                  curDisplayDev
                          %        56

                          AREA ||.data||, DATA, ALIGN=2

                  DEF_E50A2V1
                          DCD      0x00000320
                          DCD      0x000001e0
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x04000000
                          DCD      0x00000000
                          DCD      0x01000000
                          DCD      0x000000c0
                          DCD      0x020d03a0
                          DCD      0x01e00320
                          DCD      0x03250321
                          DCD      0x03780348
                          DCD      0x01f001ed

                          AREA ||area_number.31||, DATA, ALIGN=2

                          EXPORTAS ||area_number.31||, ||.data||
                  DEF_ILI9341_MPU80
                          DCD      0x000000f0
                          DCD      0x00000140
                          DCD      0x80000000
                          DCD      0x40000000
                          DCD      0x00000000
                          DCD      0x04000000
                          DCD      0x00000000
                          DCD      0x01000000
                          DCD      0x000000e0
                          DCD      0x01600100
                          DCD      0x014000f0
                          DCD      0x00fa00f5
                          DCD      0x00fc00fa
                          DCD      0x01500145

                          AREA ||area_number.32||, DATA, ALIGN=2

                          EXPORTAS ||area_number.32||, ||.data||
                  DEF_LSA40AT9001
                          DCD      0x00000320
                          DCD      0x00000258
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x04000000
                          DCD      0x00000000
                          DCD      0x01000000
                          DCD      0x000000c0
                          DCD      0x02800425
                          DCD      0x02580320
                          DCD      0x032f032a
                          DCD      0x0334032a
                          DCD      0x026c0262

                          AREA ||area_number.33||, DATA, ALIGN=2

                          EXPORTAS ||area_number.33||, ||.data||
                  DEF_FW070TFT
                          DCD      0x00000320
                          DCD      0x000001e0
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x04000000
                          DCD      0x00000000
                          DCD      0x03000000
                          DCD      0x000000c0
                          DCD      0x020d0420
                          DCD      0x01e00320
                          DCD      0x033e0339
                          DCD      0x040c03f8
                          DCD      0x020001f6

                          AREA ||area_number.34||, DATA, ALIGN=2

                          EXPORTAS ||area_number.34||, ||.data||
                  DisplayDevList
                          DCD      DEF_E50A2V1
                          DCD      DEF_ILI9341_MPU80
                          DCD      DEF_LSA40AT9001
                          DCD      DEF_FW070TFT
