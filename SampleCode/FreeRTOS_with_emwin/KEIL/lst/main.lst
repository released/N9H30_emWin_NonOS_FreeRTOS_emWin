L 1 "..\main.c"
N/**************************************************************************//**
N * @file     main.c
N * @version  V4.0
N * $Date: 19/01/16 06:00p $
N * @brief    To utilize emWin library to demonstrate interactive feature.
N *
N * @note
N * Copyright (C) 2019 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060037
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 11 "..\main.c" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 12 "..\main.c" 2
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060037
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 13 "..\main.c" 2
N#include "N9H30.h"
L 1 "..\..\..\Driver\Include\N9H30.h" 1
N/**************************************************************************//**
N * @file     N9H30.h
N * @version  V1.00
N * @brief    N9H30 peripheral access layer header file.
N *           This file contains all the peripheral register's definitions
N *           and memory mapping for NuMicro N9H30 MCU.
N *
N * @copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N/**
N   \mainpage NuMicro N9H30 Family Driver Reference Guide
N   *
N   * <b>Introduction</b>
N   *
N   * This user manual describes the usage of N9H30 family device driver
N   *
N   * <b>Disclaimer</b>
N   *
N   * The Software is furnished "AS IS", without warranty as to performance or results, and
N   * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N   * warranties, express, implied or otherwise, with regard to the Software, its use, or
N   * operation, including without limitation any and all warranties of merchantability, fitness
N   * for a particular purpose, and non-infringement of intellectual property rights.
N   *
N   * <b>Important Notice</b>
N   *
N   * Nuvoton Products are neither intended nor warranted for usage in systems or equipment,
N   * any malfunction or failure of which may cause loss of human life, bodily injury or severe
N   * property damage. Such applications are deemed, "Insecure Usage".
N   *
N   * Insecure usage includes, but is not limited to: equipment for surgical implementation,
N   * atomic energy control instruments, airplane or spaceship instruments, the control or
N   * operation of dynamic, brake or safety systems designed for vehicular use, traffic signal
N   * instruments, all types of safety devices, and other applications intended to support or
N   * sustain life.
N   *
N   * All Insecure Usage shall be made at customer's risk, and in the event that third parties
N   * lay claims to Nuvoton as a result of customer's Insecure Usage, customer shall indemnify
N   * the damages and liabilities thus incurred by Nuvoton.
N   *
N   * Please note that all data and specifications are subject to change without notice. All the
N   * trademarks of products and companies mentioned in this document belong to their respective
N   * owners.
N   *
N   * <b>Copyright Notice</b>
N   *
N   * Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N   */
N
N#ifndef __N9H30_H__
N#define __N9H30_H__
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 54 "..\..\..\Driver\Include\N9H30.h" 2
N
N/** @addtogroup N9H30_PERIPHERAL_MEM_MAP N9H30 Peripheral Memory Base
N  Memory Mapped Structure for N9H30 Peripheral
N  @{
N */
N
N/*!< AHB peripherals */
N#define    SYS_BA    0xB0000000  /*!< System Global Control */
N#define    CLK_BA    0xB0000200  /*!< Clock Control */
N#define    EBI_BA    0xB0001000  /*!< EBI Control */
N#define    SDIC_BA   0xB0001800  /*!< SDRAM (SDR/DDR/DDR2) Control */
N#define    EMC0_BA   0xB0002000  /*!< Ethernet MAC 0 Control */
N#define    EMC1_BA   0xB0003000  /*!< Ethernet MAC 1 Control */
N#define    GDMA_BA   0xB0004000  /*!< GDMA control */
N#define    USBH_BA   0xB0005000  /*!< USB Host EHCI Control */
N#define    USBD_BA   0xB0006000  /*!< USB Device Control */
N#define    USBO_BA   0xB0007000  /*!< OHCI USB Host Control */
N#define    LCM_BA    0xB0008000  /*!< Display, LCM Interface */
N#define    ACTL_BA   0xB0009000  /*!< Audio Control */
N#define    JPEG_BA   0xB000A000  /*!< JPEG Engine Control */
N#define    GE_BA     0xB000B000  /*!< 2-D Graphic Engine */
N#define    SDH_BA    0xB000C000  /*!< SD/SDIO Host Controller */
N#define    FMI_BA    0xB000D000  /*!< Flash Memory Card Interface */
N#define    CAP_BA    0xB000E000  /*!< Sensor (Capture) Interface Control */
N
N/*!< APB peripherals */
N#define    UART0_BA  0xB8000000  /*!< UART0 Control */
N#define    UART1_BA  0xB8000100  /*!< UART1 Control (High-Speed UART) */
N#define    UART2_BA  0xB8000200  /*!< UART2 Control (High-Speed UART) */
N#define    UART3_BA  0xB8000300  /*!< UART3 Control  */
N#define    UART4_BA  0xB8000400  /*!< UART4 Control (High-Speed UART) */
N#define    UART5_BA  0xB8000500  /*!< UART5 Control */
N#define    UART6_BA  0xB8000600  /*!< UART6 Control (High-Speed UART) */
N#define    UART7_BA  0xB8000700  /*!< UART7 Control */
N#define    UART8_BA  0xB8000800  /*!< UART8 Control (High-Speed UART) */
N#define    UART9_BA  0xB8000900  /*!< UART9 Control */
N#define    UARTA_BA  0xB8000A00  /*!< UARTA Control (High-Speed UART) */
N#define    TMR0_BA   0xB8001000  /*!< Timer 0 */
N#define    TMR1_BA   0xB8001010  /*!< Timer 1 */
N#define    TMR2_BA   0xB8001020  /*!< Timer 2 */
N#define    TMR3_BA   0xB8001030  /*!< Timer 3 */
N#define    TMR4_BA   0xB8001040  /*!< Timer 4 */
N#define    ETMR0_BA  0xB8001400  /*!< Enhanced Timer 0 */
N#define    ETMR1_BA  0xB8001500  /*!< Enhanced Timer 1 */
N#define    ETMR2_BA  0xB8001600  /*!< Enhanced Timer 2 */
N#define    ETMR3_BA  0xB8001700  /*!< Enhanced Timer 3 */
N#define    WDT_BA    0xB8001800  /*!< Watch Dog Timer */
N#define    WWDT_BA   0xB8001900  /*!< Window Watch Dog Timer */
N#define    AIC_BA    0xB8002000  /*!< Interrupt Controller */
N#define    GPIO_BA   0xB8003000  /*!< GPIO Control */
N#define    RTC_BA    0xB8004000  /*!< Real Time Clock Control */
N#define    SC0_BA    0xB8005000  /*!< Smart Card 0 Control */
N#define    SC1_BA    0xB8005400  /*!< Smart Card 1 Control */
N#define    I2C0_BA   0xB8006000  /*!< I2C 0 Control */
N#define    I2C1_BA   0xB8006100  /*!< I2C 1 Control */
N#define    SPI0_BA   0xB8006200  /*!< Serial Peripheral Interface 0 */
N#define    SPI1_BA   0xB8006300  /*!< Serial Peripheral Interface 1 */
N#define    PWM_BA    0xB8007000  /*!< Pulse Width Modulation (PWM) Control */
N#define    ADC_BA    0xB800A000  /*!< ADC Control */
N#define    CAN0_BA   0xB800B000  /*!< CAN 0 Control */
N#define    CAN1_BA   0xB800B400  /*!< CAN 1 Control */
N
N/*@}*/ /* end of group N9H30_PERIPHERAL_MEM_MAP */
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N/** @addtogroup N9H30_Peripherals N9H30 Control Register
N  N9H30 Device Specific Peripheral registers structures
N  @{
N*/
N
N/*---------------------- System Manger Controller -------------------------*/
N/**
N    @addtogroup SYS System Manger Controller(SYS)
N    Memory Mapped Structure for SYS Controller
N@{ */
N
N#define    REG_SYS_PDID         (SYS_BA+0x000)  /*!< Product Identifier Register */
N#define    REG_SYS_PWRON        (SYS_BA+0x004)  /*!< Power-On Setting Register */
N#define    REG_SYS_ARBCON       (SYS_BA+0x008)  /*!< Arbitration Control Register */
N#define    REG_SYS_LVRDCR       (SYS_BA+0x020)  /*!< Low Voltage Reset & Detect Control Register */
N#define    REG_SYS_MISCFCR      (SYS_BA+0x030)  /*!< Miscellaneous Function Control Register */
N#define    REG_SYS_MISCIER      (SYS_BA+0x040)  /*!< Miscellaneous Interrupt Enable Register */
N#define    REG_SYS_MISCISR      (SYS_BA+0x044)  /*!< Miscellaneous Interrupt Status Register */
N#define    REG_SYS_WKUPSER      (SYS_BA+0x058)  /*!< System Wakeup Source Enable Register */
N#define    REG_SYS_WKUPSSR      (SYS_BA+0x05C)  /*!< System Wakeup Source Status Register */
N#define    REG_SYS_AHBIPRST     (SYS_BA+0x060)  /*!< AHB IP Reset Control Register */
N#define    REG_SYS_APBIPRST0    (SYS_BA+0x064)  /*!< APB IP Reset Control Register 0 */
N#define    REG_SYS_APBIPRST1    (SYS_BA+0x068)  /*!< APB IP Reset Control Register 1 */
N#define    REG_SYS_RSTSTS       (SYS_BA+0x06C)  /*!< Reset Source Active Status Register */
N#define    REG_SYS_GPA_MFPL     (SYS_BA+0x070)  /*!< GPIOA Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPA_MFPH     (SYS_BA+0x074)  /*!< GPIOA High Byte Multiple Function Control Register */
N#define    REG_SYS_GPB_MFPL     (SYS_BA+0x078)  /*!< GPIOB Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPB_MFPH     (SYS_BA+0x07C)  /*!< GPIOB High Byte Multiple Function Control Register */
N#define    REG_SYS_GPC_MFPL     (SYS_BA+0x080)  /*!< GPIOC Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPC_MFPH     (SYS_BA+0x084)  /*!< GPIOC High Byte Multiple Function Control Register */
N#define    REG_SYS_GPD_MFPL     (SYS_BA+0x088)  /*!< GPIOD Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPD_MFPH     (SYS_BA+0x08C)  /*!< GPIOD High Byte Multiple Function Control Register */
N#define    REG_SYS_GPE_MFPL     (SYS_BA+0x090)  /*!< GPIOE Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPE_MFPH     (SYS_BA+0x094)  /*!< GPIOE High Byte Multiple Function Control Register */
N#define    REG_SYS_GPF_MFPL     (SYS_BA+0x098)  /*!< GPIOF Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPF_MFPH     (SYS_BA+0x09C)  /*!< GPIOF High Byte Multiple Function Control Register */
N#define    REG_SYS_GPG_MFPL     (SYS_BA+0x0A0)  /*!< GPIOG Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPG_MFPH     (SYS_BA+0x0A4)  /*!< GPIOG High Byte Multiple Function Control Register */
N#define    REG_SYS_GPH_MFPL     (SYS_BA+0x0A8)  /*!< GPIOH Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPH_MFPH     (SYS_BA+0x0AC)  /*!< GPIOH High Byte Multiple Function Control Register */
N#define    REG_SYS_GPI_MFPL     (SYS_BA+0x0B0)  /*!< GPIOI Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPI_MFPH     (SYS_BA+0x0B4)  /*!< GPIOI High Byte Multiple Function Control Register */
N#define    REG_SYS_GPJ_MFPL     (SYS_BA+0x0B8)  /*!< GPIOJ Low Byte Multiple Function Control Register */
N#define    REG_SYS_DDR_DSCTL    (SYS_BA+0x0F0)  /*!< DDR I/O Driving Strength Control Register */
N#define    REG_SYS_PORDISCR     (SYS_BA+0x100)  /*!< Power-On-Reset Disable Control Register */
N#define    REG_SYS_ICEDBGCR     (SYS_BA+0x104)  /*!< ICE Debug Interface Control Register */
N#define    REG_SYS_ERRADDCR     (SYS_BA+0x108)  /*!< Error Response Address Control Regsiter */
N#define    REG_SYS_REGWPCTL     (SYS_BA+0x1FC)  /*!< Register Write-Protection Control Register */
N
N/**@}*/ /* end of SYS register group */
N
N/*---------------------- System Clock Controller -------------------------*/
N/**
N    @addtogroup CLK System Clock Controller(CLK)
N    Memory Mapped Structure for CLK Controller
N@{ */
N
N#define    REG_CLK_PMCON        (CLK_BA+0x00) /*!< Power Management Control Register */
N#define    REG_CLK_HCLKEN       (CLK_BA+0x10) /*!< AHB IP Clock Enable Control Register */
N#define    REG_CLK_PCLKEN0      (CLK_BA+0x18) /*!< APB IP Clock Enable Control Register 0 */
N#define    REG_CLK_PCLKEN1      (CLK_BA+0x1C) /*!< APB IP Clock Enable Control Register 1 */
N#define    REG_CLK_DIVCTL0      (CLK_BA+0x20) /*!< Clock Divider Control Register 0 */
N#define    REG_CLK_DIVCTL1      (CLK_BA+0x24) /*!< Clock Divider Control Register 1 */
N#define    REG_CLK_DIVCTL2      (CLK_BA+0x28) /*!< Clock Divider Control Register 2 */
N#define    REG_CLK_DIVCTL3      (CLK_BA+0x2C) /*!< Clock Divider Control Register 3 */
N#define    REG_CLK_DIVCTL4      (CLK_BA+0x30) /*!< Clock Divider Control Register 4 */
N#define    REG_CLK_DIVCTL5      (CLK_BA+0x34) /*!< Clock Divider Control Register 5 */
N#define    REG_CLK_DIVCTL6      (CLK_BA+0x38) /*!< Clock Divider Control Register 6 */
N#define    REG_CLK_DIVCTL7      (CLK_BA+0x3C) /*!< Clock Divider Control Register 7 */
N#define    REG_CLK_DIVCTL8      (CLK_BA+0x40) /*!< Clock Divider Control Register 8 */
N#define    REG_CLK_DIVCTL9      (CLK_BA+0x44) /*!< Clock Divider Control Register 9 */
N#define    REG_CLK_APLLCON      (CLK_BA+0x60) /*!< APLL Control Register */
N#define    REG_CLK_UPLLCON      (CLK_BA+0x64) /*!< UPLL Control Register */
N#define    REG_CLK_PLLSTBCNTR   (CLK_BA+0x80) /*!< PLL Stable Counter and Test Clock Control Register */
N
N/**@}*/ /* end of CLK register group */
N
N
N/*---------------------- External Bus Interface Controller -------------------------*/
N/**
N    @addtogroup EBI External Bus Interface Controller(EBI)
N    Memory Mapped Structure for EBI Controller
N@{ */
N
N#define    REG_EBI_CTL          (EBI_BA+0x000)  /*!< EBI control register */
N#define    REG_EBI_BNKCTL0      (EBI_BA+0x018)  /*!< External I/O 0 control register */
N#define    REG_EBI_BNKCTL1      (EBI_BA+0x01C)  /*!< External I/O 1 control register */
N#define    REG_EBI_BNKCTL2      (EBI_BA+0x020)  /*!< External I/O 2 control register */
N#define    REG_EBI_BNKCTL3      (EBI_BA+0x024)  /*!< External I/O 3 control register */
N#define    REG_EBI_BNKCTL4      (EBI_BA+0x028)  /*!< External I/O 4 control register */
N
N/**@}*/ /* end of EBI register group */
N
N
N/*---------------------- Ethernet MAC Controller -------------------------*/
N/**
N    @addtogroup EMAC Ethernet MAC Controller(EMAC)
N    Memory Mapped Structure for EMAC Controller
N@{ */
N
N#define     REG_EMAC0_CAMCMR      (EMC0_BA+0x000) /*!< CAM Command Register */
N#define     REG_EMAC0_CAMEN       (EMC0_BA+0x004) /*!< CAM Enable Register */
N#define     REG_EMAC0_CAM0M       (EMC0_BA+0x008)  /*!< CAM0 Most Significant Word Register */
N#define     REG_EMAC0_CAM0L       (EMC0_BA+0x00c)  /*!< CAM0 Least Significant Word Register */
N#define     REG_EMAC0_CAMxM_Reg(x)(REG_EMAC0_CAM0M+(x)*0x8)  /*!< CAMx Most Significant Word Register */
N#define     REG_EMAC0_CAMxL_Reg(x)(REG_EMAC0_CAM0L+(x)*0x8)  /*!< CAMx Least Significant Word Register */
N#define     REG_EMAC0_TXDLSA      (EMC0_BA+0x088) /*!< Transmit Descriptor Link List Start Address Register */
N#define     REG_EMAC0_RXDLSA      (EMC0_BA+0x08C) /*!< Receive Descriptor Link List Start Address Register */
N#define     REG_EMAC0_MCMDR       (EMC0_BA+0x090) /*!< MAC Command Register */
N#define     REG_EMAC0_MIID        (EMC0_BA+0x094) /*!< MII Management Data Register */
N#define     REG_EMAC0_MIIDA       (EMC0_BA+0x098) /*!< MII Management Control and Address Register */
N#define     REG_EMAC0_FFTCR       (EMC0_BA+0x09C) /*!< FIFO Threshold Control Register */
N#define     REG_EMAC0_TSDR        (EMC0_BA+0x0a0) /*!< Transmit Start Demand Register */
N#define     REG_EMAC0_RSDR        (EMC0_BA+0x0a4) /*!< Receive Start Demand Register */
N#define     REG_EMAC0_DMARFC      (EMC0_BA+0x0a8) /*!< Maximum Receive Frame Control Register */
N#define     REG_EMAC0_MIEN        (EMC0_BA+0x0ac) /*!< MAC Interrupt Enable Register */
N#define     REG_EMAC0_MISTA       (EMC0_BA+0x0b0) /*!< MAC Interrupt Status Register */
N#define     REG_EMAC0_MGSTA       (EMC0_BA+0x0b4) /*!< MAC General Status Register */
N#define     REG_EMAC0_MPCNT       (EMC0_BA+0x0b8) /*!< Missed Packet Count Register */
N#define     REG_EMAC0_MRPC        (EMC0_BA+0x0bc) /*!< MAC Receive Pause Count Register */
N#define     REG_EMAC0_DMARFS      (EMC0_BA+0x0c8) /*!< DMA Receive Frame Status Register */
N#define     REG_EMAC0_CTXDSA      (EMC0_BA+0x0cc) /*!< Current Transmit Descriptor Start Address Register */
N#define     REG_EMAC0_CTXBSA      (EMC0_BA+0x0d0) /*!< Current Transmit Buffer Start Address Register */
N#define     REG_EMAC0_CRXDSA      (EMC0_BA+0x0d4) /*!< Current Receive Descriptor Start Address Register */
N#define     REG_EMAC0_CRXBSA      (EMC0_BA+0x0d8) /*!< Current Receive Buffer Start Address Register */
N#define     REG_EMAC0_TSCTL       (EMC0_BA+0x100) /*!< Time Stamp Control Register */
N#define     REG_EMAC0_TSSEC       (EMC0_BA+0x110) /*!< Time Stamp Counter Second Register */
N#define     REG_EMAC0_TSSUBSEC    (EMC0_BA+0x114) /*!< Time Stamp Counter Sub Second Register */
N#define     REG_EMAC0_TSINC       (EMC0_BA+0x118) /*!< Time Stamp Increment Register  */
N#define     REG_EMAC0_TSADDEN     (EMC0_BA+0x11c) /*!< Time Stamp Addend Register */
N#define     REG_EMAC0_TSUPDSEC    (EMC0_BA+0x120) /*!< Time Stamp Update Second Register */
N#define     REG_EMAC0_TSUPDSUBSEC (EMC0_BA+0x124) /*!< Time Stamp Update Sub Second Register */
N#define     REG_EMAC0_TSALMSEC    (EMC0_BA+0x128) /*!< Time Stamp Alarm Second Register */
N#define     REG_EMAC0_TSALMSUBSEC (EMC0_BA+0x12c) /*!< Time Stamp Alarm Sub Second Register */
N
N#define     REG_EMAC1_CAMCMR      (EMC1_BA+0x000) /*!< CAM Command Register */
N#define     REG_EMAC1_CAMEN       (EMC1_BA+0x004) /*!< CAM Enable Register */
N#define     REG_EMAC1_CAM0M       (EMC1_BA+0x008)  /*!< CAM0 Most Significant Word Register */
N#define     REG_EMAC1_CAM0L       (EMC1_BA+0x00c)  /*!< CAM0 Least Significant Word Register */
N#define     REG_EMAC1_CAMxM_Reg(x)(REG_EMAC1_CAM0M+(x)*0x8)  /*!< CAMx Most Significant Word Register */
N#define     REG_EMAC1_CAMxL_Reg(x)(REG_EMAC1_CAM0L+(x)*0x8)  /*!< CAMx Least Significant Word Register */
N#define     REG_EMAC1_TXDLSA      (EMC1_BA+0x088) /*!< Transmit Descriptor Link List Start Address Register */
N#define     REG_EMAC1_RXDLSA      (EMC1_BA+0x08C) /*!< Receive Descriptor Link List Start Address Register */
N#define     REG_EMAC1_MCMDR       (EMC1_BA+0x090) /*!< MAC Command Register */
N#define     REG_EMAC1_MIID        (EMC1_BA+0x094) /*!< MII Management Data Register */
N#define     REG_EMAC1_MIIDA       (EMC1_BA+0x098) /*!< MII Management Control and Address Register */
N#define     REG_EMAC1_FFTCR       (EMC1_BA+0x09C) /*!< FIFO Threshold Control Register */
N#define     REG_EMAC1_TSDR        (EMC1_BA+0x0a0) /*!< Transmit Start Demand Register */
N#define     REG_EMAC1_RSDR        (EMC1_BA+0x0a4) /*!< Receive Start Demand Register */
N#define     REG_EMAC1_DMARFC      (EMC1_BA+0x0a8) /*!< Maximum Receive Frame Control Register */
N#define     REG_EMAC1_MIEN        (EMC1_BA+0x0ac) /*!< MAC Interrupt Enable Register */
N#define     REG_EMAC1_MISTA       (EMC1_BA+0x0b0) /*!< MAC Interrupt Status Register */
N#define     REG_EMAC1_MGSTA       (EMC1_BA+0x0b4) /*!< MAC General Status Register */
N#define     REG_EMAC1_MPCNT       (EMC1_BA+0x0b8) /*!< Missed Packet Count Register */
N#define     REG_EMAC1_MRPC        (EMC1_BA+0x0bc) /*!< MAC Receive Pause Count Register */
N#define     REG_EMAC1_DMARFS      (EMC1_BA+0x0c8) /*!< DMA Receive Frame Status Register */
N#define     REG_EMAC1_CTXDSA      (EMC1_BA+0x0cc) /*!< Current Transmit Descriptor Start Address Register */
N#define     REG_EMAC1_CTXBSA      (EMC1_BA+0x0d0) /*!< Current Transmit Buffer Start Address Register */
N#define     REG_EMAC1_CRXDSA      (EMC1_BA+0x0d4) /*!< Current Receive Descriptor Start Address Register */
N#define     REG_EMAC1_CRXBSA      (EMC1_BA+0x0d8) /*!< Current Receive Buffer Start Address Register */
N#define     REG_EMAC1_TSCTL       (EMC1_BA+0x100) /*!< Time Stamp Control Register */
N#define     REG_EMAC1_TSSEC       (EMC1_BA+0x110) /*!< Time Stamp Counter Second Register */
N#define     REG_EMAC1_TSSUBSEC    (EMC1_BA+0x114) /*!< Time Stamp Counter Sub Second Register */
N#define     REG_EMAC1_TSINC       (EMC1_BA+0x118) /*!< Time Stamp Increment Register  */
N#define     REG_EMAC1_TSADDEN     (EMC1_BA+0x11c) /*!< Time Stamp Addend Register */
N#define     REG_EMAC1_TSUPDSEC    (EMC1_BA+0x120) /*!< Time Stamp Update Second Register */
N#define     REG_EMAC1_TSUPDSUBSEC (EMC1_BA+0x124) /*!< Time Stamp Update Sub Second Register */
N#define     REG_EMAC1_TSALMSEC    (EMC1_BA+0x128) /*!< Time Stamp Alarm Second Register */
N#define     REG_EMAC1_TSALMSUBSEC (EMC1_BA+0x12c) /*!< Time Stamp Alarm Sub Second Register */
N
N/**@}*/ /* end of EMAC register group */
N
N/*----------------------  General Direct Memory Access Controller -------------------------*/
N/**
N    @addtogroup GDMA  General Direct Memory Access Controller(GDMA)
N    Memory Mapped Structure for GDMA Controller
N@{ */
N
N#define     REG_GDMA_CTL0   (GDMA_BA+0x000)  /*!< Channel 0 Control Register */
N#define     REG_GDMA_SRCB0  (GDMA_BA+0x004)  /*!< Channel 0 Source Base Address Register */
N#define     REG_GDMA_DSTB0  (GDMA_BA+0x008)  /*!< Channel 0 Destination Base Address Register */
N#define     REG_GDMA_TCNT0  (GDMA_BA+0x00C)  /*!< Channel 0 Transfer Count Register */
N#define     REG_GDMA_CSRC0  (GDMA_BA+0x010)  /*!< Channel 0 Current Source Address Register */
N#define     REG_GDMA_CDST0  (GDMA_BA+0x014)  /*!< Channel 0 Current Destination Address Register */
N#define     REG_GDMA_CTCNT0 (GDMA_BA+0x018)  /*!< Channel 0 Current Transfer Count Register */
N#define     REG_GDMA_DADR0  (GDMA_BA+0x01C)  /*!< Channel 0 Descriptor Address Register */
N#define     REG_GDMA_CTL1   (GDMA_BA+0x020)  /*!< Channel 1 Control Register */
N#define     REG_GDMA_SRCB1  (GDMA_BA+0x024)  /*!< Channel 1 Source Base Address Register */
N#define     REG_GDMA_DSTB1  (GDMA_BA+0x028)  /*!< Channel 1 Destination Base Address Register */
N#define     REG_GDMA_TCNT1  (GDMA_BA+0x02C)  /*!< Channel 1 Transfer Count Register */
N#define     REG_GDMA_CSRC1  (GDMA_BA+0x030)  /*!< Channel 1 Current Source Address Register */
N#define     REG_GDMA_CDST1  (GDMA_BA+0x034)  /*!< Channel 1 Current Destination Address Register */
N#define     REG_GDMA_CTCNT1 (GDMA_BA+0x038)  /*!< Channel 1 Current Transfer Count Register */
N#define     REG_GDMA_DADR1  (GDMA_BA+0x03C)  /*!< Channel 1 Descriptor Address Register */
N#define     REG_GDMA_INTBUF0    (GDMA_BA+0x080)  /*!< GDMA Internal Buffer Word 0 */
N#define     REG_GDMA_INTBUF1    (GDMA_BA+0x084)  /*!< GDMA Internal Buffer Word 1 */
N#define     REG_GDMA_INTBUF2    (GDMA_BA+0x088)  /*!< GDMA Internal Buffer Word 2 */
N#define     REG_GDMA_INTBUF3    (GDMA_BA+0x08C)  /*!< GDMA Internal Buffer Word 3 */
N#define     REG_GDMA_INTBUF4    (GDMA_BA+0x090)  /*!< GDMA Internal Buffer Word 4 */
N#define     REG_GDMA_INTBUF5    (GDMA_BA+0x094)  /*!< GDMA Internal Buffer Word 5 */
N#define     REG_GDMA_INTBUF6    (GDMA_BA+0x098)  /*!< GDMA Internal Buffer Word 6 */
N#define     REG_GDMA_INTBUF7    (GDMA_BA+0x09C)  /*!< GDMA Internal Buffer Word 7 */
N#define     REG_GDMA_INTCS  (GDMA_BA+0x0A0)  /*!< Interrupt Control and Status Register */
N
N/**@}*/ /* end of GDMA register group */
N
N
N
N/*---------------------- USB Device Controller -------------------------*/
N/**
N    @addtogroup USBD USB Device Controller(USBD)
N    Memory Mapped Structure for USBD Controller
N@{ */
N#define     REG_USBD_GINTSTS        (USBD_BA+0x00)  /*!< Interrupt Status Low Register */
N#define     REG_USBD_GINTEN         (USBD_BA+0x08)  /*!< Interrupt Enable Low Register */
N#define     REG_USBD_BUSINTSTS      (USBD_BA+0x10)  /*!< USB Bus Interrupt Status Register */
N#define     REG_USBD_BUSINTEN       (USBD_BA+0x14)  /*!< USB Bus Interrupt Enable Register */
N#define     REG_USBD_OPER           (USBD_BA+0x18)  /*!< USB Operational Register */
N#define     REG_USBD_FRAMECNT       (USBD_BA+0x1C)  /*!< USB Frame Count Register */
N#define     REG_USBD_FADDR          (USBD_BA+0x20)  /*!< USB Function Address Register */
N#define     REG_USBD_TEST           (USBD_BA+0x24)  /*!< USB Test Mode Register */
N#define     REG_USBD_CEPDAT         (USBD_BA+0x28)  /*!< Control-ep data buffer register */
N#define     REG_USBD_CEPCTL         (USBD_BA+0x2C)  /*!< Control-ep control and status register */
N#define     REG_USBD_CEPINTEN       (USBD_BA+0x30)  /*!< Control-ep interrupt enable register */
N#define     REG_USBD_CEPINTSTS      (USBD_BA+0x34)  /*!< Control-ep interrupt status register */
N#define     REG_USBD_CEPTXCNT       (USBD_BA+0x38)  /*!< In-transfer data count register */
N#define     REG_USBD_CEPRXCNT       (USBD_BA+0x3C)  /*!< Out-transfer data count register */
N#define     REG_USBD_CEPDATCNT      (USBD_BA+0x40)  /*!< Control-ep data count register */
N#define     REG_USBD_SETUP1_0       (USBD_BA+0x44)  /*!< Setup byte1 & byte0 register */
N#define     REG_USBD_SETUP3_2       (USBD_BA+0x48)  /*!< Setup byte3 & byte2 register */
N#define     REG_USBD_SETUP5_4       (USBD_BA+0x4C)  /*!< Setup byte5 & byte4 register */
N#define     REG_USBD_SETUP7_6       (USBD_BA+0x50)  /*!< Setup byte7 & byte6 register */
N#define     REG_USBD_CEPBUFSTART    (USBD_BA+0x54)  /*!< Control-ep ram start address register */
N#define     REG_USBD_CEPBUFEND      (USBD_BA+0x58)  /*!< Control-ep ram end address register */
N#define     REG_USBD_DMACTL         (USBD_BA+0x5C)  /*!< Dma control and status register */
N#define     REG_USBD_DMACNT         (USBD_BA+0x60)  /*!< Dma count register */
N
N#define     REG_USBD_EPADAT         (USBD_BA+0x64)  /*!< Endpoint A data buffer register */
N#define     REG_USBD_EPAINTSTS      (USBD_BA+0x68)  /*!< Endpoint A interrupt status register */
N#define     REG_USBD_EPAINTEN       (USBD_BA+0x6C)  /*!< Endpoint A interrupt enable register */
N#define     REG_USBD_EPADATCNT      (USBD_BA+0x70)  /*!< Data count available in endpoint A buffer */
N#define     REG_USBD_EPARSPCTL      (USBD_BA+0x74)  /*!< Endpoint A response register set/clear */
N#define     REG_USBD_EPAMPS         (USBD_BA+0x78)  /*!< Endpoint A max packet size register */
N#define     REG_USBD_EPATXCNT       (USBD_BA+0x7C)  /*!< Endpoint A transfer count register */
N#define     REG_USBD_EPACFG         (USBD_BA+0x80)  /*!< Endpoint A configuration register */
N#define     REG_USBD_EPABUFSTART    (USBD_BA+0x84)  /*!< Endpoint A ram start address register */
N#define     REG_USBD_EPABUFEND      (USBD_BA+0x88)  /*!< Endpoint A ram end address register */
N
N#define     REG_USBD_EPBDAT         (USBD_BA+0x8C)  /*!< Endpoint B data buffer register */
N#define     REG_USBD_EPBINTSTS      (USBD_BA+0x90)  /*!< Endpoint B interrupt status register */
N#define     REG_USBD_EPBINTEN       (USBD_BA+0x94)  /*!< Endpoint B interrupt enable register */
N#define     REG_USBD_EPBDATCNT      (USBD_BA+0x98)  /*!< Data count available in endpoint B buffer */
N#define     REG_USBD_EPBRSPCTL      (USBD_BA+0x9C)  /*!< Endpoint B response register set/clear */
N#define     REG_USBD_EPBMPS         (USBD_BA+0xA0)  /*!< Endpoint B max packet size register */
N#define     REG_USBD_EPBTXCNT       (USBD_BA+0xA4)  /*!< Endpoint B transfer count register */
N#define     REG_USBD_EPBCFG         (USBD_BA+0xA8)  /*!< Endpoint B configuration register */
N#define     REG_USBD_EPBBUFSTART    (USBD_BA+0xAC)  /*!< Endpoint B ram start address register */
N#define     REG_USBD_EPBBUFEND      (USBD_BA+0xB0)  /*!< Endpoint B ram end address register */
N
N#define     REG_USBD_EPCDAT         (USBD_BA+0xB4)  /*!< Endpoint C data buffer register */
N#define     REG_USBD_EPCINTSTS      (USBD_BA+0xB8)  /*!< Endpoint C interrupt status register */
N#define     REG_USBD_EPCINTEN       (USBD_BA+0xBC)  /*!< Endpoint C interrupt enable register */
N#define     REG_USBD_EPCDATCNT      (USBD_BA+0xC0)  /*!< Data count available in endpoint C buffer */
N#define     REG_USBD_EPCRSPCTL      (USBD_BA+0xC4)  /*!< Endpoint C response register set/clear */
N#define     REG_USBD_EPCMPS         (USBD_BA+0xC8)  /*!< Endpoint C max packet size register */
N#define     REG_USBD_EPCTXCNT       (USBD_BA+0xCC)  /*!< Endpoint C transfer count register */
N#define     REG_USBD_EPCCFG         (USBD_BA+0xD0)  /*!< Endpoint C configuration register */
N#define     REG_USBD_EPCBUFSTART    (USBD_BA+0xD4)  /*!< Endpoint C ram start address register */
N#define     REG_USBD_EPCBUFEND      (USBD_BA+0xD8)  /*!< Endpoint C ram end address register */
N
N#define     REG_USBD_EPDDAT         (USBD_BA+0xDC)  /*!< Endpoint D data buffer register */
N#define     REG_USBD_EPDINTSTS      (USBD_BA+0xE0)  /*!< Endpoint D interrupt status register */
N#define     REG_USBD_EPDINTEN       (USBD_BA+0xE4)  /*!< Endpoint D interrupt enable register */
N#define     REG_USBD_EPDDATCNT      (USBD_BA+0xE8)  /*!< Data count available in endpoint D buffer */
N#define     REG_USBD_EPDRSPCTL      (USBD_BA+0xEC)  /*!< Endpoint D response register set/clear */
N#define     REG_USBD_EPDMPS         (USBD_BA+0xF0)  /*!< Endpoint D max packet size register */
N#define     REG_USBD_EPDTXCNT       (USBD_BA+0xF4)  /*!< Endpoint D transfer count register */
N#define     REG_USBD_EPDCFG         (USBD_BA+0xF8)  /*!< Endpoint D configuration register */
N#define     REG_USBD_EPDBUFSTART    (USBD_BA+0xFC)  /*!< Endpoint D ram start address register */
N#define     REG_USBD_EPDBUFEND      (USBD_BA+0x100) /*!< Endpoint D ram end address register */
N
N#define     REG_USBD_EPEDAT         (USBD_BA+0x104) /*!< Endpoint E data buffer register */
N#define     REG_USBD_EPEINTSTS      (USBD_BA+0x108) /*!< Endpoint E interrupt status register */
N#define     REG_USBD_EPEINTEN       (USBD_BA+0x10C) /*!< Endpoint E interrupt enable register */
N#define     REG_USBD_EPEDATCNT      (USBD_BA+0x110) /*!< Data count available in endpoint E buffer */
N#define     REG_USBD_EPERSPCTL      (USBD_BA+0x114) /*!< Endpoint E response register set/clear */
N#define     REG_USBD_EPEMPS         (USBD_BA+0x118) /*!< Endpoint E max packet size register */
N#define     REG_USBD_EPETXCNT       (USBD_BA+0x11C) /*!< Endpoint E transfer count register */
N#define     REG_USBD_EPECFG         (USBD_BA+0x120) /*!< Endpoint E configuration register */
N#define     REG_USBD_EPEBUFSTART    (USBD_BA+0x124) /*!< Endpoint E ram start address register */
N#define     REG_USBD_EPEBUFEND      (USBD_BA+0x128) /*!< Endpoint E ram end address register */
N
N#define     REG_USBD_EPFDAT         (USBD_BA+0x12C) /*!< Endpoint F data buffer register */
N#define     REG_USBD_EPFINTSTS      (USBD_BA+0x130) /*!< Endpoint F interrupt status register */
N#define     REG_USBD_EPFINTEN       (USBD_BA+0x134) /*!< Endpoint F interrupt enable register */
N#define     REG_USBD_EPFDATCNT      (USBD_BA+0x138) /*!< Data count available in endpoint F buffer */
N#define     REG_USBD_EPFRSPCTL      (USBD_BA+0x13C) /*!< Endpoint F response register set/clear */
N#define     REG_USBD_EPFMPS         (USBD_BA+0x140) /*!< Endpoint F max packet size register */
N#define     REG_USBD_EPFTXCNT       (USBD_BA+0x144) /*!< Endpoint F transfer count register */
N#define     REG_USBD_EPFCFG         (USBD_BA+0x148) /*!< Endpoint F configuration register */
N#define     REG_USBD_EPFBUFSTART    (USBD_BA+0x14C) /*!< Endpoint F ram start address register */
N#define     REG_USBD_EPFBUFEND      (USBD_BA+0x150) /*!< Endpoint F ram end address register */
N
N#define     REG_USBD_EPGDAT         (USBD_BA+0x154) /*!< Endpoint G data buffer register */
N#define     REG_USBD_EPGINTSTS      (USBD_BA+0x158) /*!< Endpoint G interrupt status register */
N#define     REG_USBD_EPGINTEN       (USBD_BA+0x15C) /*!< Endpoint G interrupt enable register */
N#define     REG_USBD_EPGDATCNT      (USBD_BA+0x160) /*!< Data count available in endpoint G buffer */
N#define     REG_USBD_EPGRSPCTL      (USBD_BA+0x164) /*!< Endpoint G response register set/clear */
N#define     REG_USBD_EPGMPS         (USBD_BA+0x168) /*!< Endpoint G max packet size register */
N#define     REG_USBD_EPGTXCNT       (USBD_BA+0x16C) /*!< Endpoint G transfer count register */
N#define     REG_USBD_EPGCFG         (USBD_BA+0x170) /*!< Endpoint G configuration register */
N#define     REG_USBD_EPGBUFSTART    (USBD_BA+0x174) /*!< Endpoint G ram start address register */
N#define     REG_USBD_EPGBUFEND      (USBD_BA+0x178) /*!< Endpoint G ram end address register */
N
N#define     REG_USBD_EPHDAT         (USBD_BA+0x17C) /*!< Endpoint H data buffer register */
N#define     REG_USBD_EPHINTSTS      (USBD_BA+0x180) /*!< Endpoint H interrupt status register */
N#define     REG_USBD_EPHINTEN       (USBD_BA+0x184) /*!< Endpoint H interrupt enable register */
N#define     REG_USBD_EPHDATCNT      (USBD_BA+0x188) /*!< Data count available in endpoint H buffer */
N#define     REG_USBD_EPHRSPCTL      (USBD_BA+0x18C) /*!< Endpoint H response register set/clear */
N#define     REG_USBD_EPHMPS         (USBD_BA+0x190) /*!< Endpoint H max packet size register */
N#define     REG_USBD_EPHTXCNT       (USBD_BA+0x194) /*!< Endpoint H transfer count register */
N#define     REG_USBD_EPHCFG         (USBD_BA+0x198) /*!< Endpoint H configuration register */
N#define     REG_USBD_EPHBUFSTART    (USBD_BA+0x19C) /*!< Endpoint H ram start address register */
N#define     REG_USBD_EPHBUFEND      (USBD_BA+0x1A0) /*!< Endpoint H ram end address register */
N
N#define     REG_USBD_EPIDAT         (USBD_BA+0x1A4) /*!< Endpoint I data buffer register */
N#define     REG_USBD_EPIINTSTS      (USBD_BA+0x1A8) /*!< Endpoint I interrupt status register */
N#define     REG_USBD_EPIINTEN       (USBD_BA+0x1AC) /*!< Endpoint I interrupt enable register */
N#define     REG_USBD_EPIDATCNT      (USBD_BA+0x1B0) /*!< Data count available in endpoint I buffer */
N#define     REG_USBD_EPIRSPCTL      (USBD_BA+0x1B4) /*!< Endpoint I response register set/clear */
N#define     REG_USBD_EPIMPS         (USBD_BA+0x1B8) /*!< Endpoint I max packet size register */
N#define     REG_USBD_EPITXCNT       (USBD_BA+0x1BC) /*!< Endpoint I transfer count register */
N#define     REG_USBD_EPICFG         (USBD_BA+0x1C0) /*!< Endpoint I configuration register */
N#define     REG_USBD_EPIBUFSTART    (USBD_BA+0x1C4) /*!< Endpoint I ram start address register */
N#define     REG_USBD_EPIBUFEND      (USBD_BA+0x1C8) /*!< Endpoint I ram end address register */
N
N#define     REG_USBD_EPJDAT         (USBD_BA+0x1CC) /*!< Endpoint J data buffer register */
N#define     REG_USBD_EPJINTSTS      (USBD_BA+0x1D0) /*!< Endpoint J interrupt status register */
N#define     REG_USBD_EPJINTEN       (USBD_BA+0x1D4) /*!< Endpoint J interrupt enable register */
N#define     REG_USBD_EPJDATCNT      (USBD_BA+0x1D8) /*!< Data count available in endpoint J buffer */
N#define     REG_USBD_EPJRSPCTL      (USBD_BA+0x1DC) /*!< Endpoint J response register set/clear */
N#define     REG_USBD_EPJMPS         (USBD_BA+0x1E0) /*!< Endpoint J max packet size register */
N#define     REG_USBD_EPJTXCNT       (USBD_BA+0x1E4) /*!< Endpoint J transfer count register */
N#define     REG_USBD_EPJCFG         (USBD_BA+0x1E8) /*!< Endpoint J configuration register */
N#define     REG_USBD_EPJBUFSTART    (USBD_BA+0x1EC) /*!< Endpoint J ram start address register */
N#define     REG_USBD_EPJBUFEND      (USBD_BA+0x1F0) /*!< Endpoint J ram end address register */
N
N#define     REG_USBD_EPKDAT         (USBD_BA+0x1F4) /*!< Endpoint K data buffer register */
N#define     REG_USBD_EPKINTSTS      (USBD_BA+0x1F8) /*!< Endpoint K interrupt status register */
N#define     REG_USBD_EPKINTEN       (USBD_BA+0x1FC) /*!< Endpoint K interrupt enable register */
N#define     REG_USBD_EPKDATCNT      (USBD_BA+0x200) /*!< Data count available in endpoint K buffer */
N#define     REG_USBD_EPKRSPCTL      (USBD_BA+0x204) /*!< Endpoint K response register set/clear */
N#define     REG_USBD_EPKMPS         (USBD_BA+0x208) /*!< Endpoint K max packet size register */
N#define     REG_USBD_EPKTXCNT       (USBD_BA+0x20C) /*!< Endpoint K transfer count register */
N#define     REG_USBD_EPKCFG         (USBD_BA+0x210) /*!< Endpoint K configuration register */
N#define     REG_USBD_EPKBUFSTART    (USBD_BA+0x214) /*!< Endpoint K ram start address register */
N#define     REG_USBD_EPKBUFEND      (USBD_BA+0x218) /*!< Endpoint K ram end address register */
N
N#define     REG_USBD_EPLDAT         (USBD_BA+0x21C) /*!< Endpoint L data buffer register */
N#define     REG_USBD_EPLINTSTS      (USBD_BA+0x220) /*!< Endpoint L interrupt status register */
N#define     REG_USBD_EPLINTEN       (USBD_BA+0x224) /*!< Endpoint L interrupt enable register */
N#define     REG_USBD_EPLDATCNT      (USBD_BA+0x228) /*!< Data count available in endpoint L buffer */
N#define     REG_USBD_EPLRSPCTL      (USBD_BA+0x22C) /*!< Endpoint L response register set/clear */
N#define     REG_USBD_EPLMPS         (USBD_BA+0x230) /*!< Endpoint L max packet size register */
N#define     REG_USBD_EPLTXCNT       (USBD_BA+0x234) /*!< Endpoint L transfer count register */
N#define     REG_USBD_EPLCFG         (USBD_BA+0x238) /*!< Endpoint L configuration register */
N#define     REG_USBD_EPLBUFSTART    (USBD_BA+0x23C) /*!< Endpoint L ram start address register */
N#define     REG_USBD_EPLBUFEND      (USBD_BA+0x240) /*!< Endpoint L ram end address register */
N#define     REG_USBD_DMAADDR        (USBD_BA+0x700) /*!< AHB_DMA address register */
N#define     REG_USBD_PHYCTL         (USBD_BA+0x704) /*!< USB PHY control register */
N
N/**@}*/ /* end of USBD register group */
N
N
N/*----------------------  LCD Display Interface Controller -------------------------*/
N/**
N    @addtogroup LCM  LCD Display Interface Controller(LCM)
N    Memory Mapped Structure for LCM Controller
N@{ */
N
N#define     REG_LCM_DCCS        (LCM_BA+0x00)  /*!< Display Controller Control/Status Register */
N#define     REG_LCM_DEV_CTRL    (LCM_BA+0x04)  /*!< Display Output Device Control Register */
N#define     REG_LCM_MPU_CMD     (LCM_BA+0x08)  /*!< MPU-Interface LCD Write Command */
N#define     REG_LCM_INT_CS      (LCM_BA+0x0c)  /*!< Interrupt Control/Status Register */
N#define     REG_LCM_CRTC_SIZE   (LCM_BA+0x10)  /*!< CRTC Display Size Control Register */
N#define     REG_LCM_CRTC_DEND   (LCM_BA+0x14)  /*!< CRTC Display Enable End */
N#define     REG_LCM_CRTC_HR     (LCM_BA+0x18)  /*!< CRTC Internal Horizontal Retrace Control Register */
N#define     REG_LCM_CRTC_HSYNC  (LCM_BA+0x1C)  /*!< CRTC Horizontal Sync Control Register */
N#define     REG_LCM_CRTC_VR     (LCM_BA+0x20)  /*!< CRTC Internal Vertical Retrace Control Register */
N#define     REG_LCM_VA_BADDR0   (LCM_BA+0x24)  /*!< Video Stream Frame Buffer-0 Starting Address */
N#define     REG_LCM_VA_BADDR1   (LCM_BA+0x28)  /*!< Video Stream Frame Buffer-1 Starting Address */
N#define     REG_LCM_VA_FBCTRL   (LCM_BA+0x2C)  /*!< Video Stream Frame Buffer Control Register */
N#define     REG_LCM_VA_SCALE    (LCM_BA+0x30)  /*!< Video Stream Scaling Control Register */
N#define     REG_LCM_VA_WIN      (LCM_BA+0x38)  /*!< Image Stream Active Window Coordinates */
N#define     REG_LCM_VA_STUFF    (LCM_BA+0x3C)  /*!< Image Stream Stuff Pixel */
N#define     REG_LCM_OSD_WINS    (LCM_BA+0x40)  /*!< OSD Window Starting Coordinates */
N#define     REG_LCM_OSD_WINE    (LCM_BA+0x44)  /*!< OSD Window Ending Coordinates */
N#define     REG_LCM_OSD_BADDR   (LCM_BA+0x48)  /*!< OSD Stream Frame Buffer Starting Address */
N#define     REG_LCM_OSD_FBCTRL  (LCM_BA+0x4c)  /*!< OSD Stream Frame Buffer Control Register */
N#define     REG_LCM_OSD_OVERLAY (LCM_BA+0x50)  /*!< OSD Overlay Control Register */
N#define     REG_LCM_OSD_CKEY    (LCM_BA+0x54)  /*!< OSD Overlay Color-Key Pattern Register */
N#define     REG_LCM_OSD_CMASK   (LCM_BA+0x58)  /*!< OSD Overlay Color-Key Mask Register */
N#define     REG_LCM_OSD_SKIP1   (LCM_BA+0x5C)  /*!< OSD Window Skip1 Register */
N#define     REG_LCM_OSD_SKIP2   (LCM_BA+0x60)  /*!< OSD Window Skip2 Register */
N#define     REG_LCM_OSD_SCALE   (LCM_BA+0x64)  /*!< OSD horizontal up scaling control register */
N#define     REG_LCM_MPU_VSYNC   (LCM_BA+0x68)  /*!< MPU Vsync control register */
N#define     REG_LCM_HC_CTRL     (LCM_BA+0x6C)  /*!< Hardware cursor control Register */
N#define     REG_LCM_HC_POS      (LCM_BA+0x70)  /*!< Hardware cursot tip point potison on va picture */
N#define     REG_LCM_HC_WBCTRL   (LCM_BA+0x74)  /*!< Hardware Cursor Window Buffer Control Register */
N#define     REG_LCM_HC_BADDR    (LCM_BA+0x78)  /*!< Hardware cursor memory base address register */
N#define     REG_LCM_HC_COLOR0   (LCM_BA+0x7C)  /*!< Hardware cursor color ram register mapped to bpp = 0 */
N#define     REG_LCM_HC_COLOR1   (LCM_BA+0x80)  /*!< Hardware cursor color ram register mapped to bpp = 1 */
N#define     REG_LCM_HC_COLOR2   (LCM_BA+0x84)  /*!< Hardware cursor color ram register mapped to bpp = 2 */
N#define     REG_LCM_HC_COLOR3   (LCM_BA+0x88)  /*!< Hardware cursor color ram register mapped to bpp = 3 */
N
N/**@}*/ /* end of LCM register group */
N
N
N/*---------------------- I2S Interface Controller -------------------------*/
N/**
N    @addtogroup I2S I2S Interface Controller(I2S)
N    Memory Mapped Structure for I2S Controller
N@{ */
N
N#define     REG_ACTL_CON            (ACTL_BA+0x00)      /*!< Audio controller control register */
N#define     REG_ACTL_RESET          (ACTL_BA+0x04)      /*!< Sub block reset control register */
N#define     REG_ACTL_RDESB          (ACTL_BA+0x08)      /*!< DMA destination base address register for record */
N#define     REG_ACTL_RDES_LENGTH    (ACTL_BA+0x0C)      /*!< DMA destination length register for record */
N#define     REG_ACTL_RDESC          (ACTL_BA+0x10)      /*!< DMA destination current address for record */
N#define     REG_ACTL_PDESB          (ACTL_BA+0x14)      /*!< DMA destination current address for play */
N#define     REG_ACTL_PDES_LENGTH    (ACTL_BA+0x18)      /*!< DMA destination length register for play */
N#define     REG_ACTL_PDESC          (ACTL_BA+0x1C)      /*!< DMA destination current address register for play */
N#define     REG_ACTL_RSR            (ACTL_BA+0x20)      /*!< Record status register */
N#define     REG_ACTL_PSR            (ACTL_BA+0x24)      /*!< Play status register */
N#define     REG_ACTL_I2SCON         (ACTL_BA+0x28)      /*!< I2S control register */
N#define     REG_ACTL_COUNTER        (ACTL_BA+0x2C)      /*!< DMA count down values */
N#define     REG_ACTL_PCMCON         (ACTL_BA+0x30)      /*!< PCM interface control register */
N#define     REG_ACTL_PCMS1ST        (ACTL_BA+0x34)      /*!< PCM interface slot1 start register */
N#define     REG_ACTL_PCMS2ST        (ACTL_BA+0x38)      /*!< PCM interface slot2 start register */
N#define     REG_ACTL_RDESB2         (ACTL_BA+0x40)      /*!< DMA destination base address register for record right channel */
N#define     REG_ACTL_PDESB2         (ACTL_BA+0x44)      /*!< DMA destination base address register for play right channel */
N
N/**@}*/ /* end of I2S register group */
N
N/*---------------------- 2D Graphic Engine -------------------------*/
N/**
N    @addtogroup GE2D 2D Graphic Engine(GE2D)
N    Memory Mapped Structure for GE2D Controller
N@{ */
N
N#define     REG_GE2D_TRG            (GE_BA+0x00)  /*!< Graphic Engine Trigger Control Register */
N#define     REG_GE2D_XYSORG         (GE_BA+0x04)  /*!< Graphic Engine XY Mode Source Origin Starting Register */
N#define     REG_GE2D_TCNTVHSF       (GE_BA+0x08)  /*!< Graphic Engine Tile Width/Height or V/H Scale Factor N/M */
N#define     REG_GE2D_XYRRP          (GE_BA+0x0C)  /*!< Graphic Engine Rotate Reference Point XY Address */
N#define     REG_GE2D_INTSTS         (GE_BA+0x10)  /*!< Graphic Engine Interrupt Status Register */
N#define     REG_GE2D_PATSA          (GE_BA+0x14)  /*!< Graphic Engine Pattern Location Starting Address Register */
N#define     REG_GE2D_BETSC          (GE_BA+0x18)  /*!< GE Bresenham Error Term Stepping Constant Register */
N#define     REG_GE2D_BIEPC          (GE_BA+0x1C)  /*!< GE Bresenham Initial Error, Pixel Count Major M Register */
N#define     REG_GE2D_CTL            (GE_BA+0x20)  /*!< Graphic Engine Control Register */
N#define     REG_GE2D_BGCOLR         (GE_BA+0x24)  /*!< Graphic Engine Background Color Register */
N#define     REG_GE2D_FGCOLR         (GE_BA+0x28)  /*!< Graphic Engine Foreground Color Register */
N#define     REG_GE2D_TRNSCOLR       (GE_BA+0x2C)  /*!< Graphic Engine Transparency Color Register */
N#define     REG_GE2D_TCMSK          (GE_BA+0x30)  /*!< Graphic Engine Transparency Color Mask Register */
N#define     REG_GE2D_XYDORG         (GE_BA+0x34)  /*!< Graphic Engine XY Mode Display Origin Starting Register */
N#define     REG_GE2D_SDPITCH        (GE_BA+0x38)  /*!< Graphic Engine Source/Destination Pitch Register */
N#define     REG_GE2D_SRCSPA         (GE_BA+0x3C)  /*!< Graphic Engine Source Start XY/Linear Address Register */
N#define     REG_GE2D_DSTSPA         (GE_BA+0x40)  /*!< Graphic Engine Destination Start XY/Linear Register */
N#define     REG_GE2D_RTGLSZ         (GE_BA+0x44)  /*!< Graphic Engine Dimension XY/Linear Register */
N#define     REG_GE2D_CLPBTL         (GE_BA+0x48)  /*!< Graphic Engine Clipping Boundary Top/Left Register */
N#define     REG_GE2D_CLPBBR         (GE_BA+0x4C)  /*!< Graphic Engine Clipping Boundary Bottom/Right Register */
N#define     REG_GE2D_PTNA           (GE_BA+0x50)  /*!< Graphic Engine Pattern A Register */
N#define     REG_GE2D_PTNB           (GE_BA+0x54)  /*!< Graphic Engine Pattern B Register */
N#define     REG_GE2D_WRPLNMSK       (GE_BA+0x58)  /*!< Graphic Engine Write Plane Mask Register */
N#define     REG_GE2D_MISCTL         (GE_BA+0x5C)  /*!< Graphic Engine Miscellaneous Control Register */
N#define     REG_GE2D_GEHBDW0        (GE_BA+0x60)  /*!< Graphic Engine HostBLT data Port 0 Register */
N#define     REG_GE2D_GEHBDW1        (GE_BA+0x64)  /*!< Graphic Engine HostBLT data Port 1 Register */
N#define     REG_GE2D_GEHBDW2        (GE_BA+0x68)  /*!< Graphic Engine HostBLT data Port 2 Register */
N#define     REG_GE2D_GEHBDW3        (GE_BA+0x6C)  /*!< Graphic Engine HostBLT data Port 3 Register */
N#define     REG_GE2D_GEHBDW4        (GE_BA+0x70)  /*!< Graphic Engine HostBLT data Port 4 Register */
N#define     REG_GE2D_GEHBDW5        (GE_BA+0x74)  /*!< Graphic Engine HostBLT data Port 5 Register */
N#define     REG_GE2D_GEHBDW6        (GE_BA+0x78)  /*!< Graphic Engine HostBLT data Port 6 Register */
N#define     REG_GE2D_GEHBDW7        (GE_BA+0x7C)  /*!< Graphic Engine HostBLT data Port 7 Register */
N
N/**@}*/ /* end of GE2D register group */
N
N/*---------------------- Flash Memory Interface -------------------------*/
N/**
N    @addtogroup FMI Flash Memory Interface(FMI)
N    Memory Mapped Structure for FMI Controller
N@{ */
N
N/* DMAC Control Registers*/
N#define     REG_FMI_BUFFER      (FMI_BA+0x000)   /*!< FMI Embedded Buffer Word */
N#define     REG_FMI_DMACTL      (FMI_BA+0x400)   /*!< FMI DMA Control Register */
N#define     REG_FMI_DMASA       (FMI_BA+0x408)   /*!< FMI DMA Transfer Starting Address Register */
N#define     REG_FMI_DMABCNT     (FMI_BA+0x40C)   /*!< FMI DMA Transfer Byte Count Register */
N#define     REG_FMI_DMAINTEN    (FMI_BA+0x410)   /*!< FMI DMA Interrupt Enable Register */
N#define     REG_FMI_DMAINTSTS   (FMI_BA+0x414)   /*!< FMI DMA Interrupt Status Register */
N
N#define     REG_FMI_CTL         (FMI_BA+0x800)   /*!< Global Control and Status Register */
N#define     REG_FMI_INTEN       (FMI_BA+0x804)   /*!< Global Interrupt Control Register */
N#define     REG_FMI_INTSTS      (FMI_BA+0x808)   /*!< Global Interrupt Status Register */
N
N/* eMMC Registers */
N#define     REG_FMI_EMMCCTL     (FMI_BA+0x820)   /*!< eMMC control and status register */
N#define     REG_FMI_EMMCCMD     (FMI_BA+0x824)   /*!< eMMC command argument register */
N#define     REG_FMI_EMMCINTEN   (FMI_BA+0x828)   /*!< eMMC interrupt enable register */
N#define     REG_FMI_EMMCINTSTS  (FMI_BA+0x82C)   /*!< eMMC interrupt status register */
N#define     REG_FMI_EMMCRESP0   (FMI_BA+0x830)   /*!< eMMC receive response token register 0 */
N#define     REG_FMI_EMMCRESP1   (FMI_BA+0x834)   /*!< eMMC receive response token register 1 */
N#define     REG_FMI_EMMCBLEN    (FMI_BA+0x838)   /*!< eMMC block length register */
N#define     REG_FMI_EMMCTOUT    (FMI_BA+0x83C)   /*!< eMMC block length register */
N
N/* NAND-type Flash Registers */
N#define     REG_NANDCTL         (FMI_BA+0x8A0)   /*!< NAND Flash Control and Status Register */
N#define     REG_NANDTMCTL       (FMI_BA+0x8A4)   /*!< NAND Flash Timing Control Register */
N#define     REG_NANDINTEN       (FMI_BA+0x8A8)   /*!< NAND Flash Interrupt Control Register */
N#define     REG_NANDINTSTS      (FMI_BA+0x8AC)   /*!< NAND Flash Interrupt Status Register */
N#define     REG_NANDCMD         (FMI_BA+0x8B0)   /*!< NAND Flash Command Port Register */
N#define     REG_NANDADDR        (FMI_BA+0x8B4)   /*!< NAND Flash Address Port Register */
N#define     REG_NANDDATA        (FMI_BA+0x8B8)   /*!< NAND Flash Data Port Register */
N#define     REG_NANDRACTL       (FMI_BA+0x8BC)   /*!< NAND Flash Redundant Area Control Register */
N#define     REG_NANDECTL        (FMI_BA+0x8C0)   /*!< NAND Flash Extend Control Regsiter */
N#define     REG_NANDECCES0      (FMI_BA+0x8D0)   /*!< NAND Flash ECC Error Status 0 */
N#define     REG_NANDECCES1      (FMI_BA+0x8D4)   /*!< NAND Flash ECC Error Status 1 */
N#define     REG_NANDECCES2      (FMI_BA+0x8D8)   /*!< NAND Flash ECC Error Status 2 */
N#define     REG_NANDECCES3      (FMI_BA+0x8DC)   /*!< NAND Flash ECC Error Status 3 */
N#define     REG_NANDPROTA0      (FMI_BA+0x8E0)   /*!< NAND Flash Protect Region End Address 0 */
N#define     REG_NANDPROTA1      (FMI_BA+0x8E4)   /*!< NAND Flash Protect Region End Address 1 */
N
N/* NAND-type Flash BCH Error Address Registers */
N#define     REG_NANDECCEA0      (FMI_BA+0x900)   /*!< NAND Flash ECC Error Byte Address 0 */
N#define     REG_NANDECCEA1      (FMI_BA+0x904)   /*!< NAND Flash ECC Error Byte Address 1 */
N#define     REG_NANDECCEA2      (FMI_BA+0x908)   /*!< NAND Flash ECC Error Byte Address 2 */
N#define     REG_NANDECCEA3      (FMI_BA+0x90C)   /*!< NAND Flash ECC Error Byte Address 3 */
N#define     REG_NANDECCEA4      (FMI_BA+0x910)   /*!< NAND Flash ECC Error Byte Address 4 */
N#define     REG_NANDECCEA5      (FMI_BA+0x914)   /*!< NAND Flash ECC Error Byte Address 5 */
N#define     REG_NANDECCEA6      (FMI_BA+0x918)   /*!< NAND Flash ECC Error Byte Address 6 */
N#define     REG_NANDECCEA7      (FMI_BA+0x91C)   /*!< NAND Flash ECC Error Byte Address 7 */
N#define     REG_NANDECCEA8      (FMI_BA+0x920)   /*!< NAND Flash ECC Error Byte Address 8 */
N#define     REG_NANDECCEA9      (FMI_BA+0x924)   /*!< NAND Flash ECC Error Byte Address 9 */
N#define     REG_NANDECCEA10     (FMI_BA+0x928)   /*!< NAND Flash ECC Error Byte Address 10 */
N#define     REG_NANDECCEA11     (FMI_BA+0x92C)   /*!< NAND Flash ECC Error Byte Address 11 */
N
N/* NAND-type Flash BCH Error Data Registers */
N#define     REG_NANDECCED0      (FMI_BA+0x960)   /*!< NAND Flash ECC Error Data Register 0 */
N#define     REG_NANDECCED1      (FMI_BA+0x964)   /*!< NAND Flash ECC Error Data Register 1 */
N#define     REG_NANDECCED2      (FMI_BA+0x968)   /*!< NAND Flash ECC Error Data Register 2 */
N#define     REG_NANDECCED3      (FMI_BA+0x96C)   /*!< NAND Flash ECC Error Data Register 3 */
N#define     REG_NANDECCED4      (FMI_BA+0x970)   /*!< NAND Flash ECC Error Data Register 4 */
N#define     REG_NANDECCED5      (FMI_BA+0x974)   /*!< NAND Flash ECC Error Data Register 5 */
N
N/* NAND-type Flash Redundant Area Registers */
N#define     REG_NANDRA0         (FMI_BA+0xA00)   /*!< NAND Flash Redundant Area Register */
N#define     REG_NANDRA1         (FMI_BA+0xA04)   /*!< NAND Flash Redundant Area Register */
N
N/**@}*/ /* end of FMI register group */
N
N
N/*---------------------- SD/SDIO Host Controller -------------------------*/
N/**
N    @addtogroup SDH SD/SDIO Host Controller(SDH)
N    Memory Mapped Structure for SDH Controller
N@{ */
N
N/* DMAC Control Registers*/
N#define     REG_SDH_FB0         (SDH_BA+0x000)   /*!< SD Host Embedded Buffer Word */
N#define     REG_SDH_DMACTL      (SDH_BA+0x400)   /*!< SD Host DMA Control and Status Register */
N#define     REG_SDH_DMASA       (SDH_BA+0x408)   /*!< SD Host DMA Transfer Starting Address Register */
N#define     REG_SDH_DMABCNT     (SDH_BA+0x40C)   /*!< SD Host DMA Transfer Byte Count Register */
N#define     REG_SDH_DMAINTEN    (SDH_BA+0x410)   /*!< SD Host DMA Interrupt Enable Register */
N#define     REG_SDH_DMAINTSTS   (SDH_BA+0x414)   /*!< SD Host DMA Interrupt Status Register */
N
N#define     REG_SDH_GCTL        (SDH_BA+0x800)   /*!< SD Host Global Control and Status Register */
N#define     REG_SDH_GINTEN      (SDH_BA+0x804)   /*!< SD Host Global Interrupt Control Register */
N#define     REG_SDH_GINTSTS     (SDH_BA+0x808)   /*!< SD Host Global Interrupt Status Register */
N
N/* Secure Digit Registers */
N#define     REG_SDH_CTL         (SDH_BA+0x820)   /*!< SD Host control and status register */
N#define     REG_SDH_CMD         (SDH_BA+0x824)   /*!< SD Host command argument register */
N#define     REG_SDH_INTEN       (SDH_BA+0x828)   /*!< SD Host interrupt enable register */
N#define     REG_SDH_INTSTS      (SDH_BA+0x82C)   /*!< SD Host interrupt status register */
N#define     REG_SDH_RESP0       (SDH_BA+0x830)   /*!< SD Host receive response token register 0 */
N#define     REG_SDH_RESP1       (SDH_BA+0x834)   /*!< SD Host receive response token register 1 */
N#define     REG_SDH_BLEN        (SDH_BA+0x838)   /*!< SD Host block length register */
N#define     REG_SDH_TMOUT       (SDH_BA+0x83C)   /*!< SD Host Response/Data-in Time-out register */
N#define     REG_SDH_ECTL        (SDH_BA+0x840)   /*!< SD Host Extend Control Register */
N
N/**@}*/ /* end of SDH register group */
N
N
N
N/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
N/**
N    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
N    Memory Mapped Structure for UART Controller
N@{ */
N
N#define     REG_UART0_RBR    (UART0_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART0_THR    (UART0_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART0_IER    (UART0_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART0_FCR    (UART0_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART0_LCR    (UART0_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART0_MCR   (UART0_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART0_MSR    (UART0_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART0_FSR    (UART0_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART0_ISR   (UART0_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART0_TOR       (UART0_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART0_BAUD      (UART0_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART0_IRCR   (UART0_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART0_ALT_CSR   (UART0_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART0_FUN_SEL   (UART0_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART0_LIN_CTL   (UART0_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART0_LIN_SR    (UART0_BA+0x38)  /*!< LIN Status Register */
N
N
N
N
N/*
N  UART1 Control Registers
N*/
N#define     REG_UART1_RBR   (UART1_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART1_THR   (UART1_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART1_IER   (UART1_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART1_FCR   (UART1_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART1_LCR   (UART1_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART1_MCR   (UART1_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART1_MSR   (UART1_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART1_FSR       (UART1_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART1_ISR   (UART1_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART1_TOR       (UART1_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART1_BAUD      (UART1_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART1_IRCR      (UART1_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART1_ALT_CSR   (UART1_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART1_FUN_SEL   (UART1_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART1_LIN_CTL   (UART1_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART1_LIN_SR    (UART1_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART2 Control Registers
N*/
N#define     REG_UART2_RBR   (UART2_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART2_THR   (UART2_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART2_IER   (UART2_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART2_FCR   (UART2_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART2_LCR   (UART2_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART2_MCR   (UART2_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART2_MSR   (UART2_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART2_FSR   (UART2_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART2_ISR   (UART2_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART2_TOR   (UART2_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART2_BAUD  (UART2_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART2_IRCR  (UART2_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART2_ALT_CSR   (UART2_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART2_FUN_SEL   (UART2_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART2_LIN_CTL   (UART2_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART2_LIN_SR    (UART2_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART3 Control Registers
N*/
N#define     REG_UART3_RBR   (UART3_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART3_THR   (UART3_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART3_IER   (UART3_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART3_FCR   (UART3_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART3_LCR   (UART3_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART3_MCR   (UART3_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART3_MSR   (UART3_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART3_FSR   (UART3_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART3_ISR   (UART3_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART3_TOR   (UART3_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART3_BAUD  (UART3_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART3_IRCR  (UART3_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART3_ALT_CSR   (UART3_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART3_FUN_SEL   (UART3_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART3_LIN_CTL   (UART3_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART3_LIN_SR    (UART3_BA+0x38)  /*!< LIN Status Register */
N
N
N/*
N  UART4 Control Registers
N*/
N#define     REG_UART4_RBR   (UART4_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART4_THR   (UART4_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART4_IER   (UART4_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART4_FCR   (UART4_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART4_LCR   (UART4_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART4_MCR   (UART4_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART4_MSR   (UART4_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART4_FSR   (UART4_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART4_ISR   (UART4_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART4_TOR   (UART4_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART4_BAUD  (UART4_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART4_IRCR  (UART4_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART4_ALT_CSR   (UART4_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART4_FUN_SEL   (UART4_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART4_LIN_CTL   (UART4_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART4_LIN_SR    (UART4_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART5 Control Registers
N*/
N#define     REG_UART5_RBR   (UART5_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART5_THR   (UART5_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART5_IER   (UART5_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART5_FCR   (UART5_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART5_LCR   (UART5_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART5_MCR   (UART5_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART5_MSR   (UART5_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART5_FSR   (UART5_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART5_ISR   (UART5_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART5_TOR   (UART5_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART5_BAUD  (UART5_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART5_IRCR  (UART5_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART5_ALT_CSR   (UART5_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART5_FUN_SEL   (UART5_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART5_LIN_CTL   (UART5_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART5_LIN_SR    (UART5_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART6 Control Registers
N*/
N#define     REG_UART6_RBR   (UART6_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART6_THR   (UART6_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART6_IER   (UART6_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART6_FCR   (UART6_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART6_LCR   (UART6_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART6_MCR   (UART6_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART6_MSR   (UART6_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART6_FSR   (UART6_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART6_ISR   (UART6_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART6_TOR   (UART6_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART6_BAUD  (UART6_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART6_IRCR  (UART6_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART6_ALT_CSR   (UART6_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART6_FUN_SEL   (UART6_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART6_LIN_CTL   (UART6_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART6_LIN_SR    (UART6_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART7 Control Registers
N*/
N#define     REG_UART7_RBR   (UART7_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART7_THR   (UART7_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART7_IER   (UART7_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART7_FCR   (UART7_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART7_LCR   (UART7_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART7_MCR   (UART7_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART7_MSR   (UART7_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART7_FSR   (UART7_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART7_ISR   (UART7_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART7_TOR   (UART7_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART7_BAUD  (UART7_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART7_IRCR  (UART7_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART7_ALT_CSR   (UART7_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART7_FUN_SEL   (UART7_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART7_LIN_CTL   (UART7_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART7_LIN_SR    (UART7_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART8 Control Registers
N*/
N#define     REG_UART8_RBR   (UART8_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART8_THR   (UART8_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART8_IER   (UART8_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART8_FCR   (UART8_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART8_LCR   (UART8_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART8_MCR   (UART8_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART8_MSR   (UART8_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART8_FSR   (UART8_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART8_ISR   (UART8_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART8_TOR   (UART8_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART8_BAUD  (UART8_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART8_IRCR  (UART8_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART8_ALT_CSR   (UART8_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART8_FUN_SEL   (UART8_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART8_LIN_CTL   (UART8_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART8_LIN_SR    (UART8_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART9 Control Registers
N*/
N#define     REG_UART9_RBR   (UART9_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART9_THR   (UART9_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART9_IER   (UART9_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART9_FCR   (UART9_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART9_LCR   (UART9_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART9_MCR   (UART9_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART9_MSR   (UART9_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART9_FSR   (UART9_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART9_ISR   (UART9_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART9_TOR   (UART9_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART9_BAUD  (UART9_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART9_IRCR  (UART9_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART9_ALT_CSR   (UART9_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART9_FUN_SEL   (UART9_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART9_LIN_CTL   (UART9_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART9_LIN_SR    (UART9_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UARTA Control Registers
N*/
N#define     REG_UARTA_RBR   (UARTA_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UARTA_THR   (UARTA_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UARTA_IER   (UARTA_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UARTA_FCR   (UARTA_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UARTA_LCR   (UARTA_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UARTA_MCR   (UARTA_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UARTA_MSR   (UARTA_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UARTA_FSR   (UARTA_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UARTA_ISR   (UARTA_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UARTA_TOR   (UARTA_BA+0x20)  /*!< Time-out Register */
N#define     REG_UARTA_BAUD  (UARTA_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UARTA_IRCR  (UARTA_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UARTA_ALT_CSR   (UARTA_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UARTA_FUN_SEL   (UARTA_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UARTA_LIN_CTL   (UARTA_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UARTA_LIN_SR    (UARTA_BA+0x38)  /*!< LIN Status Register */
N
N
N/**@}*/ /* end of UART register group */
N
N
N/*---------------------- Timer Controller -------------------------*/
N/**
N    @addtogroup TIMER Timer Controller(TIMER)
N    Memory Mapped Structure for TIMER Controller
N@{ */
N
N#define     REG_TMR0_TCSR   (TMR0_BA+0x00)  /*!< Timer Control and Status Register 0  */
N#define     REG_TMR0_TICR   (TMR0_BA+0x04)  /*!< Timer Compare Register 0             */
N#define     REG_TMR0_TDR    (TMR0_BA+0x08)  /*!< Timer Data Register 0                */
N
N#define     REG_TMR1_TCSR   (TMR1_BA+0x00)  /*!< Timer Control and Status Register 1  */
N#define     REG_TMR1_TICR   (TMR1_BA+0x04)  /*!< Timer Compare Register 1             */
N#define     REG_TMR1_TDR    (TMR1_BA+0x08)  /*!< Timer Data Register 1                */
N
N#define     REG_TMR2_TCSR   (TMR2_BA+0x00)  /*!< Timer Control and Status Register 2  */
N#define     REG_TMR2_TICR   (TMR2_BA+0x04)  /*!< Timer Compare Register 2             */
N#define     REG_TMR2_TDR    (TMR2_BA+0x08)  /*!< Timer Data Register 2                */
N
N#define     REG_TMR3_TCSR   (TMR3_BA+0x00)  /*!< Timer Control and Status Register 3  */
N#define     REG_TMR3_TICR   (TMR3_BA+0x04)  /*!< Timer Compare Register 3             */
N#define     REG_TMR3_TDR    (TMR3_BA+0x08)  /*!< Timer Data Register 3                */
N
N#define     REG_TMR4_TCSR   (TMR4_BA+0x00)  /*!< Timer Control and Status Register 4  */
N#define     REG_TMR4_TICR   (TMR4_BA+0x04)  /*!< Timer Compare Register 4             */
N#define     REG_TMR4_TDR    (TMR4_BA+0x08)  /*!< Timer Data Register 4                */
N
N#define     REG_TMR_TISR    (TMR0_BA+0x60)  /*!< Timer Interrupt Status Register      */
N
N/**@}*/ /* end of TIMER register group */
N
N/*---------------------- Enhance Timer Controller -------------------------*/
N/**
N    @addtogroup ETIMER Enhance Timer Controller(ETIMER)
N    Memory Mapped Structure for TIMER Controller
N@{ */
N
N#define     REG_ETMR0_CTL       (ETMR0_BA+0x00)  /*!< Enhance Timer 0 Control Register */
N#define     REG_ETMR0_PRECNT    (ETMR0_BA+0x04)  /*!< Enhance Timer 0 Pre-Scale Counter Register */
N#define     REG_ETMR0_CMPR      (ETMR0_BA+0x08)  /*!< Enhance Timer 0 Compare Register */
N#define     REG_ETMR0_IER       (ETMR0_BA+0x0C)  /*!< Enhance Timer 0 Interrupt Enable Register */
N#define     REG_ETMR0_ISR       (ETMR0_BA+0x10)  /*!< Enhance Timer 0 Interrupt Status Register  */
N#define     REG_ETMR0_DR        (ETMR0_BA+0x14)  /*!< Enhance Timer 0 Data Register */
N#define     REG_ETMR0_TCAP      (ETMR0_BA+0x18)  /*!< Enhance Timer 0 Capture Data Register  */
N
N#define     REG_ETMR1_CTL       (ETMR1_BA+0x00)  /*!< Enhance Timer 1 Control Register */
N#define     REG_ETMR1_PRECNT    (ETMR1_BA+0x04)  /*!< Enhance Timer 1 Pre-Scale Counter Register */
N#define     REG_ETMR1_CMPR      (ETMR1_BA+0x08)  /*!< Enhance Timer 1 Compare Register */
N#define     REG_ETMR1_IER       (ETMR1_BA+0x0C)  /*!< Enhance Timer 1 Interrupt Enable Register */
N#define     REG_ETMR1_ISR       (ETMR1_BA+0x10)  /*!< Enhance Timer 1 Interrupt Status Register  */
N#define     REG_ETMR1_DR        (ETMR1_BA+0x14)  /*!< Enhance Timer 1 Data Register */
N#define     REG_ETMR1_TCAP      (ETMR1_BA+0x18)  /*!< Enhance Timer 1 Capture Data Register  */
N
N#define     REG_ETMR2_CTL       (ETMR2_BA+0x00)  /*!< Enhance Timer 2 Control Register */
N#define     REG_ETMR2_PRECNT    (ETMR2_BA+0x04)  /*!< Enhance Timer 2 Pre-Scale Counter Register */
N#define     REG_ETMR2_CMPR      (ETMR2_BA+0x08)  /*!< Enhance Timer 2 Compare Register */
N#define     REG_ETMR2_IER       (ETMR2_BA+0x0C)  /*!< Enhance Timer 2 Interrupt Enable Register */
N#define     REG_ETMR2_ISR       (ETMR2_BA+0x10)  /*!< Enhance Timer 2 Interrupt Status Register  */
N#define     REG_ETMR2_DR        (ETMR2_BA+0x14)  /*!< Enhance Timer 2 Data Register */
N#define     REG_ETMR2_TCAP      (ETMR2_BA+0x18)  /*!< Enhance Timer 2 Capture Data Register  */
N
N#define     REG_ETMR3_CTL       (ETMR3_BA+0x00)  /*!< Enhance Timer 3 Control Register */
N#define     REG_ETMR3_PRECNT    (ETMR3_BA+0x04)  /*!< Enhance Timer 3 Pre-Scale Counter Register */
N#define     REG_ETMR3_CMPR      (ETMR3_BA+0x08)  /*!< Enhance Timer 3 Compare Register */
N#define     REG_ETMR3_IER       (ETMR3_BA+0x0C)  /*!< Enhance Timer 3 Interrupt Enable Register */
N#define     REG_ETMR3_ISR       (ETMR3_BA+0x10)  /*!< Enhance Timer 3 Interrupt Status Register  */
N#define     REG_ETMR3_DR        (ETMR3_BA+0x14)  /*!< Enhance Timer 3 Data Register */
N#define     REG_ETMR3_TCAP      (ETMR3_BA+0x18)  /*!< Enhance Timer 3 Capture Data Register  */
N/**@}*/ /* end of ETIMER register group */
N
N/*---------------------- WDT Controller -------------------------*/
N/**
N    @addtogroup WDT Watch Dog Timer Controller(WDT)
N    Memory Mapped Structure for WDT Controller
N@{ */
N
N#define     REG_WDT_CTL         (WDT_BA+0x00)  /*!< WDT Control Register              */
N#define     REG_WDT_ATLCTL      (WDT_BA+0x04)  /*!< WDT Alternative Control Register  */
N
N/**@}*/ /* end of WDT register group */
N
N/*---------------------- WWDT Controller -------------------------*/
N/**
N    @addtogroup WWDT Window Watch Dog Timer Controller(WWDT)
N    Memory Mapped Structure for WWDT Controller
N@{ */
N
N#define     REG_WWDT_RLDCNT     (WWDT_BA+0x00)  /*!< WWDT Reload Counter Register             */
N#define     REG_WWDT_CTL        (WWDT_BA+0x04)  /*!< WWDT Control Register                    */
N#define     REG_WWDT_STATUS     (WWDT_BA+0x08)  /*!< WWDT Status Register                     */
N#define     REG_WWDT_CNT        (WWDT_BA+0x0C)  /*!< WWDT Counter Value Register              */
N
N/**@}*/ /* end of WWDT register group */
N
N/*---------------------- SC Host Interface -------------------------*/
N/**
N    @addtogroup SC Smart Card Host Interface (SC)
N    Memory Mapped Structure for Smart Card Host Interface
N@{ */
N
N#define     REG_SC0_DAT     (SC0_BA+0x00)  /*!< SC0 Receiving/Transmit Holding Buffer Register */
N#define     REG_SC0_CTL     (SC0_BA+0x04)  /*!< SC0 Control Register */
N#define     REG_SC0_ALTCTL  (SC0_BA+0x08)  /*!< SC0 Alternate Control Register  */
N#define     REG_SC0_EGT     (SC0_BA+0x0C)  /*!< SC0 Extend Guard Time Register  */
N#define     REG_SC0_RXTOUT  (SC0_BA+0x10)  /*!< SC0 Receive Buffer Time-out Register */
N#define     REG_SC0_ETUCTL  (SC0_BA+0x14)  /*!< SC0 ETU Control Register */
N#define     REG_SC0_INTEN   (SC0_BA+0x18)  /*!< SC0 Interrupt Enable Control Register */
N#define     REG_SC0_INTSTS  (SC0_BA+0x1C)  /*!< SC0 Interrupt Status Register */
N#define     REG_SC0_STATUS  (SC0_BA+0x20)  /*!< SC0 Status Register */
N#define     REG_SC0_PINCTL  (SC0_BA+0x24)  /*!< SC0 Pin Control State Register */
N#define     REG_SC0_TMRCTL0 (SC0_BA+0x28)  /*!< SC0 Internal Timer Control Register 0 */
N#define     REG_SC0_TMRCTL1 (SC0_BA+0x2C)  /*!< SC0 Internal Timer Control Register 1 */
N#define     REG_SC0_TMRCTL2 (SC0_BA+0x30)  /*!< SC0 Internal Timer Control Register 2 */
N#define     REG_SC0_UARTCTL (SC0_BA+0x34)  /*!< SC0 UART Mode Control Register */
N#define     REG_SC0_TMRDAT0 (SC0_BA+0x38)  /*!< SC0 Timer Current Data Register 0 */
N#define     REG_SC0_TMRDAT1 (SC0_BA+0x3C)  /*!< SC0 Timer Current Data Register 1 */
N
N#define     REG_SC1_DAT     (SC1_BA+0x00)  /*!< SC1 Receiving/Transmit Holding Buffer Register */
N#define     REG_SC1_CTL     (SC1_BA+0x04)  /*!< SC1 Control Register */
N#define     REG_SC1_ALTCTL  (SC1_BA+0x08)  /*!< SC1 Alternate Control Register  */
N#define     REG_SC1_EGT     (SC1_BA+0x0C)  /*!< SC1 Extend Guard Time Register  */
N#define     REG_SC1_RXTOUT  (SC1_BA+0x10)  /*!< SC1 Receive Buffer Time-out Register */
N#define     REG_SC1_ETUCTL  (SC1_BA+0x14)  /*!< SC1 ETU Control Register */
N#define     REG_SC1_INTEN   (SC1_BA+0x18)  /*!< SC1 Interrupt Enable Control Register */
N#define     REG_SC1_INTSTS  (SC1_BA+0x1C)  /*!< SC1 Interrupt Status Register */
N#define     REG_SC1_STATUS  (SC1_BA+0x20)  /*!< SC1 Status Register */
N#define     REG_SC1_PINCTL  (SC1_BA+0x24)  /*!< SC1 Pin Control State Register */
N#define     REG_SC1_TMRCTL0 (SC1_BA+0x28)  /*!< SC1 Internal Timer Control Register 0 */
N#define     REG_SC1_TMRCTL1 (SC1_BA+0x2C)  /*!< SC1 Internal Timer Control Register 1 */
N#define     REG_SC1_TMRCTL2 (SC1_BA+0x30)  /*!< SC1 Internal Timer Control Register 2 */
N#define     REG_SC1_UARTCTL (SC1_BA+0x34)  /*!< SC1 UART Mode Control Register */
N#define     REG_SC1_TMRDAT0 (SC1_BA+0x38)  /*!< SC1 Timer Current Data Register 0 */
N#define     REG_SC1_TMRDAT1 (SC1_BA+0x3C)  /*!< SC1 Timer Current Data Register 1 */
N
N/**@}*/ /* end of SC register group */
N
N
N/*---------------------- Advance Interrupt Controller -------------------------*/
N/**
N    @addtogroup AIC Advance Interrupt Controller(AIC)
N    Memory Mapped Structure for AIC Controller
N@{ */
N
N#define     REG_AIC_SCR1    (AIC_BA+0x00)    /*!< Source control register 1 */
N#define     REG_AIC_SCR2    (AIC_BA+0x04)    /*!< Source control register 2 */
N#define     REG_AIC_SCR3    (AIC_BA+0x08)    /*!< Source control register 3 */
N#define     REG_AIC_SCR4    (AIC_BA+0x0C)    /*!< Source control register 4 */
N#define     REG_AIC_SCR5    (AIC_BA+0x10)    /*!< Source control register 5 */
N#define     REG_AIC_SCR6    (AIC_BA+0x14)    /*!< Source control register 6 */
N#define     REG_AIC_SCR7    (AIC_BA+0x18)    /*!< Source control register 7 */
N#define     REG_AIC_SCR8    (AIC_BA+0x1C)    /*!< Source control register 8 */
N#define     REG_AIC_SCR9    (AIC_BA+0x20)    /*!< Source control register 9 */
N#define     REG_AIC_SCR10   (AIC_BA+0x24)    /*!< Source control register 10 */
N#define     REG_AIC_SCR11   (AIC_BA+0x28)    /*!< Source control register 11 */
N#define     REG_AIC_SCR12   (AIC_BA+0x2C)    /*!< Source control register 12 */
N#define     REG_AIC_SCR13   (AIC_BA+0x30)    /*!< Source control register 13 */
N#define     REG_AIC_SCR14   (AIC_BA+0x34)    /*!< Source control register 14 */
N#define     REG_AIC_SCR15   (AIC_BA+0x38)    /*!< Source control register 15 */
N#define     REG_AIC_SCR16   (AIC_BA+0x3C)    /*!< Source control register 16 */
N#define     REG_AIC_IRSR    (AIC_BA+0x100)   /*!< Interrupt raw status register */
N#define     REG_AIC_IRSRH   (AIC_BA+0x104)   /*!< Interrupt raw status register (Hign) */
N#define     REG_AIC_IASR    (AIC_BA+0x108)   /*!< Interrupt active status register */
N#define     REG_AIC_IASRH   (AIC_BA+0x10C)   /*!< Interrupt active status register (Hign) */
N#define     REG_AIC_ISR     (AIC_BA+0x110)   /*!< Interrupt status register */
N#define     REG_AIC_ISRH    (AIC_BA+0x114)   /*!< Interrupt status register (High) */
N#define     REG_AIC_IPER    (AIC_BA+0x118)   /*!< Interrupt priority encoding register */
N#define     REG_AIC_ISNR    (AIC_BA+0x120)   /*!< Interrupt source number register */
N#define     REG_AIC_OISR    (AIC_BA+0x124)   /*!< Output interrupt status register */
N#define     REG_AIC_IMR     (AIC_BA+0x128)   /*!< Interrupt mask register */
N#define     REG_AIC_IMRH    (AIC_BA+0x12C)   /*!< Interrupt mask register (High) */
N#define     REG_AIC_MECR    (AIC_BA+0x130)   /*!< Mask enable command register */
N#define     REG_AIC_MECRH   (AIC_BA+0x134)   /*!< Mask enable command register (High) */
N#define     REG_AIC_MDCR    (AIC_BA+0x138)   /*!< Mask disable command register */
N#define     REG_AIC_MDCRH   (AIC_BA+0x13C)   /*!< Mask disable command register (High) */
N#define     REG_AIC_SSCR    (AIC_BA+0x140)   /*!< Source Set Command Register */
N#define     REG_AIC_SSCRH   (AIC_BA+0x144)   /*!< Source Set Command Register (High) */
N#define     REG_AIC_SCCR    (AIC_BA+0x148)   /*!< Source Clear Command Register */
N#define     REG_AIC_SCCRH   (AIC_BA+0x14C)   /*!< Source Clear Command Register (High) */
N#define     REG_AIC_EOSCR   (AIC_BA+0x150)   /*!< End of service command register */
N
N/**@}*/ /* end of AIC register group */
N
N
N/*---------------------- General Purpose Input/Output Controller -------------------------*/
N/**
N    @addtogroup GPIO General Purpose Input/Output Controller(GPIO)
N    Memory Mapped Structure for GPIO Controller
N@{ */
N
N#define     REG_GPIOA_DIR       (GPIO_BA+0x000)  /*!< GPIO portA direction control register */
N#define     REG_GPIOA_DATAOUT   (GPIO_BA+0x004)  /*!< GPIO portA data output register */
N#define     REG_GPIOA_DATAIN    (GPIO_BA+0x008)  /*!< GPIO portA data input register */
N#define     REG_GPIOA_IMD       (GPIO_BA+0x00C)  /*!< GPIO Port A Interrupt Mode Register */
N#define     REG_GPIOA_IREN      (GPIO_BA+0x010)  /*!< GPIO Port A Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOA_IFEN      (GPIO_BA+0x014)  /*!< GPIO Port A Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOA_ISR       (GPIO_BA+0x018)  /*!< GPIO Port A Interrupt Status Register */
N#define     REG_GPIOA_DBEN      (GPIO_BA+0x01C)  /*!< GPIO Port A De-bounce Enable Register */
N#define     REG_GPIOA_PUEN      (GPIO_BA+0x020)  /*!< GPIO Port A Pull-Up Enable Register */
N#define     REG_GPIOA_PDEN      (GPIO_BA+0x024)  /*!< GPIO Port A Pull-Down Enable Register */
N#define     REG_GPIOA_ICEN      (GPIO_BA+0x028)  /*!< GPIO Port A CMOS Input Enable Register */
N#define     REG_GPIOA_ISEN      (GPIO_BA+0x02C)  /*!< GPIO Port A Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOB_DIR       (GPIO_BA+0x040)  /*!< GPIO port B direction control register */
N#define     REG_GPIOB_DATAOUT   (GPIO_BA+0x044)  /*!< GPIO port B data output register */
N#define     REG_GPIOB_DATAIN    (GPIO_BA+0x048)  /*!< GPIO port B data input register */
N#define     REG_GPIOB_IMD       (GPIO_BA+0x04C)  /*!< GPIO Port B Interrupt Mode Register */
N#define     REG_GPIOB_IREN      (GPIO_BA+0x050)  /*!< GPIO Port B Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOB_IFEN      (GPIO_BA+0x054)  /*!< GPIO Port B Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOB_ISR       (GPIO_BA+0x058)  /*!< GPIO Port B Interrupt Status Register */
N#define     REG_GPIOB_DBEN      (GPIO_BA+0x05C)  /*!< GPIO Port B De-bounce Enable Register */
N#define     REG_GPIOB_PUEN      (GPIO_BA+0x060)  /*!< GPIO Port B Pull-Up Enable Register */
N#define     REG_GPIOB_PDEN      (GPIO_BA+0x064)  /*!< GPIO Port B Pull-Down Enable Register */
N#define     REG_GPIOB_ICEN      (GPIO_BA+0x068)  /*!< GPIO Port B CMOS Input Enable Register */
N#define     REG_GPIOB_ISEN      (GPIO_BA+0x06C)  /*!< GPIO Port B Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOC_DIR       (GPIO_BA+0x080)  /*!< GPIO port C direction control register */
N#define     REG_GPIOC_DATAOUT   (GPIO_BA+0x084)  /*!< GPIO port C data output register */
N#define     REG_GPIOC_DATAIN    (GPIO_BA+0x088)  /*!< GPIO port C data input register */
N#define     REG_GPIOC_IMD       (GPIO_BA+0x08C)  /*!< GPIO Port C Interrupt Mode Register */
N#define     REG_GPIOC_IREN      (GPIO_BA+0x090)  /*!< GPIO Port C Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOC_IFEN      (GPIO_BA+0x094)  /*!< GPIO Port C Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOC_ISR       (GPIO_BA+0x098)  /*!< GPIO Port C Interrupt Status Register */
N#define     REG_GPIOC_DBEN      (GPIO_BA+0x09C)  /*!< GPIO Port C De-bounce Enable Register */
N#define     REG_GPIOC_PUEN      (GPIO_BA+0x0A0)  /*!< GPIO Port C Pull-Up Enable Register */
N#define     REG_GPIOC_PDEN      (GPIO_BA+0x0A4)  /*!< GPIO Port C Pull-Down Enable Register */
N#define     REG_GPIOC_ICEN      (GPIO_BA+0x0A8)  /*!< GPIO Port C CMOS Input Enable Register */
N#define     REG_GPIOC_ISEN      (GPIO_BA+0x0AC)  /*!< GPIO Port C Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOD_DIR       (GPIO_BA+0x0C0)  /*!< GPIO port D direction control register */
N#define     REG_GPIOD_DATAOUT   (GPIO_BA+0x0C4)  /*!< GPIO port D data output register */
N#define     REG_GPIOD_DATAIN    (GPIO_BA+0x0C8)  /*!< GPIO port D data input register */
N#define     REG_GPIOD_IMD       (GPIO_BA+0x0CC)  /*!< GPIO Port D Interrupt Mode Register */
N#define     REG_GPIOD_IREN      (GPIO_BA+0x0D0)  /*!< GPIO Port D Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOD_IFEN      (GPIO_BA+0x0D4)  /*!< GPIO Port D Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOD_ISR       (GPIO_BA+0x0D8)  /*!< GPIO Port D Interrupt Status Register */
N#define     REG_GPIOD_DBEN      (GPIO_BA+0x0DC)  /*!< GPIO Port D De-bounce Enable Register */
N#define     REG_GPIOD_PUEN      (GPIO_BA+0x0E0)  /*!< GPIO Port D Pull-Up Enable Register */
N#define     REG_GPIOD_PDEN      (GPIO_BA+0x0E4)  /*!< GPIO Port D Pull-Down Enable Register */
N#define     REG_GPIOD_ICEN      (GPIO_BA+0x0E8)  /*!< GPIO Port D CMOS Input Enable Register */
N#define     REG_GPIOD_ISEN      (GPIO_BA+0x0EC)  /*!< GPIO Port D Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOE_DIR       (GPIO_BA+0x100)  /*!< GPIO port E direction control register */
N#define     REG_GPIOE_DATAOUT   (GPIO_BA+0x104)  /*!< GPIO port E data output register */
N#define     REG_GPIOE_DATAIN    (GPIO_BA+0x108)  /*!< GPIO port E data input register */
N#define     REG_GPIOE_IMD       (GPIO_BA+0x10C)  /*!< GPIO Port E Interrupt Mode Register */
N#define     REG_GPIOE_IREN      (GPIO_BA+0x110)  /*!< GPIO Port E Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOE_IFEN      (GPIO_BA+0x114)  /*!< GPIO Port E Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOE_ISR       (GPIO_BA+0x118)  /*!< GPIO Port E Interrupt Status Register */
N#define     REG_GPIOE_DBEN      (GPIO_BA+0x11C)  /*!< GPIO Port E De-bounce Enable Register */
N#define     REG_GPIOE_PUEN      (GPIO_BA+0x120)  /*!< GPIO Port E Pull-Up Enable Register */
N#define     REG_GPIOE_PDEN      (GPIO_BA+0x124)  /*!< GPIO Port E Pull-Down Enable Register */
N#define     REG_GPIOE_ICEN      (GPIO_BA+0x128)  /*!< GPIO Port E CMOS Input Enable Register */
N#define     REG_GPIOE_ISEN      (GPIO_BA+0x12C)  /*!< GPIO Port E Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOF_DIR       (GPIO_BA+0x140)  /*!< GPIO port F direction control register */
N#define     REG_GPIOF_DATAOUT   (GPIO_BA+0x144)  /*!< GPIO port F data output register */
N#define     REG_GPIOF_DATAIN    (GPIO_BA+0x148)  /*!< GPIO port F data input register */
N#define     REG_GPIOF_IMD       (GPIO_BA+0x14C)  /*!< GPIO Port F Interrupt Mode Register */
N#define     REG_GPIOF_IREN      (GPIO_BA+0x150)  /*!< GPIO Port F Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOF_IFEN      (GPIO_BA+0x154)  /*!< GPIO Port F Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOF_ISR       (GPIO_BA+0x158)  /*!< GPIO Port F Interrupt Status Register */
N#define     REG_GPIOF_DBEN      (GPIO_BA+0x15C)  /*!< GPIO Port F De-bounce Enable Register */
N#define     REG_GPIOF_PUEN      (GPIO_BA+0x160)  /*!< GPIO Port F Pull-Up Enable Register */
N#define     REG_GPIOF_PDEN      (GPIO_BA+0x164)  /*!< GPIO Port F Pull-Down Enable Register */
N#define     REG_GPIOF_ICEN      (GPIO_BA+0x168)  /*!< GPIO Port F CMOS Input Enable Register */
N#define     REG_GPIOF_ISEN      (GPIO_BA+0x16C)  /*!< GPIO Port F Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOG_DIR       (GPIO_BA+0x180)  /*!< GPIO port G direction control register */
N#define     REG_GPIOG_DATAOUT   (GPIO_BA+0x184)  /*!< GPIO port G data output register */
N#define     REG_GPIOG_DATAIN    (GPIO_BA+0x188)  /*!< GPIO port G data input register */
N#define     REG_GPIOG_IMD       (GPIO_BA+0x18C)  /*!< GPIO Port G Interrupt Mode Register */
N#define     REG_GPIOG_IREN      (GPIO_BA+0x190)  /*!< GPIO Port G Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOG_IFEN      (GPIO_BA+0x194)  /*!< GPIO Port G Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOG_ISR       (GPIO_BA+0x198)  /*!< GPIO Port G Interrupt Status Register */
N#define     REG_GPIOG_DBEN      (GPIO_BA+0x19C)  /*!< GPIO Port G De-bounce Enable Register */
N#define     REG_GPIOG_PUEN      (GPIO_BA+0x1A0)  /*!< GPIO Port G Pull-Up Enable Register */
N#define     REG_GPIOG_PDEN      (GPIO_BA+0x1A4)  /*!< GPIO Port G Pull-Down Enable Register */
N#define     REG_GPIOG_ICEN      (GPIO_BA+0x1A8)  /*!< GPIO Port G CMOS Input Enable Register */
N#define     REG_GPIOG_ISEN      (GPIO_BA+0x1AC)  /*!< GPIO Port G Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOH_DIR       (GPIO_BA+0x1C0)  /*!< GPIO port H direction control register */
N#define     REG_GPIOH_DATAOUT   (GPIO_BA+0x1C4)  /*!< GPIO port H data output register */
N#define     REG_GPIOH_DATAIN    (GPIO_BA+0x1C8)  /*!< GPIO port H data input register */
N#define     REG_GPIOH_IMD       (GPIO_BA+0x1CC)  /*!< GPIO Port H Interrupt Mode Register */
N#define     REG_GPIOH_IREN      (GPIO_BA+0x1D0)  /*!< GPIO Port H Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOH_IFEN      (GPIO_BA+0x1D4)  /*!< GPIO Port H Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOH_ISR       (GPIO_BA+0x1D8)  /*!< GPIO Port H Interrupt Status Register */
N#define     REG_GPIOH_DBEN      (GPIO_BA+0x1DC)  /*!< GPIO Port H De-bounce Enable Register */
N#define     REG_GPIOH_PUEN      (GPIO_BA+0x1E0)  /*!< GPIO Port H Pull-Up Enable Register */
N#define     REG_GPIOH_PDEN      (GPIO_BA+0x1E4)  /*!< GPIO Port H Pull-Down Enable Register */
N#define     REG_GPIOH_ICEN      (GPIO_BA+0x1E8)  /*!< GPIO Port H CMOS Input Enable Register */
N#define     REG_GPIOH_ISEN      (GPIO_BA+0x1EC)  /*!< GPIO Port H Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOI_DIR       (GPIO_BA+0x200)  /*!< GPIO port I direction control register */
N#define     REG_GPIOI_DATAOUT   (GPIO_BA+0x204)  /*!< GPIO port I data output register */
N#define     REG_GPIOI_DATAIN    (GPIO_BA+0x208)  /*!< GPIO port I data input register */
N#define     REG_GPIOI_IMD       (GPIO_BA+0x20C)  /*!< GPIO Port I Interrupt Mode Register */
N#define     REG_GPIOI_IREN      (GPIO_BA+0x210)  /*!< GPIO Port I Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOI_IFEN      (GPIO_BA+0x214)  /*!< GPIO Port I Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOI_ISR       (GPIO_BA+0x218)  /*!< GPIO Port I Interrupt Status Register */
N#define     REG_GPIOI_DBEN      (GPIO_BA+0x21C)  /*!< GPIO Port I De-bounce Enable Register */
N#define     REG_GPIOI_PUEN      (GPIO_BA+0x220)  /*!< GPIO Port I Pull-Up Enable Register */
N#define     REG_GPIOI_PDEN      (GPIO_BA+0x224)  /*!< GPIO Port I Pull-Down Enable Register */
N#define     REG_GPIOI_ICEN      (GPIO_BA+0x228)  /*!< GPIO Port I CMOS Input Enable Register */
N#define     REG_GPIOI_ISEN      (GPIO_BA+0x22C)  /*!< GPIO Port I Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOJ_DIR       (GPIO_BA+0x240)  /*!< GPIO port J direction control register */
N#define     REG_GPIOJ_DATAOUT   (GPIO_BA+0x244)  /*!< GPIO port J data output register */
N#define     REG_GPIOJ_DATAIN    (GPIO_BA+0x248)  /*!< GPIO port J data input register */
N#define     REG_GPIOJ_IMD       (GPIO_BA+0x24C)  /*!< GPIO Port J Interrupt Mode Register */
N#define     REG_GPIOJ_IREN      (GPIO_BA+0x250)  /*!< GPIO Port J Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOJ_IFEN      (GPIO_BA+0x254)  /*!< GPIO Port J Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOJ_ISR       (GPIO_BA+0x258)  /*!< GPIO Port J Interrupt Status Register */
N#define     REG_GPIOJ_DBEN      (GPIO_BA+0x25C)  /*!< GPIO Port J De-bounce Enable Register */
N#define     REG_GPIOJ_PUEN      (GPIO_BA+0x260)  /*!< GPIO Port J Pull-Up Enable Register */
N#define     REG_GPIOJ_PDEN      (GPIO_BA+0x264)  /*!< GPIO Port J Pull-Down Enable Register */
N#define     REG_GPIOJ_ICEN      (GPIO_BA+0x268)  /*!< GPIO Port J CMOS Input Enable Register */
N#define     REG_GPIOJ_ISEN      (GPIO_BA+0x26C)  /*!< GPIO Port J Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIO_DBNCECON   (GPIO_BA+0x3F0)  /*!< GPIO Debounce Control Register */
N#define     REG_GPIO_ISR        (GPIO_BA+0x3FC)  /*!< GPIO Port Interrupt Status Register */
N
N/**@}*/ /* end of GPIO register group */
N
N
N/*---------------------- Real Time Clock Controller -------------------------*/
N/**
N    @addtogroup RTC Real Time Clock Controller(RTC)
N    Memory Mapped Structure for RTC Controller
N@{ */
N
N#define     REG_RTC_INIT    (RTC_BA+0x00)   /*!< RTC Initiation Register */
N#define     REG_RTC_RWEN    (RTC_BA+0x04)   /*!< RTC Access Enable Register */
N#define     REG_RTC_FREQADJ (RTC_BA+0x08)   /*!< RTC Frequency Compensation Register */
N#define     REG_RTC_TIME    (RTC_BA+0x0C)   /*!< Time Loading Register */
N#define     REG_RTC_CAL     (RTC_BA+0x10)   /*!< Calendar Loading Register */
N#define     REG_RTC_TIMEFMT (RTC_BA+0x14)   /*!< Time Format Selection Register */
N#define     REG_RTC_WEEKDAY (RTC_BA+0x18)   /*!< Day of the Week Register */
N#define     REG_RTC_TALM    (RTC_BA+0x1C)   /*!< Time Alarm Register */
N#define     REG_RTC_CALM    (RTC_BA+0x20)   /*!< Calendar Alarm Register */
N#define     REG_RTC_LEAPYEAR    (RTC_BA+0x24)   /*!< Leap year Indicator Register */
N#define     REG_RTC_INTEN   (RTC_BA+0x28)   /*!< RTC Interrupt Enable Register */
N#define     REG_RTC_INTSTS  (RTC_BA+0x2C)   /*!< RTC Interrupt Indicator Register */
N#define     REG_RTC_TICK    (RTC_BA+0x30)   /*!< RTC Time Tick Register */
N#define     REG_RTC_PWRCTL      (RTC_BA+0x34)   /*!< Power Control Register */
N#define     REG_RTC_PWRCNT      (RTC_BA+0x38)   /*!< Power Control Counter Register */
N#define     REG_RTC_SPR0        (RTC_BA+0x40)   /*!< Spare REgistger 0 */
N#define     REG_RTC_SPR1        (RTC_BA+0x44)   /*!< Spare REgistger 1 */
N#define     REG_RTC_SPR2        (RTC_BA+0x48)   /*!< Spare REgistger 2 */
N#define     REG_RTC_SPR3        (RTC_BA+0x4C)   /*!< Spare REgistger 3 */
N#define     REG_RTC_SPR4        (RTC_BA+0x50)   /*!< Spare REgistger 4 */
N#define     REG_RTC_SPR5        (RTC_BA+0x54)   /*!< Spare REgistger 5 */
N#define     REG_RTC_SPR6        (RTC_BA+0x58)   /*!< Spare REgistger 6 */
N#define     REG_RTC_SPR7        (RTC_BA+0x5C)   /*!< Spare REgistger 7 */
N#define     REG_RTC_SPR8        (RTC_BA+0x60)   /*!< Spare REgistger 8 */
N#define     REG_RTC_SPR9        (RTC_BA+0x64)   /*!< Spare REgistger 9 */
N#define     REG_RTC_SPR10       (RTC_BA+0x68)   /*!< Spare REgistger 10 */
N#define     REG_RTC_SPR11       (RTC_BA+0x6C)   /*!< Spare REgistger 11 */
N#define     REG_RTC_SPR12       (RTC_BA+0x70)   /*!< Spare REgistger 12 */
N#define     REG_RTC_SPR13       (RTC_BA+0x74)   /*!< Spare REgistger 13 */
N#define     REG_RTC_SPR14       (RTC_BA+0x78)   /*!< Spare REgistger 14 */
N#define     REG_RTC_SPR15       (RTC_BA+0x7C)   /*!< Spare REgistger 15 */
N
N/**@}*/ /* end of RTC register group */
N
N/*---------------------- Inter-IC Bus Controller -------------------------*/
N/**
N    @addtogroup I2C Inter-IC Bus Controller(I2C)
N    Memory Mapped Structure for I2C Controller
N@{ */
N
N#define     REG_I2C0_CSR        (I2C0_BA+0x00)  /*!< Control and Status Register */
N#define     REG_I2C0_DIVIDER    (I2C0_BA+0x04)  /*!< Clock Prescale Register */
N#define     REG_I2C0_CMDR       (I2C0_BA+0x08)  /*!< Command Register */
N#define     REG_I2C0_SWR        (I2C0_BA+0x0C)  /*!< Software Mode Control Register */
N#define     REG_I2C0_RXR        (I2C0_BA+0x10)  /*!< Data Receive Register */
N#define     REG_I2C0_TXR        (I2C0_BA+0x14)  /*!< Data Transmit Register */
N
N#define     REG_I2C1_CSR        (I2C1_BA+0x00)  /*!< Control and Status Register */
N#define     REG_I2C1_DIVIDER    (I2C1_BA+0x04)  /*!< Clock Prescale Register */
N#define     REG_I2C1_CMDR       (I2C1_BA+0x08)  /*!< Command Register */
N#define     REG_I2C1_SWR        (I2C1_BA+0x0C)  /*!< Software Mode Control Register */
N#define     REG_I2C1_RXR        (I2C1_BA+0x10)  /*!< Data Receive Register */
N#define     REG_I2C1_TXR        (I2C1_BA+0x14)  /*!< Data Transmit Register */
N
N/**@}*/ /* end of I2C register group */
N
N
N/*---------------------- Serial Peripheral Interface Controller -------------------------*/
N/**
N    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
N    Memory Mapped Structure for SPI Controller
N@{ */
N
N#define     REG_SPI0_CNTRL   (SPI0_BA+0x00)  /*!< Control and Status Register */
N#define     REG_SPI0_DIVIDER (SPI0_BA+0x04)  /*!< Clock Divider Register */
N#define     REG_SPI0_SSR     (SPI0_BA+0x08)  /*!< Slave Select Register */
N#define     REG_SPI0_RX0     (SPI0_BA+0x10)  /*!< Data Receive Register 0 */
N#define     REG_SPI0_RX1     (SPI0_BA+0x14)  /*!< Data Receive Register 1 */
N#define     REG_SPI0_RX2     (SPI0_BA+0x18)  /*!< Data Receive Register 2 */
N#define     REG_SPI0_RX3     (SPI0_BA+0x1C)  /*!< Data Receive Register 3 */
N#define     REG_SPI0_TX0     (SPI0_BA+0x10)  /*!< Data Transmit Register 0 */
N#define     REG_SPI0_TX1     (SPI0_BA+0x14)  /*!< Data Transmit Register 1 */
N#define     REG_SPI0_TX2     (SPI0_BA+0x18)  /*!< Data Transmit Register 2 */
N#define     REG_SPI0_TX3     (SPI0_BA+0x1C)  /*!< Data Transmit Register 3 */
N
N#define     REG_SPI1_CNTRL   (SPI1_BA+0x00)  /*!< Control and Status Register */
N#define     REG_SPI1_DIVIDER (SPI1_BA+0x04)  /*!< Clock Divider Register */
N#define     REG_SPI1_SSR     (SPI1_BA+0x08)  /*!< Slave Select Register */
N#define     REG_SPI1_RX0     (SPI1_BA+0x10)  /*!< Data Receive Register 0 */
N#define     REG_SPI1_RX1     (SPI1_BA+0x14)  /*!< Data Receive Register 1 */
N#define     REG_SPI1_RX2     (SPI1_BA+0x18)  /*!< Data Receive Register 2 */
N#define     REG_SPI1_RX3     (SPI1_BA+0x1C)  /*!< Data Receive Register 3 */
N#define     REG_SPI1_TX0     (SPI1_BA+0x10)  /*!< Data Transmit Register 0 */
N#define     REG_SPI1_TX1     (SPI1_BA+0x14)  /*!< Data Transmit Register 1 */
N#define     REG_SPI1_TX2     (SPI1_BA+0x18)  /*!< Data Transmit Register 2 */
N#define     REG_SPI1_TX3     (SPI1_BA+0x1C)  /*!< Data Transmit Register 3 */
N
N/**@}*/ /* end of SPI register group */
N
N
N/*---------------------- Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup PWM Pulse Width Modulation Controller(PWM)
N    Memory Mapped Structure for PWM Controller
N@{ */
N
N#define     REG_PWM_PPR     (PWM_BA+0x00)  /*!< PWM Pre-scale Register 0 */
N#define     REG_PWM_CSR     (PWM_BA+0x04)  /*!< PWM Clock Select Register */
N#define     REG_PWM_PCR     (PWM_BA+0x08)  /*!< PWM Control Register */
N#define     REG_PWM_CNR0    (PWM_BA+0x0C)  /*!< PWM Counter Register 0 */
N#define     REG_PWM_CMR0    (PWM_BA+0x10)  /*!< PWM Comparator Register 0 */
N#define     REG_PWM_PDR0    (PWM_BA+0x14)  /*!< PWM Data Register 0 */
N#define     REG_PWM_CNR1    (PWM_BA+0x18)  /*!< PWM Counter Register 1 */
N#define     REG_PWM_CMR1    (PWM_BA+0x1C)  /*!< PWM Comparator Register 1 */
N#define     REG_PWM_PDR1    (PWM_BA+0x20)  /*!< PWM Data Register 1 */
N#define     REG_PWM_CNR2    (PWM_BA+0x24)  /*!< PWM Counter Register 2 */
N#define     REG_PWM_CMR2    (PWM_BA+0x28)  /*!< PWM Comparator Register 2 */
N#define     REG_PWM_PDR2    (PWM_BA+0x2C)  /*!< PWM Data Register 2 */
N#define     REG_PWM_CNR3    (PWM_BA+0x30)  /*!< PWM Counter Register 3 */
N#define     REG_PWM_CMR3    (PWM_BA+0x34)  /*!< PWM Comparator Register 3 */
N#define     REG_PWM_PDR3    (PWM_BA+0x38)  /*!< PWM Data Register 3 */
N#define     REG_PWM_PIER    (PWM_BA+0x3C)  /*!< PWM Timer Interrupt Enable Register */
N#define     REG_PWM_PIIR    (PWM_BA+0x40)  /*!< PWM Timer Interrupt Identification Register */
N
N/**@}*/ /* end of PWM register group */
N
N
N/*---------------------- Analog to Digital Converter -------------------------*/
N/**
N    @addtogroup ADC Analog to Digital Converter(ADC)
N    Memory Mapped Structure for ADC Controller
N@{ */
N
N#define REG_ADC_CTL       (ADC_BA+0x000) /*!< ADC Contrl */
N#define REG_ADC_CONF      (ADC_BA+0x004) /*!< ADC Configure */
N#define REG_ADC_IER       (ADC_BA+0x008) /*!< ADC Interrupt Enable Register */
N#define REG_ADC_ISR       (ADC_BA+0x00C) /*!< ADC Interrupt Status Register */
N#define REG_ADC_WKISR     (ADC_BA+0x010) /*!< ADC Wake Up Interrupt Status Register */
N#define REG_ADC_XYDATA    (ADC_BA+0x020) /*!< ADC Touch XY Pressure Data */
N#define REG_ADC_ZDATA     (ADC_BA+0x024) /*!< ADC Touch Z Pressure Data */
N#define REG_ADC_DATA      (ADC_BA+0x028) /*!< ADC Normal Conversion Data */
N#define REG_ADC_VBADATA   (ADC_BA+0x02C) /*!< ADC Battery Detection Data */
N#define REG_ADC_KPDATA    (ADC_BA+0x030) /*!< ADC Key Pad Data */
N#define REG_ADC_SELFDATA  (ADC_BA+0x034) /*!< ADC Self-Test Data */
N#define REG_ADC_XYSORT0   (ADC_BA+0x1F4) /*!< ADC Touch XY Position Mean Value Sort 0 */
N#define REG_ADC_XYSORT1   (ADC_BA+0x1F8) /*!< ADC Touch XY Position Mean Value Sort 1 */
N#define REG_ADC_XYSORT2   (ADC_BA+0x1FC) /*!< ADC Touch XY Position Mean Value Sort 2 */
N#define REG_ADC_XYSORT3   (ADC_BA+0x200) /*!< ADC Touch XY Position Mean Value Sort 3 */
N#define REG_ADC_ZSORT0    (ADC_BA+0x204) /*!< ADC Touch Z Pressure Mean Value Sort 0 */
N#define REG_ADC_ZSORT1    (ADC_BA+0x208) /*!< ADC Touch Z Pressure Mean Value Sort 1 */
N#define REG_ADC_ZSORT2    (ADC_BA+0x20C) /*!< ADC Touch Z Pressure Mean Value Sort 2 */
N#define REG_ADC_ZSORT3    (ADC_BA+0x210) /*!< ADC Touch Z Pressure Mean Value Sort 3 */
N#define REG_ADC_MTMULCK   (ADC_BA+0x220) /*!< ADC Manual Test Mode Unlock */
N#define REG_ADC_MTCONF    (ADC_BA+0x224) /*!< ADC Manual Test Mode Configure */
N#define REG_ADC_MTCON     (ADC_BA+0x228) /*!< ADC Manual Test Mode Control */
N#define REG_ADC_ADCAII    (ADC_BA+0x22C) /*!< ADC Analog Interface Information */
N#define REG_ADC_ADCAIIRLT (ADC_BA+0x230) /*!< ADC Analog Interface Information Result */
N
N/**@}*/ /* end of ADC register group */
N
N/*------------------ Capture Sensor Interface Controller ---------------------*/
N/**
N    @addtogroup CAP Capture Sensor Interface Controller(CAP)
N    Memory Mapped Structure for CAP Controller
N@{ */
N
N#define REG_CAP_CTL            (CAP_BA+0x000)  /*!< Image Capture Interface Control Register */
N#define REG_CAP_PAR            (CAP_BA+0x004)  /*!< Image Capture Interface Parameter Register */
N#define REG_CAP_INT            (CAP_BA+0x008)  /*!< Image Capture Interface Interrupt Registe */
N#define REG_CAP_POSTERIZE      (CAP_BA+0x00C)  /*!< YUV Component Posterizing Factor Register */
N#define REG_CAP_MD             (CAP_BA+0x010)  /*!< Motion Detection Register */
N#define REG_CAP_MDADDR         (CAP_BA+0x014)  /*!< Motion Detection Output Address Register */
N#define REG_CAP_MDYADDR        (CAP_BA+0x018)  /*!< Motion Detection Temp YOutput Address Register */
N#define REG_CAP_SEPIA          (CAP_BA+0x01C)  /*!< Sepia Effect Control Register */
N#define REG_CAP_CWSP           (CAP_BA+0x020)  /*!< Cropping Window Starting Address Register */
N#define REG_CAP_CWS            (CAP_BA+0x024)  /*!< Cropping Window Size Register */
N#define REG_CAP_PKTSL          (CAP_BA+0x028)  /*!< Packet Scaling Vertical/Horizontal Factor Register (LSB) */
N#define REG_CAP_PLNSL          (CAP_BA+0x02C)  /*!< Planar Scaling Vertical/Horizontal Factor Register (LSB) */
N#define REG_CAP_FRCTL          (CAP_BA+0x030)  /*!< Scaling Frame Rate Factor Register */
N#define REG_CAP_STRIDE         (CAP_BA+0x034)  /*!< Frame Output Pixel Stride Register */
N#define REG_CAP_FIFOTH         (CAP_BA+0x03C)  /*!< FIFO threshold Register */
N#define REG_CAP_CMPADDR        (CAP_BA+0x040)  /*!< Compare Packet Memory Base Address Register */
N#define REG_CAP_PKTSM          (CAP_BA+0x048)  /*!< Packet Scaling Vertical/Horizontal Factor Register (MSB) */
N#define REG_CAP_PLNSM          (CAP_BA+0x04C)  /*!< Planar Scaling Vertical/Horizontal Factor Register (MSB) */
N#define REG_CAP_CURADDRP       (CAP_BA+0x050)  /*!< Current Packet System Memory Address Register */
N#define REG_CAP_CURADDRY       (CAP_BA+0x054)  /*!< Current Planar Y System Memory Address Register */
N#define REG_CAP_CURADDRU       (CAP_BA+0x058)  /*!< Current Planar U System Memory Address Register */
N#define REG_CAP_CURADDRV       (CAP_BA+0x05C)  /*!< Current Planar V System Memory Address Register */
N#define REG_CAP_PKTBA0         (CAP_BA+0x060)  /*!< System Memory Packet Base Address Register */
N#define REG_CAP_PKTBA1         (CAP_BA+0x064)  /*!< System Memory Packet Base Address Register */
N#define REG_CAP_YBA            (CAP_BA+0x080)  /*!< System Memory Planar Y Base Address Register */
N#define REG_CAP_UBA            (CAP_BA+0x084)  /*!< System Memory Planar U Base Address Register */
N#define REG_CAP_VBA            (CAP_BA+0x088)  /*!< System Memory Planar V Base Address Register */
N
N/**@}*/ /* end of CAP register group */
N
N/*------------------ SDRAM Interface Controller ---------------------*/
N/**
N    @addtogroup SDIC SDRAM Interface Controller(SDIC)
N    Memory Mapped Structure for SDIC Controller
N@{ */
N
N#define REG_SDIC_OPMCTL     (SDIC_BA+0x000)    /*!< SDRAM Controller Operation Mode Control Register */
N#define REG_SDIC_CMD        (SDIC_BA+0x004)    /*!< SDRAM Command Register */
N#define REG_SDIC_REFCTL     (SDIC_BA+0x008)    /*!< SDRAM Controller Refresh Control Register */
N#define REG_SDIC_SIZE0      (SDIC_BA+0x010)    /*!< SDRAM 0 Size Register */
N#define REG_SDIC_SIZE1      (SDIC_BA+0x014)    /*!< SDRAM 1 Size Register */
N#define REG_SDIC_MR         (SDIC_BA+0x018)    /*!< SDRAM Mode Register */
N#define REG_SDIC_EMR        (SDIC_BA+0x01C)    /*!< SDRAM Extended Mode Register */
N#define REG_SDIC_EMR2       (SDIC_BA+0x020)    /*!< SDRAM Extended Mode Register 2 */
N#define REG_SDIC_EMR3       (SDIC_BA+0x024)    /*!< SDRAM Extended Mode Register 3 */
N#define REG_SDIC_TIME       (SDIC_BA+0x028)    /*!< SDRAM Timing Control Register */
N#define REG_SDIC_DQSODS     (SDIC_BA+0x030)    /*!< DQS Output Delay Selection Register */
N#define REG_SDIC_CKDQSDS    (SDIC_BA+0x034)    /*!< Clock and DQS Delay Selection Register */
N#define REG_SDIC_DAENSEL    (SDIC_BA+0x038)    /*!< Data Latch Enable Selection Register */
N
N/**@}*/ /* end of SDIC register group */
N
N/*---------------------- Controller Area Network -------------------------*/
N/**
N    @addtogroup CAN Controller Area Network(CAN)
N    Memory Mapped Structure for CAN Controller
N@{ */
N
N#define REG_CAN0_CON       (CAN0_BA+0x00) /*!< Control Register */
N#define REG_CAN0_STATUS    (CAN0_BA+0x04) /*!< Status Register */
N#define REG_CAN0_ERR       (CAN0_BA+0x08) /*!< Error Counter Register */
N#define REG_CAN0_BTIME     (CAN0_BA+0x0C) /*!< Bit Time Register */
N#define REG_CAN0_IIDR      (CAN0_BA+0x10) /*!< Interrupt Identifier Register */
N#define REG_CAN0_TEST      (CAN0_BA+0x14) /*!< Test Register */
N#define REG_CAN0_BRPE      (CAN0_BA+0x18) /*!< BRP Extension Register */
N#define REG_CAN0_IF1_CREQ  (CAN0_BA+0x20) /*!< IF1 Command Request Register */
N#define REG_CAN0_IF2_CREQ  (CAN0_BA+0x80) /*!< IF2 Command Request Register */
N#define REG_CAN0_IF1_CMASK (CAN0_BA+0x24) /*!< IF1 Command Mask Register */
N#define REG_CAN0_IF2_CMASK (CAN0_BA+0x84) /*!< IF2 Command Mask Register */
N#define REG_CAN0_IF1_MASK1 (CAN0_BA+0x28) /*!< IF1 Msak 1 Register */
N#define REG_CNA0_IF2_MASK1 (CAN0_BA+0x88) /*!< IF2 Mask 1 Register */
N#define REG_CAN0_IF1_MASK2 (CAN0_BA+0x2C) /*!< IF1 Mask 2 Register */
N#define REG_CAN0_IF2_MASK2 (CAN0_BA+0x8C) /*!< IF2 Mask 2 REgister */
N#define REG_CAN0_IF1_ARB1  (CAN0_BA+0x30) /*!< IF1 Arbitration 1 Register */
N#define REG_CAN0_IF2_ARB1  (CAN0_BA+0x90) /*!< IF2 Arbitration 1 Register */
N#define REG_CAN0_IF1_ARB2  (CAN0_BA+0x34) /*!< IF1 Arbitration 2 Register */
N#define REG_CAN0_IF2_ARB2  (CAN0_BA+0x94) /*!< IF2 Arbitration 2 Register */
N#define REG_CAN0_IF1_MCON  (CAN0_BA+0x38) /*!< IF1 Message Control Register */
N#define REG_CAN0_IF2_MCON  (CAN0_BA+0x98) /*!< IF2 Message Control Register */
N#define REG_CAN0_IF1_DAT_A1 (CAN0_BA+0x3C) /*!< IF1 Data A1 Register */
N#define REG_CAN0_IF1_DAT_A2 (CAN0_BA+0x40) /*!< IF1 Data A2 Register */
N#define REG_CAN0_IF1_DAT_B1 (CAN0_BA+0x44) /*!< IF1 Data B1 Register */
N#define REG_CAN0_IF1_DAT_B2 (CAN0_BA+0x48) /*!< IF1 Data B2 Register */
N#define REG_CAN0_IF2_DAT_A1 (CAN0_BA+0x9C) /*!< IF2 Data A1 Register */
N#define REG_CAN0_IF2_DAT_A2 (CAN0_BA+0xA0) /*!< IF2 Data A2 Register */
N#define REG_CAN0_IF2_DAT_B1 (CAN0_BA+0xA4) /*!< IF2 Data B1 Register */
N#define REG_CAN0_IF2_DAT_B2 (CAN0_BA+0xA8) /*!< IF2 Data B2 Register */
N#define REG_CAN0_TXREQ1     (CAN0_BA+0x100) /*!< Transmission Request Register 1 */
N#define REG_CAN0_TXREQ2     (CAN0_BA+0x104) /*!< Transmission Request Register 2 */
N#define REG_CAN0_NDAT1      (CAN0_BA+0x120) /*!< New Data Register 1 */
N#define REG_CAN0_NDAT2      (CAN0_BA+0x124) /*!< New Data Register 2 */
N#define REG_CAN0_IPND1      (CAN0_BA+0x140) /*!< Interrupt Pending Register 1 */
N#define REG_CAN0_IPND2      (CAN0_BA+0x142) /*!< Interrupt Pending Register 2 */
N#define REG_CAN0_MVLD1      (CAN0_BA+0x160) /*!< Message Valid Register 1 */
N#define REG_CAN0_MVLD2      (CAN0_BA+0x164) /*!< Message Valid Register 2 */
N#define REG_CAN0_WU_EN      (CAN0_BA+0x168) /*!< Wake-up Function Enable */
N#define REG_CAN0_WU_STATUS  (CAN0_BA+0x16C) /*!< Wake-up Function Status */
N
N#define REG_CAN1_CON       (CAN1_BA+0x00) /*!< Control Register */
N#define REG_CAN1_STATUS    (CAN1_BA+0x04) /*!< Status Register */
N#define REG_CAN1_ERR       (CAN1_BA+0x08) /*!< Error Counter Register */
N#define REG_CAN1_BTIME     (CAN1_BA+0x0C) /*!< Bit Time Register */
N#define REG_CAN1_IIDR      (CAN1_BA+0x10) /*!< Interrupt Identifier Register */
N#define REG_CAN1_TEST      (CAN1_BA+0x14) /*!< Test Register */
N#define REG_CAN1_BRPE      (CAN1_BA+0x18) /*!< BRP Extension Register */
N#define REG_CAN1_IF1_CREQ  (CAN1_BA+0x20) /*!< IF1 Command Request Register */
N#define REG_CAN1_IF2_CREQ  (CAN1_BA+0x80) /*!< IF2 Command Request Register */
N#define REG_CAN1_IF1_CMASK (CAN1_BA+0x24) /*!< IF1 Command Mask Register */
N#define REG_CAN1_IF2_CMASK (CAN1_BA+0x84) /*!< IF2 Command Mask Register */
N#define REG_CAN1_IF1_MASK1 (CAN1_BA+0x28) /*!< IF1 Msak 1 Register */
N#define REG_CNA1_IF2_MASK1 (CAN1_BA+0x88) /*!< IF2 Mask 1 Register */
N#define REG_CAN1_IF1_MASK2 (CAN1_BA+0x2C) /*!< IF1 Mask 2 Register */
N#define REG_CAN1_IF2_MASK2 (CAN1_BA+0x8C) /*!< IF2 Mask 2 REgister */
N#define REG_CAN1_IF1_ARB1  (CAN1_BA+0x30) /*!< IF1 Arbitration 1 Register */
N#define REG_CAN1_IF2_ARB1  (CAN1_BA+0x90) /*!< IF2 Arbitration 1 Register */
N#define REG_CAN1_IF1_ARB2  (CAN1_BA+0x34) /*!< IF1 Arbitration 2 Register */
N#define REG_CAN1_IF2_ARB2  (CAN1_BA+0x94) /*!< IF2 Arbitration 2 Register */
N#define REG_CAN1_IF1_MCON  (CAN1_BA+0x38) /*!< IF1 Message Control Register */
N#define REG_CAN1_IF2_MCON  (CAN1_BA+0x98) /*!< IF2 Message Control Register */
N#define REG_CAN1_IF1_DAT_A1 (CAN1_BA+0x3C) /*!< IF1 Data A1 Register */
N#define REG_CAN1_IF1_DAT_A2 (CAN1_BA+0x40) /*!< IF1 Data A2 Register */
N#define REG_CAN1_IF1_DAT_B1 (CAN1_BA+0x44) /*!< IF1 Data B1 Register */
N#define REG_CAN1_IF1_DAT_B2 (CAN1_BA+0x48) /*!< IF1 Data B2 Register */
N#define REG_CAN1_IF2_DAT_A1 (CAN1_BA+0x9C) /*!< IF2 Data A1 Register */
N#define REG_CAN1_IF2_DAT_A2 (CAN1_BA+0xA0) /*!< IF2 Data A2 Register */
N#define REG_CAN1_IF2_DAT_B1 (CAN1_BA+0xA4) /*!< IF2 Data B1 Register */
N#define REG_CAN1_IF2_DAT_B2 (CAN1_BA+0xA8) /*!< IF2 Data B2 Register */
N#define REG_CAN1_TXREQ1     (CAN1_BA+0x100) /*!< Transmission Request Register 1 */
N#define REG_CAN1_TXREQ2     (CAN1_BA+0x104) /*!< Transmission Request Register 2 */
N#define REG_CAN1_NDAT1      (CAN1_BA+0x120) /*!< New Data Register 1 */
N#define REG_CAN1_NDAT2      (CAN1_BA+0x124) /*!< New Data Register 2 */
N#define REG_CAN1_IPND1      (CAN1_BA+0x140) /*!< Interrupt Pending Register 1 */
N#define REG_CAN1_IPND2      (CAN1_BA+0x142) /*!< Interrupt Pending Register 2 */
N#define REG_CAN1_MVLD1      (CAN1_BA+0x160) /*!< Message Valid Register 1 */
N#define REG_CAN1_MVLD2      (CAN1_BA+0x164) /*!< Message Valid Register 2 */
N#define REG_CAN1_WU_EN      (CAN1_BA+0x168) /*!< Wake-up Function Enable */
N#define REG_CAN1_WU_STATUS  (CAN1_BA+0x16C) /*!< Wake-up Function Status */
N
N/**@}*/ /* end of CAN register group */
N
N
N/*------------------- JPEG Controller --------------------*/
N/**
N    @addtogroup JPEG JPEG Controller (JPEG)
N    Memory Mapped Structure for JPEG Controller
N@{ */
N#define JMCR           (JPEG_BA+0x00)           /*!< JPEG Mode Control Register  */
N#define JHEADER        (JPEG_BA+0x04)           /*!< JPEG Encode Header Control Register  */
N#define JITCR          (JPEG_BA+0x08)           /*!< JPEG Image Type Control Register  */
N#define JPRIQC         (JPEG_BA+0x10)           /*!< JPEG Primary Q-Table Control Register  */
N#define JTHBQC         (JPEG_BA+0x14)           /*!< JPEG Thumbnail Q-Table Control Register  */
N#define JPRIWH         (JPEG_BA+0x18)           /*!< JPEG Encode Primary Width/Height Register  */
N#define JTHBWH         (JPEG_BA+0x1C)           /*!< JPEG Encode Thumbnail Width/Height Register  */
N#define JPRST          (JPEG_BA+0x20)           /*!< JPEG Encode Primary Restart Interval Register  */
N#define JTRST          (JPEG_BA+0x24)           /*!< JPEG Encode Thumbnail Restart Interval  */
N#define JDECWH         (JPEG_BA+0x28)           /*!< JPEG Decode Image Width/Height Register  */
N#define JINTCR         (JPEG_BA+0x2C)           /*!< JPEG Interrupt Control and Status Register  */
N#define JDOWFBS        (JPEG_BA+0x3c)           /*!< JPEG Decoding Output Wait Frame Buffer Size  */
N#define JPEG_BSBAD     (JPEG_BA+0x40)           /*!< JPEG Test Control Register  */
N#define JWINDEC0       (JPEG_BA+0x44)           /*!< JPEG Window Decode Mode Control Register 0  */
N#define JWINDEC1       (JPEG_BA+0x48)           /*!< JPEG Window Decode Mode Control Register 1  */
N#define JWINDEC2       (JPEG_BA+0x4C)           /*!< JPEG Window Decode Mode Control Register 2  */
N#define JMACR          (JPEG_BA+0x50)           /*!< JPEG Memory Address Mode Control Register  */
N#define JPSCALU        (JPEG_BA+0x54)           /*!< JPEG Primary Scaling-Up Control Register  */
N#define JPSCALD        (JPEG_BA+0x58)           /*!< JPEG Primary Scaling-Down Control Register  */
N#define JTSCALD        (JPEG_BA+0x5C)           /*!< JPEG Thumbnail  Scaling-Down Control Register  */
N#define JDBCR          (JPEG_BA+0x60)           /*!< JPEG Dual-Buffer Control Register  */
N#define JRESERVE       (JPEG_BA+0x70)           /*!< JPEG Encode Primary Bit-stream Reserved Size Register  */
N#define JOFFSET        (JPEG_BA+0x74)           /*!< JPEG Offset Between Primary & Thumbnail Register  */
N#define JFSTRIDE       (JPEG_BA+0x78)           /*!< JPEG Encode Bit-stream Frame Stride Register  */
N#define JYADDR0        (JPEG_BA+0x7C)           /*!< JPEG Y Component Frame Buffer-0 Starting Address Register  */
N#define JUADDR0        (JPEG_BA+0x80)           /*!< JPEG U Component Frame Buffer-0 Starting Address Register  */
N#define JVADDR0        (JPEG_BA+0x84)           /*!< JPEG V Component Frame Buffer-0 Starting Address Register  */
N#define JYADDR1        (JPEG_BA+0x88)           /*!< JPEG Y Component Frame Buffer-1 Starting Address Register  */
N#define JUADDR1        (JPEG_BA+0x8C)           /*!< JPEG U Component Frame Buffer-1 Starting Address Register  */
N#define JVADDR1        (JPEG_BA+0x90)           /*!< JPEG V Component Frame Buffer-1 Starting Address Register  */
N#define JYSTRIDE       (JPEG_BA+0x94)           /*!< JPEG Y Component Frame Buffer Stride Register  */
N#define JUSTRIDE       (JPEG_BA+0x98)           /*!< JPEG U Component Frame Buffer Stride Register  */
N#define JVSTRIDE       (JPEG_BA+0x9C)           /*!< JPEG V Component Frame Buffer Stride Register  */
N#define JIOADDR0       (JPEG_BA+0xA0)           /*!< JPEG Bit-stream Frame Buffer-0 Starting Address Register  */
N#define JIOADDR1       (JPEG_BA+0xA4)           /*!< JPEG Bit-stream Frame Buffer-1 Starting Address Register  */
N#define JPRI_SIZE      (JPEG_BA+0xA8)           /*!< JPEG Encode Primary Image Bit-stream Size Register  */
N#define JTHB_SIZE      (JPEG_BA+0xAC)           /*!< JPEG Encode Thumbnail Image Bit-stream Size Register  */
N#define JUPRAT         (JPEG_BA+0xB0)           /*!< JPEG Encode Up-Scale Ratio Register  */
N#define JBSFIFO        (JPEG_BA+0xB4)           /*!< JPEG Bit-stream FIFO Control Register  */
N#define JSRCH          (JPEG_BA+0xB8)           /*!< JPEG Encode Source Image Height  */
N#define JQTAB0         (JPEG_BA+0x100)          /*!< JPEG Quantization-Table 0 Register  */
N#define JQTAB1         (JPEG_BA+0x140)          /*!< JPEG Quantization-Table 1 Register  */
N#define JQTAB2         (JPEG_BA+0x180)          /*!< JPEG Quantization-Table 2 Register  */
N
N/**@}*/ /* end of JPEG register group */
N
N
N
N/*@}*/ /* end of group N9H30_Peripherals */
N
N
N/** @addtogroup N9H30_IO_ROUTINE N9H30 I/O Routines
N  The Declaration of N9H30 I/O Routines
N  @{
N */
N
Ntypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Ntypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Ntypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
N
N/**
N  * @brief Get a 8-bit unsigned value from specified address
N  * @param[in] addr Address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified address
N  */
N#define M8(addr)  (*((vu8  *) (addr)))
N
N/**
N  * @brief Get a 16-bit unsigned value from specified address
N  * @param[in] addr Address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified address
N  * @note The input address must be 16-bit aligned
N  */
N#define M16(addr) (*((vu16 *) (addr)))
N
N/**
N  * @brief Get a 32-bit unsigned value from specified address
N  * @param[in] addr Address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified address
N  * @note The input address must be 32-bit aligned
N  */
N#define M32(addr) (*((vu32 *) (addr)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outpw(port,value)     *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inpw(port)            (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outps(port,value)     *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inps(port)            (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outpb(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inpb(port)            (*((volatile unsigned char *)(port)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outp32(port,value)    *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inp32(port)           (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outp16(port,value)    *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inp16(port)           (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outp8(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inp8(port)            (*((volatile unsigned char *)(port)))
N
N
N/*@}*/ /* end of group N9H30_IO_ROUTINE */
N
N/******************************************************************************/
N/*                Legacy Constants                                            */
N/******************************************************************************/
N/** @addtogroup N9H30_legacy_Constants N9H30 Legacy Constants
N  N9H30 Legacy Constants
N  @{
N*/
Ntypedef void *            PVOID;    ///< Define void pointer data type
Ntypedef void              VOID;     ///< Define void data type
Ntypedef char              BOOL;     ///< Define bool data type
Ntypedef char *            PBOOL;    ///< Define bool pointer data type
N
Ntypedef char              INT8;     ///< Define 8-bit singed data type
Ntypedef char              CHAR;     ///< Define char data type
Ntypedef char *            PINT8;    ///< Define 8-bit singed pointer data type
Ntypedef char *            PCHAR;    ///< Define char pointer data type
Ntypedef unsigned char     UINT8;    ///< Define 8-bit unsigned data type
Ntypedef unsigned char     UCHAR;    ///< Define char unsigned data type
Ntypedef unsigned char *   PUINT8;   ///< Define 8-bit unsigned pointer data type
Ntypedef unsigned char *   PUCHAR;   ///< Define char unsigned pointer data type
Ntypedef char *            PSTR;     ///< Define string pointer data type
Ntypedef const char *      PCSTR;    ///< Define constant string pointer data type
N
Ntypedef short             SHORT;    ///< Define short signed data type
Ntypedef short *           PSHORT;   ///< Define short signed pointer data type
Ntypedef unsigned short    USHORT;   ///< Define short unsigned data type
Ntypedef unsigned short *  PUSHORT;  ///< Define short unsigned pointer data type
N
Ntypedef short             INT16;    ///< Define 16-bit signed data type
Ntypedef short *           PINT16;   ///< Define 16-bit signed pointer data type
Ntypedef unsigned short    UINT16;   ///< Define 16-bit unsigned data type
Ntypedef unsigned short *  PUINT16;  ///< Define 16-bit unsigned pointer data type
N
Ntypedef int               INT;      ///< Define integer signed data type
Ntypedef int *             PINT;     ///< Define integer signed pointer data type
Ntypedef unsigned int      UINT;     ///< Define integer unsigned data type
Ntypedef unsigned int *    PUINT;    ///< Define integer unsigned pointer data type
N
Ntypedef int               INT32;    ///< Define 32-bit signed data type
Ntypedef int *             PINT32;   ///< Define 32-bit signed pointer data type
Ntypedef unsigned int      UINT32;   ///< Define 32-bit unsigned data type
Ntypedef unsigned int *    PUINT32;  ///< Define 32-bit unsigned pointer data type
N
Ntypedef __int64           INT64;    ///< Define 64-bit signed data type
Ntypedef unsigned __int64  UINT64;   ///< Define 64-bit unsigned data type
N
Ntypedef float             FLOAT;    ///< Define float data type
Ntypedef float *           PFLOAT;   ///< Define float pointer data type
N
Ntypedef double            DOUBLE;   ///< Define double data type
Ntypedef double *          PDOUBLE;  ///< Define double pointer data type
N
Ntypedef int               SIZE_T;   ///< Define size of data type
N
Ntypedef unsigned char     REG8;     ///< Define 8-bit register data type
Ntypedef unsigned short    REG16;    ///< Define 16-bit register data type
Ntypedef unsigned int      REG32;    ///< Define 32-bit register data type
N
N
N#ifndef NULL
S#define NULL           (0)      ///< NULL pointer
N#endif
N
N#define TRUE           (1)      ///< Boolean true, define to use in API parameters or return value
N#define FALSE          (0)      ///< Boolean false, define to use in API parameters or return value
N
N#define ENABLE         (1)      ///< Enable, define to use in API parameters
N#define DISABLE        (0)      ///< Disable, define to use in API parameters
N
N
N#define   Successful  0         ///< Function return value success
N#define   Fail        1         ///< Function return value failed
N
N/* Define one bit mask */
N#define BIT0     (0x00000001)       ///< Bit 0 mask of an 32 bit integer
N#define BIT1     (0x00000002)       ///< Bit 1 mask of an 32 bit integer
N#define BIT2     (0x00000004)       ///< Bit 2 mask of an 32 bit integer
N#define BIT3     (0x00000008)       ///< Bit 3 mask of an 32 bit integer
N#define BIT4     (0x00000010)       ///< Bit 4 mask of an 32 bit integer
N#define BIT5     (0x00000020)       ///< Bit 5 mask of an 32 bit integer
N#define BIT6     (0x00000040)       ///< Bit 6 mask of an 32 bit integer
N#define BIT7     (0x00000080)       ///< Bit 7 mask of an 32 bit integer
N#define BIT8     (0x00000100)       ///< Bit 8 mask of an 32 bit integer
N#define BIT9     (0x00000200)       ///< Bit 9 mask of an 32 bit integer
N#define BIT10    (0x00000400)       ///< Bit 10 mask of an 32 bit integer
N#define BIT11    (0x00000800)       ///< Bit 11 mask of an 32 bit integer
N#define BIT12    (0x00001000)       ///< Bit 12 mask of an 32 bit integer
N#define BIT13    (0x00002000)       ///< Bit 13 mask of an 32 bit integer
N#define BIT14    (0x00004000)       ///< Bit 14 mask of an 32 bit integer
N#define BIT15    (0x00008000)       ///< Bit 15 mask of an 32 bit integer
N#define BIT16    (0x00010000)       ///< Bit 16 mask of an 32 bit integer
N#define BIT17    (0x00020000)       ///< Bit 17 mask of an 32 bit integer
N#define BIT18    (0x00040000)       ///< Bit 18 mask of an 32 bit integer
N#define BIT19    (0x00080000)       ///< Bit 19 mask of an 32 bit integer
N#define BIT20    (0x00100000)       ///< Bit 20 mask of an 32 bit integer
N#define BIT21    (0x00200000)       ///< Bit 21 mask of an 32 bit integer
N#define BIT22    (0x00400000)       ///< Bit 22 mask of an 32 bit integer
N#define BIT23    (0x00800000)       ///< Bit 23 mask of an 32 bit integer
N#define BIT24    (0x01000000)       ///< Bit 24 mask of an 32 bit integer
N#define BIT25    (0x02000000)       ///< Bit 25 mask of an 32 bit integer
N#define BIT26    (0x04000000)       ///< Bit 26 mask of an 32 bit integer
N#define BIT27    (0x08000000)       ///< Bit 27 mask of an 32 bit integer
N#define BIT28    (0x10000000)       ///< Bit 28 mask of an 32 bit integer
N#define BIT29    (0x20000000)       ///< Bit 29 mask of an 32 bit integer
N#define BIT30    (0x40000000)       ///< Bit 30 mask of an 32 bit integer
N#define BIT31    (0x80000000)       ///< Bit 31 mask of an 32 bit integer
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk              (0x000000FF)         ///< Mask to get bit0~bit7 from a 32 bit integer
N#define BYTE1_Msk              (0x0000FF00)         ///< Mask to get bit8~bit15 from a 32 bit integer
N#define BYTE2_Msk              (0x00FF0000)         ///< Mask to get bit16~bit23 from a 32 bit integer
N#define BYTE3_Msk              (0xFF000000)         ///< Mask to get bit24~bit31 from a 32 bit integer
N
N#define GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N
N#endif /* __N9H30_H__ */
N
N/*@}*/ /* end of group N9H30_legacy_Constants */
L 14 "..\main.c" 2
N#include "sys.h"
L 1 "..\..\..\Driver\Include\sys.h" 1
N/**************************************************************************//**
N* @file     sys.h
N* @brief    N9H30 SYS driver header file
N*
N* @note
N* Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup N9H30_Device_Driver N9H30 Device Driver
N  @{
N*/
N
N/** @addtogroup N9H30_SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup N9H30_SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/
N
N/**
N * @details  Interrupt Number Definition.
N */
Ntypedef enum IRQn {
N
N    /******  N9H30 Specific Interrupt Numbers *****************************************/
N
N    WDT_IRQn                = 1,       /*!< Watch Dog Timer Interrupt                  */
N    WWDT_IRQn               = 2,       /*!< Windowed-WDT Interrupt                     */
N    LVD_IRQn                = 3,       /*!< Low Voltage Detect Interrupt               */
N    EINT0_IRQn              = 4,       /*!< External Interrupt 0                       */
N    EINT1_IRQn              = 5,       /*!< External Interrupt 1                       */
N    EINT2_IRQn              = 6,       /*!< External Interrupt 2                       */
N    EINT3_IRQn              = 7,       /*!< External Interrupt 3                       */
N    EINT4_IRQn              = 8,       /*!< External Interrupt 4                       */
N    EINT5_IRQn              = 9,       /*!< External Interrupt 5                       */
N    EINT6_IRQn              = 10,      /*!< External Interrupt 6                       */
N    EINT7_IRQn              = 11,      /*!< External Interrupt 7                       */
N    ACTL_IRQn               = 12,      /*!< Audio Controller Interrupt                 */
N    LCD_IRQn                = 13,      /*!< LCD Controller Interrupt                   */
N    CAP_IRQn                = 14,      /*!< Sensor Interface Controller Interrupt      */
N    RTC_IRQn                = 15,      /*!< Real Time Clock Interrupt                  */
N    TMR0_IRQn               = 16,      /*!< Timer 0 Interrupt                          */
N    TMR1_IRQn               = 17,      /*!< Timer 1 Interrupt                          */
N    ADC_IRQn                = 18,      /*!< ADC Interrupt                              */
N    EMC0_RX_IRQn            = 19,      /*!< EMC 0 RX Interrupt                         */
N    EMC1_RX_IRQn            = 20,      /*!< EMC 1 RX Interrupt                         */
N    EMC0_TX_IRQn            = 21,      /*!< EMC 0 TX Interrupt                         */
N    EMC1_TX_IRQn            = 22,      /*!< EMC 1 TX Interrupt                         */
N    EHCI_IRQn               = 23,      /*!< USB 2.0 Host Controller Interrupt          */
N    OHCI_IRQn               = 24,      /*!< USB 1.1 Host Controller Interrupt          */
N    GDMA0_IRQn              = 25,      /*!< GDMA Channel 0 Interrupt                   */
N    GDMA1_IRQn              = 26,      /*!< GDMA Channel 1 Interrupt                   */
N    SDH_IRQn                = 27,      /*!< SD/SDIO Host Interrupt                     */
N    FMI_IRQn                = 28,      /*!< FMI Interrupt                              */
N    USBD_IRQn               = 29,      /*!< USB Device Interrupt                       */
N    TMR2_IRQn               = 30,      /*!< Timer 2 Interrupt                          */
N    TMR3_IRQn               = 31,      /*!< Timer 3 Interrupt                          */
N    TMR4_IRQn               = 32,      /*!< Timer 4 Interrupt                          */
N    JPEG_IRQn               = 33,      /*!< JPEG Engine Interrupt                      */
N    GE2D_IRQn               = 34,      /*!< 2D Graphic Engine Interrupt                */
N    UART0_IRQn              = 36,      /*!< UART 0 Interrupt                           */
N    UART1_IRQn              = 37,      /*!< UART 1 Interrupt                           */
N    UART2_IRQn              = 38,      /*!< UART 2 Interrupt                           */
N    UART4_IRQn              = 39,      /*!< UART 4 Interrupt                           */
N    UART6_IRQn              = 40,      /*!< UART 6 Interrupt                           */
N    UART8_IRQn              = 41,      /*!< UART 8 Interrupt                           */
N    UART10_IRQn             = 42,      /*!< UART 10 Interrupt                          */
N    UART3_IRQn              = 43,      /*!< UART 3 Interrupt                           */
N    UART5_IRQn              = 44,      /*!< UART 5 Interrupt                           */
N    UART7_IRQn              = 45,      /*!< UART 7 Interrupt                           */
N    UART9_IRQn              = 46,      /*!< UART 9 Interrupt                           */
N    ETMR0_IRQn              = 47,      /*!< Enhanced Timer 0 Interrupt                 */
N    ETMR1_IRQn              = 48,      /*!< Enhanced Timer 1 Interrupt                 */
N    ETMR2_IRQn              = 49,      /*!< Enhanced Timer 2 Interrupt                 */
N    ETMR3_IRQn              = 50,      /*!< Enhanced Timer 3 Interrupt                 */
N    SPI0_IRQn               = 51,      /*!< SPI 0 Interrupt                            */
N    SPI1_IRQn               = 52,      /*!< SPI 1 Interrupt                            */
N    I2C0_IRQn               = 53,      /*!< I2C 0 Interrupt                            */
N    I2C1_IRQn               = 54,      /*!< I2C 1 Interrupt                            */
N    SC0_IRQn                = 55,      /*!< Smart Card 0 Interrupt                     */
N    SC1_IRQn                = 56,      /*!< Smart Card 1 Interrupt                     */
N    GPIO_IRQn               = 57,      /*!< GPIO Interrupt                             */
N    CAN0_IRQn               = 58,      /*!< CAN 0 Interrupt                            */
N    CAN1_IRQn               = 59,      /*!< CAN 1 Interrupt                            */
N    PWM_IRQn                = 60,      /*!< PWM Interrupt                              */
N}
NIRQn_Type;
N
N/* Define constants for use timer in service parameters.  */
N#define TIMER0            0     /*!< Select Timer0 */
N#define TIMER1            1     /*!< Select Timer1 */
N
N#define ONE_SHOT_MODE     0     /*!< Timer Operation Mode - One Shot */
N#define PERIODIC_MODE     1     /*!< Timer Operation Mode - Periodic */
N#define TOGGLE_MODE       2     /*!< Timer Operation Mode - Toggle */
N
N/* The parameters for sysSetInterruptPriorityLevel() and
N   sysInstallISR() use */
N#define FIQ_LEVEL_0     0       /*!< FIQ Level 0 */
N#define IRQ_LEVEL_1     1       /*!< IRQ Level 1 */
N#define IRQ_LEVEL_2     2       /*!< IRQ Level 2 */
N#define IRQ_LEVEL_3     3       /*!< IRQ Level 3 */
N#define IRQ_LEVEL_4     4       /*!< IRQ Level 4 */
N#define IRQ_LEVEL_5     5       /*!< IRQ Level 5 */
N#define IRQ_LEVEL_6     6       /*!< IRQ Level 6 */
N#define IRQ_LEVEL_7     7       /*!< IRQ Level 7 */
N
N#define ONE_HALF_SECS     0     /*!< WDT interval - 1.5s */
N#define FIVE_SECS         1     /*!< WDT interval - 5s */
N#define TEN_SECS          2     /*!< WDT interval - 10s */
N#define TWENTY_SECS       3     /*!< WDT interval - 20s */
N
N/* Define constants for use AIC in service parameters.  */
N#define SYS_SWI           0     /*!< Exception - SWI */
N#define SYS_D_ABORT       1     /*!< Exception - Data abort */
N#define SYS_I_ABORT       2     /*!< Exception - Instruction abort */
N#define SYS_UNDEFINE      3     /*!< Exception - undefine */
N
N/* The parameters for sysSetLocalInterrupt() use */
N#define ENABLE_IRQ        0x7F  /*!< Enable I-bit of CP15  */
N#define ENABLE_FIQ        0xBF  /*!< Enable F-bit of CP15  */
N#define ENABLE_FIQ_IRQ    0x3F  /*!< Enable I-bit and F-bit of CP15  */
N#define DISABLE_IRQ       0x80  /*!< Disable I-bit of CP15  */
N#define DISABLE_FIQ       0x40  /*!< Disable F-bit of CP15  */
N#define DISABLE_FIQ_IRQ   0xC0  /*!< Disable I-bit and F-bit of CP15  */
N
N/* Define Cache type  */
N#define CACHE_WRITE_BACK        0     /*!< Cache Write-back mode  */
N#define CACHE_WRITE_THROUGH     1     /*!< Cache Write-through mode  */
N#define CACHE_DISABLE           -1    /*!< Cache Disable  */
N
N/** \brief  Structure type of clock source
N */
Ntypedef enum CLKn {
N
N    SYS_UPLL     = 1,   /*!< UPLL clock */
N    SYS_APLL     = 2,   /*!< APLL clock */
N    SYS_SYSTEM   = 3,   /*!< System clock */
N    SYS_HCLK1    = 4,   /*!< HCLK1 clock */
N    SYS_HCLK234  = 5,   /*!< HCLK234 clock */
N    SYS_PCLK     = 6,   /*!< PCLK clock */
N    SYS_CPU      = 7,   /*!< CPU clock */
N
N}  CLK_Type;
N
N
N
N/// @cond HIDDEN_SYMBOLS
Ntypedef struct datetime_t {
N    UINT32  year;
N    UINT32  mon;
N    UINT32  day;
N    UINT32  hour;
N    UINT32  min;
N    UINT32  sec;
N} DateTime_T;
N
N/* The parameters for sysSetInterruptType() use */
N#define LOW_LEVEL_SENSITIVE        0x00
N#define HIGH_LEVEL_SENSITIVE       0x40
N#define NEGATIVE_EDGE_TRIGGER      0x80
N#define POSITIVE_EDGE_TRIGGER      0xC0
N
N/* The parameters for sysSetGlobalInterrupt() use */
N#define ENABLE_ALL_INTERRUPTS      0
N#define DISABLE_ALL_INTERRUPTS     1
N
N#define MMU_DIRECT_MAPPING  0
N#define MMU_INVERSE_MAPPING 1
N
N
N/* Define constants for use Cache in service parameters.  */
N#define CACHE_4M        2
N#define CACHE_8M        3
N#define CACHE_16M       4
N#define CACHE_32M       5
N#define I_CACHE         6
N#define D_CACHE         7
N#define I_D_CACHE       8
N
N
N/// @endcond HIDDEN_SYMBOLS
N
N/*@}*/ /* end of group N9H30_SYS_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup N9H30_SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N/* Define system library Timer functions */
NUINT32  sysGetTicks (INT32 nTimeNo);
NINT32   sysResetTicks (INT32 nTimeNo);
NINT32   sysUpdateTickCount(INT32 nTimeNo, UINT32 uCount);
NINT32   sysSetTimerReferenceClock (INT32 nTimeNo, UINT32 uClockRate);
NINT32   sysStartTimer (INT32 nTimeNo, UINT32 uTicksPerSecond, INT32 nOpMode);
NINT32   sysStopTimer (INT32 nTimeNo);
Nvoid    sysClearWatchDogTimerCount (void);
Nvoid    sysClearWatchDogTimerInterruptStatus(void);
Nvoid    sysDisableWatchDogTimer (void);
Nvoid    sysDisableWatchDogTimerReset(void);
Nvoid    sysEnableWatchDogTimer (void);
Nvoid    sysEnableWatchDogTimerReset(void);
NPVOID   sysInstallWatchDogTimerISR (INT32 nIntTypeLevel, PVOID pvNewISR);
NINT32   sysSetWatchDogTimerInterval (INT32 nWdtInterval);
NINT32   sysSetTimerEvent(INT32 nTimeNo, UINT32 uTimeTick, PVOID pvFun);
Nvoid    sysClearTimerEvent(INT32 nTimeNo, UINT32 uTimeEventNo);
Nvoid    sysSetLocalTime(DateTime_T ltime);          /*!< Set local time \hideinitializer */
Nvoid    sysGetCurrentTime(DateTime_T *curTime);     /*!< Get current time \hideinitializer */
Nvoid    sysDelay(UINT32 uTicks);
N
N/* Define system library UART functions */
NINT8    sysGetChar (void);
NINT32   sysInitializeUART (void);
Nvoid    sysprintf (PINT8 pcStr,...);
Nvoid    sysPutChar (UINT8 ucCh);
NINT     sysIsKbHit(void);
N
N/* Define system library AIC functions */
NINT32   sysDisableInterrupt (IRQn_Type eIntNo);
NINT32   sysEnableInterrupt (IRQn_Type eIntNo);
NBOOL    sysGetIBitState(void);              /*!< Get I bit state \hideinitializer */
NUINT32  sysGetInterruptEnableStatus(void);  /*!< Get interrupt enable status \hideinitializer */
NUINT32  sysGetInterruptEnableStatusH(void); /*!< Get interrupt enable status \hideinitializer */
NPVOID   sysInstallExceptionHandler (INT32 nExceptType, PVOID pvNewHandler);
NPVOID   sysInstallFiqHandler (PVOID pvNewISR);
NPVOID   sysInstallIrqHandler (PVOID pvNewISR);
NPVOID   sysInstallISR (INT32 nIntTypeLevel, IRQn_Type eIntNo, PVOID pvNewISR);
NINT32   sysSetGlobalInterrupt (INT32 nIntState);    /*!< Enable/Disable all interrupt \hideinitializer */
NINT32   sysSetInterruptPriorityLevel (IRQn_Type eIntNo, UINT32 uIntLevel);
NINT32   sysSetInterruptType (IRQn_Type eIntNo, UINT32 uIntSourceType);      /*!< Change interrupt type \hideinitializer */
NINT32   sysSetLocalInterrupt (INT32 nIntState);
N
N
N/* Define system library Cache functions */
Nvoid    sysDisableCache(void);
NINT32   sysEnableCache(UINT32 uCacheOpMode);
Nvoid    sysFlushCache(INT32 nCacheType);    /*!< flush cache \hideinitializer */
NBOOL    sysGetCacheState(void);             /*!< get cache state \hideinitializer */
NINT32   sysGetSdramSizebyMB(void);          /*!< Get DRAM size \hideinitializer */
Nvoid    sysInvalidCache(void);              /*!< invalid cache \hideinitializer */
NINT32   sysSetCachePages(UINT32 addr, INT32 size, INT32 cache_mode);    /*!< set cache page \hideinitializer */
N
Nint sysSetMMUMappingMethod(int mode);   /*!< MMU mapping \hideinitializer */
N
NUINT32 sysGetClock(CLK_Type clk);
N
Ntypedef void (*sys_pvFunPtr)();   /* function pointer */
N/// @cond HIDDEN_SYMBOLS
Nextern sys_pvFunPtr sysIrqHandlerTable[];
Nextern BOOL volatile _sys_bIsAICInitial;
N/// @endcond
N#ifdef __cplusplus
S}
N#endif
N
N/*@}*/ /* end of group N9H30_SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group N9H30_SYS_Driver */
N
N/*@}*/ /* end of group N9H30_Device_Driver */
N
N#endif //__SYS_H__
N
N/*** (C) COPYRIGHT 2018 Nuvoton Technology Corp. ***/
N
L 15 "..\main.c" 2
N
N#ifdef __USE_SD__
S#include "sdh.h"
N#else
N#include "spi.h"
L 1 "..\..\..\Driver\Include\spi.h" 1
N/**************************************************************************//**
N* @file     spi.h
N* @brief    N9H30 SPI driver header file
N*
N* @note
N* Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef _SPI_H_
N#define _SPI_H_
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup N9H30_Device_Driver N9H30 Device Driver
N  @{
N*/
N
N/** @addtogroup N9H30_SPI_Driver SPI Driver
N  @{
N*/
N
N/** @addtogroup N9H30_SPI_EXPORTED_CONSTANTS SPI Exported Constants
N  @{
N*/
N/// @cond HIDDEN_SYMBOLS
N
N#define CNTRL   0x00    /*!< Control Register Address */
N#define DIVIDER 0x04    /*!< Divider Register Address */
N#define SSR     0x08    /*!< Slave Select Register Address */
N#define RX0     0x10    /*!< Receive Register 0 Address */
N#define RX1     0x14    /*!< Receive Register 1 Address */
N#define RX2     0x18    /*!< Receive Register 2 Address */
N#define RX3     0x1C    /*!< Receive Register 3 Address */
N#define TX0     0x10    /*!< Transfer Register 0 Address */
N#define TX1     0x14    /*!< Transfer Register 1 Address */
N#define TX2     0x18    /*!< Transfer Register 2 Address */
N#define TX3     0x1C    /*!< Transfer Register 3 Address */
N
N#define SPI_INPUT_CLOCK         75000000        /* 75 000 KHz */
N/// @endcond HIDDEN_SYMBOLS
N
N#define SPI_NUMBER  2       /*!< 2 spi interfaces  */
N
N#define SPI_NO_ERR      0   /*!< No error  */
N
N#define SPI_ERR_NODEV   -1  /*!< Wrong device id  */
N#define SPI_ERR_BUSY    -2  /*!< Interface is busy  */
N#define SPI_ERR_IO      -3  /*!< IO control error for not opened interface  */
N#define SPI_ERR_ARG     -4  /*!< Wrong argument in IO control  */
N
N#define SPI_IOC_TRIGGER                 0   /*!< Trigger SPI interface */
N#define SPI_IOC_SET_INTERRUPT           1   /*!< Enable/disable interrupt ,arguments could be \ref SPI_DISABLE_INTERRUPT and \ref SPI_ENABLE_INTERRUPT */
N#define SPI_IOC_SET_SPEED               2   /*!< Set SPI clock speed */
N#define SPI_IOC_SET_DUAL_QUAD_MODE      3   /*!< Enable/disable Quad/Dual mode ,arguments could be \ref SPI_DISABLE_DUAL_QUAD, \ref SPI_DUAL_MODE, \ref SPI_QUAD_MODE*/
N#define SPI_IOC_SET_DUAL_QUAD_DIR       4   /*!< Set Quad/Dual mode direction ,arguments could be \ref SPI_DUAL_QUAD_INPUT, \ref SPI_DUAL_QUAD_OUTPUT */
N#define SPI_IOC_SET_LSB_MSB             5   /*!< Set MSB/LSB ,arguments could be \ref SPI_MSB, \ref SPI_LSB */
N#define SPI_IOC_SET_TX_NUM              6   /*!< Set transfer number */
N#define SPI_IOC_SET_TX_BITLEN           7   /*!< Set transfer bit number */
N#define SPI_IOC_SET_MODE                8   /*!< Set SPI mode ,arguments could be \ref SPI_MODE_0, \ref SPI_MODE_1, \ref SPI_MODE_2, \ref SPI_MODE_3 */
N#define SPI_IOC_ENABLE_SS               9   /*!< Enable slave select pin */
N#define SPI_IOC_DISABLE_SS              10  /*!< Disable slave select pin */
N#define SPI_IOC_SET_AUTOSS              11  /*!< Enable/disable auto slave select function ,arguments could be \ref SPI_DISABLE_AUTOSS, \ref SPI_ENABLE_AUTOSS */
N#define SPI_IOC_SET_SS_ACTIVE_LEVEL     12  /*!< Set slave select active level ,arguments could be \ref SPI_SS_ACTIVE_LOW, \ref SPI_SS_ACTIVE_HIGH */
N
N#define SPI_DISABLE_INTERRUPT   0   /*!< Disable interrupt */
N#define SPI_ENABLE_INTERRUPT    1   /*!< Enable interrupt */
N
N#define SPI_DISABLE_DUAL_QUAD   0   /*!< Disable quad and dual mode */
N#define SPI_DUAL_MODE           1   /*!< Enable dual mode */
N#define SPI_QUAD_MODE           2   /*!< Enable quad mode */
N
N#define SPI_DUAL_QUAD_INPUT     0   /*!< Set dual/quad mode io direction to input */
N#define SPI_DUAL_QUAD_OUTPUT    1   /*!< Set dual/quad mode io direction to output */
N
N#define SPI_MSB                 0   /*!< Enable MSB */
N#define SPI_LSB                 1   /*!< Enable LSB */
N
N#define SPI_MODE_0              0   /*!< Set to SPI mode 0 */
N#define SPI_MODE_1              1   /*!< Set to SPI mode 1 */
N#define SPI_MODE_2              2   /*!< Set to SPI mode 2 */
N#define SPI_MODE_3              3   /*!< Set to SPI mode 3 */
N
N#define SPI_SS_SS0              0   /*!< Select SS0 */
N#define SPI_SS_SS1              1   /*!< Select SS1 */
N#define SPI_SS_BOTH             2   /*!< Select both SS0/SS1 */
N
N#define SPI_DISABLE_AUTOSS      0   /*!< Disable auto slave select function */
N#define SPI_ENABLE_AUTOSS       1   /*!< Enable auto slave select function */
N
N#define SPI_SS_ACTIVE_LOW       0   /*!< Set active level of slave select to low */
N#define SPI_SS_ACTIVE_HIGH      1   /*!< Set active level of slave select to high */
N
N/*@}*/ /* end of group N9H30_SPI_EXPORTED_CONSTANTS */
N
N/** @addtogroup N9H30_SPI_EXPORTED_FUNCTIONS SPI Exported Functions
N  @{
N*/
N
Nint32_t  spiInit(int32_t fd);
Nint32_t spiIoctl(int32_t fd, uint32_t cmd, uint32_t arg0, uint32_t arg1);
Nint spiOpen(int32_t fd);
Nuint8_t spiGetBusyStatus(int32_t fd);
Nuint32_t spiRead(int32_t fd, uint8_t buff_id);
Nvoid spiWrite(int32_t fd, uint8_t buff_id, uint32_t data);
N/*@}*/ /* end of group N9H30_SPI_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group N9H30_SPI_Driver */
N
N/*@}*/ /* end of group N9H30_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SPI_H__
N
N/*** (C) COPYRIGHT 2018 Nuvoton Technology Corp. ***/
L 20 "..\main.c" 2
N#include "spilib.h"
L 1 "..\tslib\spilib.h" 1
N#ifndef __SPILIB_H__
N#define __SPILIB_H__
N
N#define __DEMO_TSFILE_ADDR__    0x00180000 /* SPI flash 1.5MB address */
N
Nvoid _DemoSpiInit(void);
Nint SpiFlash_SectorErase(uint32_t StartAddress);
Nuint8_t SpiFlash_ReadStatusReg(void);
Nvoid SpiFlash_WaitReady(void);
Nint SpiFlash_NormalProgram(uint32_t StartAddress, uint8_t *u8DataBuffer, uint32_t data_len);
Nint SpiFlash_NormalRead(uint32_t StartAddress, uint8_t *u8DataBuffer, uint32_t data_len);
Nuint16_t SpiFlash_ReadMidDid(void);
N
N#endif
L 21 "..\main.c" 2
N#endif
N
N#include "gpio.h"
L 1 "..\..\..\Driver\Include\gpio.h" 1
N/**************************************************************************//**
N* @file     gpio.h
N* @version  V1.00
N* @brief    N9H30 GPIO driver header file
N*
N* @copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef __GPIO_H__
N#define __GPIO_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup N9H30_Device_Driver N9H30 Device Driver
N  @{
N*/
N
N/** @addtogroup N9H30_GPIO_Driver GPIO Driver
N  @{
N*/
N
N/** @addtogroup N9H30_GPIO_EXPORTED_CONSTANTS GPIO Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  MODE Constant Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N/// @cond HIDDEN_SYMBOLS
N#ifndef GPIO_ERR_PORT_BUSY
N#define GPIO_ERR_PORT_BUSY      -1
N#define GPIO_ERR_UNSUPPORTED    -2
N#define GPIO_ERR_BIT_BUSY       -3
N#define SUCCESSFUL              0
N#endif
N/// @endcond HIDDEN_SYMBOLS
N
N#define MAX_PORT 10  /*!< GPIO Port Number */
N
N#define GPIOA_MASK  0x0000FFFF  /*!< GPIO Port A Mask */
N#define GPIOB_MASK  0x0000FFFF  /*!< GPIO Port B Mask */
N#define GPIOC_MASK  0x00007FFF  /*!< GPIO Port C Mask */
N#define GPIOD_MASK  0x0000FFFF  /*!< GPIO Port D Mask */
N#define GPIOE_MASK  0x0000FFFF  /*!< GPIO Port E Mask */
N#define GPIOF_MASK  0x0000FFFF  /*!< GPIO Port F Mask */
N#define GPIOG_MASK  0x0000FFFF  /*!< GPIO Port G Mask */
N#define GPIOH_MASK  0x0000FFFF  /*!< GPIO Port H Mask */
N#define GPIOI_MASK  0x0000FFFF  /*!< GPIO Port I Mask */
N#define GPIOJ_MASK  0x0000003F  /*!< GPIO Port J Mask */
N
N/// @cond HIDDEN_SYMBOLS
Ntypedef INT32 (*GPIO_CALLBACK)(UINT32 status, UINT32 userData);
Ntypedef INT32 (*EINT_CALLBACK)(UINT32 status, UINT32 userData);
N/// @endcond HIDDEN_SYMBOLS
N
N/** \brief  Structure type of GPIO_PORT
N */
Ntypedef enum
N{
N    GPIOA=0x000,   /*!< Port A offset of GPIO base address      */
N    GPIOB=0x040,   /*!< Port B offset of GPIO base address      */
N    GPIOC=0x080,   /*!< Port C offset of GPIO base address      */
N    GPIOD=0x0C0,   /*!< Port D offset of GPIO base address      */
N    GPIOE=0x100,   /*!< Port E offset of GPIO base address      */
N    GPIOF=0x140,   /*!< Port F offset of GPIO base address      */
N    GPIOG=0x180,   /*!< Port G offset of GPIO base address      */
N    GPIOH=0x1C0,   /*!< Port H offset of GPIO base address      */
N    GPIOI=0x200,   /*!< Port I offset of GPIO base address      */
N    GPIOJ=0x240,   /*!< Port J offset of GPIO base address      */
N} GPIO_PORT;
N
N/** \brief  Structure type of GPIO_DIR
N */
Ntypedef enum
N{
N    DIR_INPUT,   /*!< GPIO Output mode      */
N    DIR_OUTPUT   /*!< GPIO Input mode      */
N} GPIO_DIR;
N
N/** \brief  Structure type of GPIO_PULL
N */
Ntypedef enum
N{
N    NO_PULL_UP, /*!< GPIO Pull-Up Disable */
N    PULL_UP     /*!< GPIO Pull-Up Enable */
N} GPIO_PULL;
N
N/** \brief  Structure type of GPIO_DRV
N */
Ntypedef enum
N{
N    DRV_LOW,   /*!< GPIO Set to Low */
N    DRV_HIGH   /*!< GPIO Set to High */
N} GPIO_DRV;
N
N/** \brief  Structure type of GPIO_NIRQ
N */
Ntypedef enum
N{
N    NIRQ0=0,   /*!< External interrupt 0 */
N    NIRQ1,     /*!< External interrupt 1 */
N    NIRQ2,     /*!< External interrupt 2 */
N    NIRQ3,     /*!< External interrupt 3 */
N    NIRQ4,     /*!< External interrupt 4 */
N    NIRQ5,     /*!< External interrupt 5 */
N    NIRQ6,     /*!< External interrupt 6 */
N    NIRQ7,     /*!< External interrupt 7 */
N} GPIO_NIRQ;
N
N/** \brief  Structure type of GPIO_TRIGGER_TYPE
N */
Ntypedef enum
N{
N    LOW,                   /*!< Trigger type set low */
N    HIGH,                  /*!< Trigger type set high */
N    FALLING,               /*!< Trigger type set falling edge */
N    RISING,                /*!< Trigger type set rising edge */
N    BOTH_EDGE              /*!< Trigger type set falling edge and rising edge */
N} GPIO_TRIGGER_TYPE;
N
N/// @cond HIDDEN_SYMBOLS
Ntypedef struct
N{
N    UINT16          bitBusyFlag[MAX_PORT];
X    UINT16          bitBusyFlag[10];
N    GPIO_CALLBACK   IRQCallback[MAX_PORT];
X    GPIO_CALLBACK   IRQCallback[10];
N    UINT32          IRQUserData[MAX_PORT];
X    UINT32          IRQUserData[10];
N    EINT_CALLBACK   EINTIRQCallback[8];
N    UINT32          EINTIRQUserData[8];
N} GPIO_CFG;
N/// @endcond HIDDEN_SYMBOLS
N
N/*@}*/ /* end of group N9H30_GPIO_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup N9H30_GPIO_EXPORTED_FUNCTIONS GPIO Exported Functions
N  @{
N*/
N
NINT32 GPIO_Open(GPIO_PORT port, GPIO_DIR direction, GPIO_PULL pull);
NINT32 GPIO_Close(GPIO_PORT port);
NINT32 GPIO_Set(GPIO_PORT port, UINT32 bitMap);
NINT32 GPIO_Clr(GPIO_PORT port, UINT32 bitMap);
NUINT32 GPIO_ReadPort(GPIO_PORT port);
NINT32 GPIO_SetPortDir(GPIO_PORT port, GPIO_DIR direction);
N
N/* General GPIO bit function */
NINT32 GPIO_OpenBit(GPIO_PORT port, UINT32 bit, GPIO_DIR direction, GPIO_PULL pull);
NINT32 GPIO_CloseBit(GPIO_PORT port, UINT32 bit);
NINT32 GPIO_SetBit(GPIO_PORT port, UINT32 bit);
NINT32 GPIO_ClrBit(GPIO_PORT port, UINT32 bit);
NINT32 GPIO_ReadBit(GPIO_PORT port, UINT32 bit);
NINT32 GPIO_SetBitDir(GPIO_PORT port, UINT32 bit, GPIO_DIR direction);
NINT32 GPIO_EnableTriggerType(GPIO_PORT port, UINT32 bit, GPIO_TRIGGER_TYPE triggerType);
NINT32 GPIO_DisableTriggerType(GPIO_PORT port, UINT32 bit);
NINT32 GPIO_EnableInt(GPIO_PORT port, GPIO_CALLBACK callback, UINT32 userData);
NINT32 GPIO_DisableInt(GPIO_PORT port);
NINT32 GPIO_ClrISR(GPIO_PORT port, UINT32 bit);
NINT32 GPIO_ClrISRBit(GPIO_PORT port, UINT32 bit);
N
N/* GPIO status function */
NBOOL GPIO_BitIsUsed(GPIO_PORT port, UINT32 bit);
N
N/* External GPIO interrupt function */
NINT32 GPIO_EnableEINT(GPIO_NIRQ nIrq, GPIO_CALLBACK callback, UINT32 userData);
NINT32 GPIO_DisableEINT(GPIO_NIRQ nIrq);
NINT32 GPIO_EnableDebounce(INT32 debounceClkSel);
NINT32 GPIO_DisableDebounce(void);
N
N/*@}*/ /* end of group N9H30_GPIO_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group N9H30_GPIO_Driver */
N
N/*@}*/ /* end of group N9H30_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__GPIO_H__
N
L 24 "..\main.c" 2
N#include "lcd.h"
L 1 "..\..\..\Driver\Include\lcd.h" 1
N/**************************************************************************//**
N* @file     lcd.h
N* @version  V1.00
N* @brief    N9H30 LCD driver header file
N*
N* @copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef _LCD_H_
N#define _LCD_H_
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup N9H30_Device_Driver N9H30 Device Driver
N  @{
N*/
N
N/** @addtogroup N9H30_LCD_Driver LCD Driver
N  @{
N*/
N
N/** @addtogroup N9H30_LCD_EXPORTED_CONSTANTS LCD Exported Constants
N  @{
N*/
N/// @cond HIDDEN_SYMBOLS
N
N/* bit definition of REG_LCM_DCCS register */
N#define VPOSTB_HC_EN        ((UINT32)1<<31)
N#define VPOSTB_DISP_ON              (1<<25)
N#define VPOSTB_ITUEN                (1<<15)
N#define VPOSTB_OSD_SRC_YUV422       (0<<12)
N#define VPOSTB_OSD_SRC_YCBCR422     (1<<12)
N#define VPOSTB_OSD_SRC_RGB888       (2<<12)
N#define VPOSTB_OSD_SRC_RGB666       (3<<12)
N#define VPOSTB_OSD_SRC_RGB565       (4<<12)
N#define VPOSTB_OSD_SRC_RGB444_LOW   (5<<12)
N#define VPOSTB_OSD_SRC_RGB444_HIGH  (7<<12)
N#define VPOSTB_VA_SRC_YUV422        (0<<8 )
N#define VPOSTB_VA_SRC_YCBCR422      (1<<8 )
N#define VPOSTB_VA_SRC_RGB888        (2<<8 )
N#define VPOSTB_VA_SRC_RGB666        (3<<8 )
N#define VPOSTB_VA_SRC_RGB565        (4<<8 )
N#define VPOSTB_VA_SRC_RGB444_LOW    (5<<8 )
N#define VPOSTB_VA_SRC_RGB444_HIGH   (7<<8 )
N#define VPOSTB_SINGLE               (1<<7 )
N#define VPOSTB_FIELD_INTR           (1<<6 )
N#define VPOSTB_CMD_ON               (1<<5 )
N#define VPOSTB_DISP_INT_EN          (1<<4 )
N#define VPOSTB_DISP_OUT_EN          (1<<3 )
N#define VPOSTB_OSD_EN               (1<<2 )
N#define VPOSTB_VA_EN                (1<<1 )
N#define VPOSTB_ENG_RST              (1)
N
N
N/* bit definition of REG_LCM_DEV_CTRL register */
N#define VPOSTB_CMDHIGH  (0)
N#define VPOSTB_CMDLOW   ((UINT32)1<<31)
N#define VPOSTB_CM16t18LOW   (0)
N#define VPOSTB_CM16t18HIGH  ((UINT32)1<<30)
N#define VPOSTB_CMD8    (0)
N#define VPOSTB_CMD16    ((UINT32)1<<29)
N#define VPOSTB_IM256K_9or18 (0)
N#define VPOSTB_IM256K_8or16 ((UINT32)1<<28)
N#define VPOSTB_MPU80    (0)
N#define VPOSTB_MPU68    (1<<27)
N#define VPOSTB_DATA8or9   (0)
N#define VPOSTB_DATA16or18   (1<<26)
N#define VPOSTB_COLORTYPE_4K         (0)
N#define VPOSTB_COLORTYPE_64K        (1<<24)
N#define VPOSTB_COLORTYPE_256K       (2<<24)
N#define VPOSTB_COLORTYPE_16M        (3<<24)
N#define VPOSTB_LACE     (1<<23)
N#define VPOSTB_VR_LACE  (1<<22)
N#define VPOSTB_V_POL    (1<<21)
N#define VPOSTB_H_POL    (1<<20)
N#define VPOSTB_FAL_D    (1<<19)
N#define VPOSTB_YUV2CCIR (1<<16)
N#define VPOSTB_DEVICE_SYNC_YUV422       (0)
N#define VPOSTB_DEVICE_SYNC_UNIPAC       (4<<5)
N#define VPOSTB_DEVICE_SYNC_EPSON        (5<<5)
N#define VPOSTB_DEVICE_SYNC_HIGHCOLOR    (6<<5)
N#define VPOSTB_DEVICE_MPU               (7<<5)
N#define VPOSTB_SWAP_YUYV    (1<<1)
N
N/* bit definition of REG_LCM_INT_CS register */
N#define VPOSTB_DISP_F_INT           (1<<31)
N#define VPOSTB_DISP_F_STATUS        (1<<30)
N#define VPOSTB_UNDERRUN_INT         (1<<29)
N#define VPOSTB_BUS_ERROR_INT        (1<<28)
N#define VPOSTB_FLY_ERR              (1<<27)
N#define VPOSTB_UNDERRUN_EN          (1<<1)
N#define VPOSTB_DISP_F_EN            (1)
N
N/* bit definition of REG_LCM_VA_FBCTRL register */
N#define VPOSTB_DB_EN    ((UINT32)1<<31)
N#define VPOSTB_FLY_EN   (1<<12)
N
N/* bit definition of REG_LCM_OSD_OVERLAY register */
N#define VPOSTB_BLI_ON   (1<<9)
N#define VPOSTB_CKEY_ON  (1<<8)
N
N#define DISPLAY_VIDEO           (0)
N#define DISPLAY_OSD             (1)
N#define DISPLAY_SYNTHESIZED     (2)
N
N/// @endcond HIDDEN_SYMBOLS
N
N#define VA_SRC_YUV422       (0<<8 )     /*!< YUV422 format */
N#define VA_SRC_YCBCR422     (1<<8 )     /*!< YCBCR422 format */
N#define VA_SRC_RGB888       (2<<8 )     /*!< RGB888 format */
N#define VA_SRC_RGB666       (3<<8 )     /*!< RGB666 format */
N#define VA_SRC_RGB565       (4<<8 )     /*!< RGB565 format */
N#define VA_SRC_RGB444_LOW   (5<<8 )     /*!< RGB444 low nibble format */
N#define VA_SRC_RGB444_HIGH  (7<<8 )     /*!< RGB444 high nibble format */
N
N#define OSD_SRC_YUV422      (0<<12)     /*!< YUV422 format */
N#define OSD_SRC_YCBCR422    (1<<12)     /*!< YCBCR422 format */
N#define OSD_SRC_RGB888      (2<<12)     /*!< RGB888 format */
N#define OSD_SRC_RGB666      (3<<12)     /*!< RGB666 format */
N#define OSD_SRC_RGB565      (4<<12)     /*!< RGB565 format */
N#define OSD_SRC_RGB444_LOW  (5<<12)     /*!< RGB444 low nibble format */
N#define OSD_SRC_RGB444_HIGH (7<<12)     /*!< RGB444 high nibble format */
N#define OSD_SRC_RGB332      (6<<12)     /*!< RGB332 format */
N
N#define VPOST_DISPLAY_SINGLE        1   /*!< Single display mode */
N#define VPOST_DISPLAY_CONTINUOUS    0   /*!< Continuous display mode */
N
N#define VPOSTB_OSD_VUP_1X           (0<<16)     /*!< OSD vertical scale up 1x */
N#define VPOSTB_OSD_VUP_2X           (1<<16)     /*!< OSD vertical scale up 2x */
N#define VPOSTB_OSD_VUP_4X           (2<<16)     /*!< OSD vertical scale up 4x */
N
N#define DISPLAY_VIDEO           (0)     /*!< Display video data */
N#define DISPLAY_OSD             (1)     /*!< Display OSD data */
N#define DISPLAY_SYNTHESIZED     (2)     /*!< Display synthesized data */
N
N#define VA_SCALE_INTERPOLATION  (0)     /*!< Scale mode is interpolation */
N#define VA_SCALE_DUPLICATION    (1<<15) /*!< Scale mode is duplication */
N
Ntypedef enum va_hcmode_e
N{
N    HC_MODE0,           /*!< 32X32X2bpp 4 color */
N    HC_MODE1,           /*!< 32X32X2bpp 3 color and 1 transparent */
N    HC_MODE2,           /*!< 64X64X2bpp 4 color */
N    HC_MODE3,           /*!< 64X64X2bpp 3 color and 1 transparent */
N    HC_MODE4,           /*!< 128X128X1bpp 2 color */
N    HC_MODE5            /*!< 128X128X1bpp 1 color and 1 transparent */
N} VA_HCMODE_E;
N
Ntypedef struct
N{
N    uint32_t ucVASrcFormat;         /*!< User input Display source format */
N    uint32_t nScreenWidth;          /*!< Driver output,LCD width */
N    uint32_t nScreenHeight;         /*!< Driver output,LCD height */
N    uint32_t nFrameBufferSize;      /*!< Driver output,Frame buffer size(malloc by driver) */
N    uint8_t ucROT90;                /*!< Rotate 90 degree or not */
N} LCDFORMATEX;
N
Ntypedef struct
N{
N    uint32_t ucOSDSrcFormat;         /*!< User input, OSD source format */
N    uint32_t nXstart;                /*!< User input, OSD X axis position */
N    uint32_t nYstart;                /*!< User input, OSD Y axis position */
N    uint32_t nOSDWidth;              /*!< User input, OSD width */
N    uint32_t nOSDHeight;             /*!< User input, OSD height */
N    uint32_t nImageWidth;            /*!< User input, The width of OSD source image width */
N    uint32_t* pFrameBuffer;          /*!< User input, The address of OSD source image */
N} OSDFORMATEX;
N
N#define DIS_PANEL_E50A2V1       0
N#define DIS_PANEL_ILI9341_MPU80 1
N#define DIS_LSA40AT9001         2
N#define DIS_PANEL_FW070TFT      3
Ntypedef struct
N{
N    uint32_t u32DevWidth;           /*!< Panel width */
N    uint32_t u32DevHeight;          /*!< Panel height */
N    uint32_t u32CmdLow;             /*!< MPU command line low indicator */
N    uint32_t u32Cmd16t18;           /*!< MPU command width */
N    uint32_t u32CmdBusWidth;        /*!< MPU bus width */
N    uint32_t u32DataBusWidth;       /*!< Display bus width */
N    uint32_t u32MPU_Mode;           /*!< MPU mode */
N    uint32_t u32DisplayColors;      /*!< Display colors */
N    uint32_t u32DevType;            /*!< Type of display panel */
N    uint32_t u32Reg_CRTCSIZE;       /*!< CRTCSIZE register value */
N    uint32_t u32Reg_CRTCDEND;       /*!< CRTCDEND register value */
N    uint32_t u32Reg_CRTCHR;         /*!< CRTCHR register value */
N    uint32_t u32Reg_CRTCHSYNC;      /*!< CRTCHSYNC register value */
N    uint32_t u32Reg_CRTCVR;         /*!< CRTCVR register value */
N} VPOST_T;
N
N#define LCM_ERR_ID      0xFFFF0400  /*!< LCM library ID */
N
N/* error code */
N#define ERR_NULL_BUF            (LCM_ERR_ID | 0x04)  /*!< error memory location */
N#define ERR_NO_DEVICE           (LCM_ERR_ID | 0x05)  /*!< error no device */
N#define ERR_BAD_PARAMETER       (LCM_ERR_ID | 0x06)  /*!< error for bad parameter */
N#define ERR_POWER_STATE         (LCM_ERR_ID | 0x07)  /*!< error power state control */
N/*@}*/ /* end of group N9H30_LCD_EXPORTED_CONSTANTS */
N
N/** @addtogroup N9H30_LCD_EXPORTED_FUNCTIONS LCD Exported Functions
N  @{
N*/
N
Nvoid vpostLCMInit(uint32_t u32DisplayPanelID);
Nuint8_t* vpostGetFrameBuffer(void);
Nuint8_t* vpostGetMultiFrameBuffer(uint32_t u32Cnt);
Nvoid vpostLCMDeinit(void);
Nvoid vpostSetDisplayMode(uint8_t u8DisplayMode);
Nvoid vpostSetVASrc(uint32_t u32VASrcType);
Nvoid vpostVAStartTrigger(void);
Nvoid vpostVAStopTrigger(void);
Nvoid vpostVAScalingCtrl(uint8_t u8HIntegral, uint16_t u16HDecimal, uint8_t u8VIntegral, uint16_t u16VDecimal, uint32_t u32Mode);
N
Nvoid vpostOSDSetColKey(uint8_t u8CKeyColorR, uint8_t u8CKeyColorG, uint8_t u8CKeyColorB);
Nvoid vpostOSDSetColMask(uint8_t u8MaskColorR, uint8_t u8MaskColorG, uint8_t u8MaskColorB);
Nvoid vpostOSDSetBlinking(uint8_t u8OSDBlinkVcnt);
Nvoid vpostOSDDisableBlinking(void);
Nvoid vpostSetOSDSrc(uint32_t u32OSDSrcType);
Nuint8_t* vpostGetOSDBuffer(void);
Nvoid vpostOSDEnable(void);
Nvoid vpostOSDScalingCtrl(uint8_t u8HIntegral, uint16_t u16HDecimal,uint8_t u8VScall);
Nvoid vpostOSDSetWindow(uint32_t u32XStart,uint32_t u32YStart,uint32_t u32Width,uint32_t u32Height);
Nvoid vpostHCInit(uint32_t *u32CursorBMPBuff, VA_HCMODE_E ucMode);
Nvoid vpostHCPosCtrl(uint32_t u32CursorX, uint32_t u32CursorY);
Nvoid vpostOSDSetOverlay(uint8_t u8OSDDisplayMatch, uint8_t u8OSDDisplayUnMatch, uint8_t u8OSDSynW);
Nvoid vpostMPUWriteAddr(uint16_t uscmd);
Nvoid vpostMPUWriteData(uint16_t usdata);
Nuint32_t vpostMPUReadData(void);
N
N/*@}*/ /* end of group N9H30_LCD_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group N9H30_LCD_Driver */
N
N/*@}*/ /* end of group N9H30_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__LCD_H__
N
N
L 25 "..\main.c" 2
N
N#include "TouchPanel.h"
L 1 "..\tslib\TouchPanel.h" 1
N#ifndef __TOUCHPANEL_H__
N#define __TOUCHPANEL_H__
N
N#define __DEMO_TS_WIDTH__       800
N#define __DEMO_TS_HEIGHT__      480
N
Nint Init_TouchPanel(void);
Nint Read_TouchPanel(int *x, int *y);
Nint Uninit_TouchPanel(void);
Nint Check_TouchPanel(void);
N#endif
L 27 "..\main.c" 2
N#include "gui.h"
L 1 "..\..\..\ThirdParty\emWin\Include\gui.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI.h
NPurpose     : GUI API include file
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef  GUI_H
N#define  GUI_H
N
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199409L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 48 "..\..\..\ThirdParty\emWin\Include\gui.h" 2
N
N#include "GUI_ConfDefaults.h"
L 1 "..\..\..\ThirdParty\emWin\Include\GUI_ConfDefaults.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_ConfDefaults.h
NPurpose     : Defaults for GUI config switches.
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUI_CONFDEFAULTS_H
N#define  GUI_CONFDEFAULTS_H
N
N#include "GUIConf.h"
L 1 "..\..\..\ThirdParty\emWin\Config\GUIConf.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUIConf.h
NPurpose     : Configures emWins abilities, fonts etc.
N----------------------------------------------------------------------
N*/
N
N#ifndef GUICONF_H
N#define GUICONF_H
N
N/*********************************************************************
N*
N*       Multi layer/display support
N*/
N#define GUI_NUM_LAYERS            1    // Maximum number of available layers
N
N/*********************************************************************
N*
N*       Multi tasking support
N*/
N#define GUI_OS                    (1)  // Compile with multitasking support
N
N/*********************************************************************
N*
N*       Configuration of touch support
N*/
N#define GUI_SUPPORT_TOUCH         (1)  // Support a touch screen (req. win-manager)
N
N/*********************************************************************
N*
N*       Default font
N*/
N#define GUI_DEFAULT_FONT          &GUI_Font6x8
N
N/*********************************************************************
N*
N*         Configuration of available packages
N*/
N#define GUI_SUPPORT_MOUSE    1    // Mouse support
N#define GUI_WINSUPPORT       1    // Use Window Manager
N#define GUI_SUPPORT_MEMDEV   1    // Use Memory Devices
N#define GUI_SUPPORT_DEVICES  1    // Enable use of device pointers
N
N#endif  // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 52 "..\..\..\ThirdParty\emWin\Include\GUI_ConfDefaults.h" 2
N
N#ifndef   GUI_USE_MIXCOLORS
N  #define GUI_USE_MIXCOLORS 1
N#endif
N
N#ifndef   GUI_USE_BIDI2
N  #define GUI_USE_BIDI2 1
N#endif
N
N#ifndef   LCD_MAX_LOG_COLORS
N  #define LCD_MAX_LOG_COLORS 256
N#else
S  #if (LCD_MAX_LOG_COLORS > 256)
S    #error The value of LCD_MAX_LOG_COLORS must be <= 256!
S  #endif
N#endif
N
N#define LCD_PIXELINDEX U32
N
N#ifndef LCD_YMAG
N  #define LCD_YMAG 1
N#endif
N#ifndef LCD_XMAG
N  #define LCD_XMAG 1
N#endif
N
N/**********************************************************************
N*
N*       Defaults for config switches
N*
N***********************************************************************
N*/
N
N/* ATTENTION: This define swaps the meaning of a logical color from
N   ABGR to ARGB.
N   
N   It further swaps the meaning of a transparent pixel:
N   ABGR: 0x00 means opaque, 0xFF means transparent
N   ARGB: 0x00 means transparent, 0xFF means opaque (default)
N*/
N#ifndef GUI_USE_ARGB
N  #define GUI_USE_ARGB 1
N#endif
N
N/* Define "universal pointer". Normally, this is not needed (define will expand to nothing)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __generic),
N   since a default pointer can access RAM only, not the built-in Flash
N*/
N#ifndef GUI_UNI_PTR
N  #define GUI_UNI_PTR /* Remains only for compatibility purpose, no longer used in emWin */
N#endif
N
N/* Define const storage. Normally, this is not needed (define will expand to const)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __flash const),
N   since otherwise constants are copied into RAM
N*/
N#ifndef GUI_CONST_STORAGE
N  #define GUI_CONST_STORAGE const
N#endif
N
N#ifndef GUI_USE_MEMDEV_1BPP_FOR_SCREEN
N  #define GUI_USE_MEMDEV_1BPP_FOR_SCREEN 1
N#endif
N
N#ifndef GUI_BIDI_MAX_CHARS_PER_LINE
N  #if GUI_USE_BIDI2
X  #if 1
N    #define GUI_BIDI_MAX_CHARS_PER_LINE 200
N  #else
S    #define GUI_BIDI_MAX_CHARS_PER_LINE  80
N  #endif
N#endif
N
N#ifndef GUI_SUPPORT_TOUCH
S  #define GUI_SUPPORT_TOUCH   0
N#endif
N
N#ifndef GUI_SUPPORT_MOUSE
S  #define GUI_SUPPORT_MOUSE   0
N#endif
N
N#ifndef GUI_SUPPORT_MEMDEV
S  #define GUI_SUPPORT_MEMDEV  0
N#endif
N
N#ifndef GUI_OS
S  #define GUI_OS              0
N#endif
N
N#ifndef GUI_NUM_LAYERS
S  #define GUI_NUM_LAYERS      4
N#endif
N
N#ifndef GUI_SUPPORT_CURSOR
N  #define GUI_SUPPORT_CURSOR  (GUI_SUPPORT_MOUSE | GUI_SUPPORT_TOUCH)
N#endif
N
N#ifndef   GUI_CURSOR_LAYER
N  #define GUI_CURSOR_LAYER 0
N#endif
N
N#ifndef GUI_SUPPORT_ROTATION
N  #define GUI_SUPPORT_ROTATION 1
N#endif
N
N/* In order to avoid warnings for undefined parameters */
N#ifndef GUI_USE_PARA
N  #if defined (__BORLANDC__) || defined(NC30) || defined(NC308)
X  #if 0L || 0L || 0L
S    #define GUI_USE_PARA(para)
N  #else
N    #define GUI_USE_PARA(para) (void)para
N  #endif
N#endif
N
N/* Default for types */
N#ifndef GUI_TIMER_TIME
N  #define GUI_TIMER_TIME int  /* default is to use 16 bits for 16 bit CPUs,
N	                           32 bits on 32 bit CPUs for timing */
N#endif
N
N/* Types used for memory allocation */
N#define GUI_ALLOC_DATATYPE   I32
N#define GUI_ALLOC_DATATYPE_U U32
N
N#ifndef   GUI_MAX_XBF_BYTES
N  #define GUI_MAX_XBF_BYTES 200
N#endif
N
N#ifndef   GUI_MEMSET
N  #define GUI_MEMSET memset
N#endif
N
N#ifndef GUI_MEMCPY
N  #define GUI_MEMCPY memcpy
N#endif
N
N/* Optional custom drawing of memory devices */
N#ifndef   GUI_MEMDEV_SUPPORT_CUSTOMDRAW
N  #define GUI_MEMDEV_SUPPORT_CUSTOMDRAW 0
N#endif
N
N/* Clip static memory devices to parent borders */
N#ifndef   GUI_MEMDEV_CLIP_AT_PARENT
N  #define GUI_MEMDEV_CLIP_AT_PARENT 0
N#endif
N
N#endif   /* ifdef GUI_CONFDEFAULTS_H */
N
N/*************************** End of file ****************************/
L 50 "..\..\..\ThirdParty\emWin\Include\gui.h" 2
N#include "GUI_Type.h"
L 1 "..\..\..\ThirdParty\emWin\Include\GUI_Type.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_Type.h
NPurpose     : Include file define the types used for GUI
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUITYPE_H_INCLUDED
N#define  GUITYPE_H_INCLUDED
N
N#include "LCD.h"
L 1 "..\..\..\ThirdParty\emWin\Include\LCD.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : LCD.h
NPurpose     : Declares LCD interface functions
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_H
N#define LCD_H
N
N#include "GUI_ConfDefaults.h" /* Used for GUI_CONST_STORAGE */
N#include "Global.h"
L 1 "..\..\..\ThirdParty\emWin\Include\Global.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile    : Global.h
NPurpose : Global types
N          In case your application already has a Global.h, you should
N          merge the files. In order to use Segger code, the types
N          U8, U16, U32, I8, I16, I32 need to be defined in Global.h;
N          additional definitions do not hurt.
NRevision: $Rev: 9374 $
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef GLOBAL_H            // Guard against multiple inclusion
N#define GLOBAL_H
N
N#define U8    unsigned char
N#define I8    signed char
N#define U16   unsigned short
N#define I16   signed short
N#ifdef __x86_64__
S#define U32   unsigned
S#define I32   int
N#else
N#define U32   unsigned long
N#define I32   signed long
N#endif
N
N#if defined(_WIN32) && !defined(__clang__) && !defined(__MINGW32__)
X#if 0L && !0L && !0L
S  //
S  // Microsoft VC6 compiler related
S  //
S  #define U64   unsigned __int64
S  #define U128  unsigned __int128
S  #define I64   __int64
S  #define I128  __int128
S  #if _MSC_VER <= 1200
S    #define U64_C(x) x##UI64
S  #else
S    #define U64_C(x) x##ULL
S  #endif
N#else
N  //
N  // C99 compliant compiler
N  //
N  #define U64   unsigned long long
N  #define I64   signed long long
N  #define U64_C(x) x##ULL
N#endif
N
N#ifndef PTR_ADDR
N  #if (defined(_WIN64) || defined(__LP64__))  // 64-bit symbols used by Visual Studio and GCC, maybe others as well.
X  #if (0L || 0L)  
S    #define PTR_ADDR  U64
N  #else
N    #define PTR_ADDR  U32
N  #endif
N#endif
N
N#endif                      // Avoid multiple inclusion
N
N/*************************** End of file ****************************/
L 49 "..\..\..\ThirdParty\emWin\Include\LCD.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Basic type defines
N*
N* The follwing are defines for types used in the LCD-driver and the
N* GUI layers on top of that. Since "C" does not provide data types of
N* fixed length which are identical on all platforms, this is done here.
N* For most 16/32 controllers, the settings will work fine. However, if
N* you have similar defines in other sections of your program, you might
N* want to change or relocate these defines, e.g. in a TYPE.h file.
N*/
N#define I16P I16              /*   signed 16 bits OR MORE ! */
N#define U16P U16              /* unsigned 16 bits OR MORE ! */
N
N/*********************************************************************
N*
N*       Settings for windows simulation
N*
N* Some settings in the configuration may conflict with the values required
N* in the Simulation. This is why we ignore the target settings for data
N* types and use the correct settings for the simulation.
N* (U32 could be defined as long, which would yield a 64 bit type on
N* the PC)
N*/
N#ifdef WIN32
S  #pragma warning( disable : 4244 )  // Disable warning messages in simulation
S  #pragma warning( disable : 4761 )  // Disable warning "integral size mismatch in argument; conversion supplied"
N#endif
N
N/*********************************************************************
N*
N*       Constants
N*/
N#define LCD_ERR0 (0x10)
N#define LCD_ERR_CONTROLLER_NOT_FOUND (LCD_ERR0+1)
N#define LCD_ERR_MEMORY               (LCD_ERR0+2)
N
N/*********************************************************************
N*
N*       Drawing modes
N*/
N#define LCD_DRAWMODE_NORMAL (0)
N#define LCD_DRAWMODE_XOR    (1<<0)
N#define LCD_DRAWMODE_TRANS  (1<<1)
N#define LCD_DRAWMODE_REV    (1<<2)
N
N/*********************************************************************
N*
N*       Typedefs
N*/
Ntypedef int LCD_DRAWMODE;
Ntypedef U32 LCD_COLOR;
Xtypedef unsigned long LCD_COLOR;
N
N/*********************************************************************
N*
N*       Data structures
N*/
Ntypedef struct { I16P x,y; } GUI_POINT;
Xtypedef struct { signed short x,y; } GUI_POINT;
Ntypedef struct { I16 x0,y0,x1,y1; } LCD_RECT;
Xtypedef struct { signed short x0,y0,x1,y1; } LCD_RECT;
N
Ntypedef struct {
N  int              NumEntries;
N  char             HasTrans;
N  const LCD_COLOR * pPalEntries;
N} LCD_LOGPALETTE;
N
N/* This is used for the simulation only ! */
Ntypedef struct {
N  int x,y;
N  unsigned char KeyStat;
N} LCD_tMouseState;
N
Ntypedef struct {
N  int               NumEntries;
N  const LCD_COLOR * pPalEntries;
N} LCD_PHYSPALETTE;
N
N/*********************************************************************
N*
N*       LCD_L0_... color conversion
N*/
Ntypedef LCD_COLOR      tLCDDEV_Index2Color  (LCD_PIXELINDEX Index);
Xtypedef LCD_COLOR      tLCDDEV_Index2Color  (unsigned long Index);
Ntypedef LCD_PIXELINDEX tLCDDEV_Color2Index  (LCD_COLOR Color);
Xtypedef unsigned long tLCDDEV_Color2Index  (LCD_COLOR Color);
Ntypedef LCD_PIXELINDEX tLCDDEV_GetIndexMask (void);
Xtypedef unsigned long tLCDDEV_GetIndexMask (void);
N
Ntypedef void tLCDDEV_Index2ColorBulk(void * pIndex, LCD_COLOR * pColor, U32 NumItems, U8 SizeOfIndex);
Xtypedef void tLCDDEV_Index2ColorBulk(void * pIndex, LCD_COLOR * pColor, unsigned long NumItems, unsigned char SizeOfIndex);
Ntypedef void tLCDDEV_Color2IndexBulk(LCD_COLOR * pColor, void * pIndex, U32 NumItems, U8 SizeOfIndex);
Xtypedef void tLCDDEV_Color2IndexBulk(LCD_COLOR * pColor, void * pIndex, unsigned long NumItems, unsigned char SizeOfIndex);
N
N/*********************************************************************
N*
N*       Color conversion API tables
N*/
Ntypedef struct {
N  tLCDDEV_Color2Index  * pfColor2Index;
N  tLCDDEV_Index2Color  * pfIndex2Color;
N  tLCDDEV_GetIndexMask * pfGetIndexMask;
N  int NoAlpha;
N  tLCDDEV_Color2IndexBulk * pfColor2IndexBulk;
N  tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk;
N} LCD_API_COLOR_CONV;
N
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_0;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_2;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_4;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_5;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_8;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1_24;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_2;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_4;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_5;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_6;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1616I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_111;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_222;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_233;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_323;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_332;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_12;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_12_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_444_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_555;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_556;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_655;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_666_9;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_822216;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_84444;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8666_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_88666I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M111;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M1555I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M222;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M233;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M323;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M332;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M4444I;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_12;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_12_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M444_16;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M555;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M556;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M655;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M666;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M666_9;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8565;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8888;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_M8888I;
N
N#define GUICC_0         &LCD_API_ColorConv_0
N#define GUICC_1         &LCD_API_ColorConv_1
N#define GUICC_1_2       &LCD_API_ColorConv_1_2
N#define GUICC_1_4       &LCD_API_ColorConv_1_4
N#define GUICC_1_5       &LCD_API_ColorConv_1_5
N#define GUICC_1_8       &LCD_API_ColorConv_1_8
N#define GUICC_1_16      &LCD_API_ColorConv_1_16
N#define GUICC_1_24      &LCD_API_ColorConv_1_24
N#define GUICC_2         &LCD_API_ColorConv_2
N#define GUICC_4         &LCD_API_ColorConv_4
N#define GUICC_5         &LCD_API_ColorConv_5
N#define GUICC_6         &LCD_API_ColorConv_6
N#define GUICC_8         &LCD_API_ColorConv_8
N#define GUICC_16        &LCD_API_ColorConv_16
N#define GUICC_1616I     &LCD_API_ColorConv_1616I
N#define GUICC_111       &LCD_API_ColorConv_111
N#define GUICC_222       &LCD_API_ColorConv_222
N#define GUICC_233       &LCD_API_ColorConv_233
N#define GUICC_323       &LCD_API_ColorConv_323
N#define GUICC_332       &LCD_API_ColorConv_332
N#define GUICC_M4444I    &LCD_API_ColorConv_M4444I
N#define GUICC_444_12    &LCD_API_ColorConv_444_12
N#define GUICC_444_12_1  &LCD_API_ColorConv_444_12_1
N#define GUICC_444_16    &LCD_API_ColorConv_444_16
N#define GUICC_555       &LCD_API_ColorConv_555
N#define GUICC_565       &LCD_API_ColorConv_565
N#define GUICC_556       &LCD_API_ColorConv_556
N#define GUICC_655       &LCD_API_ColorConv_655
N#define GUICC_666       &LCD_API_ColorConv_666
N#define GUICC_666_9     &LCD_API_ColorConv_666_9
N#define GUICC_822216    &LCD_API_ColorConv_822216
N#define GUICC_84444     &LCD_API_ColorConv_84444
N#define GUICC_8666      &LCD_API_ColorConv_8666
N#define GUICC_8666_1    &LCD_API_ColorConv_8666_1
N#define GUICC_88666I    &LCD_API_ColorConv_88666I
N#define GUICC_888       &LCD_API_ColorConv_888
N#define GUICC_8888      &LCD_API_ColorConv_8888
N#define GUICC_M111      &LCD_API_ColorConv_M111
N#define GUICC_M1555I    &LCD_API_ColorConv_M1555I
N#define GUICC_M222      &LCD_API_ColorConv_M222
N#define GUICC_M233      &LCD_API_ColorConv_M233
N#define GUICC_M323      &LCD_API_ColorConv_M323
N#define GUICC_M332      &LCD_API_ColorConv_M332
N#define GUICC_M444_12   &LCD_API_ColorConv_M444_12
N#define GUICC_M444_12_1 &LCD_API_ColorConv_M444_12_1
N#define GUICC_M444_16   &LCD_API_ColorConv_M444_16
N#define GUICC_M555      &LCD_API_ColorConv_M555
N#define GUICC_M565      &LCD_API_ColorConv_M565
N#define GUICC_M556      &LCD_API_ColorConv_M556
N#define GUICC_M655      &LCD_API_ColorConv_M655
N#define GUICC_M666      &LCD_API_ColorConv_M666
N#define GUICC_M666_9    &LCD_API_ColorConv_M666_9
N#define GUICC_M8565     &LCD_API_ColorConv_M8565
N#define GUICC_M888      &LCD_API_ColorConv_M888
N#define GUICC_M8888     &LCD_API_ColorConv_M8888
N#define GUICC_M8888I    &LCD_API_ColorConv_M8888I
N
Nvoid GUICC_M1555I_SetCustColorConv(tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M565_SetCustColorConv  (tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M4444I_SetCustColorConv(tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M888_SetCustColorConv  (tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
Nvoid GUICC_M8888I_SetCustColorConv(tLCDDEV_Color2IndexBulk * pfColor2IndexBulk, tLCDDEV_Index2ColorBulk * pfIndex2ColorBulk);
N
N/*********************************************************************
N*
N*       Compatibility defines for older versions
N*/
N#define GUI_COLOR_CONV_1    GUICC_1
N#define GUI_COLOR_CONV_2    GUICC_2
N#define GUI_COLOR_CONV_4    GUICC_4
N#define GUI_COLOR_CONV_8666 GUICC_8666
N#define GUI_COLOR_CONV_888  GUICC_888
N#define GUI_COLOR_CONV_8888 GUICC_8888
N#define GUI_COLOR_CONV_565  GUICC_565
N#define GUI_COLOR_CONV_M565 GUICC_M565
N
N/*********************************************************************
N*
N*       LCDDEV function table
N*
N*  Below the routines which need to in an LCDDEV routine table are
N*  defined. All of these routines have to be in the low-level driver
N*  (LCD_L0) or in the memory device which can be used to replace the
N*  driver.
N*  The one exception to this is the SetClipRect routine, which would
N*  be identical for all drivers and is therefor contained in the
N*  level above (LCD).
N*/
Ntypedef void         tLCDDEV_DrawPixel    (int x, int y);
Ntypedef void         tLCDDEV_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void         tLCDDEV_DrawVLine    (int x , int y0,  int y1);
Ntypedef void         tLCDDEV_FillRect     (int x0, int y0, int x1, int y1);
Ntypedef unsigned int tLCDDEV_GetPixelIndex(int x, int y);
Ntypedef void         tLCDDEV_SetPixelIndex(int x, int y, int ColorIndex);
Ntypedef void         tLCDDEV_XorPixel     (int x, int y);
Ntypedef void         tLCDDEV_FillPolygon  (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_FillPolygonAA(const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_GetRect      (LCD_RECT * pRect);
Ntypedef int          tLCDDEV_Init         (void);
Ntypedef void         tLCDDEV_On           (void);
Ntypedef void         tLCDDEV_Off          (void);
Ntypedef void         tLCDDEV_SetLUTEntry  (U8 Pos, LCD_COLOR color);
Xtypedef void         tLCDDEV_SetLUTEntry  (unsigned char Pos, LCD_COLOR color);
Ntypedef void *       tLCDDEV_GetDevFunc   (int Index);
Ntypedef I32          tLCDDEV_GetDevProp   (int Index);
Xtypedef signed long          tLCDDEV_GetDevProp   (int Index);
Ntypedef void         tLCDDEV_SetOrg       (int x, int y);
N
N/*********************************************************************
N*
N*       Memory device API tables
N*/
Ntypedef struct GUI_DEVICE     GUI_DEVICE;
Ntypedef struct GUI_DEVICE_API GUI_DEVICE_API;
N
Ntypedef void tLCDDEV_DrawBitmap   (int x0, int y0, int xsize, int ysize,
N                       int BitsPerPixel, int BytesPerLine,
N                       const U8 * pData, int Diff,
X                       const unsigned char * pData, int Diff,
N                       const void * pTrans);   /* Really LCD_PIXELINDEX, but is void to avoid compiler warnings */
N#define GUI_MEMDEV_APILIST_1  &GUI_MEMDEV_DEVICE_1
N#define GUI_MEMDEV_APILIST_8  &GUI_MEMDEV_DEVICE_8
N#define GUI_MEMDEV_APILIST_16 &GUI_MEMDEV_DEVICE_16
N#define GUI_MEMDEV_APILIST_32 &GUI_MEMDEV_DEVICE_32
N
N/*********************************************************************
N*
N*       Defines for device capabilities
N*
N* The following is the list of device capabilities which can, but do
N* not have to be implemented in the driver. This way the driver can be
N* enhanced in the future without affecting the driver interface,
N* keeping older drivers compatible.
N* More DevCaps can always be added in the future, as older drivers
N* are guaranteed to return 0 for all unimplemented features or queries.
N*
N* The values below define the legal parameters to the LCD_GetDeviceCaps
N* and the LCD_GetpCapFunc routines.
N*/
N
N#define LCD_DEVCAP_XSIZE             0x01    /* Quest horiz. res. of display */
N#define LCD_DEVCAP_YSIZE             0x02    /* Quest vert. res. of display */
N#define LCD_DEVCAP_VXSIZE            0x03    /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_VYSIZE            0x04    /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_XORG              0x05    /* X-origin ... usually 0 */
N#define LCD_DEVCAP_YORG              0x06    /* Y-origin ... usually 0 */
N#define LCD_DEVCAP_CONTROLLER        0x07    /* LCD Controller (Numerical) */
N#define LCD_DEVCAP_BITSPERPIXEL      0x08    /* Bits per pixel ... 1/2/4/8 */
N#define LCD_DEVCAP_NUMCOLORS         0x09    /* Quest number of colors */
N#define LCD_DEVCAP_XMAG              0x0A
N#define LCD_DEVCAP_YMAG              0x0B
N#define LCD_DEVCAP_MIRROR_X          0x0C
N#define LCD_DEVCAP_MIRROR_Y          0x0D
N#define LCD_DEVCAP_SWAP_XY           0x0E
N#define LCD_DEVCAP_SWAP_RB           0x0F
N
Nint LCD_GetXSizeMax(void);
Nint LCD_GetYSizeMax(void);
Nint LCD_GetVXSizeMax(void);
Nint LCD_GetVYSizeMax(void);
Nint LCD_GetBitsPerPixelMax(void);
Nvoid LCD_SetDisplaySize(int xSizeDisplay, int ySizeDisplay);
Nint LCD_GetXSizeDisplay(void);
Nint LCD_GetYSizeDisplay(void);
N
Nint LCD_GetXSizeEx          (int LayerIndex);
Nint LCD_GetYSizeEx          (int LayerIndex);
Nint LCD_GetVXSizeEx         (int LayerIndex);
Nint LCD_GetVYSizeEx         (int LayerIndex);
Nint LCD_GetBitsPerPixelEx   (int LayerIndex);
NU32 LCD_GetNumColorsEx      (int LayerIndex);
Xunsigned long LCD_GetNumColorsEx      (int LayerIndex);
Nint LCD_GetXMagEx           (int LayerIndex);
Nint LCD_GetYMagEx           (int LayerIndex);
Nint LCD_GetMirrorXEx        (int LayerIndex);
Nint LCD_GetMirrorYEx        (int LayerIndex);
Nint LCD_GetSwapXYEx         (int LayerIndex);
Nint LCD_GetReversLUTEx      (int LayerIndex);
Nint LCD_GetPhysColorsInRAMEx(int LayerIndex);
N
Nint LCD_GetXSize            (void);
Nint LCD_GetYSize            (void);
Nint LCD_GetVXSize           (void);
Nint LCD_GetVYSize           (void);
Nint LCD_GetBitsPerPixel     (void);
NU32 LCD_GetNumColors        (void);
Xunsigned long LCD_GetNumColors        (void);
Nint LCD_GetXMag             (void);
Nint LCD_GetYMag             (void);
Nint LCD_GetMirrorX          (void);
Nint LCD_GetMirrorY          (void);
Nint LCD_GetSwapXY           (void);
Nint LCD_GetReversLUT        (void);
Nint LCD_GetPhysColorsInRAM  (void);
N
NI32 LCD__GetBPP      (U32 IndexMask);
Xsigned long LCD__GetBPP      (unsigned long IndexMask);
NI32 LCD__GetBPPDevice(U32 IndexMask);
Xsigned long LCD__GetBPPDevice(unsigned long IndexMask);
N
NtLCDDEV_Index2Color * LCD_GetpfIndex2ColorEx(int LayerIndex);
NtLCDDEV_Color2Index * LCD_GetpfColor2IndexEx(int LayerIndex);
N
NtLCDDEV_Color2Index * LCD_GetpfColor2Index(void);
N
Nint LCD_GetNumLayers(void);
N
NLCD_COLOR * LCD_GetPalette   (void);
NLCD_COLOR * LCD_GetPaletteEx (int LayerIndex);
Nvoid      * LCD_GetVRAMAddr  (void);
Nvoid      * LCD_GetVRAMAddrEx(int LayerIndex);
N
Nvoid (* LCD_GetDevFunc(int LayerIndex, int Item))(void);
N
N/*********************************************************************
N*
N*       Runtime rotation of drivers
N*/
Nint LCD_ROTATE_AddDriver  (const GUI_DEVICE_API * pDriver);
Nint LCD_ROTATE_AddDriverEx(const GUI_DEVICE_API * pDeviceAPI, int LayerIndex);
Nint LCD_ROTATE_DecSel     (void);
Nint LCD_ROTATE_DecSelEx   (int LayerIndex);
Nint LCD_ROTATE_IncSel     (void);
Nint LCD_ROTATE_IncSelEx   (int LayerIndex);
Nint LCD_ROTATE_SetCallback(void (* pCbOnConfig)(GUI_DEVICE *, int, int), int LayerIndex);
Nint LCD_ROTATE_SetSel     (int Index);
Nint LCD_ROTATE_SetSelEx   (int Index, int LayerIndex);
N
N/*********************************************************************
N*
N*       Values for requesting and setting function pointers (display driver)
N*/
N                                       /* Request of a function pointer for... */
N#define LCD_DEVFUNC_READRECT      0x01 /* ...reading a rectangular display area */
N#define LCD_DEVFUNC_SETALPHA      0x02 /* ...setting the alpha blending factor */
N#define LCD_DEVFUNC_SETPOS        0x03 /* ...setting the layer position */
N#define LCD_DEVFUNC_GETPOS        0x04 /* ...getting the layer position */
N#define LCD_DEVFUNC_SETSIZE       0x05 /* ...setting the layer size */
N#define LCD_DEVFUNC_SETVIS        0x06 /* ...setting the visibility of a layer */
N#define LCD_DEVFUNC_24BPP         0x07 /* ...drawing 24bpp bitmaps */
N#define LCD_DEVFUNC_NEXT_PIXEL    0x08 /* ...drawing a bitmap pixel by pixel */
N#define LCD_DEVFUNC_SET_VRAM_ADDR 0x09 /* ...setting the VRAM address */
N#define LCD_DEVFUNC_SET_VSIZE     0x0A /* ...setting the VRAM size */
N#define LCD_DEVFUNC_SET_SIZE      0x0B /* ...setting the display size */
N#define LCD_DEVFUNC_INIT          0x0C /* ...initializing the display controller */
N#define LCD_DEVFUNC_CONTROLCACHE  0x0D /* ...controlling the cache */
N#define LCD_DEVFUNC_ON            0x0E /* ...switching the display on */
N#define LCD_DEVFUNC_OFF           0x0F /* ...switching the display off */
N#define LCD_DEVFUNC_SETLUTENTRY   0x10 /* ...setting a LUT entry */
N#define LCD_DEVFUNC_FILLPOLY      0x11 /* ...filling a polygon */
N#define LCD_DEVFUNC_FILLPOLYAA    0x12 /* ...filling an antialiased polygon */
N#define LCD_DEVFUNC_ALPHAMODE     0x13 /* ...setting the alpha blending mode */
N#define LCD_DEVFUNC_CHROMAMODE    0x14 /* ...setting the chroma blending mode */
N#define LCD_DEVFUNC_CHROMA        0x15 /* ...setting the chroma values */
N#define LCD_DEVFUNC_SETFUNC       0x16 /* ...setting a function pointer */
N#define LCD_DEVFUNC_REFRESH       0x17 /* ...refreshing the display */
N#define LCD_DEVFUNC_SETRECT       0x18 /* ...setting the drawing rectangle */
N                                       /* Setting a function pointer for... */
N#define LCD_DEVFUNC_FILLRECT      0x19 /* ...filling a rectangular area */
N#define LCD_DEVFUNC_DRAWBMP_1BPP  0x20 /* ...drawing a 1bpp bitmap */
N#define LCD_DEVFUNC_COPYBUFFER    0x21 /* ...copying complete frame buffers */
N#define LCD_DEVFUNC_SHOWBUFFER    0x22 /* ...shows the given buffer */
N#define LCD_DEVFUNC_COPYRECT      0x23 /* ...filling a rectangular area */
N#define LCD_DEVFUNC_DRAWBMP_16BPP 0x24 /* ...drawing a 16bpp bitmap */
N#define LCD_DEVFUNC_DRAWBMP_8BPP  0x25 /* ...drawing a 8bpp bitmap */
N#define LCD_DEVFUNC_READPIXEL     0x26 /* ...reading a pixel index */
N#define LCD_DEVFUNC_READMPIXELS   0x27 /* ...reading multiple pixel indices */
N#define LCD_DEVFUNC_DRAWBMP_32BPP 0x28 /* ...drawing a 32bpp bitmap */
N#define LCD_DEVFUNC_SET_BUFFERPTR 0x29 /* ...setting an array of buffer pointers */
N#define LCD_DEVFUNC_EXIT          0x30 /* ...free memory and shut down controller */
N
N/*********************************************************************
N*
N*       Values for requesting function pointers (memory devices)
N*/
N                                          /* Request of a function pointer for... */
N#define MEMDEV_DEVFUNC_WRITETOACTIVE 0x16 /* ...writing the memory device */
N
N/*********************************************************************
N*
N*       Values for requesting data
N*/
N                                       /* Request pointer to... */
N#define LCD_DEVDATA_MEMDEV        0x01 /* ...default memory device API */
N#define LCD_DEVDATA_PHYSPAL       0x02 /* ...physical palette */
N#define LCD_DEVDATA_VRAMADDR      0x03 /* ...VRAM address */
N
N/*********************************************************************
N*
N*       Structures for passing data to LCD_X_DisplayDriver()
N*/
Ntypedef struct {
N  void * pVRAM;
N} LCD_X_SETVRAMADDR_INFO;
N
Ntypedef struct {
N  int xPos, yPos;
N} LCD_X_SETORG_INFO;
N
Ntypedef struct {
N  LCD_COLOR Color;
N  U8 Pos;
X  unsigned char Pos;
N} LCD_X_SETLUTENTRY_INFO;
N
Ntypedef struct {
N  int xSize, ySize;
N} LCD_X_SETSIZE_INFO;
N
Ntypedef struct {
N  int xPos, yPos;
N  int xLen, yLen;
N  int BytesPerPixel;
N  U32 Off;
X  unsigned long Off;
N} LCD_X_SETPOS_INFO;
N
Ntypedef struct {
N  int Alpha;
N} LCD_X_SETALPHA_INFO;
N
Ntypedef struct {
N  int OnOff;
N} LCD_X_SETVIS_INFO;
N
Ntypedef struct {
N  int AlphaMode;
N} LCD_X_SETALPHAMODE_INFO;
N
Ntypedef struct {
N  int ChromaMode;
N} LCD_X_SETCHROMAMODE_INFO;
N
Ntypedef struct {
N  LCD_COLOR ChromaMin;
N  LCD_COLOR ChromaMax;
N} LCD_X_SETCHROMA_INFO;
N
Ntypedef struct {
N  int Index;
N} LCD_X_SHOWBUFFER_INFO;
N
N/*********************************************************************
N*
N*       Commands for LCD_X_DisplayDriver()
N*/
N#define LCD_X_INITCONTROLLER 0x01 /* Initializing the display controller */
N#define LCD_X_SETVRAMADDR    0x02 /* Setting the video RAM address */
N#define LCD_X_SETORG         0x03 /* Setting the origin within a layer */
N#define LCD_X_SETLUTENTRY    0x04 /* Setting an entry of the LUT */
N#define LCD_X_ON             0x05 /* Switching the display on */
N#define LCD_X_OFF            0x06 /* Switching the display off */
N#define LCD_X_SETSIZE        0x07 /* Setting the layer size */
N#define LCD_X_SETPOS         0x08 /* Setting the layer position */
N#define LCD_X_SETVIS         0x09 /* Setting the visibility of a layer */
N#define LCD_X_SETALPHA       0x0A /* Setting the alpha value of the layer */
N#define LCD_X_SETALPHAMODE   0x0B /* Setting the alpha blending mode */
N#define LCD_X_SETCHROMAMODE  0x0C /* Setting the chroma blending mode */
N#define LCD_X_SETCHROMA      0x0D /* Setting the chroma values */
N#define LCD_X_SHOWBUFFER     0x0E /* Switching to the given buffer */
N
Nint  LCD_X_DisplayDriver(unsigned LayerIndex, unsigned Cmd, void * pData);
Nvoid LCD_X_Config(void);
N
N/*********************************************************************
N*
N*       Get/Set layer properties
N*/
Nint  LCD_GetPosEx       (int LayerIndex, int * pxPos, int * pyPos);
Nint  LCD_OffEx          (int LayerIndex);
Nint  LCD_OnEx           (int LayerIndex);
Nint  LCD_RefreshEx      (int LayerIndex);
Nint  LCD_SetAlphaEx     (int LayerIndex, int Alpha);
Nint  LCD_SetAlphaModeEx (int LayerIndex, int AlphaMode);
Nint  LCD_SetBufferPtrEx (int LayerIndex, void ** pBufferPTR);
Nint  LCD_SetChromaEx    (int LayerIndex, LCD_COLOR ChromaMin, LCD_COLOR ChromaMax);
Nint  LCD_SetChromaModeEx(int LayerIndex, int ChromaMode);
Nint  LCD_SetDevFunc     (int LayerIndex, int IdFunc, void (* pDriverFunc)(void));
Nint  LCD_SetLUTEntryEx  (int LayerIndex, U8 Pos, LCD_COLOR Color);
Xint  LCD_SetLUTEntryEx  (int LayerIndex, unsigned char Pos, LCD_COLOR Color);
Nint  LCD_SetPosEx       (int LayerIndex, int xPos, int yPos);
Nint  LCD_SetSizeEx      (int LayerIndex, int xSize, int ySize);
Nint  LCD_SetVisEx       (int LayerIndex, int OnOff);
Nint  LCD_SetVRAMAddrEx  (int LayerIndex, void * pVRAM);
Nint  LCD_SetVSizeEx     (int LayerIndex, int xSize, int ySize);
N
Nint  LCD_GetPos         (int * pxPos, int * pyPos);
Nint  LCD_Off            (void);
Nint  LCD_On             (void);
Nint  LCD_Refresh        (void);
Nint  LCD_SetAlpha       (int Alpha);
Nint  LCD_SetAlphaMode   (int AlphaMode);
Nint  LCD_SetBufferPtr   (void ** pBufferPTR);
Nint  LCD_SetChroma      (LCD_COLOR ChromaMin, LCD_COLOR ChromaMax);
Nint  LCD_SetChromaMode  (int ChromaMode);
Nint  LCD_SetLUTEntry    (U8 Pos, LCD_COLOR Color);
Xint  LCD_SetLUTEntry    (unsigned char Pos, LCD_COLOR Color);
Nvoid LCD_SetOrg         (int xOrg, int yOrg);
Nint  LCD_SetPos         (int xPos, int yPos);
Nint  LCD_SetSize        (int xSize, int ySize);
Nint  LCD_SetVis         (int OnOff);
Nint  LCD_SetVRAMAddr    (void * pVRAM);
Nint  LCD_SetVSize       (int xSize, int ySize);
N
N/*********************************************************************
N*
N*       NEXT_PIXEL API support
N*/
Ntypedef struct {
N  int  (* pfStart)   (int x0, int y0, int x1, int y1);
N  void (* pfSetPixel)(LCD_PIXELINDEX PixelIndex);
X  void (* pfSetPixel)(unsigned long PixelIndex);
N  void (* pfNextLine)(void);
N  void (* pfEnd)     (void);
N} LCD_API_NEXT_PIXEL;
N
NLCD_API_NEXT_PIXEL * LCD_GetNextPixelAPI(void);
N
N/*********************************************************************
N*
N*      LCD_CLIP function table
N*/
Ntypedef void tLCD_HL_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void tLCD_HL_DrawPixel    (int x0, int y0);
N
Ntypedef struct {
N  tLCD_HL_DrawHLine * pfDrawHLine;
N  tLCD_HL_DrawPixel * pfDrawPixel;
N} tLCD_HL_APIList;
N
Nvoid LCD_DrawHLine(int x0, int y0,  int x1);
Nvoid LCD_DrawPixel(int x0, int y0);
Nvoid LCD_DrawVLine(int x,  int y0,  int y1);
N
N
N/*********************************************************************
N*
N*       Declarations for LCD_
N*/
Nvoid LCD_SetClipRectEx(const LCD_RECT * pRect);
Nvoid LCD_SetClipRectMax(void);
N
N/* Get device capabilities (0 if not supported) */
NI32  LCD_GetDevCap  (int Index);
Xsigned long  LCD_GetDevCap  (int Index);
NI32  LCD_GetDevCapEx(int LayerIndex, int Index);
Xsigned long  LCD_GetDevCapEx(int LayerIndex, int Index);
N
N/* Initialize LCD using config-parameters */
Nint LCD_Init(void);
Nint LCD_InitColors(void);
Nint LCD_InitEx(GUI_DEVICE * pDevice, int ClearScreen);
Nint LCD_ExitEx(int LayerIndex);
N
Nvoid LCD_SetBkColor   (LCD_COLOR Color); /* Set background color */
Nvoid LCD_SetColor     (LCD_COLOR Color); /* Set foreground color */
Nvoid LCD_SetPixelIndex(int x, int y, int ColorIndex);
N
N/* Palette routines (Not available on all drivers) */
Nvoid LCD_InitLUT(void);
Nvoid LCD_SetLUTEx(int LayerIndex, const LCD_PHYSPALETTE * pPalette);
Nvoid LCD_SetLUT  (const LCD_PHYSPALETTE * pPalette);
N
NLCD_DRAWMODE LCD_SetDrawMode  (LCD_DRAWMODE dm);
Nvoid LCD_SetColorIndex(unsigned PixelIndex);
Nvoid LCD_SetBkColorIndex(unsigned PixelIndex);
Nvoid LCD_FillRect(int x0, int y0, int x1, int y1);
Ntypedef void tLCD_SetPixelAA(int x, int y, U8 Intens);
Xtypedef void tLCD_SetPixelAA(int x, int y, unsigned char Intens);
N
Nvoid LCD_SetPixelAA4_Trans  (int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA4_Trans  (int x, int y, unsigned char Intens);
Nvoid LCD_SetPixelAA4_NoTrans(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA4_NoTrans(int x, int y, unsigned char Intens);
N
Nvoid LCD_SetPixelAA8_Trans  (int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA8_Trans  (int x, int y, unsigned char Intens);
Nvoid LCD_SetPixelAA8_NoTrans(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA8_NoTrans(int x, int y, unsigned char Intens);
N
Nvoid LCD_AA_EnableGamma(int OnOff);
Nvoid LCD_AA_SetGamma   (U8 * pGamma);
Xvoid LCD_AA_SetGamma   (unsigned char * pGamma);
Nvoid LCD_AA_GetGamma   (U8 * pGamma);
Xvoid LCD_AA_GetGamma   (unsigned char * pGamma);
N
NLCD_COLOR    LCD_AA_MixColors16 (LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR    LCD_AA_MixColors16 (LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
NLCD_COLOR    LCD_AA_MixColors256(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR    LCD_AA_MixColors256(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
NLCD_COLOR    LCD_MixColors256   (LCD_COLOR Color, LCD_COLOR BkColor, unsigned Intens);
NLCD_COLOR    LCD_GetPixelColor(int x, int y);     /* Get RGB color of pixel */
Nunsigned int LCD_GetPixelIndex(int x, int y);
Nint          LCD_GetBkColorIndex (void);
Nint          LCD_GetColorIndex (void);
N#if (GUI_USE_ARGB)
X#if (1)
NU32          LCD_AA_SetOrMask(U32 OrMask);
Xunsigned long          LCD_AA_SetOrMask(unsigned long OrMask);
N#else
SU32          LCD_AA_SetAndMask(U32 AndMask);
N#endif
N
N/* Configuration */
Nint  LCD_SetMaxNumColors(unsigned MaxNumColors);
Nint  LCD_GetMaxNumColors(void);
Nvoid LCD__SetPaletteConversionHook(void (* pfPaletteConversionHook)(const LCD_LOGPALETTE * pLogPal));
N
N/*********************************************************************
N*
N*       Optional support for rotation
N*/
N#if GUI_SUPPORT_ROTATION
X#if 1
N
Ntypedef void tLCD_DrawBitmap(int x0, int y0, int xsize, int ysize,
N                             int xMul, int yMul, int BitsPerPixel, int BytesPerLine,
N                             const U8 * pPixel, const void * pTrans);
X                             const unsigned char * pPixel, const void * pTrans);
Ntypedef void tRect2TextRect (LCD_RECT * pRect);
N
Nstruct tLCD_APIList_struct {
N  tLCD_DrawBitmap   * pfDrawBitmap;
N  tRect2TextRect    * pfRect2TextRect;
N  tRect2TextRect    * pfTransformRect;
N};
N
Ntypedef struct tLCD_APIList_struct tLCD_APIList;
N
Nextern tLCD_APIList LCD_APIListCCW;
Nextern tLCD_APIList LCD_APIListCW;
Nextern tLCD_APIList LCD_APIList180;
N
N#define GUI_ROTATION   tLCD_APIList
N#define GUI_ROTATE_CCW &LCD_APIListCCW
N#define GUI_ROTATE_CW  &LCD_APIListCW
N#define GUI_ROTATE_180 &LCD_APIList180
N#define GUI_ROTATE_0   0
N
NtLCD_SetPixelAA * LCD__GetPfSetPixel(int BitsPerPixel);
N
N#endif
N
N/*********************************************************************
N*
N*       Physical color access, internally used only
N*/
Nvoid LCD__SetPhysColor(U8 Pos, LCD_COLOR Color);
Xvoid LCD__SetPhysColor(unsigned char Pos, LCD_COLOR Color);
N
N/*********************************************************************
N*
N*       Cache control
N*/
N#define LCD_CC_UNLOCK (0)    /* Default mode: Cache is transparent */
N#define LCD_CC_LOCK   (1)    /* Cache is locked, no write operations */
N#define LCD_CC_FLUSH  (2)    /* Flush cache, do not change mode */
N
Nint LCD_ControlCache  (int Cmd);
Nint LCD_ControlCacheEx(int LayerIndex, int Cmd);
N
N/*********************************************************************
N*
N*       Color conversion
N*/
NLCD_PIXELINDEX   LCD_Color2Index     (LCD_COLOR Color);
Xunsigned long   LCD_Color2Index     (LCD_COLOR Color);
NLCD_COLOR        LCD_Index2Color     (int Index);
NLCD_COLOR        LCD_Index2ColorEx   (int i, unsigned LayerIndex);
N
N/*********************************************************************
N*
N*       LCD_X_...
N*/
Nunsigned char LCD_X_Read00(void);
Nunsigned char LCD_X_Read01(void);
Nvoid LCD_X_Write00 (unsigned char c);
Nvoid LCD_X_Write01 (unsigned char c);
Nvoid LCD_X_WriteM01(unsigned char * pData, int NumBytes);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif /* LCD_H */
N
N/*************************** End of file ****************************/
L 52 "..\..\..\ThirdParty\emWin\Include\GUI_Type.h" 2
N#include "GUIConf.h"
N
N/*********************************************************************
N*
N*       Common types
N*/
Ntypedef const char *  GUI_ConstString;
N
Ntypedef LCD_COLOR       GUI_COLOR;
Ntypedef LCD_LOGPALETTE  GUI_LOGPALETTE;
Ntypedef LCD_DRAWMODE    GUI_DRAWMODE;
Ntypedef LCD_RECT        GUI_RECT;
N
Ntypedef struct {
N  void      (* pfDraw)  (int x0,
N                         int y0,
N                         int xsize, 
N                         int ysize, 
N                         const U8 * pPixel, 
X                         const unsigned char * pPixel, 
N                         const LCD_LOGPALETTE * pLogPal, 
N                         int xMag, 
N                         int yMag);
N  GUI_COLOR (* pfIndex2Color)(LCD_PIXELINDEX Index);
X  GUI_COLOR (* pfIndex2Color)(unsigned long Index);
N  void      (* pfDrawHW)(int x0,
N                         int y0,
N                         int xsize, 
N                         int ysize, 
N                         const U8 * pPixel, 
X                         const unsigned char * pPixel, 
N                         const LCD_LOGPALETTE * pLogPal, 
N                         int xMag, 
N                         int yMag);
N  const LCD_API_COLOR_CONV * pColorConvAPI;
N} GUI_BITMAP_METHODS;
N
Ntypedef struct {
N  U16P XSize;
X  unsigned short XSize;
N  U16P YSize;
X  unsigned short YSize;
N  U16P BytesPerLine;
X  unsigned short BytesPerLine;
N  U16P BitsPerPixel;
X  unsigned short BitsPerPixel;
N  const U8 * pData;
X  const unsigned char * pData;
N  const GUI_LOGPALETTE * pPal;
N  const GUI_BITMAP_METHODS * pMethods;
N} GUI_BITMAP;
N
N/* This structure may not be changed because the data that it
N   expects is read in binary form (via any kind of interface,
N   at runtime).
N   This structure should therefor not be changed.
N*/
Ntypedef struct {
N  U16 ID;
X  unsigned short ID;
N  U16 Format;
X  unsigned short Format;
N  U16 XSize;
X  unsigned short XSize;
N  U16 YSize;
X  unsigned short YSize;
N  U16 BytesPerLine;
X  unsigned short BytesPerLine;
N  U16 BitsPerPixel;
X  unsigned short BitsPerPixel;
N  U16 NumColors;
X  unsigned short NumColors;
N  U16 HasTrans;
X  unsigned short HasTrans;
N} GUI_BITMAP_STREAM;
N
Ntypedef struct {
N  int    Cmd;
N  U32    v;
X  unsigned long    v;
N  void * p;
N} GUI_BITMAPSTREAM_PARAM;
N
Ntypedef struct {
N  int XSize;
N  int YSize;
N  int BitsPerPixel;
N  int NumColors;
N  int HasTrans;
N} GUI_BITMAPSTREAM_INFO;
N
Ntypedef void * (* GUI_BITMAPSTREAM_CALLBACK)(GUI_BITMAPSTREAM_PARAM * pParam);
N
Ntypedef struct {
N  int x,y;
N  U8  Pressed;
X  unsigned char  Pressed;
N  U8  Layer;
X  unsigned char  Layer;
N} GUI_PID_STATE;
N
Ntypedef struct {
N  int Key;
N  int Pressed;
N} GUI_KEY_STATE;
N
Ntypedef struct {
N  int xPos;
N  int yPos;
N  int xSize;
N  int ySize;
N  int Delay;
N} GUI_GIF_IMAGE_INFO;
N
Ntypedef struct {
N  int xSize;
N  int ySize;
N  int NumImages;
N} GUI_GIF_INFO;
N
N#define GUI_REGISTER_INIT GUI_REGISTER_HOOK
N#define GUI_REGISTER_EXIT GUI_REGISTER_HOOK
N
Ntypedef struct GUI_REGISTER_HOOK GUI_REGISTER_HOOK;
N
Nstruct GUI_REGISTER_HOOK {
N  void (* pfVoid)(void);
N  GUI_REGISTER_HOOK * pNext;
N};
N
Ntypedef struct {
N  void (* cbBegin)(void);
N  void (* cbEnd)  (void);
N} GUI_MULTIBUF_API;
N
Ntypedef struct {
N  void (* cbBeginEx)(int LayerIndex);
N  void (* cbEndEx)  (int LayerIndex);
N} GUI_MULTIBUF_API_EX;
N
N/*********************************************************************
N*
N*       FONT structures
N*/
N
N/* Translation list. Translates a character code into up to 2
N   indices of images to display on top of each other;
N   '' -> index('a'), index('') */
Ntypedef struct {
N  I16P c0;
X  signed short c0;
N  I16P c1;
X  signed short c1;
N} GUI_FONT_TRANSLIST;
N
Ntypedef struct {
N  U16P FirstChar;
X  unsigned short FirstChar;
N  U16P LastChar;
X  unsigned short LastChar;
N  const GUI_FONT_TRANSLIST * pList;
N} GUI_FONT_TRANSINFO;
N
Ntypedef struct {
N  U8 XSize;
X  unsigned char XSize;
N  U8 XDist;
X  unsigned char XDist;
N  U8 BytesPerLine;
X  unsigned char BytesPerLine;
N  const unsigned char * pData;
N} GUI_CHARINFO;
N
Ntypedef struct {
N  U8 XSize;
X  unsigned char XSize;
N  U8 YSize;
X  unsigned char YSize;
N  I8 XPos;
X  signed char XPos;
N  I8 YPos;
X  signed char YPos;
N  U8 XDist;
X  unsigned char XDist;
N  const unsigned char * pData;
N} GUI_CHARINFO_EXT;
N
Ntypedef struct GUI_FONT_PROP {
N  U16P First;                                  /* First character               */
X  unsigned short First;                                   
N  U16P Last;                                   /* Last character                */
X  unsigned short Last;                                    
N  const GUI_CHARINFO         * paCharInfo;     /* Address of first character    */
N  const struct GUI_FONT_PROP * pNext;          /* Pointer to next               */
N} GUI_FONT_PROP;
N
Ntypedef struct GUI_FONT_PROP_EXT {
N  U16P First;                                  /* First character               */
X  unsigned short First;                                   
N  U16P Last;                                   /* Last character                */
X  unsigned short Last;                                    
N  const GUI_CHARINFO_EXT         * paCharInfo; /* Address of first character    */
N  const struct GUI_FONT_PROP_EXT * pNext;      /* Pointer to next               */
N} GUI_FONT_PROP_EXT;
N
Ntypedef struct {
N  const unsigned char      * pData;
N  const U8                 * pTransData;
X  const unsigned char                 * pTransData;
N  const GUI_FONT_TRANSINFO * pTrans;
N  U16P                       FirstChar;
X  unsigned short                       FirstChar;
N  U16P                       LastChar;
X  unsigned short                       LastChar;
N  U8                         XSize;
X  unsigned char                         XSize;
N  U8                         XDist;
X  unsigned char                         XDist;
N  U8                         BytesPerLine;
X  unsigned char                         BytesPerLine;
N} GUI_FONT_MONO;
N
N/*********************************************************************
N*
N*       FONT structures
N*
N* This structure is used when retrieving information about a font.
N* It is designed for future expansion without incompatibilities.
N*/
Ntypedef struct {
N  U16 Flags;
X  unsigned short Flags;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N} GUI_FONTINFO;
N
N#define GUI_FONTINFO_FLAG_PROP    (1 << 0)    /* Is proportional */
N#define GUI_FONTINFO_FLAG_MONO    (1 << 1)    /* Is monospaced */
N#define GUI_FONTINFO_FLAG_AA      (1 << 2)    /* Is an antialiased font */
N#define GUI_FONTINFO_FLAG_AA2     (1 << 3)    /* Is an antialiased font, 2bpp */
N#define GUI_FONTINFO_FLAG_AA4     (1 << 4)    /* Is an antialiased font, 4bpp */
N#define GUI_FONTINFO_FLAG_PROPFRM (1 << 5)    /* Is proportional, framed */
N
N/*********************************************************************
N*
N*       UNICODE Encoding
N*/
Ntypedef U16  tGUI_GetCharCode   (const char * s);
Xtypedef unsigned short  tGUI_GetCharCode   (const char * s);
Ntypedef int  tGUI_GetCharSize   (const char * s);
Ntypedef int  tGUI_CalcSizeOfChar(U16 Char);
Xtypedef int  tGUI_CalcSizeOfChar(unsigned short Char);
Ntypedef int  tGUI_Encode        (char * s, U16 Char);
Xtypedef int  tGUI_Encode        (char * s, unsigned short Char);
N
Ntypedef struct {
N  tGUI_GetCharCode    * pfGetCharCode;
N  tGUI_GetCharSize    * pfGetCharSize;
N  tGUI_CalcSizeOfChar * pfCalcSizeOfChar;
N  tGUI_Encode         * pfEncode;
N} GUI_UC_ENC_APILIST;
N
N/*********************************************************************
N*
N*       FONT Encoding
N*/
Ntypedef int  tGUI_GetLineDistX(const char * s, int Len);
Ntypedef int  tGUI_GetLineLen  (const char * s, int MaxLen);
Ntypedef void tGL_DispLine     (const char * s, int Len);
N
Ntypedef struct {
N  tGUI_GetLineDistX * pfGetLineDistX;
N  tGUI_GetLineLen   * pfGetLineLen;
N  tGL_DispLine      * pfDispLine;
N} tGUI_ENC_APIList;
N
Nextern const tGUI_ENC_APIList GUI_ENC_APIList_SJIS;
Nextern const tGUI_ENC_APIList GUI_ENC_APIList_EXT;
N
N/*********************************************************************
N*
N*       FONT methods
N*/
Ntypedef struct GUI_FONT GUI_FONT;
N
Ntypedef void GUI_DISPCHAR    (U16 c);
Xtypedef void GUI_DISPCHAR    (unsigned short c);
Ntypedef int  GUI_GETCHARDISTX(U16P c, int * pSizeX);
Xtypedef int  GUI_GETCHARDISTX(unsigned short c, int * pSizeX);
Ntypedef void GUI_GETFONTINFO (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Ntypedef char GUI_ISINFONT    (const GUI_FONT * pFont, U16 c);
Xtypedef char GUI_ISINFONT    (const GUI_FONT * pFont, unsigned short c);
Ntypedef int  GUI_GETCHARINFO (U16P c, GUI_CHARINFO_EXT * pInfo);
Xtypedef int  GUI_GETCHARINFO (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N
N#define DECLARE_FONT(Type)                                     \
Nvoid GUI##Type##_DispChar    (U16P c);                         \
Nint  GUI##Type##_GetCharDistX(U16P c, int * pSizeX);                         \
Nvoid GUI##Type##_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); \
Nchar GUI##Type##_IsInFont    (const GUI_FONT * pFont, U16 c); \
Nint  GUI##Type##_GetCharInfo (U16P c, GUI_CHARINFO_EXT * pInfo)
X#define DECLARE_FONT(Type)                                     void GUI##Type##_DispChar    (U16P c);                         int  GUI##Type##_GetCharDistX(U16P c, int * pSizeX);                         void GUI##Type##_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUI##Type##_IsInFont    (const GUI_FONT * pFont, U16 c); int  GUI##Type##_GetCharInfo (U16P c, GUI_CHARINFO_EXT * pInfo)
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
NDECLARE_FONT(MONO);
Xvoid GUIMONO_DispChar (unsigned short c); int GUIMONO_GetCharDistX(unsigned short c, int * pSizeX); void GUIMONO_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIMONO_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIMONO_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP);
Xvoid GUIPROP_DispChar (unsigned short c); int GUIPROP_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_EXT);
Xvoid GUIPROP_EXT_DispChar (unsigned short c); int GUIPROP_EXT_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_EXT_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_EXT_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_FRM);
Xvoid GUIPROP_FRM_DispChar (unsigned short c); int GUIPROP_FRM_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_FRM_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_FRM_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_FRM_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROPAA);
Xvoid GUIPROPAA_DispChar (unsigned short c); int GUIPROPAA_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROPAA_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROPAA_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROPAA_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA2);
Xvoid GUIPROP_AA2_DispChar (unsigned short c); int GUIPROP_AA2_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA2_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA2_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA2_EXT);
Xvoid GUIPROP_AA2_EXT_DispChar (unsigned short c); int GUIPROP_AA2_EXT_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA2_EXT_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_EXT_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA2_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA4);
Xvoid GUIPROP_AA4_DispChar (unsigned short c); int GUIPROP_AA4_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA4_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA4_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
NDECLARE_FONT(PROP_AA4_EXT);
Xvoid GUIPROP_AA4_EXT_DispChar (unsigned short c); int GUIPROP_AA4_EXT_GetCharDistX(unsigned short c, int * pSizeX); void GUIPROP_AA4_EXT_GetFontInfo (const GUI_FONT * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_EXT_IsInFont (const GUI_FONT * pFont, unsigned short c); int GUIPROP_AA4_EXT_GetCharInfo (unsigned short c, GUI_CHARINFO_EXT * pInfo);
N
N/* MONO: Monospaced fonts */
N#define GUI_FONTTYPE_MONO       \
N  GUIMONO_DispChar,             \
N  GUIMONO_GetCharDistX,         \
N  GUIMONO_GetFontInfo,          \
N  GUIMONO_IsInFont,             \
N  (GUI_GETCHARINFO *)0,         \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_MONO         GUIMONO_DispChar,               GUIMONO_GetCharDistX,           GUIMONO_GetFontInfo,            GUIMONO_IsInFont,               (GUI_GETCHARINFO *)0,           (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts */
N#define GUI_FONTTYPE_PROP       \
N  GUIPROP_DispChar,             \
N  GUIPROP_GetCharDistX,         \
N  GUIPROP_GetFontInfo,          \
N  GUIPROP_IsInFont,             \
N  (GUI_GETCHARINFO *)0,         \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP         GUIPROP_DispChar,               GUIPROP_GetCharDistX,           GUIPROP_GetFontInfo,            GUIPROP_IsInFont,               (GUI_GETCHARINFO *)0,           (tGUI_ENC_APIList*)0
N
N/* PROP_EXT: Extended proportional fonts */
N#define GUI_FONTTYPE_PROP_EXT       \
N  GUIPROP_EXT_DispChar,             \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_EXT         GUIPROP_EXT_DispChar,               GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_FRM: Extended proportional fonts, framed */
N#define GUI_FONTTYPE_PROP_FRM       \
N  GUIPROP_FRM_DispChar,             \
N  GUIPROP_FRM_GetCharDistX,         \
N  GUIPROP_FRM_GetFontInfo,          \
N  GUIPROP_FRM_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_FRM         GUIPROP_FRM_DispChar,               GUIPROP_FRM_GetCharDistX,           GUIPROP_FRM_GetFontInfo,            GUIPROP_FRM_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts SJIS */
N#define GUI_FONTTYPE_PROP_SJIS  \
N  GUIPROP_DispChar,             \
N  GUIPROP_GetCharDistX,         \
N  GUIPROP_GetFontInfo,          \
N  GUIPROP_IsInFont,             \
N  (GUI_GETCHARINFO *)0,         \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_SJIS    GUIPROP_DispChar,               GUIPROP_GetCharDistX,           GUIPROP_GetFontInfo,            GUIPROP_IsInFont,               (GUI_GETCHARINFO *)0,           &GUI_ENC_APIList_SJIS
N
N/* PROPAA: Proportional, antialiased fonts */
N#define GUI_FONTTYPE_PROPAA       \
N  GUIPROPAA_DispChar,             \
N  GUIPROPAA_GetCharDistX,         \
N  GUIPROPAA_GetFontInfo,          \
N  GUIPROPAA_IsInFont,             \
N  (GUI_GETCHARINFO *)0,           \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROPAA         GUIPROPAA_DispChar,               GUIPROPAA_GetCharDistX,           GUIPROPAA_GetFontInfo,            GUIPROPAA_IsInFont,               (GUI_GETCHARINFO *)0,             (tGUI_ENC_APIList*)0
N
N/* PROP_AA2: Proportional, antialiased fonts, 2bpp */
N#define GUI_FONTTYPE_PROP_AA2       \
N  GUIPROP_AA2_DispChar,             \
N  GUIPROP_AA2_GetCharDistX,         \
N  GUIPROP_AA2_GetFontInfo,          \
N  GUIPROP_AA2_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA2         GUIPROP_AA2_DispChar,               GUIPROP_AA2_GetCharDistX,           GUIPROP_AA2_GetFontInfo,            GUIPROP_AA2_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP_AA2_EXT: Proportional, antialiased fonts, 2bpp, extended font information */
N#define GUI_FONTTYPE_PROP_AA2_EXT   \
N  GUIPROP_AA2_EXT_DispChar,         \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_AA2_EXT     GUIPROP_AA2_EXT_DispChar,           GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_AA2: Proportional, antialiased fonts, 2bpp, SJIS encoding */
N#define GUI_FONTTYPE_PROP_AA2_SJIS  \
N  GUIPROP_AA2_DispChar,             \
N  GUIPROP_AA2_GetCharDistX,         \
N  GUIPROP_AA2_GetFontInfo,          \
N  GUIPROP_AA2_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_AA2_SJIS    GUIPROP_AA2_DispChar,               GUIPROP_AA2_GetCharDistX,           GUIPROP_AA2_GetFontInfo,            GUIPROP_AA2_IsInFont,               (GUI_GETCHARINFO *)0,               &GUI_ENC_APIList_SJIS
N
N/* PROP_AA4: Proportional, antialiased fonts, 4bpp */
N#define GUI_FONTTYPE_PROP_AA4       \
N  GUIPROP_AA4_DispChar,             \
N  GUIPROP_AA4_GetCharDistX,         \
N  GUIPROP_AA4_GetFontInfo,          \
N  GUIPROP_AA4_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA4         GUIPROP_AA4_DispChar,               GUIPROP_AA4_GetCharDistX,           GUIPROP_AA4_GetFontInfo,            GUIPROP_AA4_IsInFont,               (GUI_GETCHARINFO *)0,               (tGUI_ENC_APIList*)0
N
N/* PROP_AA4_EXT: Proportional, antialiased fonts, 4bpp, extended font information */
N#define GUI_FONTTYPE_PROP_AA4_EXT   \
N  GUIPROP_AA4_EXT_DispChar,         \
N  GUIPROP_EXT_GetCharDistX,         \
N  GUIPROP_EXT_GetFontInfo,          \
N  GUIPROP_EXT_IsInFont,             \
N  GUIPROP_EXT_GetCharInfo,          \
N  &GUI_ENC_APIList_EXT
X#define GUI_FONTTYPE_PROP_AA4_EXT     GUIPROP_AA4_EXT_DispChar,           GUIPROP_EXT_GetCharDistX,           GUIPROP_EXT_GetFontInfo,            GUIPROP_EXT_IsInFont,               GUIPROP_EXT_GetCharInfo,            &GUI_ENC_APIList_EXT
N
N/* PROP_AA4: Proportional, antialiased fonts, 4bpp, SJIS encoding */
N#define GUI_FONTTYPE_PROP_AA4_SJIS  \
N  GUIPROP_AA4_DispChar,             \
N  GUIPROP_AA4_GetCharDistX,         \
N  GUIPROP_AA4_GetFontInfo,          \
N  GUIPROP_AA4_IsInFont,             \
N  (GUI_GETCHARINFO *)0,             \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_AA4_SJIS    GUIPROP_AA4_DispChar,               GUIPROP_AA4_GetCharDistX,           GUIPROP_AA4_GetFontInfo,            GUIPROP_AA4_IsInFont,               (GUI_GETCHARINFO *)0,               &GUI_ENC_APIList_SJIS
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
Nstruct GUI_FONT {
N  GUI_DISPCHAR     * pfDispChar; 
N  GUI_GETCHARDISTX * pfGetCharDistX; 
N  GUI_GETFONTINFO  * pfGetFontInfo; 
N  GUI_ISINFONT     * pfIsInFont;
N  GUI_GETCHARINFO  * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N  U8 YSize;
X  unsigned char YSize;
N  U8 YDist;
X  unsigned char YDist;
N  U8 XMag;
X  unsigned char XMag;
N  U8 YMag;
X  unsigned char YMag;
N  union {
N    const void              * pFontData;
N    const GUI_FONT_MONO     * pMono;
N    const GUI_FONT_PROP     * pProp;
N    const GUI_FONT_PROP_EXT * pPropExt;
N  } p;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* Height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* Height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N};
N
N/*********************************************************************
N*
N*       Bitmap serialization (BMP)
N*/
Ntypedef void GUI_CALLBACK_VOID_U8_P(U8 Data, void * p);
Xtypedef void GUI_CALLBACK_VOID_U8_P(unsigned char Data, void * p);
N
N/*********************************************************************
N*
N*       System independent font structures (SIF)
N*/
Ntypedef struct {
N  U32 ID;           /* Font file ID */
X  unsigned long ID;            
N  U16 YSize;        /* Height of font */
X  unsigned short YSize;         
N  U16 YDist;        /* Space of font Y */
X  unsigned short YDist;         
N  U16 Baseline;     /* Index of baseline */
X  unsigned short Baseline;      
N  U16 LHeight;      /* Height of a small lower case character (a) */
X  unsigned short LHeight;       
N  U16 CHeight;      /* Height of a upper case character (A) */
X  unsigned short CHeight;       
N  U16 NumAreas;     /* Number of character areas */
X  unsigned short NumAreas;      
N} GUI_SI_FONT;
N
Ntypedef struct {
N  U16 First;        /* Index of first character */
X  unsigned short First;         
N  U16 Last;         /* Index of last character */
X  unsigned short Last;          
N} GUI_SIF_CHAR_AREA;
N
Ntypedef struct {
N  U16 XSize;        /* Size of bitmap data in X */
X  unsigned short XSize;         
N  U16 XDist;        /* Number of pixels for increment cursor in X */
X  unsigned short XDist;         
N  U16 BytesPerLine; /* Number of bytes per line */
X  unsigned short BytesPerLine;  
N  U16 Dummy;
X  unsigned short Dummy;
N  U32 OffData;      /* Offset of pixel data */
X  unsigned long OffData;       
N} GUI_SIF_CHARINFO;
N
Ntypedef struct {
N  U16 XSize;        /* Size of bitmap data in X */
X  unsigned short XSize;         
N  U16 YSize;        /* Size of bitmap data in X */
X  unsigned short YSize;         
N  I16 XOff;         /* Display offset of bitmap data in X */
X  signed short XOff;          
N  I16 YOff;         /* Display offset of bitmap data in Y */
X  signed short YOff;          
N  U16 XDist;        /* Number of pixels for increment cursor in X */
X  unsigned short XDist;         
N  U16 Dummy;
X  unsigned short Dummy;
N  U32 OffData;      /* Offset of pixel data */
X  unsigned long OffData;       
N} GUI_SIF_CHARINFO_EXT;
N
Ntypedef struct tGUI_SIF_APIList_struct {
N  GUI_DISPCHAR          * pfDispChar;
N  GUI_GETCHARDISTX      * pfGetCharDistX;
N  GUI_GETFONTINFO       * pfGetFontInfo;
N  GUI_ISINFONT          * pfIsInFont;
N  GUI_GETCHARINFO       * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N} tGUI_SIF_APIList;
N
N#define GUI_SIF_TYPE              tGUI_SIF_APIList
N#define GUI_SIF_TYPE_PROP         &GUI_SIF_APIList_Prop
N#define GUI_SIF_TYPE_PROP_EXT     &GUI_SIF_APIList_Prop_Ext
N#define GUI_SIF_TYPE_PROP_FRM     &GUI_SIF_APIList_Prop_Frm
N#define GUI_SIF_TYPE_PROP_AA2     &GUI_SIF_APIList_Prop_AA2
N#define GUI_SIF_TYPE_PROP_AA4     &GUI_SIF_APIList_Prop_AA4
N#define GUI_SIF_TYPE_PROP_AA2_EXT &GUI_SIF_APIList_Prop_AA2_EXT
N#define GUI_SIF_TYPE_PROP_AA4_EXT &GUI_SIF_APIList_Prop_AA4_EXT
N
N/*********************************************************************
N*
N*       External binary font structures (XBF)
N*/
Ntypedef int GUI_XBF_GET_DATA_FUNC(U32 Off, U16 NumBytes, void * pVoid, void * pBuffer);
Xtypedef int GUI_XBF_GET_DATA_FUNC(unsigned long Off, unsigned short NumBytes, void * pVoid, void * pBuffer);
N
Ntypedef struct {
N  U16 First;                         /* First character of font */
X  unsigned short First;                          
N  U16 Last;                          /* Last character of font */
X  unsigned short Last;                           
N  void * pVoid;                      /* Void pointer passed to GetData-function */
N  GUI_XBF_GET_DATA_FUNC * pfGetData; /* Pointer to callback function */
N} GUI_XBF_DATA;
N
Ntypedef struct tGUI_XBF_APIList_struct {
N  GUI_DISPCHAR          * pfDispChar;
N  GUI_GETCHARDISTX      * pfGetCharDistX;
N  GUI_GETFONTINFO       * pfGetFontInfo;
N  GUI_ISINFONT          * pfIsInFont;
N  GUI_GETCHARINFO       * pfGetCharInfo;
N  const tGUI_ENC_APIList* pafEncode;
N} tGUI_XBF_APIList;
N
N#define GUI_XBF_TYPE              tGUI_XBF_APIList
N#define GUI_XBF_TYPE_PROP         &GUI_XBF_APIList_Prop
N#define GUI_XBF_TYPE_PROP_EXT     &GUI_XBF_APIList_Prop_Ext
N#define GUI_XBF_TYPE_PROP_FRM     &GUI_XBF_APIList_Prop_Frm
N#define GUI_XBF_TYPE_PROP_AA2_EXT &GUI_XBF_APIList_Prop_AA2_Ext
N#define GUI_XBF_TYPE_PROP_AA4_EXT &GUI_XBF_APIList_Prop_AA4_Ext
N
N/*********************************************************************
N*
N*       TrueType support (TTF)
N*/
Ntypedef struct {
N  const void * pData;      /* Pointer to TTF font file in addressable memory area */
N  U32 NumBytes;            /* Size of file in bytes */
X  unsigned long NumBytes;             
N} GUI_TTF_DATA;
N
Ntypedef struct {
N  GUI_TTF_DATA * pTTF;     /* Pointer to GUI_TTF_DATA structure which contains location and size of font file */
N  U32 aImageTypeBuffer[4]; /* Buffer for image type structure */
X  unsigned long aImageTypeBuffer[4];  
N  int PixelHeight;         /* Pixel height of new font. It means the height of the surrounding rectangle
N                            * between the glyphs 'g' anf 'f'. Please notice that it is not the distance
N                            * between two lines of text. With other words the value returned byGUI_GetFontSizeY()
N                            * is not identically with this value. */
N  int FaceIndex;           /* Some font files can contain more than one font face. In case of more than one face
N                            * this index specifies the zero based face index to be used to create the font. 
N                            * Usually 0. */
N} GUI_TTF_CS;
N
N/*********************************************************************
N*
N*       Task synchronization
N*/
Ntypedef void (* GUI_SIGNAL_EVENT_FUNC)    (void);
Ntypedef void (* GUI_WAIT_EVENT_FUNC)      (void);
Ntypedef void (* GUI_WAIT_EVENT_TIMED_FUNC)(int Period);
N
N/*********************************************************************
N*
N*       Memory management
N*/
N#ifndef     GUI_HMEM
N  #define     GUI_HMEM        I32
N#endif
N#define     GUI_HMEM_NULL     (0)
Ntypedef     GUI_HMEM      GUI_HWIN;
Xtypedef     signed long      GUI_HWIN;
Ntypedef     GUI_HMEM      GUI_HSPRITE;
Xtypedef     signed long      GUI_HSPRITE;
N
N/*********************************************************************
N*
N*       Multi touch input
N*/
N#ifndef   GUI_MTOUCH_MAX_NUM_POINTS
N  #define GUI_MTOUCH_MAX_NUM_POINTS 10
N#endif
N
Ntypedef struct {
N  I32 x;
X  signed long x;
N  I32 y;
X  signed long y;
N  U32 Id;
X  unsigned long Id;
N  U16 Flags;
X  unsigned short Flags;
N} GUI_MTOUCH_INPUT;
N
Ntypedef struct {
N  int            LayerIndex;
N  unsigned       NumPoints;
N  GUI_TIMER_TIME TimeStamp;
X  int TimeStamp;
N  PTR_ADDR       hInput;
X  unsigned long       hInput;
N} GUI_MTOUCH_EVENT;
N
N//
N// Used for emWinSPY with reduced data types and array sizes
N//
Ntypedef struct {
N  U8  Layer;
X  unsigned char  Layer;
N  U8  NumPoints;
X  unsigned char  NumPoints;
N  I16 ax[5];
X  signed short ax[5];
N  I16 ay[5];
X  signed short ay[5];
N  U16 aId[5];
X  unsigned short aId[5];
N  U8  aFlags[5];
X  unsigned char  aFlags[5];
N} GUI_MTOUCH_STATE;
N
Ntypedef void (* T_GUI_MTOUCH_STOREEVENT)(GUI_MTOUCH_EVENT *, GUI_MTOUCH_INPUT * pInput);
N
N/*********************************************************************
N*
N*       Hardware routines
N*/
Ntypedef struct {
N  //
N  // 8 Bit access
N  //
N  void (* pfWrite8_A0)  (U8 Data);
X  void (* pfWrite8_A0)  (unsigned char Data);
N  void (* pfWrite8_A1)  (U8 Data);
X  void (* pfWrite8_A1)  (unsigned char Data);
N  void (* pfWriteM8_A0) (U8 * pData, int NumItems);
X  void (* pfWriteM8_A0) (unsigned char * pData, int NumItems);
N  void (* pfWriteM8_A1) (U8 * pData, int NumItems);
X  void (* pfWriteM8_A1) (unsigned char * pData, int NumItems);
N  U8   (* pfRead8_A0)   (void);
X  unsigned char   (* pfRead8_A0)   (void);
N  U8   (* pfRead8_A1)   (void);
X  unsigned char   (* pfRead8_A1)   (void);
N  void (* pfReadM8_A0)  (U8 * pData, int NumItems);
X  void (* pfReadM8_A0)  (unsigned char * pData, int NumItems);
N  void (* pfReadM8_A1)  (U8 * pData, int NumItems);
X  void (* pfReadM8_A1)  (unsigned char * pData, int NumItems);
N  //
N  // 16 Bit access
N  //
N  void (* pfWrite16_A0) (U16 Data);
X  void (* pfWrite16_A0) (unsigned short Data);
N  void (* pfWrite16_A1) (U16 Data);
X  void (* pfWrite16_A1) (unsigned short Data);
N  void (* pfWriteM16_A0)(U16 * pData, int NumItems);
X  void (* pfWriteM16_A0)(unsigned short * pData, int NumItems);
N  void (* pfWriteM16_A1)(U16 * pData, int NumItems);
X  void (* pfWriteM16_A1)(unsigned short * pData, int NumItems);
N  U16  (* pfRead16_A0)  (void);
X  unsigned short  (* pfRead16_A0)  (void);
N  U16  (* pfRead16_A1)  (void);
X  unsigned short  (* pfRead16_A1)  (void);
N  void (* pfReadM16_A0) (U16 * pData, int NumItems);
X  void (* pfReadM16_A0) (unsigned short * pData, int NumItems);
N  void (* pfReadM16_A1) (U16 * pData, int NumItems);
X  void (* pfReadM16_A1) (unsigned short * pData, int NumItems);
N  //
N  // 32 Bit access
N  //
N  void (* pfWrite32_A0) (U32 Data);
X  void (* pfWrite32_A0) (unsigned long Data);
N  void (* pfWrite32_A1) (U32 Data);
X  void (* pfWrite32_A1) (unsigned long Data);
N  void (* pfWriteM32_A0)(U32 * pData, int NumItems);
X  void (* pfWriteM32_A0)(unsigned long * pData, int NumItems);
N  void (* pfWriteM32_A1)(U32 * pData, int NumItems);
X  void (* pfWriteM32_A1)(unsigned long * pData, int NumItems);
N  U32  (* pfRead32_A0)  (void);
X  unsigned long  (* pfRead32_A0)  (void);
N  U32  (* pfRead32_A1)  (void);
X  unsigned long  (* pfRead32_A1)  (void);
N  void (* pfReadM32_A0) (U32 * pData, int NumItems);
X  void (* pfReadM32_A0) (unsigned long * pData, int NumItems);
N  void (* pfReadM32_A1) (U32 * pData, int NumItems);
X  void (* pfReadM32_A1) (unsigned long * pData, int NumItems);
N  //
N  // SPI access
N  //
N  void (* pfSetCS)      (U8 NotActive);
X  void (* pfSetCS)      (unsigned char NotActive);
N  //
N  // Common routines
N  //
N  void (* pfFlushBuffer)(void);
N} GUI_PORT_API;
N
N/*********************************************************************
N*
N*       Send/Receive function for VNC and/or emWinSPY
N*/
Ntypedef int    (* GUI_tSend)  (const U8 * pData, int len, void * p);
Xtypedef int    (* GUI_tSend)  (const unsigned char * pData, int len, void * p);
Ntypedef int    (* GUI_tRecv)  (      U8 * pData, int len, void * p);
Xtypedef int    (* GUI_tRecv)  (      unsigned char * pData, int len, void * p);
N
N/*********************************************************************
N*
N*       Memory allocation replacement for emWinSPY
N*/
Ntypedef void * (* GUI_tMalloc)(unsigned int);
Ntypedef void   (* GUI_tFree)  (void *);
N
N#endif  /* GUITYPE_H_INCLUDED */
N
N/*************************** End of file ****************************/
L 51 "..\..\..\ThirdParty\emWin\Include\gui.h" 2
N#include "GUI_Version.h"
L 1 "..\..\..\ThirdParty\emWin\Include\GUI_Version.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_Version.h
NPurpose     : Include file defining current GUI version
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef  GUI_VERSION_H
N#define  GUI_VERSION_H
N
N#define GUI_VERSION 548112
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 52 "..\..\..\ThirdParty\emWin\Include\gui.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Disable string function warning with newer MSVC versions
N*/
N#if defined (_MSC_VER)
X#if 0L
S  #if (_MSC_VER > 1200)
S    #pragma warning( disable : 4996)
S  #endif
N#endif
N
N/*********************************************************************
N*
N*       Macros, function replacement
N*/
N#define GUI_COUNTOF(a)          (sizeof(a) / sizeof(a[0]))
N#define GUI_MIN(a,b)            (((a) < (b)) ? (a) : (b))
N#define GUI_MAX(a,b)            (((a) > (b)) ? (a) : (b))
N#define GUI_ZEROFILL(p, Size)   (memset(p, 0, Size)) /**/
N
N/*********************************************************************
N*
N*       Support for multitasking systems (locking)
N*/
Ntypedef struct GUI_CONTEXT GUI_CONTEXT;
N
N#if !GUI_OS
X#if !(1)
S  #define GUI_LOCK()
S  #define GUI_UNLOCK()
S  #define GUITASK_INIT()
S  #define GUITASK_COPY_CONTEXT()
N#else
N  void GUI_Lock(void);
N  void GUI_Unlock(void);
N  void GUITASK_Init(void);
N  void GUITASK_CopyContext(void);
N  void GUITASK_SetMaxTask(int MaxTask);
N  int  GUITASK_GetMaxTask(void);
N  GUI_CONTEXT * GUITASK_GetpContext(int Index);
N  #define GUI_LOCK()             GUI_Lock()
N  #define GUI_UNLOCK()           GUI_Unlock()
N  #define GUITASK_INIT()         GUITASK_Init()
N  #define GUITASK_COPY_CONTEXT() GUITASK_CopyContext()
N#endif
N
N/*********************************************************************
N*
N*       API table of a display driver
N*/
Nstruct GUI_DEVICE_API {
N  //
N  // Data
N  //
N  int DeviceClassIndex;
N  //
N  // Drawing functions
N  //
N  void           (* pfDrawBitmap   )(GUI_DEVICE *  pDevice,  int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const U8 * pData, int Diff, const LCD_PIXELINDEX * pTrans);
X  void           (* pfDrawBitmap   )(GUI_DEVICE *  pDevice,  int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const unsigned char * pData, int Diff, const unsigned long * pTrans);
N  void           (* pfDrawHLine    )(GUI_DEVICE *  pDevice,  int x0, int y0,  int x1);
N  void           (* pfDrawVLine    )(GUI_DEVICE *  pDevice,  int x , int y0,  int y1);
N  void           (* pfFillRect     )(GUI_DEVICE *  pDevice,  int x0, int y0, int x1, int y1);
N  LCD_PIXELINDEX (* pfGetPixelIndex)(GUI_DEVICE *  pDevice,  int x, int y);
X  unsigned long (* pfGetPixelIndex)(GUI_DEVICE *  pDevice,  int x, int y);
N  void           (* pfSetPixelIndex)(GUI_DEVICE *  pDevice,  int x, int y, LCD_PIXELINDEX ColorIndex);
X  void           (* pfSetPixelIndex)(GUI_DEVICE *  pDevice,  int x, int y, unsigned long ColorIndex);
N  void           (* pfXorPixel     )(GUI_DEVICE *  pDevice,  int x, int y);
N  //
N  // Set origin
N  //
N  void           (* pfSetOrg       )(GUI_DEVICE *  pDevice,  int x, int y);
N  //
N  // Request information
N  //
N  void         (*(* pfGetDevFunc)   (GUI_DEVICE ** ppDevice, int Index))(void);
N  I32            (* pfGetDevProp   )(GUI_DEVICE *  pDevice,  int Index);
X  signed long            (* pfGetDevProp   )(GUI_DEVICE *  pDevice,  int Index);
N  void          *(* pfGetDevData   )(GUI_DEVICE *  pDevice,  int Index);
N  void           (* pfGetRect      )(GUI_DEVICE *  pDevice,  LCD_RECT * pRect);
N};
N
N/*********************************************************************
N*
N*       Device classes
N*/
Ntypedef enum {
N  DEVICE_CLASS_DRIVER = 0,
N  DEVICE_CLASS_DRIVER_MODIFIER,   // Zoom or delta-pixel modifier
N  DEVICE_CLASS_VNC,
N  DEVICE_CLASS_SPRITE,
N  DEVICE_CLASS_MEMDEV,
N  DEVICE_CLASS_ALPHA,
N  DEVICE_CLASS_AUTOALPHA,
N  DEVICE_CLASS_MEASDEV
N} DEVICE_CLASS;
N
N#define GUI_DEVICE_STAYONTOP 1
N
N/*********************************************************************
N*
N*       Display drivers
N*/
N//
N// Addresses
N//
Nextern const GUI_DEVICE_API GUIDRV_Win_API;
Nextern const GUI_DEVICE_API GUIDRV_Template_API;
N
N//
N// Macros to be used in configuration files
N//
N#define GUIDRV_WIN32       &GUIDRV_Win_API
N
N#if defined(WIN32) && !defined(LCD_SIMCONTROLLER)
X#if 0L && !0L
S  #define GUIDRV_TEMPLATE         &GUIDRV_Win_API
N#else
N  #define GUIDRV_TEMPLATE         &GUIDRV_Template_API
N#endif
N
N/*********************************************************************
N*
N*       Definition of GUI_DEVICE structure
N*/
Nstruct GUI_DEVICE {
N  //
N  // Linking
N  //
N  GUI_DEVICE * pNext;
N  GUI_DEVICE * pPrev;
N  //
N  // Data
N  //
N  union {
N    GUI_HMEM hContext; // Handle of payload data like sprite- or memory device context
X    signed long hContext; 
N    void   * pContext; // Pointer for context data in a fixed block
N  } u;
N  //
N  // API pointers
N  //
N  const GUI_DEVICE_API     * pDeviceAPI;
N  const LCD_API_COLOR_CONV * pColorConvAPI;
N  U16 Flags;
X  unsigned short Flags;
N  int LayerIndex;
N};
N
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_1;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_8;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_16;
Nextern const GUI_DEVICE_API GUI_MEMDEV_DEVICE_32;
N
N/*********************************************************************
N*
N*       GUI_CONTEXT
N*
N*  This structure is public for one reason only:
N*  To allow the application to save and restore the context.
N*/
Ntypedef union {
N  U8  aColorIndex8[2];
X  unsigned char  aColorIndex8[2];
N  U16 aColorIndex16[2];
X  unsigned short aColorIndex16[2];
N  U32 aColorIndex32[2];
X  unsigned long aColorIndex32[2];
N} LCD_COLORINDEX_UNION;
N
Nstruct GUI_CONTEXT {
N  //
N  // Variables in LCD module
N  //
N  LCD_COLORINDEX_UNION uLCD;
N  LCD_RECT       ClipRect;
N  U8             DrawMode;
X  unsigned char             DrawMode;
N  U8             SelLayer;
X  unsigned char             SelLayer;
N  U8             TextStyle;
X  unsigned char             TextStyle;
N  //
N  // Variables in GL module
N  //
N  GUI_RECT * pClipRect_HL;                 // High level clip rectangle ... Speed optimization so drawing routines can optimize
N  U8         PenSize;
X  unsigned char         PenSize;
N  U8         PenShape;
X  unsigned char         PenShape;
N  U8         LineStyle;
X  unsigned char         LineStyle;
N  U8         StrikeWidth;
X  unsigned char         StrikeWidth;
N  //
N  // Variables in GUICHAR module
N  //
N  const GUI_FONT * pAFont;
N  I16P LBorder;
X  signed short LBorder;
N  I16P DispPosX, DispPosY;
X  signed short DispPosX, DispPosY;
N  I16P DrawPosX, DrawPosY;
X  signed short DrawPosX, DrawPosY;
N  I16P TextMode, TextAlign;
X  signed short TextMode, TextAlign;
N  GUI_COLOR Color, BkColor;                // Required only when changing devices and for speed opt (caching)
N  //
N  // Pointer to  color indices
N  //
N  LCD_PIXELINDEX * LCD_pBkColorIndex;
X  unsigned long * LCD_pBkColorIndex;
N  LCD_PIXELINDEX * LCD_pColorIndex;
X  unsigned long * LCD_pColorIndex;
N  //
N  // Variables in WM module
N  //
N  #if GUI_WINSUPPORT
X  #if 1
N    const GUI_RECT * WM__pUserClipRect;
N    GUI_HWIN hAWin;
N    int xOff, yOff;
N    U8 WM_IsActive;
X    unsigned char WM_IsActive;
N  #endif
N  //
N  // Array of pointers to device chains
N  //
N  GUI_DEVICE * apDriver[GUI_NUM_LAYERS];
X  GUI_DEVICE * apDriver[1];
N  //
N  // Variables in MEMDEV module (with memory devices only)
N  //
N  GUI_HMEM    hDevData;
X  signed long    hDevData;
N  //
N  // Variables in Anitaliasing module
N  //
N  const tLCD_HL_APIList * pLCD_HL;       // Required to reroute drawing (HLine & Pixel) to the AA module
N  U8 AA_Factor;
X  unsigned char AA_Factor;
N  U8 AA_HiResEnable;
X  unsigned char AA_HiResEnable;
N  void (* AA_pfSetPixelAA)(int x, int y, U8 Intens); // Function to be used for drawing a single pixel
X  void (* AA_pfSetPixelAA)(int x, int y, unsigned char Intens); 
N  //
N  // Used to reference and link in the copyright string for libraries.
N  //
N  const char * sCopyright;
N};
N
N/* Rename GUI_SaveContext in order to avoid crashes if wrong GUIConf is used */
N#if (GUI_WINSUPPORT == 1)
X#if (1 == 1)
N  #define GUI_SaveContext GUI_SaveContext_W
N#else
S  #define GUI_SaveContext GUI_SaveContext_
N#endif
N
N/*********************************************************************
N*
N*       Device management
N*/
NGUI_DEVICE * GUI_DEVICE_Create       (const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, U16 Flags, int LayerIndex);
XGUI_DEVICE * GUI_DEVICE_Create       (const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, unsigned short Flags, int LayerIndex);
NGUI_DEVICE * GUI_DEVICE_CreateAndLink(const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, U16 Flags, int LayerIndex);
XGUI_DEVICE * GUI_DEVICE_CreateAndLink(const GUI_DEVICE_API * pDeviceAPI, const LCD_API_COLOR_CONV * pColorConvAPI, unsigned short Flags, int LayerIndex);
Nvoid         GUI_DEVICE_Delete       (GUI_DEVICE * pDevice);
Nint          GUI_DEVICE_Link         (GUI_DEVICE * pDevice);
Nvoid         GUI_DEVICE_Unlink       (GUI_DEVICE * pDevice);
NGUI_DEVICE * GUI_DEVICE__GetpDriver  (int LayerIndex);
NGUI_DEVICE * GUI_DEVICE__GetpDevice  (int LayerIndex, int DeviceClass);
N
NGUI_DEVICE * GUI_DEVICE_UnlinkTaskDevices(void);
Nvoid         GUI_DEVICE_LinkDevices      (GUI_DEVICE * pDevice);
N
N/*********************************************************************
N*
N*       GUI_DIRTYDEVICE
N*/
Ntypedef struct {
N  void * pData;         // Pointer to first pixel
N  int    x0, y0;        // Coordinates of the upper left pixel
N  int    xSize, ySize;  // Size of dirty rectangle
N  int    LineOff;       // Virtual xSize in pixels
N  int    BytesPerPixel; // Number of bytes required per pixel
N  int    IsDirty;       // Indicates if dirty pixels exist
N} GUI_DIRTYDEVICE_INFO;
N
Nint GUI_DIRTYDEVICE_Create      (void);
Nint GUI_DIRTYDEVICE_CreateEx    (int LayerIndex);
Nint GUI_DIRTYDEVICE_CreateExInfo(GUI_DIRTYDEVICE_INFO * pInfo, int LayerIndex);
Nint GUI_DIRTYDEVICE_Delete      (void);
Nint GUI_DIRTYDEVICE_DeleteEx    (int LayerIndex);
Nint GUI_DIRTYDEVICE_Fetch       (GUI_DIRTYDEVICE_INFO * pInfo);
Nint GUI_DIRTYDEVICE_FetchEx     (GUI_DIRTYDEVICE_INFO * pInfo, int LayerIndex);
N
N/*********************************************************************
N*
N*       GUI_GCACHE
N*/
Nint GUI_GCACHE_4_Create(const LCD_API_COLOR_CONV * pColorConvAPI);
Nint GUI_GCACHE_4_CreateEx(int LayerIndex, const LCD_API_COLOR_CONV * pColorConvAPI);
N
N/*********************************************************************
N*
N*       GUI_DCACHE
N*/
Nvoid GUI_DCACHE_SetClearCacheHook(void (* pFunc)(U32 LayerMask));
Xvoid GUI_DCACHE_SetClearCacheHook(void (* pFunc)(unsigned long LayerMask));
Nvoid GUI_DCACHE_Clear            (U32 LayerMask);
Xvoid GUI_DCACHE_Clear            (unsigned long LayerMask);
N
Nextern void (* GUI_DCACHE__pfClearCacheHook)(U32 LayerMask);
Xextern void (* GUI_DCACHE__pfClearCacheHook)(unsigned long LayerMask);
N
N/*********************************************************************
N*
N*       GUI_SOFTLAYER
N*/
Ntypedef struct {
N  int xPos;
N  int yPos;
N  int xSize;
N  int ySize;
N  int Visible;
N} GUI_SOFTLAYER_CONFIG;
N
Nint  GUI_SOFTLAYER_Enable           (GUI_SOFTLAYER_CONFIG * pConfig, int NumLayers, GUI_COLOR CompositeColor);
Nint  GUI_SOFTLAYER_Refresh          (void);
Nvoid GUI_SOFTLAYER_SetCompositeColor(U32 Color);
Xvoid GUI_SOFTLAYER_SetCompositeColor(unsigned long Color);
Nint  GUI_SOFTLAYER_MULTIBUF_Enable  (int OnOff);
N
N/*********************************************************************
N*
N*       General routines
N*/
Nvoid             GUI_Exit                 (void);
NGUI_COLOR        GUI_GetDefaultBkColor    (void);
NGUI_COLOR        GUI_GetDefaultColor      (void);
Nconst GUI_FONT * GUI_GetDefaultFont       (void);
Nint              GUI_GetScreenSizeX       (void);
Nint              GUI_GetScreenSizeY       (void);
Nconst char *     GUI_GetVersionString     (void);
Nint              GUI_Init                 (void);
Nint              GUI_IsInitialized        (void);
Nvoid             GUI_SetAfterInitHook     (void (* pFunc)(void));
Nvoid             GUI_RegisterAfterInitHook(void (* pFunc)(void), GUI_REGISTER_INIT * pRegisterInit);
Xvoid             GUI_RegisterAfterInitHook(void (* pFunc)(void), GUI_REGISTER_HOOK * pRegisterInit);
Nvoid             GUI_RestoreContext       (const GUI_CONTEXT * pContext);
Nvoid             GUI_SaveContext          (GUI_CONTEXT * pContext);
Xvoid             GUI_SaveContext_W          (GUI_CONTEXT * pContext);
Nconst GUI_RECT * GUI_SetClipRect          (const GUI_RECT * pRect);
Nvoid             GUI_SetControlHook       (void (* pFunc)(int LayerIndex, int Cmd));
Nvoid             GUI_SetDefault           (void);
Nvoid             GUI_SetDefaultBkColor    (GUI_COLOR Color);
Nvoid             GUI_SetDefaultColor      (GUI_COLOR Color);
Nvoid             GUI_SetDefaultFont       (const GUI_FONT * pFont);
NGUI_DRAWMODE     GUI_SetDrawMode          (GUI_DRAWMODE dm);
Nvoid             GUI_SetScreenSizeX       (int xSize);
Nvoid             GUI_SetScreenSizeY       (int ySize);
Nvoid             GUI_SetRefreshHook       (void (* pFunc)(void));
Nvoid             MainTask                 (void);
N
N#define GUI_PID_SetInitFunc(x) GUI_SetAfterInitHook(x)  // Compatibility
N
N/*********************************************************************
N*
N*       Function replacement
N*/
Nvoid GUI_SetpfMemset(void * (* pFunc)(void * pDest, int c, size_t Cnt));
Nvoid GUI_SetpfMemcpy(void * (* pFunc)(void * pDest, const void * pSrc, size_t Cnt));
Nvoid GUI_SetpfStrcmp(int    (* pFunc)(const char *, const char *));
Nvoid GUI_SetpfStrlen(size_t (* pFunc)(const char *));
Nvoid GUI_SetpfStrcpy(char * (* pFunc)(char *, const char *));
N
N/*********************************************************************
N*
N*       Rectangle helper functions
N*/
Nvoid GUI_AddRect        (GUI_RECT * pDest, const GUI_RECT * pRect, int Dist);
Nint  GUI_RectsIntersect(const GUI_RECT * pr0, const GUI_RECT * pr1);
Nvoid GUI_MoveRect       (GUI_RECT * pRect, int x, int y);
Nvoid GUI_MergeRect      (GUI_RECT * pDest, const GUI_RECT * pr0, const GUI_RECT * pr1);
Nint  GUI__IntersectRects(GUI_RECT * pDest, const GUI_RECT * pr0, const GUI_RECT * pr1);
Nvoid GUI__IntersectRect (GUI_RECT * pDest, const GUI_RECT * pr0);
Nvoid GUI__ReduceRect    (GUI_RECT * pDest, const GUI_RECT * pRect, int Dist);
N
N/*********************************************************************
N*
N*       Misc helper functions
N*/
NI32  GUI__ATan2(I32 x, I32 y, I32 * ph);
Xsigned long  GUI__ATan2(signed long x, signed long y, signed long * ph);
NI32  GUI__ASinHQ(I32 SinHQ);
Xsigned long  GUI__ASinHQ(signed long SinHQ);
Nint  GUI__CompactPixelIndices  (LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel);
Xint  GUI__CompactPixelIndices  (unsigned long * pBuffer, int NumPixels, int BitsPerPixel);
Nint  GUI__CompactPixelIndicesEx(LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI);
Xint  GUI__CompactPixelIndicesEx(unsigned long * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI);
Nint  GUI__ConvertColor2Index   (LCD_PIXELINDEX * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI, void * pResult);
Xint  GUI__ConvertColor2Index   (unsigned long * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI, void * pResult);
Nvoid GUI__Config(void);
NI32  GUI__CosHQ(I32 Ang1000);
Xsigned long  GUI__CosHQ(signed long Ang1000);
Nint  GUI__DivideRound     (int a, int b);
NI32  GUI__DivideRound32   (I32 a, I32 b);
Xsigned long  GUI__DivideRound32   (signed long a, signed long b);
Nvoid GUI__ExpandPixelIndices   (void * pBuffer, int NumPixels, int BitsPerPixel);
Nvoid GUI__ExpandPixelIndicesEx (void * pBuffer, int NumPixels, int BitsPerPixel, const LCD_API_COLOR_CONV * pColorConvAPI);
Nint  GUI__SetText(GUI_HMEM * phText, const char * s);
Xint  GUI__SetText(signed long * phText, const char * s);
NI32  GUI__SinHQ(I32 Ang1000);
Xsigned long  GUI__SinHQ(signed long Ang1000);
NI32  GUI__sqrt32(I32 Square);
Xsigned long  GUI__sqrt32(signed long Square);
Nvoid GUI__DrawTwinArc2(int xl, int xr, int y0,         int r, GUI_COLOR ColorR0, GUI_COLOR ColorR1, GUI_COLOR ColorFill);
Nvoid GUI__DrawTwinArc4(int x0, int y0, int x1, int y1, int r, GUI_COLOR ColorR0, GUI_COLOR ColorR1, GUI_COLOR ColorFill);
Nvoid GUI__FillTrippleArc(int x0, int y0, int Size, GUI_COLOR ColorR0, GUI_COLOR ColorR1, GUI_COLOR ColorR2, GUI_COLOR ColorFill);
Nvoid GUI__RegisterExit(GUI_REGISTER_EXIT * pRegisterExit);
Xvoid GUI__RegisterExit(GUI_REGISTER_HOOK * pRegisterExit);
Nvoid GUI__RegisterInit(GUI_REGISTER_INIT * pRegisterInit);
Xvoid GUI__RegisterInit(GUI_REGISTER_HOOK * pRegisterInit);
N
N/*********************************************************************
N*
N*       Optional function replacement
N*/
Nvoid * GUI__memcpy(void * pDest, const void * pSrc, size_t NumBytes);
Nvoid * GUI__memset(void * pDest, int c, size_t Cnt);
N
N/*********************************************************************
N*
N*       Get / Set Attributes
N*/
NGUI_COLOR GUI_GetBkColor     (void);
Nint       GUI_GetBkColorIndex(void);
NGUI_COLOR GUI_GetColor       (void);
Nint       GUI_GetColorIndex  (void);
NU8        GUI_GetLineStyle   (void);
Xunsigned char        GUI_GetLineStyle   (void);
NU8        GUI_GetPenSize     (void);
Xunsigned char        GUI_GetPenSize     (void);
NU8        GUI_GetPenShape    (void);
Xunsigned char        GUI_GetPenShape    (void);
Nunsigned  GUI_GetPixelIndex  (int x, int y);
N
Nvoid      GUI_SetBkColor   (GUI_COLOR);
Nvoid      GUI_SetColor     (GUI_COLOR);
Nvoid      GUI_SetBkColorIndex(int Index);
Nvoid      GUI_SetColorIndex(int Index);
N
NU8        GUI_SetPenSize   (U8 Size);
Xunsigned char        GUI_SetPenSize   (unsigned char Size);
NU8        GUI_SetPenShape  (U8 Shape);
Xunsigned char        GUI_SetPenShape  (unsigned char Shape);
NU8        GUI_SetLineStyle (U8 Style);
Xunsigned char        GUI_SetLineStyle (unsigned char Style);
N
N/* Get/Set Character used as decimal point (usually '.' or ',') */
Nchar      GUI_GetDecChar(void);
Nchar      GUI_SetDecChar(char c);
N
N/*********************************************************************
N*
N*       Color / Index related functions
N*/
Nint       GUI_Color2Index(GUI_COLOR color);
NGUI_COLOR GUI_Color2VisColor(GUI_COLOR color);
Nchar      GUI_ColorIsAvailable(GUI_COLOR color);
NGUI_COLOR GUI_Index2Color(int Index);
NU32       GUI_CalcColorDist (GUI_COLOR Color0, GUI_COLOR  Color1);
Xunsigned long       GUI_CalcColorDist (GUI_COLOR Color0, GUI_COLOR  Color1);
NU32       GUI_CalcVisColorError(GUI_COLOR color);
Xunsigned long       GUI_CalcVisColorError(GUI_COLOR color);
N
N/*********************************************************************
N*
N*       Error handler
N*/
Nvoid GUI_SetOnErrorFunc(void (* pFunc)(const char * s));
N
N/*********************************************************************
N*
N*       Logging (for debugging primarily)
N*/
Nvoid GUI_Log      (const char * s);
Nvoid GUI_Log1     (const char * s, I32 p0);
Xvoid GUI_Log1     (const char * s, signed long p0);
Nvoid GUI_Log2     (const char * s, I32 p0, I32 p1);
Xvoid GUI_Log2     (const char * s, signed long p0, signed long p1);
Nvoid GUI_Log3     (const char * s, I32 p0, I32 p1, I32 p2);
Xvoid GUI_Log3     (const char * s, signed long p0, signed long p1, signed long p2);
Nvoid GUI_Log4     (const char * s, I32 p0, I32 p1, I32 p2,I32 p3);
Xvoid GUI_Log4     (const char * s, signed long p0, signed long p1, signed long p2,signed long p3);
Nvoid GUI_Warn     (const char * s);
Nvoid GUI_Warn1    (const char * s, I32 p0);
Xvoid GUI_Warn1    (const char * s, signed long p0);
Nvoid GUI_Warn2    (const char * s, I32 p0, I32 p1);
Xvoid GUI_Warn2    (const char * s, signed long p0, signed long p1);
Nvoid GUI_Warn3    (const char * s, I32 p0, I32 p1, I32 p2);
Xvoid GUI_Warn3    (const char * s, signed long p0, signed long p1, signed long p2);
Nvoid GUI_Warn4    (const char * s, I32 p0, I32 p1, I32 p2, I32 p3);
Xvoid GUI_Warn4    (const char * s, signed long p0, signed long p1, signed long p2, signed long p3);
Nvoid GUI_ErrorOut (const char * s);
Nvoid GUI_ErrorOut1(const char * s, I32 p0);
Xvoid GUI_ErrorOut1(const char * s, signed long p0);
Nvoid GUI_ErrorOut2(const char * s, I32 p0, I32 p1);
Xvoid GUI_ErrorOut2(const char * s, signed long p0, signed long p1);
Nvoid GUI_ErrorOut3(const char * s, I32 p0, I32 p1, I32 p2);
Xvoid GUI_ErrorOut3(const char * s, signed long p0, signed long p1, signed long p2);
Nvoid GUI_ErrorOut4(const char * s, I32 p0, I32 p1, I32 p2, I32 p3);
Xvoid GUI_ErrorOut4(const char * s, signed long p0, signed long p1, signed long p2, signed long p3);
N
N/*********************************************************************
N*
N*       2d - GL
N*/
Nvoid GUI_Clear            (void);
Nvoid GUI_ClearRect        (int x0, int y0, int x1, int y1);
Nvoid GUI_ClearRectEx      (const GUI_RECT * pRect);
Nvoid GUI_CopyRect         (int x0, int y0, int x1, int y1, int dx, int dy);
Nvoid GUI_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_DrawBitmap       (const GUI_BITMAP * pBM, int x0, int y0);
Nvoid GUI_DrawBitmapMag    (const GUI_BITMAP * pBM, int x0, int y0, int XMul, int YMul);
Nvoid GUI_DrawBitmapEx     (const GUI_BITMAP * pBM, int x0, int y0, int xCenter, int yCenter, int xMag, int yMag);
Nvoid GUI_DrawBitmapExp    (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const U8 * pData, const GUI_LOGPALETTE * pPal);
Xvoid GUI_DrawBitmapExp    (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const unsigned char * pData, const GUI_LOGPALETTE * pPal);
Nvoid GUI_DrawBitmapHWAlpha(const GUI_BITMAP * pBM, int x0, int y0);
Nvoid GUI_DrawCircle       (int x0, int y0, int r);
Nvoid GUI_DrawEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_DrawGradientH    (int x0, int y0, int x1, int y1, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientV    (int x0, int y0, int x1, int y1, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientRoundedH(int x0, int y0, int x1, int y1, int rd, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGradientRoundedV(int x0, int y0, int x1, int y1, int rd, GUI_COLOR Color0, GUI_COLOR Color1);
Nvoid GUI_DrawGraph        (I16 * pay, int NumPoints, int x0, int y0);
Xvoid GUI_DrawGraph        (signed short * pay, int NumPoints, int x0, int y0);
Nvoid GUI_DrawGraphEx      (I16 * pay, int NumPoints, int x0, int y0, int Numerator, int Denominator, int MirrorX);
Xvoid GUI_DrawGraphEx      (signed short * pay, int NumPoints, int x0, int y0, int Numerator, int Denominator, int MirrorX);
Nvoid GUI_DrawHLine        (int y0, int x0, int x1);
Nvoid GUI_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawLineRel      (int dx, int dy);
Nvoid GUI_DrawLineTo       (int x, int y);
Nvoid GUI_DrawPie          (int x0, int y0, int r, int a0, int a1, int Type);
Nvoid GUI_DrawPixel        (int x, int y);
Nvoid GUI_DrawPoint        (int x, int y);
Nvoid GUI_DrawPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawPolyLine     (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawFocusRect    (const GUI_RECT  * pRect, int Dist);
Nvoid GUI_DrawRect         (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawRectEx       (const GUI_RECT * pRect);
Nvoid GUI_DrawRoundedFrame (int x0, int y0, int x1, int y1, int r, int w);
Nvoid GUI_DrawRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_DrawVLine        (int x0, int y0, int y1);
Nvoid GUI_FillCircle       (int x0, int y0, int r);
Nvoid GUI_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_FillPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_FillRect         (int x0, int y0, int x1, int y1);
Nvoid GUI_FillRectEx       (const GUI_RECT * pRect);
Nvoid GUI_FillRoundedFrame (int x0, int y0, int x1, int y1, int r, int w);
Nvoid GUI_FillRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_FillRoundedRectB (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_FillRoundedRectT (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_GetClientRect    (GUI_RECT * pRect);
Nvoid GUI_InvertRect       (int x0, int y0, int x1, int y1);
Nvoid GUI_MoveRel          (int dx, int dy);
Nvoid GUI_MoveTo           (int x, int y);
Nvoid GUI_SetAlphaMask8888 (U32 OrMask, U32 AndMask);
Xvoid GUI_SetAlphaMask8888 (unsigned long OrMask, unsigned long AndMask);
N
N/*********************************************************************
N*
N*       IMAGE file support
N*/
Ntypedef int GUI_GET_DATA_FUNC(void * p, const U8 ** ppData, unsigned NumBytes, U32 Off);
Xtypedef int GUI_GET_DATA_FUNC(void * p, const unsigned char ** ppData, unsigned NumBytes, unsigned long Off);
N
N/*********************************************************************
N*
N*       GIF file support
N*/
Nint GUI_GIF_Draw           (const void * pGIF, U32 NumBytes,         int x0, int y0);
Xint GUI_GIF_Draw           (const void * pGIF, unsigned long NumBytes,         int x0, int y0);
Nint GUI_GIF_DrawEx         (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_GIF_DrawSub        (const void * pGIF, U32 NumBytes,         int x0, int y0, int Index);
Xint GUI_GIF_DrawSub        (const void * pGIF, unsigned long NumBytes,         int x0, int y0, int Index);
Nint GUI_GIF_DrawSubEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Index);
Nint GUI_GIF_DrawSubScaled  (const void * pGIF, U32 NumBytes,         int x0, int y0, int Index, int Num, int Denom);
Xint GUI_GIF_DrawSubScaled  (const void * pGIF, unsigned long NumBytes,         int x0, int y0, int Index, int Num, int Denom);
Nint GUI_GIF_DrawSubScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Index, int Num, int Denom);
Nint GUI_GIF_GetComment     (const void * pGIF, U32 NumBytes,         U8 * pBuffer, int MaxSize, int Index);
Xint GUI_GIF_GetComment     (const void * pGIF, unsigned long NumBytes,         unsigned char * pBuffer, int MaxSize, int Index);
Nint GUI_GIF_GetCommentEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, U8 * pBuffer, int MaxSize, int Index);
Xint GUI_GIF_GetCommentEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, unsigned char * pBuffer, int MaxSize, int Index);
Nint GUI_GIF_GetImageInfo   (const void * pGIF, U32 NumBytes,         GUI_GIF_IMAGE_INFO * pInfo, int Index);
Xint GUI_GIF_GetImageInfo   (const void * pGIF, unsigned long NumBytes,         GUI_GIF_IMAGE_INFO * pInfo, int Index);
Nint GUI_GIF_GetImageInfoEx (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_GIF_IMAGE_INFO * pInfo, int Index);
Nint GUI_GIF_GetInfo        (const void * pGIF, U32 NumBytes,         GUI_GIF_INFO * pInfo);
Xint GUI_GIF_GetInfo        (const void * pGIF, unsigned long NumBytes,         GUI_GIF_INFO * pInfo);
Nint GUI_GIF_GetInfoEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_GIF_INFO * pInfo);
Nint GUI_GIF_GetXSize       (const void * pGIF);
Nint GUI_GIF_GetXSizeEx     (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_GIF_GetYSize       (const void * pGIF);
Nint GUI_GIF_GetYSizeEx     (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_GIF_SetFillTrans   (int OnOff);
N
N/*********************************************************************
N*
N*       BMP file support
N*/
Nint  GUI_BMP_Draw        (const void * pFileData,                  int x0, int y0);
Nint  GUI_BMP_DrawEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint  GUI_BMP_DrawScaled  (const void * pFileData,                  int x0, int y0, int Num, int Denom);
Nint  GUI_BMP_DrawScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Num, int Denom);
Nint  GUI_BMP_GetXSize    (const void * pFileData);
Nint  GUI_BMP_GetXSizeEx  (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint  GUI_BMP_GetYSize    (const void * pFileData);
Nint  GUI_BMP_GetYSizeEx  (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nvoid GUI_BMP_EnableAlpha (void);
Nvoid GUI_BMP_DisableAlpha(void);
N
N/*********************************************************************
N*
N*       PNG file support
N*/
Nint GUI_PNG_Draw      (const void * pFileData, int DataSize, int x0, int y0);
Nint GUI_PNG_DrawEx    (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_PNG_GetXSize  (const void * pFileData, int FileSize);
Nint GUI_PNG_GetXSizeEx(GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint GUI_PNG_GetYSize  (const void * pFileData, int FileSize);
Nint GUI_PNG_GetYSizeEx(GUI_GET_DATA_FUNC * pfGetData, void * p);
N
N/*********************************************************************
N*
N*       JPEG file support
N*/
Ntypedef struct {
N  int XSize;
N  int YSize;
N} GUI_JPEG_INFO;
N
Nint GUI_JPEG_Draw        (const void * pFileData, int DataSize,    int x0, int y0);
Nint GUI_JPEG_DrawEx      (GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0);
Nint GUI_JPEG_DrawScaled  (const void * pFileData, int DataSize,    int x0, int y0, int Num, int Denom);
Nint GUI_JPEG_DrawScaledEx(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0, int Num, int Denom);
Nint GUI_JPEG_GetInfo     (const void * pFileData, int DataSize,    GUI_JPEG_INFO * pInfo);
Nint GUI_JPEG_GetInfoEx   (GUI_GET_DATA_FUNC * pfGetData, void * p, GUI_JPEG_INFO * pInfo);
N
Nvoid GUI_JPEG_SetpfDrawEx(int (* pfDrawEx)(GUI_GET_DATA_FUNC * pfGetData, void * p, int x0, int y0));
N
N/*********************************************************************
N*
N*       MOVIE file support
N*/
N#define GUI_MOVIE_NOTIFICATION_PREDRAW  0 // Immediately before frame is drawn
N#define GUI_MOVIE_NOTIFICATION_POSTDRAW 1 // Immediately after a frame is drawn
N#define GUI_MOVIE_NOTIFICATION_START    2 // Send when start playing a movie
N#define GUI_MOVIE_NOTIFICATION_STOP     3 // Movie has stopped
N#define GUI_MOVIE_NOTIFICATION_DELETE   4 // Movie has been deleted
N
Ntypedef GUI_HMEM GUI_MOVIE_HANDLE;
Xtypedef signed long GUI_MOVIE_HANDLE;
N
Ntypedef void GUI_MOVIE_FUNC(GUI_MOVIE_HANDLE hMovie, int Notification, U32 CurrentFrame);
Xtypedef void GUI_MOVIE_FUNC(GUI_MOVIE_HANDLE hMovie, int Notification, unsigned long CurrentFrame);
N
Ntypedef struct {
N  int xSize;         // X-size of images
N  int ySize;         // Y-size of images
N  int msPerFrame;    // Default duration of 1 frame
N  U32 NumFrames;     // Number of frames
X  unsigned long NumFrames;     
N} GUI_MOVIE_INFO;
N
NGUI_MOVIE_HANDLE GUI_MOVIE_Create       (const void * pFileData, U32 FileSize, GUI_MOVIE_FUNC * pfNotify);
XGUI_MOVIE_HANDLE GUI_MOVIE_Create       (const void * pFileData, unsigned long FileSize, GUI_MOVIE_FUNC * pfNotify);
NGUI_MOVIE_HANDLE GUI_MOVIE_CreateEx     (GUI_GET_DATA_FUNC * pfGetData, void * pParam, GUI_MOVIE_FUNC * pfNotify);
Nint              GUI_MOVIE_Delete       (GUI_MOVIE_HANDLE hMovie);
Nvoid             GUI_MOVIE_DrawFrame    (GUI_MOVIE_HANDLE hMovie, int Index, int x, int y);
NU32              GUI_MOVIE_GetFrameIndex(GUI_MOVIE_HANDLE hMovie);
Xunsigned long              GUI_MOVIE_GetFrameIndex(GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_GetInfo      (const void * pFileData, U32 FileSize, GUI_MOVIE_INFO * pInfo);
Xint              GUI_MOVIE_GetInfo      (const void * pFileData, unsigned long FileSize, GUI_MOVIE_INFO * pInfo);
Nint              GUI_MOVIE_GetInfoEx    (GUI_GET_DATA_FUNC * pfGetData, void * pParam, GUI_MOVIE_INFO * pInfo);
Nint              GUI_MOVIE_GetNumFrames (GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_GetPos       (GUI_MOVIE_HANDLE hMovie, int * pxPos, int * pyPos, int * pxSize, int * pySize);
Nint              GUI_MOVIE_GotoFrame    (GUI_MOVIE_HANDLE hMovie, U32 Frame);
Xint              GUI_MOVIE_GotoFrame    (GUI_MOVIE_HANDLE hMovie, unsigned long Frame);
Nint              GUI_MOVIE_Pause        (GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_Play         (GUI_MOVIE_HANDLE hMovie);
Nint              GUI_MOVIE_SetPeriod    (GUI_MOVIE_HANDLE hMovie, unsigned Period);
Nvoid             GUI_MOVIE_SetpfNotify  (GUI_MOVIE_FUNC * pfNotify);
Nint              GUI_MOVIE_SetPos       (GUI_MOVIE_HANDLE hMovie, int xPos, int yPos);
Nint              GUI_MOVIE_Show         (GUI_MOVIE_HANDLE hMovie, int xPos, int yPos, int DoLoop);
N
N/*********************************************************************
N*
N*       Splines
N*/
NGUI_HMEM GUI_SPLINE_Create  (const int * px, const int * py, unsigned NumPoints);
Xsigned long GUI_SPLINE_Create  (const int * px, const int * py, unsigned NumPoints);
Nvoid     GUI_SPLINE_Draw    (GUI_HMEM hSpline, int x, int y);
Xvoid     GUI_SPLINE_Draw    (signed long hSpline, int x, int y);
Nvoid     GUI_SPLINE_Delete  (GUI_HMEM hSpline);
Xvoid     GUI_SPLINE_Delete  (signed long hSpline);
NI16      GUI_SPLINE_GetY    (GUI_HMEM hSpline, unsigned Index, float * py);
Xsigned short      GUI_SPLINE_GetY    (signed long hSpline, unsigned Index, float * py);
Nunsigned GUI_SPLINE_GetXSize(GUI_HMEM hSpline);
Xunsigned GUI_SPLINE_GetXSize(signed long hSpline);
Nvoid     GUI_SPLINE_DrawAA  (GUI_HMEM hSpline, int x, int y, unsigned Width);
Xvoid     GUI_SPLINE_DrawAA  (signed long hSpline, int x, int y, unsigned Width);
N
N/*********************************************************************
N*
N*       Cursor routines
N*/
N#define GUI_CURSOR_SHOW 0
N#define GUI_CURSOR_HIDE 1
N
Ntypedef struct {
N  const GUI_BITMAP  * pBitmap;
N  int                 xHot;
N  int                 yHot;
N} GUI_CURSOR;
N
Ntypedef struct {
N  const GUI_BITMAP ** ppBm;
N  int                 xHot;
N  int                 yHot;
N  unsigned            Period;
N  const unsigned    * pPeriod;
N  int                 NumItems;
N} GUI_CURSOR_ANIM;
N
N#if GUI_SUPPORT_CURSOR
X#if (1 | (1))
N  int                GUI_CURSOR_GetState     (void);
N  int                GUI_CURSOR_GetStateEx   (int Layer);
N  void               GUI_CURSOR_Hide         (void);
N  void               GUI_CURSOR_HideEx       (int Layer);
N  const GUI_CURSOR * GUI_CURSOR_Select       (const GUI_CURSOR * pCursor);
N  const GUI_CURSOR * GUI_CURSOR_SelectEx     (const GUI_CURSOR * pCursor, int Layer);
N  int                GUI_CURSOR_SelectAnim   (const GUI_CURSOR_ANIM * pCursorAnim);
N  int                GUI_CURSOR_SelectAnimEx (const GUI_CURSOR_ANIM * pCursorAnim, int LayerIndex);
N  int                GUI_CURSOR_SetBitmap    (const GUI_BITMAP * pBM);
N  int                GUI_CURSOR_SetBitmapEx  (const GUI_BITMAP * pBM, int Layer);
N  void               GUI_CURSOR_SetPosition  (int x, int y);
N  void               GUI_CURSOR_SetPositionEx(int xNewPos, int yNewPos, int Layer);
N  void               GUI_CURSOR_Show         (void);
N  void               GUI_CURSOR_ShowEx       (int Layer);
N  GUI_HSPRITE        GUI_CURSOR__GetSpriteEx (int LayerIndex, int * pxPos, int * pyPos);
N  void               GUI_CURSOR__SetSpriteEx (GUI_HSPRITE hSprite, const GUI_CURSOR * pCursor, int LayerIndex);
N#else
S  #define GUI_CURSOR_Show();
S  #define GUI_CURSOR_Clear();
N#endif
N
N/*********************************************************************
N*
N*       Sprite support
N*/
N#define GUI_SPRITE_CF_STAYONTOP (1 << 0)
N#define GUI_SPRITE_CF_SHOW      (1 << 1)
N
N#define GUI_SPRITE_SHOW 0
N#define GUI_SPRITE_HIDE 1
N
NGUI_HSPRITE GUI_SPRITE__CreateEx           (const GUI_BITMAP * pBM, int x, int y, int Layer, U16 Flags); /* Not to be documented, only used by cursor modul */
XGUI_HSPRITE GUI_SPRITE__CreateEx           (const GUI_BITMAP * pBM, int x, int y, int Layer, unsigned short Flags);  
Nvoid        GUI_SPRITE__SetCallback        (GUI_HSPRITE hSprite, GUI_HMEM hContext, void (* pCB)(GUI_HSPRITE, int));
Xvoid        GUI_SPRITE__SetCallback        (GUI_HSPRITE hSprite, signed long hContext, void (* pCB)(GUI_HSPRITE, int));
NGUI_HSPRITE GUI_SPRITE_Create              (const GUI_BITMAP * pBM, int x, int y);
NGUI_HSPRITE GUI_SPRITE_CreateAnim          (const GUI_BITMAP ** ppBm, int x, int y, unsigned Period, const unsigned * pPeriod, int NumItems);
NGUI_HSPRITE GUI_SPRITE_CreateEx            (const GUI_BITMAP * pBM, int x, int y, int Layer);
NGUI_HSPRITE GUI_SPRITE_CreateExAnim        (const GUI_BITMAP ** ppBm, int x, int y, unsigned Period, const unsigned * pPeriod, int NumItems, int LayerIndex);
NGUI_HSPRITE GUI_SPRITE_CreateHidden        (const GUI_BITMAP * pBM, int x, int y);
NGUI_HSPRITE GUI_SPRITE_CreateHiddenEx      (const GUI_BITMAP * pBM, int x, int y, int Layer);
Nvoid        GUI_SPRITE_Delete              (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_GetState            (GUI_HSPRITE hSprite);
Nvoid        GUI_SPRITE_Hide                (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_SetBitmap           (GUI_HSPRITE hSprite, const GUI_BITMAP * pBM);
Nint         GUI_SPRITE_SetBitmapAndPosition(GUI_HSPRITE hSprite, const GUI_BITMAP * pBM, int x, int y);
Nint         GUI_SPRITE_SetLoop             (GUI_HSPRITE hSprite, int OnOff);
Nvoid        GUI_SPRITE_SetPosition         (GUI_HSPRITE hSprite, int x, int y);
Nint         GUI_SPRITE_StartAnim           (GUI_HSPRITE hSprite);
Nint         GUI_SPRITE_StopAnim            (GUI_HSPRITE hSprite);
Nvoid        GUI_SPRITE_Show                (GUI_HSPRITE hSprite);
N
N/*********************************************************************
N*
N*       Cursors and their bitmaps
N*/
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Xextern const GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Xextern const GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Xextern const GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Xextern const GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Xextern const GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Xextern const GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
Xextern const GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR_ANIM GUI_CursorAnimHourglassM;
Xextern const GUI_CURSOR_ANIM GUI_CursorAnimHourglassM;
N
N/*********************************************************************
N*
N*       Wrap modes
N*/
Ntypedef enum { GUI_WRAPMODE_NONE, GUI_WRAPMODE_WORD, GUI_WRAPMODE_CHAR } GUI_WRAPMODE;
N
N/*********************************************************************
N*
N*       Text related routines
N*/
Nvoid  GUI_DispCEOL              (void);
Nvoid  GUI_DispChar              (U16 c);
Xvoid  GUI_DispChar              (unsigned short c);
Nvoid  GUI_DispCharAt            (U16 c, I16P x, I16P y);
Xvoid  GUI_DispCharAt            (unsigned short c, signed short x, signed short y);
Nvoid  GUI_DispChars             (U16 c, int Cnt);
Xvoid  GUI_DispChars             (unsigned short c, int Cnt);
Nvoid  GUI_DispNextLine          (void);
Nvoid  GUI_DispString            (const char * s);
Nvoid  GUI_DispStringAt          (const char * s, int x, int y);
Nvoid  GUI_DispStringAtCEOL      (const char * s, int x, int y);
Nvoid  GUI_DispStringHCenterAt   (const char * s, int x, int y);
Nvoid  GUI__DispStringInRect     (const char * s, GUI_RECT * pRect, int TextAlign, int MaxNumChars);
Nvoid  GUI_DispStringInRect      (const char * s, GUI_RECT * pRect, int TextAlign);
N#if GUI_SUPPORT_ROTATION
X#if 1
Nvoid  GUI_DispStringInRectEx    (const char * s, GUI_RECT * pRect, int TextAlign, int MaxLen, const GUI_ROTATION * pLCD_Api);
Xvoid  GUI_DispStringInRectEx    (const char * s, GUI_RECT * pRect, int TextAlign, int MaxLen, const tLCD_APIList * pLCD_Api);
N#endif
Nvoid  GUI_DispStringInRectMax   (const char * s, GUI_RECT * pRect, int TextAlign, int MaxLen); /* Not to be doc. */
Nvoid  GUI_DispStringInRectWrap  (const char * s, GUI_RECT * pRect, int TextAlign, GUI_WRAPMODE WrapMode); /* Not to be doc. */
N#if GUI_SUPPORT_ROTATION
X#if 1
Nvoid  GUI_DispStringInRectWrapEx(const char * s, GUI_RECT * pRect, int TextAlign, GUI_WRAPMODE WrapMode, const GUI_ROTATION * pLCD_Api);
Xvoid  GUI_DispStringInRectWrapEx(const char * s, GUI_RECT * pRect, int TextAlign, GUI_WRAPMODE WrapMode, const tLCD_APIList * pLCD_Api);
N#endif
Nvoid  GUI_DispStringLen         (const char * s, int Len);
Nvoid  GUI_GetTextExtend         (GUI_RECT* pRect, const char * s, int Len);
Nint   GUI_GetYAdjust            (void);
Nint   GUI_GetDispPosX           (void);
Nint   GUI_GetDispPosY           (void);
Nconst GUI_FONT * GUI_GetFont    (void);
Nint   GUI_GetCharDistX          (U16 c);
Xint   GUI_GetCharDistX          (unsigned short c);
Nint   GUI_GetCharDistXEx        (U16 c, int * pSizeX);
Xint   GUI_GetCharDistXEx        (unsigned short c, int * pSizeX);
Nint   GUI_GetStringDistX        (const char * s);
NGUI_DRAWMODE GUI_GetDrawMode    (void);
Nint   GUI_GetFontDistY          (void);
Nint   GUI_GetFontSizeY          (void);
Nvoid  GUI_GetFontInfo           (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Nvoid  GUI_GetOrg                (int * px, int * py);
Nint   GUI_GetYSizeOfFont        (const GUI_FONT * pFont);
Nint   GUI_GetYDistOfFont        (const GUI_FONT * pFont);
Nint   GUI_GetTextAlign          (void);
Nint   GUI_GetTextMode           (void);
Nchar  GUI_IsInFont              (const GUI_FONT * pFont, U16 c);
Xchar  GUI_IsInFont              (const GUI_FONT * pFont, unsigned short c);
NU8    GUI_SetClearTextRectMode  (unsigned OnOff);
Xunsigned char    GUI_SetClearTextRectMode  (unsigned OnOff);
Nint   GUI_SetTextAlign          (int Align);
Nint   GUI_SetTextMode           (int Mode);
Nchar  GUI_SetTextStyle          (char Style);
Nint   GUI_SetLBorder            (int x);
NU8    GUI_SetStrikeWidth        (U8 StrikeWidth);
Xunsigned char    GUI_SetStrikeWidth        (unsigned char StrikeWidth);
Nconst GUI_FONT * GUI_SetFont    (const GUI_FONT * pNewFont);
Nchar  GUI_GotoXY                (int x, int y);
Nchar  GUI_GotoX                 (int x);
Nchar  GUI_GotoY                 (int y);
Nint   GUI_WrapGetNumLines       (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint   GUI_WrapGetPositions      (const char * pText, int xSize, GUI_WRAPMODE WrapMode, int * aPos, int NumItems);
Nvoid  GUI_WrapSetSeparators     (const U16 * pSep, int NumSeps);
Xvoid  GUI_WrapSetSeparators     (const unsigned short * pSep, int NumSeps);
N
Nint   GUI_GetLeadingBlankCols (U16 c);
Xint   GUI_GetLeadingBlankCols (unsigned short c);
Nint   GUI_GetTrailingBlankCols(U16 c);
Xint   GUI_GetTrailingBlankCols(unsigned short c);
N
N
N/*********************************************************************
N*
N*       System independent fonts (SIF)
N*/
Nvoid GUI_SIF_CreateFont(const void * pFontData, GUI_FONT * pFont, const GUI_SIF_TYPE * pFontType);
Xvoid GUI_SIF_CreateFont(const void * pFontData, GUI_FONT * pFont, const tGUI_SIF_APIList * pFontType);
Nvoid GUI_SIF_DeleteFont(GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*       External binary fonts (XBF)
N*/
Nint  GUI_XBF_CreateFont(GUI_FONT * pFont, GUI_XBF_DATA * pXBF, const GUI_XBF_TYPE * pFontType, GUI_XBF_GET_DATA_FUNC * pfGetData, void * pVoid);
Xint  GUI_XBF_CreateFont(GUI_FONT * pFont, GUI_XBF_DATA * pXBF, const tGUI_XBF_APIList * pFontType, GUI_XBF_GET_DATA_FUNC * pfGetData, void * pVoid);
Nvoid GUI_XBF_DeleteFont(GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*       TrueType support (TTF)
N*/
Nint  GUI_TTF_CreateFont   (GUI_FONT * pFont, GUI_TTF_CS * pCS);
Nint  GUI_TTF_CreateFontAA (GUI_FONT * pFont, GUI_TTF_CS * pCS);
Nvoid GUI_TTF_DestroyCache (void);
Nvoid GUI_TTF_Done         (void);
Nint  GUI_TTF_GetFamilyName(GUI_FONT * pFont, char * pBuffer, int NumBytes);
Nint  GUI_TTF_GetStyleName (GUI_FONT * pFont, char * pBuffer, int NumBytes);
Nvoid GUI_TTF_SetCacheSize (unsigned MaxFaces, unsigned MaxSizes, U32 MaxBytes);
Xvoid GUI_TTF_SetCacheSize (unsigned MaxFaces, unsigned MaxSizes, unsigned long MaxBytes);
N
N/*********************************************************************
N*
N*       Resource file support
N*/
Nint          GUI_LANG_GetLang          (void);
Nint          GUI_LANG_GetNumItems      (int IndexLang);
Nconst char * GUI_LANG_GetText          (int IndexText);
Nint          GUI_LANG_GetTextBuffered  (int IndexText, char * pBuffer, int SizeOfBuffer);
Nint          GUI_LANG_GetTextBufferedEx(int IndexText, int IndexLang, char * pBuffer, int SizeOfBuffer);
Nconst char * GUI_LANG_GetTextEx        (int IndexText, int IndexLang);
Nint          GUI_LANG_LoadCSV          (U8 * pFileData, U32 FileSize);
Xint          GUI_LANG_LoadCSV          (unsigned char * pFileData, unsigned long FileSize);
Nint          GUI_LANG_LoadCSVEx        (GUI_GET_DATA_FUNC * pfGetData, void * p);
Nint          GUI_LANG_LoadText         (U8 * pFileData, U32 FileSize, int IndexLang);
Xint          GUI_LANG_LoadText         (unsigned char * pFileData, unsigned long FileSize, int IndexLang);
Nint          GUI_LANG_LoadTextEx       (GUI_GET_DATA_FUNC * pfGetData, void * p, int IndexLang);
Nint          GUI_LANG_SetLang          (int IndexLang);
Nunsigned     GUI_LANG_SetMaxNumLang    (unsigned MaxNumLang);
NU16          GUI_LANG_SetSep           (U16 Sep);
Xunsigned short          GUI_LANG_SetSep           (unsigned short Sep);
N
N/*********************************************************************
N*
N*       Unicode support
N*/
Nint  GUI_UC_ConvertUC2UTF8(const U16 * s, int Len, char * pBuffer, int BufferSize);
Xint  GUI_UC_ConvertUC2UTF8(const unsigned short * s, int Len, char * pBuffer, int BufferSize);
Nint  GUI_UC_ConvertUTF82UC(const char * s, int Len, U16 * pBuffer, int BufferSize);
Xint  GUI_UC_ConvertUTF82UC(const char * s, int Len, unsigned short * pBuffer, int BufferSize);
Nint  GUI_UC_EnableBIDI    (int OnOff);
Nint  GUI_UC_Encode        (char * s, U16 Char);
Xint  GUI_UC_Encode        (char * s, unsigned short Char);
Nint  GUI_UC_GetCharSize   (const char * s);
NU16  GUI_UC_GetCharCode   (const char * s);
Xunsigned short  GUI_UC_GetCharCode   (const char * s);
Nvoid GUI_UC_SetEncodeNone (void);
Nvoid GUI_UC_SetEncodeSJIS (void);
Nvoid GUI_UC_SetEncodeUTF8 (void);
Nvoid GUI_UC_SetBaseDir    (int Dir);  // Only available with new version of BIDI algorithm (GUI_USE_BIDI2 == 1)
Nint  GUI_UC_GetBaseDir    (void);     // Only available with new version of BIDI algorithm (GUI_USE_BIDI2 == 1)
N
Nvoid GUI_UC_DispString(const U16 * s);
Xvoid GUI_UC_DispString(const unsigned short * s);
Nvoid GUI_UC2DB (U16 Code, U8 * pOut);
Xvoid GUI_UC2DB (unsigned short Code, unsigned char * pOut);
NU16  GUI_DB2UC (U8 Byte0, U8 Byte1);
Xunsigned short  GUI_DB2UC (unsigned char Byte0, unsigned char Byte1);
N
N/*********************************************************************
N*
N*       Bidi support
N*/
N#define GUI_BIDI_BASEDIR_LTR  0
N#define GUI_BIDI_BASEDIR_RTL  1
N#define GUI_BIDI_BASEDIR_AUTO 2
N
N#define GUI_BIDI_LOG2VIS_CALC     0
N#define GUI_BIDI_LOG2VIS_GETCACHE 1
N
N/*********************************************************************
N*
N*       Drawing of binary, decimal and hexadecimal values
N*/
Nvoid GUI_DispBin  (U32  v, U8 Len);
Xvoid GUI_DispBin  (unsigned long  v, unsigned char Len);
Nvoid GUI_DispBinAt(U32  v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispBinAt(unsigned long  v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDec  (I32 v, U8 Len);
Xvoid GUI_DispDec  (signed long v, unsigned char Len);
Nvoid GUI_DispDecAt (I32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispDecAt (signed long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDecMin(I32 v);
Xvoid GUI_DispDecMin(signed long v);
Nvoid GUI_DispDecShift(I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispDecShift(signed long v, unsigned char Len, unsigned char Shift);
Nvoid GUI_DispDecSpace(I32 v, U8 MaxDigits);
Xvoid GUI_DispDecSpace(signed long v, unsigned char MaxDigits);
Nvoid GUI_DispHex  (U32 v, U8 Len);
Xvoid GUI_DispHex  (unsigned long v, unsigned char Len);
Nvoid GUI_DispHexAt(U32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispHexAt(unsigned long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispSDec(I32 v, U8 Len);
Xvoid GUI_DispSDec(signed long v, unsigned char Len);
Nvoid GUI_DispSDecShift(I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispSDecShift(signed long v, unsigned char Len, unsigned char Shift);
N
N/*********************************************************************
N*
N*       Drawing of floating point values
N*/
Nvoid GUI_DispFloat    (float v, char Len);
Nvoid GUI_DispFloatFix (float v, char Len, char Fract);
Nvoid GUI_DispFloatMin (float v, char Fract);
Nvoid GUI_DispSFloatFix(float v, char Len, char Fract);
Nvoid GUI_DispSFloatMin(float v, char Fract);
N
N/*********************************************************************
N*
N*       Dynamic memory management
N*/
Ntypedef struct {
N  U32 TotalBytes;
X  unsigned long TotalBytes;
N  U32 FreeBytes;
X  unsigned long FreeBytes;
N  U32 UsedBytes;
X  unsigned long UsedBytes;
N  U32 AllocSize;
X  unsigned long AllocSize;
N  U32 NumFixedBytes;
X  unsigned long NumFixedBytes;
N  U32 MaxUsedBytes;
X  unsigned long MaxUsedBytes;
N} GUI_ALLOC_INFO;
N
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBlocks(void);
Xsigned long GUI_ALLOC_GetNumFreeBlocks(void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes (void);
Xsigned long GUI_ALLOC_GetNumFreeBytes (void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBlocks(void);
Xsigned long GUI_ALLOC_GetNumUsedBlocks(void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBytes (void);
Xsigned long GUI_ALLOC_GetNumUsedBytes (void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxUsedBytes (void);
Xsigned long GUI_ALLOC_GetMaxUsedBytes (void);
N
Nvoid GUI_ALLOC_GetMemInfo  (GUI_ALLOC_INFO * pInfo);
Nvoid GUI_ALLOC_SuppressPeak(int OnOff);
N
NGUI_HMEM           GUI_ALLOC_AllocInit       (const void * pInitData, GUI_ALLOC_DATATYPE Size);
Xsigned long           GUI_ALLOC_AllocInit       (const void * pInitData, signed long Size);
NGUI_HMEM           GUI_ALLOC_AllocNoInit     (GUI_ALLOC_DATATYPE size);
Xsigned long           GUI_ALLOC_AllocNoInit     (signed long size);
NGUI_HMEM           GUI_ALLOC_AllocZero       (GUI_ALLOC_DATATYPE size);
Xsigned long           GUI_ALLOC_AllocZero       (signed long size);
Nvoid               GUI_ALLOC_AssignMemory    (void * p, U32 NumBytes);
Xvoid               GUI_ALLOC_AssignMemory    (void * p, unsigned long NumBytes);
Nvoid               GUI_ALLOC_Free            (GUI_HMEM  hMem);
Xvoid               GUI_ALLOC_Free            (signed long  hMem);
Nvoid               GUI_ALLOC_FreeFixedBlock  (void * p);
Nvoid               GUI_ALLOC_FreePtrArray    (GUI_HMEM * pArray, int NumElems);
Xvoid               GUI_ALLOC_FreePtrArray    (signed long * pArray, int NumElems);
Nvoid               GUI_ALLOC_FreePtr         (GUI_HMEM * phMem);
Xvoid               GUI_ALLOC_FreePtr         (signed long * phMem);
Nvoid *             GUI_ALLOC_GetFixedBlock   (GUI_ALLOC_DATATYPE Size);
Xvoid *             GUI_ALLOC_GetFixedBlock   (signed long Size);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize      (void);
Xsigned long GUI_ALLOC_GetMaxSize      (void);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetSize         (GUI_HMEM  hMem);
Xsigned long GUI_ALLOC_GetSize         (signed long  hMem);
Nvoid *             GUI_ALLOC_h2p             (GUI_HMEM  hMem);
Xvoid *             GUI_ALLOC_h2p             (signed long  hMem);
NGUI_HMEM           GUI_ALLOC_p2h             (void * p);
Xsigned long           GUI_ALLOC_p2h             (void * p);
Nvoid               GUI_ALLOC_Init            (void);
Nvoid               GUI_ALLOC_Lock            (void);
Nvoid *             GUI_ALLOC_LockH           (GUI_HMEM  hMem);
Xvoid *             GUI_ALLOC_LockH           (signed long  hMem);
NGUI_HMEM           GUI_ALLOC_Realloc         (GUI_HMEM hOld, int NewSize);
Xsigned long           GUI_ALLOC_Realloc         (signed long hOld, int NewSize);
NGUI_ALLOC_DATATYPE GUI_ALLOC_RequestSize     (void);
Xsigned long GUI_ALLOC_RequestSize     (void);
Nvoid               GUI_ALLOC_SetAvBlockSize  (U32 BlockSize);
Xvoid               GUI_ALLOC_SetAvBlockSize  (unsigned long BlockSize);
Nvoid               GUI_ALLOC_Unlock          (void);
Nvoid *             GUI_ALLOC_UnlockH         (void ** pp);
Nint                GUI_ALLOC_SetMaxPercentage(int MaxPercentage);
Nvoid               GUI_ALLOC_Exit            (void);
N
N/*********************************************************************
N*
N*       Memory devices: GUI_MEMDEV
N*/
N#define GUI_MEMDEV_HASTRANS       0
N#define GUI_MEMDEV_NOTRANS  (1 << 0)
N
Ntypedef GUI_HMEM GUI_MEMDEV_Handle;
Xtypedef signed long GUI_MEMDEV_Handle;
Ntypedef void     GUI_CALLBACK_VOID_P        (void * p);
Ntypedef int      GUI_ANIMATION_CALLBACK_FUNC(int TimeRem, void * pVoid);
Ntypedef void     GUI_DRAWMEMDEV_16BPP_FUNC  (void * pDst, const void * pSrc, int xSize, int ySize, int BytesPerLineDst, int BytesPerLineSrc);
N
N#define GUI_DRAWMEMDEV_FUNC GUI_DRAWMEMDEV_16BPP_FUNC
N
Ntypedef void GUI_DRAWBITMAP_FUNC (int LayerIndex, int x, int y, const void * p, int xSize, int ySize, int BytesPerLine);
N
Nint GUI_SetFuncDrawAlpha(GUI_DRAWMEMDEV_FUNC * pfDrawMemdevFunc, GUI_DRAWBITMAP_FUNC * pfDrawBitmapFunc);
Xint GUI_SetFuncDrawAlpha(GUI_DRAWMEMDEV_16BPP_FUNC * pfDrawMemdevFunc, GUI_DRAWBITMAP_FUNC * pfDrawBitmapFunc);
Nint GUI_SetFuncDrawM565 (GUI_DRAWMEMDEV_FUNC * pfDrawMemdevFunc, GUI_DRAWBITMAP_FUNC * pfDrawBitmapFunc);
Xint GUI_SetFuncDrawM565 (GUI_DRAWMEMDEV_16BPP_FUNC * pfDrawMemdevFunc, GUI_DRAWBITMAP_FUNC * pfDrawBitmapFunc);
N
Nextern GUI_ANIMATION_CALLBACK_FUNC * GUI_MEMDEV__pCbAnimation;
Nextern void                        * GUI_MEMDEV__pVoid;
N
Nextern void (* GUI_MEMDEV__pfMEMDEV_Write)    (GUI_MEMDEV_Handle hMem);
Nextern void (* GUI_MEMDEV__pfMEMDEV_CopyToLCD)(GUI_MEMDEV_Handle hMem);
N
Ntypedef struct {
N  GUI_RECT rView, rPrev;
N  char FirstCall;
N} GUI_AUTODEV;
N
Ntypedef struct {
N  char DrawFixed;
N  char IsMeasurement;
N} GUI_AUTODEV_INFO;
N
Nint  GUI_MEMDEV_CreateAuto(GUI_AUTODEV * pAutoDev);
Nvoid GUI_MEMDEV_DeleteAuto(GUI_AUTODEV * pAutoDev);
Nint  GUI_MEMDEV_DrawAuto  (GUI_AUTODEV * pAutoDev, GUI_AUTODEV_INFO * pAutoDevInfo, GUI_CALLBACK_VOID_P * pfDraw, void * pData);
N
N/* Create a memory device which is compatible to the selected LCD */
NGUI_MEMDEV_Handle GUI_MEMDEV_Create       (int x0, int y0, int xSize, int ySize);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateEx     (int x0, int y0, int xSize, int ySize, int Flags);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateFixed  (int x0, int y0, int xSize, int ySize, int Flags,
N                                           const GUI_DEVICE_API     * pDeviceAPI,
N                                           const LCD_API_COLOR_CONV * pColorConvAPI);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateFixed32(int x0, int y0, int xSize, int ySize);
N
Nvoid GUI_MEMDEV_Clear                (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_ClearAlpha           (GUI_MEMDEV_Handle hMemData, GUI_MEMDEV_Handle hMemMask);
Nvoid GUI_MEMDEV_CopyFromLCD          (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyFromLCDAA        (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyToLCD            (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyToLCDAA          (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_CopyToLCDAt          (GUI_MEMDEV_Handle hMem, int x, int y);
Nint  GUI_MEMDEV_CompareWithLCD       (GUI_MEMDEV_Handle hMem, int * px, int * py, int * pExp, int * pAct);
Nvoid GUI_MEMDEV_Delete               (GUI_MEMDEV_Handle MemDev);
Nvoid GUI_MEMDEV_DrawPerspectiveX     (GUI_MEMDEV_Handle hMem, int x, int y, int h0, int h1, int dx, int dy);
Nint  GUI_MEMDEV_GetXPos              (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_GetXSize             (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_GetYPos              (GUI_MEMDEV_Handle hMem);
Nint  GUI_MEMDEV_GetYSize             (GUI_MEMDEV_Handle hMem);
Nvoid GUI_MEMDEV_MarkDirty            (GUI_MEMDEV_Handle hMem, int x0, int y0, int x1, int y1);
Nvoid GUI_MEMDEV_ReduceYSize          (GUI_MEMDEV_Handle hMem, int YSize);
Nvoid GUI_MEMDEV_Rotate               (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
Nvoid GUI_MEMDEV_RotateAlpha          (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, U8 Alpha);
Xvoid GUI_MEMDEV_RotateAlpha          (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, unsigned char Alpha);
Nvoid GUI_MEMDEV_RotateHR             (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, I32 dx, I32 dy, int a, int Mag);
Xvoid GUI_MEMDEV_RotateHR             (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, signed long dx, signed long dy, int a, int Mag);
Nvoid GUI_MEMDEV__Rotate              (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, U32 Mask);
Xvoid GUI_MEMDEV__Rotate              (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, unsigned long Mask);
Nvoid GUI_MEMDEV__RotateHR            (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, I32 dx, I32 dy, int a, int Mag, U32 Mask);
Xvoid GUI_MEMDEV__RotateHR            (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, signed long dx, signed long dy, int a, int Mag, unsigned long Mask);
Nvoid GUI_MEMDEV_RotateHQ             (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
Nvoid GUI_MEMDEV_RotateHQAlpha        (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, U8 Alpha);
Xvoid GUI_MEMDEV_RotateHQAlpha        (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag, unsigned char Alpha);
Nvoid GUI_MEMDEV_RotateHQHR           (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, I32 dx, I32 dy, int a, int Mag);
Xvoid GUI_MEMDEV_RotateHQHR           (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, signed long dx, signed long dy, int a, int Mag);
Nvoid GUI_MEMDEV_RotateHQT            (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
Nvoid GUI_MEMDEV_RotateHQTI           (GUI_MEMDEV_Handle hSrc, GUI_MEMDEV_Handle hDst, int dx, int dy, int a, int Mag);
NGUI_MEMDEV_Handle GUI_MEMDEV_Select  (GUI_MEMDEV_Handle hMem);  /* Select (activate) a particular memory device. */
Nvoid  GUI_MEMDEV_SetOrg              (GUI_MEMDEV_Handle hMem, int x0, int y0);
Nvoid  GUI_MEMDEV_WriteAt             (GUI_MEMDEV_Handle hMem, int x, int y);
Nvoid  GUI_MEMDEV_Write               (GUI_MEMDEV_Handle hMem);
Nvoid  GUI_MEMDEV_WriteAlphaAt        (GUI_MEMDEV_Handle hMem, int Alpha, int x, int y);
Nvoid  GUI_MEMDEV_WriteAlpha          (GUI_MEMDEV_Handle hMem, int Alpha);
Nvoid  GUI_MEMDEV_WriteExAt           (GUI_MEMDEV_Handle hMem, int x, int y, int xMag, int yMag, int Alpha);
Nvoid  GUI_MEMDEV_WriteEx             (GUI_MEMDEV_Handle hMem, int xMag, int yMag, int Alpha);
Nvoid  GUI_MEMDEV_WriteOpaque         (GUI_MEMDEV_Handle hMem);
Nvoid  GUI_MEMDEV_WriteOpaqueAt       (GUI_MEMDEV_Handle hMem, int x, int y);
Nint   GUI_MEMDEV_Draw                (GUI_RECT * pRect, GUI_CALLBACK_VOID_P * pfDraw, void * pData, int NumLines, int Flags);
Nvoid* GUI_MEMDEV_GetDataPtr          (GUI_MEMDEV_Handle hMem);
Nvoid  GUI_MEMDEV_SetColorConv        (GUI_MEMDEV_Handle hMem, const LCD_API_COLOR_CONV * pColorConvAPI);
Nconst LCD_API_COLOR_CONV * GUI_MEMDEV_GetColorConv(GUI_MEMDEV_Handle hMemDev);
Nint   GUI_MEMDEV_GetBitsPerPixel     (GUI_MEMDEV_Handle hMemDev);
Nint   GUI_MEMDEV_FadeInDevices       (GUI_MEMDEV_Handle hMem0, GUI_MEMDEV_Handle hMem1, int Period);
Nint   GUI_MEMDEV_FadeOutDevices      (GUI_MEMDEV_Handle hMem0, GUI_MEMDEV_Handle hMem1, int Period);
Nvoid  GUI_MEMDEV_SerializeBMP        (GUI_MEMDEV_Handle hDev, GUI_CALLBACK_VOID_U8_P * pfSerialize, void * p);
Nvoid  GUI_MEMDEV_SetAnimationCallback(GUI_ANIMATION_CALLBACK_FUNC * pCbAnimation, void * pVoid);
Nvoid  GUI_MEMDEV__FadeDevice         (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, U8 Intens);
Xvoid  GUI_MEMDEV__FadeDevice         (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, unsigned char Intens);
Nvoid  GUI_MEMDEV__FadeDeviceEx       (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, U8 Intens, int xPosWin, int yPosWin);
Xvoid  GUI_MEMDEV__FadeDeviceEx       (GUI_MEMDEV_Handle hMemWin, GUI_MEMDEV_Handle hMemBk, GUI_MEMDEV_Handle hMemDst, unsigned char Intens, int xPosWin, int yPosWin);
Nint   GUI_MEMDEV_PunchOutDevice      (GUI_MEMDEV_Handle hMemData, GUI_MEMDEV_Handle hMemMask);
Nvoid  GUI_MEMDEV_SetTimePerFrame     (unsigned TimePerFrame);
Nint   GUI_MEMDEV_MULTIBUF_Enable     (int OnOff);
N
Nvoid  GUI_SelectLCD(void);
N
N/* Blurring, dithering and blending */
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32  (GUI_MEMDEV_Handle hMem, U8 Depth);
XGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32  (GUI_MEMDEV_Handle hMem, unsigned char Depth);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32HQ(GUI_MEMDEV_Handle hMem, U8 Depth);
XGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32HQ(GUI_MEMDEV_Handle hMem, unsigned char Depth);
NGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32LQ(GUI_MEMDEV_Handle hMem, U8 Depth);
XGUI_MEMDEV_Handle GUI_MEMDEV_CreateBlurredDevice32LQ(GUI_MEMDEV_Handle hMem, unsigned char Depth);
Nvoid              GUI_MEMDEV_SetBlurHQ              (void);
Nvoid              GUI_MEMDEV_SetBlurLQ              (void);
Nint               GUI_MEMDEV_BlendColor32           (GUI_MEMDEV_Handle hMem, U32 BlendColor, U8 BlendIntens);
Xint               GUI_MEMDEV_BlendColor32           (GUI_MEMDEV_Handle hMem, unsigned long BlendColor, unsigned char BlendIntens);
Nint               GUI_MEMDEV_Dither32               (GUI_MEMDEV_Handle hMem, const LCD_API_COLOR_CONV * pColorConvAPI);
N
N/* Optional custom drawing of 16bpp memory devices */
Nvoid GUI_MEMDEV_SetDrawMemdev16bppFunc(GUI_DRAWMEMDEV_16BPP_FUNC * pfDrawMemdev16bppFunc);
N
N/*********************************************************************
N*
N*       Alpha blending
N*/
Ntypedef struct {
N  U32 UserAlpha;
X  unsigned long UserAlpha;
N} GUI_ALPHA_STATE;
N
N#define GUI_MAKE_ALPHA(Alpha, Color) ((U32)(((U32)Alpha << 24) | (Color & 0xFFFFFF)))
N
Nunsigned     GUI_EnableAlpha         (unsigned OnOff);
NU32          GUI_RestoreUserAlpha    (GUI_ALPHA_STATE * pAlphaState);
Xunsigned long          GUI_RestoreUserAlpha    (GUI_ALPHA_STATE * pAlphaState);
Nunsigned     GUI_SetAlpha            (U8 Alpha);
Xunsigned     GUI_SetAlpha            (unsigned char Alpha);
NU32          GUI_SetUserAlpha        (GUI_ALPHA_STATE * pAlphaState, U32 UserAlpha);
Xunsigned long          GUI_SetUserAlpha        (GUI_ALPHA_STATE * pAlphaState, unsigned long UserAlpha);
Nvoid      (* GUI_SetFuncAlphaBlending(void (* pfAlphaBlending)(LCD_COLOR *, LCD_COLOR *, LCD_COLOR *, U32)))
Xvoid      (* GUI_SetFuncAlphaBlending(void (* pfAlphaBlending)(LCD_COLOR *, LCD_COLOR *, LCD_COLOR *, unsigned long)))
N                                                              (LCD_COLOR *, LCD_COLOR *, LCD_COLOR *, U32);
X                                                              (LCD_COLOR *, LCD_COLOR *, LCD_COLOR *, unsigned long);
NLCD_COLOR (* GUI_SetFuncMixColors    (LCD_COLOR (* pFunc)(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens)))
XLCD_COLOR (* GUI_SetFuncMixColors    (LCD_COLOR (* pFunc)(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens)))
N                                                         (LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
X                                                         (LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
Nvoid      (* GUI_SetFuncMixColorsBulk(void (* pFunc)(U32 * pFG, U32 * pBG, U32 * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, U8 Intens)))
Xvoid      (* GUI_SetFuncMixColorsBulk(void (* pFunc)(unsigned long * pFG, unsigned long * pBG, unsigned long * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, unsigned char Intens)))
N                                                    (U32 * pFG, U32 * pBG, U32 * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, U8 Intens);
X                                                    (unsigned long * pFG, unsigned long * pBG, unsigned long * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, unsigned char Intens);
Nunsigned     GUI_PreserveTrans       (unsigned OnOff);
N
N/*********************************************************************
N*
N*       Multi layer support
N*/
Nunsigned GUI_SelectLayer(unsigned Index);
Nunsigned GUI_GetSelLayer(void);
N
Nint  GUI_SetLayerPosEx  (unsigned Index, int xPos, int yPos);
Nint  GUI_SetLayerSizeEx (unsigned Index, int xSize, int ySize);
Nint  GUI_SetLayerVisEx  (unsigned Index, int OnOff);
Nint  GUI_SetLayerAlphaEx(unsigned Index, int Alpha);
Nint  GUI_GetLayerPosEx  (unsigned Index, int * pxPos, int * pyPos);
N
Nvoid     GUI_AssignCursorLayer(unsigned Index, unsigned CursorLayer);
Nunsigned GUI_GetCursorLayer   (unsigned Index);
N
N/*********************************************************************
N*
N*       Multiple buffers and display origin
N*/
Nvoid GUI_SetOrg(int x, int y);
N
Nvoid GUI_MULTIBUF_Begin          (void);
Nvoid GUI_MULTIBUF_BeginEx        (int LayerIndex);
Nvoid GUI_MULTIBUF_End            (void);
Nvoid GUI_MULTIBUF_EndEx          (int LayerIndex);
Nvoid GUI_MULTIBUF_Config         (int NumBuffers);
Nvoid GUI_MULTIBUF_ConfigEx       (int LayerIndex, int NumBuffers);
Nvoid GUI_MULTIBUF_Confirm        (int Index);
Nvoid GUI_MULTIBUF_ConfirmEx      (int LayerIndex, int BufferIndex);
Nint  GUI_MULTIBUF_GetNumBuffers  (void);
Nint  GUI_MULTIBUF_GetNumBuffersEx(int LayerIndex);
Nvoid GUI_MULTIBUF_SetLayerMask   (U32 LayerMask);
Xvoid GUI_MULTIBUF_SetLayerMask   (unsigned long LayerMask);
Nvoid GUI_MULTIBUF_UseSingleBuffer(void);
N
N/*********************************************************************
N*
N*       emWinSPY
N*/
Nint  GUI_SPY_Process      (GUI_tSend pfSend, GUI_tRecv pfRecv, void * pConnectInfo);
Nvoid GUI_SPY_SetMemHandler(GUI_tMalloc pMalloc, GUI_tFree pFree);
Nint  GUI_SPY_StartServer  (void);
Nint  GUI_SPY_StartServerEx(int (* pGUI_SPY_X_StartServer)(void));
Nint  GUI_SPY_X_StartServer(void);
N
N/*********************************************************************
N*
N*       QR-Codes
N*/
N#define GUI_QR_ECLEVEL_L 0
N#define GUI_QR_ECLEVEL_M 1
N#define GUI_QR_ECLEVEL_Q 2
N#define GUI_QR_ECLEVEL_H 3
N
Ntypedef struct {
N  int Version;  // Version according to QR code documentation
N  int Width;    // Number of 'Modules'
N  int Size;     // Size of bitmap in pixels
N} GUI_QR_INFO;
N
NGUI_HMEM GUI_QR_Create (const char * pText, int PixelSize, int EccLevel, int Version);
Xsigned long GUI_QR_Create (const char * pText, int PixelSize, int EccLevel, int Version);
Nvoid     GUI_QR_Draw   (GUI_HMEM hQR, int xPos, int yPos);
Xvoid     GUI_QR_Draw   (signed long hQR, int xPos, int yPos);
Nvoid     GUI_QR_GetInfo(GUI_HMEM hQR, GUI_QR_INFO * pInfo);
Xvoid     GUI_QR_GetInfo(signed long hQR, GUI_QR_INFO * pInfo);
Nvoid     GUI_QR_Delete (GUI_HMEM hQR);
Xvoid     GUI_QR_Delete (signed long hQR);
N
N/*********************************************************************
N*
N*       Basics for animations
N*/
N#define ANIM_LINEAR     GUI_ANIM__Linear
N#define ANIM_ACCEL      GUI_ANIM__Accel
N#define ANIM_DECEL      GUI_ANIM__Decel
N#define ANIM_ACCELDECEL GUI_ANIM__AccelDecel
N
N#define GUI_ANIM_START   0
N#define GUI_ANIM_RUNNING 1
N#define GUI_ANIM_END     2
N
N#ifndef   GUI_ANIM_RANGE
N  #define GUI_ANIM_RANGE 32767L
N#endif
N
Ntypedef GUI_HMEM GUI_ANIM_HANDLE;
Xtypedef signed long GUI_ANIM_HANDLE;
N
Ntypedef I32 (* GUI_ANIM_GETPOS_FUNC)(GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xtypedef signed long (* GUI_ANIM_GETPOS_FUNC)(int ts, int te, int tNow);
N
Ntypedef struct {
N  int Pos;
N  int State;
N  GUI_ANIM_HANDLE hAnim;
N  GUI_TIMER_TIME Period;
X  int Period;
N} GUI_ANIM_INFO;
N
Ntypedef void GUI_ANIMATION_FUNC(GUI_ANIM_INFO * pInfo, void * pVoid);
N
NI32 GUI_ANIM__Linear    (GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__Linear    (int ts, int te, int tNow);
NI32 GUI_ANIM__Decel     (GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__Decel     (int ts, int te, int tNow);
NI32 GUI_ANIM__Accel     (GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__Accel     (int ts, int te, int tNow);
NI32 GUI_ANIM__AccelDecel(GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_TIMER_TIME tNow);
Xsigned long GUI_ANIM__AccelDecel(int ts, int te, int tNow);
N
Nint             GUI_ANIM_AddItem(GUI_ANIM_HANDLE hAnim, GUI_TIMER_TIME ts, GUI_TIMER_TIME te, GUI_ANIM_GETPOS_FUNC pfGetPos, void * pVoid, GUI_ANIMATION_FUNC * pfAnim);
Xint             GUI_ANIM_AddItem(GUI_ANIM_HANDLE hAnim, int ts, int te, GUI_ANIM_GETPOS_FUNC pfGetPos, void * pVoid, GUI_ANIMATION_FUNC * pfAnim);
NGUI_ANIM_HANDLE GUI_ANIM_Create (GUI_TIMER_TIME Period, unsigned MinTimePerFrame, void * pVoid, void (* pfSliceInfo)(int State, void * _pVoid));
XGUI_ANIM_HANDLE GUI_ANIM_Create (int Period, unsigned MinTimePerFrame, void * pVoid, void (* pfSliceInfo)(int State, void * _pVoid));
Nvoid            GUI_ANIM_Delete (GUI_ANIM_HANDLE hAnim);
Nint             GUI_ANIM_Exec   (GUI_ANIM_HANDLE hAnim);
Nvoid            GUI_ANIM_Start  (GUI_ANIM_HANDLE hAnim);
Nvoid            GUI_ANIM_StartEx(GUI_ANIM_HANDLE hAnim, int NumLoops, void (* pfOnDelete)(void * pVoid));
Nvoid            GUI_ANIM_Stop   (GUI_ANIM_HANDLE hAnim);
N
N/*********************************************************************
N*
N*       Display orientation
N*/
N/*********************************************************************
N*
N*       GUI_ORIENTATION_API
N*/
Ntypedef struct {
N  void           (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const U8 * pData, int Diff, const LCD_PIXELINDEX * pTrans);
X  void           (* pfDrawBitmap   )(GUI_DEVICE * pDevice, int x0, int y0, int xsize, int ysize, int BitsPerPixel, int BytesPerLine, const unsigned char * pData, int Diff, const unsigned long * pTrans);
N  void           (* pfDrawHLine    )(GUI_DEVICE * pDevice, int x0, int y0,  int x1);
N  void           (* pfDrawVLine    )(GUI_DEVICE * pDevice, int x , int y0,  int y1);
N  void           (* pfFillRect     )(GUI_DEVICE * pDevice, int x0, int y0, int x1, int y1);
N  LCD_PIXELINDEX (* pfGetPixelIndex)(GUI_DEVICE * pDevice, int x, int y);
X  unsigned long (* pfGetPixelIndex)(GUI_DEVICE * pDevice, int x, int y);
N  void           (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, LCD_PIXELINDEX ColorIndex);
X  void           (* pfSetPixelIndex)(GUI_DEVICE * pDevice, int x, int y, unsigned long ColorIndex);
N  void           (* pfXorPixel     )(GUI_DEVICE * pDevice, int x, int y);
N  int            BytesPerPixel;
N} GUI_ORIENTATION_API;
N
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C0;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C8;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C16;
Nextern const GUI_ORIENTATION_API GUI_OrientationAPI_C32;
N
N#define GUI_ORIENTATION_C0  &GUI_OrientationAPI_C0
N#define GUI_ORIENTATION_C8  &GUI_OrientationAPI_C8
N#define GUI_ORIENTATION_C16 &GUI_OrientationAPI_C16
N#define GUI_ORIENTATION_C32 &GUI_OrientationAPI_C32
N
Nint GUI_SetOrientation        (int Orientation);
Nint GUI_SetOrientationEx      (int Orientation, int LayerIndex);
Nint GUI_SetOrientationExCached(int Orientation, int LayerIndex, const GUI_ORIENTATION_API * pAPI);
N
N/*********************************************************************
N*
N*       Measure device: GUI_MEASDEV
N*/
Ntypedef GUI_HMEM GUI_MEASDEV_Handle;
Xtypedef signed long GUI_MEASDEV_Handle;
N
NGUI_MEASDEV_Handle GUI_MEASDEV_Create (void);
Nvoid               GUI_MEASDEV_Delete (GUI_MEASDEV_Handle hMemDev);
Nvoid               GUI_MEASDEV_Select (GUI_MEASDEV_Handle hMem);
Nvoid               GUI_MEASDEV_GetRect(GUI_MEASDEV_Handle hMem, GUI_RECT * pRect);
Nvoid               GUI_MEASDEV_ClearRect(GUI_MEASDEV_Handle hMem);
N
N/*********************************************************************
N*
N*       Polygon helpers
N*/
Nvoid GUI_RotatePolygon (GUI_POINT * pDest, const GUI_POINT * pSrc, int NumPoints, float Angle);
Nvoid GUI_MagnifyPolygon(GUI_POINT * pDest, const GUI_POINT * pSrc, int NumPoints, int Mag);
Nvoid GUI_EnlargePolygon(GUI_POINT * pDest, const GUI_POINT * pSrc, int NumPoints, int Len);
N
N/*********************************************************************
N*
N*       Streamed bitmaps
N*/
N#define GUI_BITMAPSTREAM_GET_BUFFER     1
N#define GUI_BITMAPSTREAM_RELEASE_BUFFER 2
N#define GUI_BITMAPSTREAM_MODIFY_PALETTE 3
N
N#define DECLARE_CREATE_FROM_STREAM(ID) int GUI_CreateBitmapFromStream##ID(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
N
NDECLARE_CREATE_FROM_STREAM(IDX)
Xint GUI_CreateBitmapFromStreamIDX(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE4)
Xint GUI_CreateBitmapFromStreamRLE4(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE8)
Xint GUI_CreateBitmapFromStreamRLE8(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(565)
Xint GUI_CreateBitmapFromStream565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M565)
Xint GUI_CreateBitmapFromStreamM565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(555)
Xint GUI_CreateBitmapFromStream555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M555)
Xint GUI_CreateBitmapFromStreamM555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(A565)
Xint GUI_CreateBitmapFromStreamA565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(AM565)
Xint GUI_CreateBitmapFromStreamAM565(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(A555)
Xint GUI_CreateBitmapFromStreamA555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(AM555)
Xint GUI_CreateBitmapFromStreamAM555(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE16)
Xint GUI_CreateBitmapFromStreamRLE16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLEM16)
Xint GUI_CreateBitmapFromStreamRLEM16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(24)
Xint GUI_CreateBitmapFromStream24(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(Alpha)
Xint GUI_CreateBitmapFromStreamAlpha(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M8888I)
Xint GUI_CreateBitmapFromStreamM8888I(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLEAlpha)
Xint GUI_CreateBitmapFromStreamRLEAlpha(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(RLE32)
Xint GUI_CreateBitmapFromStreamRLE32(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(444_12)
Xint GUI_CreateBitmapFromStream444_12(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M444_12)
Xint GUI_CreateBitmapFromStreamM444_12(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(444_12_1)
Xint GUI_CreateBitmapFromStream444_12_1(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M444_12_1)
Xint GUI_CreateBitmapFromStreamM444_12_1(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(444_16)
Xint GUI_CreateBitmapFromStream444_16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
NDECLARE_CREATE_FROM_STREAM(M444_16)
Xint GUI_CreateBitmapFromStreamM444_16(GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
N
Nint  GUI_CreateBitmapFromStream   (GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const void * p);
Nvoid GUI_DrawStreamedBitmap       (const void * p, int x, int y);
Nvoid GUI_DrawStreamedBitmapAuto   (const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapEx     (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapExAuto (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap555Ex  (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapM555Ex (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap565Ex  (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapM565Ex (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapA555Ex (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapAM555Ex(GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapA565Ex (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmapAM565Ex(GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nint  GUI_DrawStreamedBitmap24Ex   (GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
Nvoid GUI_GetStreamedBitmapInfo    (const void * p, GUI_BITMAPSTREAM_INFO * pInfo);
Nint  GUI_GetStreamedBitmapInfoEx  (GUI_GET_DATA_FUNC * pfGetData, const void * p, GUI_BITMAPSTREAM_INFO * pInfo);
Nvoid GUI_SetStreamedBitmapHook    (GUI_BITMAPSTREAM_CALLBACK pfStreamedBitmapHook);
N
Nvoid LCD__RLE4_SetFunc (GUI_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off, const LCD_LOGPALETTE * pLogPal);
Xvoid LCD__RLE4_SetFunc (GUI_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off, const LCD_LOGPALETTE * pLogPal);
Nvoid LCD__RLE8_SetFunc (GUI_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off, const LCD_LOGPALETTE * pLogPal);
Xvoid LCD__RLE8_SetFunc (GUI_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off, const LCD_LOGPALETTE * pLogPal);
Nvoid LCD__RLE16_SetFunc(GUI_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off);
Xvoid LCD__RLE16_SetFunc(GUI_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off);
Nvoid LCD__RLE32_SetFunc(GUI_GET_DATA_FUNC * pfGetData, void * pVoid, U32 Off);
Xvoid LCD__RLE32_SetFunc(GUI_GET_DATA_FUNC * pfGetData, void * pVoid, unsigned long Off);
N
N/*********************************************************************
N*
N*       BMP-export
N*/
Nvoid GUI_BMP_Serialize     (GUI_CALLBACK_VOID_U8_P * pfSerialize, void * p);
Nvoid GUI_BMP_SerializeEx   (GUI_CALLBACK_VOID_U8_P * pfSerialize, int x0, int y0, int xSize, int ySize, void * p);
Nvoid GUI_BMP_SerializeExBpp(GUI_CALLBACK_VOID_U8_P * pfSerialize, int x0, int y0, int xSize, int ySize, void * p, int BitsPerPixel);
N
Nvoid GUI_BMP__WriteBitmapHeader(GUI_CALLBACK_VOID_U8_P * pfSerialize, int xSize, int ySize, void * p, int BitsPerPixel, int BytesPerLine, int BytesPerPixel, int NumColors, int Padding);
N
N/*********************************************************************
N*
N*       Time / execution related routines
N*/
Nvoid           GUI_Delay       (int Period);
NGUI_TIMER_TIME GUI_GetTime     (void);
Xint GUI_GetTime     (void);
Nint            GUI_GetTimeSlice(void);
Nint            GUI_Exec        (void);        /* Execute all jobs ... Return 0 if nothing was done. */
Nint            GUI_Exec1       (void);        /* Execute one job  ... Return 0 if nothing was done. */
Nvoid           GUI_SetTimeSlice(int TimeSlice);
N
N/*********************************************************************
N*
N*       MessageBox
N*/
Nint     GUI_MessageBox   (const char * sMessage, const char * sCaption, int Flags);
N#define GUI_MESSAGEBOX_CF_MOVEABLE (1 << 0)
N#define GUI_MESSAGEBOX_CF_MODAL    (1 << 1)
N
N#define GUI_MB_OK                20
N#define GUI_MB_WARNING           21
N
N/*********************************************************************
N*
N*       GUI_TIMER module
N*/
N#define GUI_TIMER_CF_WINDOW (1 << 0)
N#define GUI_TIMER_CF_CURSOR (1 << 1)
N
Ntypedef GUI_HMEM GUI_TIMER_HANDLE;
Xtypedef signed long GUI_TIMER_HANDLE;
N
Ntypedef struct {
N  GUI_TIMER_TIME   Time;
X  int   Time;
N  PTR_ADDR         Context;
X  unsigned long         Context;
N  GUI_TIMER_HANDLE hTimer;
N} GUI_TIMER_MESSAGE;
N
Ntypedef void GUI_TIMER_CALLBACK(/*const*/ GUI_TIMER_MESSAGE* pTM);
N
NGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK * cb, GUI_TIMER_TIME Time, PTR_ADDR Context, U16 Flags);
XGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK * cb, int Time, unsigned long Context, unsigned short Flags);
Nvoid             GUI_TIMER_Delete   (GUI_TIMER_HANDLE hObj);
N
N/* Methods changing properties */
NGUI_TIMER_TIME GUI_TIMER_GetPeriod(GUI_TIMER_HANDLE hObj);
Xint GUI_TIMER_GetPeriod(GUI_TIMER_HANDLE hObj);
Nvoid           GUI_TIMER_SetPeriod(GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Period);
Xvoid           GUI_TIMER_SetPeriod(GUI_TIMER_HANDLE hObj, int Period);
Nvoid           GUI_TIMER_SetTime  (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Period);
Xvoid           GUI_TIMER_SetTime  (GUI_TIMER_HANDLE hObj, int Period);
Nvoid           GUI_TIMER_SetDelay (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Delay);
Xvoid           GUI_TIMER_SetDelay (GUI_TIMER_HANDLE hObj, int Delay);
Nvoid           GUI_TIMER_Restart  (GUI_TIMER_HANDLE hObj);
Nint            GUI_TIMER_GetFlag  (GUI_TIMER_HANDLE hObj, int Flag); /* Not to be documented */
Nint            GUI_TIMER_Exec     (void);
N
N/*********************************************************************
N*
N*       Anti Aliasing
N*/
N#define GUI_AA_TRANS   0 // Foreground color mixed up with current content of framebuffer
N#define GUI_AA_NOTRANS 1 // Foreground color mixed up with current background color
N
Nvoid GUI_AA_DisableHiRes     (void);
Nvoid GUI_AA_EnableHiRes      (void);
Nint  GUI_AA_GetFactor        (void);
Nvoid GUI_AA_SetFactor        (int Factor);
Nvoid GUI_AA_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_AA_DrawCircle       (int x0, int y0, int r);  // Currently not implemented, only for Dave2D
Nvoid GUI_AA_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GUI_AA_DrawPolyOutline  (const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y);
Nvoid GUI_AA_DrawPolyOutlineEx(const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y, GUI_POINT * pBuffer);
Nvoid GUI_AA_DrawRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_AA_DrawRoundedRectEx(GUI_RECT * pRect, int r);
Nvoid GUI_AA_FillCircle       (int x0, int y0, int r);
Nvoid GUI_AA_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_AA_FillPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_AA_FillRoundedRect  (int x0, int y0, int x1, int y1, int r);
Nvoid GUI_AA_FillRoundedRectEx(GUI_RECT * pRect, int r);
Nint  GUI_AA_SetDrawMode      (int Mode);
Nvoid GUI_AA_SetpfDrawCharAA4 (int (* pfDrawChar)(int LayerIndex, int x, int y, U8 const * p, int xSize, int ySize, int BytesPerLine));
Xvoid GUI_AA_SetpfDrawCharAA4 (int (* pfDrawChar)(int LayerIndex, int x, int y, unsigned char const * p, int xSize, int ySize, int BytesPerLine));
Nvoid GUI_AA_SetGammaAA4      (U8 * pGamma);
Xvoid GUI_AA_SetGammaAA4      (unsigned char * pGamma);
Nvoid GUI_AA_GetGammaAA4      (U8 * pGamma);
Xvoid GUI_AA_GetGammaAA4      (unsigned char * pGamma);
Nvoid GUI_AA_EnableGammaAA4   (int OnOff);
N
N#define GUI_AA_PreserveTrans(OnOff) GUI_PreserveTrans(OnOff)  // For compatibility only
N
Nvoid GUI_AA_SetFuncDrawArc        (int (* pfDrawArc)    (int x0, int y0, int rx, int ry, int a0, int a1));
Nvoid GUI_AA_SetFuncDrawCircle     (int (* pfDrawCircle) (int x0, int y0, int r));
Nvoid GUI_AA_SetFuncDrawLine       (int (* pfDrawLine)   (int x0, int y0, int x1, int y1));
Nvoid GUI_AA_SetFuncDrawPolyOutline(int (* pfDrawPolyOutline)(const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y));
Nvoid GUI_AA_SetFuncFillCircle     (int (* pfFillCircle) (int x0, int y0, int r));
Nvoid GUI_AA_SetFuncFillPolygon    (int (* pfFillPolygon)(const GUI_POINT * pPoints, int NumPoints, int x0, int y0));
N
N/*********************************************************************
N*
N*       Keyboard
N*/
N/* Message layer */
Nvoid GUI_StoreKeyMsg(int Key, int Pressed);
Nvoid GUI_SendKeyMsg (int Key, int Pressed);
Nint  GUI_PollKeyMsg (void);
Nvoid GUI_GetKeyState(GUI_KEY_STATE * pState);
N
Nvoid GUI_KEY__SetHook(void (* pfHook)(const GUI_KEY_STATE *));
N
N/* Application layer */
Nint  GUI_GetKey(void);
Nint  GUI_WaitKey(void);
Nvoid GUI_StoreKey(int c);
Nvoid GUI_ClearKeyBuffer(void);
N
N/*********************************************************************
N*
N*       Task synchronization
N*/
Nvoid GUI_WaitEvent            (void);
Nvoid GUI_SignalEvent          (void);
Nvoid GUI_SetSignalEventFunc   (GUI_SIGNAL_EVENT_FUNC     pfSignalEvent);
Nvoid GUI_SetWaitEventFunc     (GUI_WAIT_EVENT_FUNC       pfWaitEvent);
Nvoid GUI_SetWaitEventTimedFunc(GUI_WAIT_EVENT_TIMED_FUNC pfWaitEventTimed);
N
N/*********************************************************************
N*
N*       Joystick, generic
N*/
Nvoid GUI_JOYSTICK_StoreState(const GUI_PID_STATE * pState);
N
N/*********************************************************************
N*
N*       PID  (Pointer input device ... mouse/touch)
N*/
Nvoid GUI_PID_StoreState     (const GUI_PID_STATE * pState);
Nint  GUI_PID_GetState       (      GUI_PID_STATE * pState);
Nvoid GUI_PID_GetCurrentState(      GUI_PID_STATE * pState);
Nint  GUI_PID_IsEmpty        (void);
Nint  GUI_PID_IsPressed      (void);
Nvoid GUI_PID_RegisterHook   (GUI_REGISTER_HOOK * pRegisterHook);
Nvoid GUI_PID_SetHook        (void (* pfHook)(      GUI_PID_STATE *));  // Public
Nvoid GUI_PID__SetHook       (void (* pfHook)(const GUI_PID_STATE *));  // Private
N
N/*********************************************************************
N*
N*       Mouse, generic
N*/
Nint  GUI_MOUSE_GetState  (      GUI_PID_STATE * pState);
Nvoid GUI_MOUSE_StoreState(const GUI_PID_STATE * pState);
N
N/*********************************************************************
N*
N*       TOUCH screen, generic
N*/
Nint  GUI_TOUCH_GetLayer     (void);
Nint  GUI_TOUCH_GetState     (GUI_PID_STATE * pState);
Nvoid GUI_TOUCH_GetUnstable  (int * px, int * py);  /* for diagnostics only */
Nvoid GUI_TOUCH_SetLayer     (int Layer);
Nvoid GUI_TOUCH_StoreState   (int x, int y);
Nvoid GUI_TOUCH_StoreStateEx (const GUI_PID_STATE * pState);
Nvoid GUI_TOUCH_StoreUnstable(int x, int y);
N
N/*********************************************************************
N*
N*       Mouse, PS2 driver
N*/
Nvoid GUI_MOUSE_DRIVER_PS2_Init(void);               /* optional */
Nvoid GUI_MOUSE_DRIVER_PS2_OnRx(unsigned char Data);
N
N/*********************************************************************
N*
N*       TOUCH screen, analog driver
N*/
Nint  GUI_TOUCH_CalcCoefficients (int NumPoints, int * pxRef, int * pyRef, int * pxSample, int * pySample, int xSize, int ySize);
Nint  GUI_TOUCH_Calibrate        (int Coord, int Log0, int Log1, int Phys0, int Phys1);
Nint  GUI_TOUCH_CalibratePoint   (int * px, int * py);
Nvoid GUI_TOUCH_EnableCalibration(int OnOff);
Nvoid GUI_TOUCH_Exec             (void);
Nint  GUI_TOUCH_GetxPhys         (void);    /* for diagnostics only */
Nint  GUI_TOUCH_GetyPhys         (void);    /* for diagnostics only */
Nvoid GUI_TOUCH_SetCalibration   (int (* pFunc)(int *, int *)); /* Not to be documented */
Nvoid GUI_TOUCH_SetOrientation   (unsigned Orientation);
Nint  GUI_TOUCH_TransformPoint   (int * px, int * py);          /* Not to be documented */
N
N/*********************************************************************
N*
N*       TOUCH: imports
N*
N* Please note: The following functions are required by the module.
N* They need to be part of your application software (or rather, part
N* of the hardware-layer of your software).
N*/
Nvoid GUI_TOUCH_X_ActivateX(void);
Nvoid GUI_TOUCH_X_ActivateY(void);
Nvoid GUI_TOUCH_X_Disable  (void);
Nint  GUI_TOUCH_X_MeasureX (void);
Nint  GUI_TOUCH_X_MeasureY (void);
N
N/*********************************************************************
N*
N*       GUI_X_
N*
N* Externals, to be defined by application
N*
N* The externals defined below should be defined by the
N* application. They are per default contained in the module
N* GUI_X.c.
N* Note that a lot if not all of these are not required in most target
N* systems.
N* For this module, samples are available for configurations
N* with or without operating system.
N*/
N//
N// Configuration
N//
Nvoid GUI_X_Config(void);
Nvoid GUI_X_Init  (void);
N
N//
N// Timing routines
N//
NGUI_TIMER_TIME GUI_X_GetTime(void);
Xint GUI_X_GetTime(void);
Nvoid           GUI_X_Delay  (int Period);
N
N//
N// Multitask routines - required only if multitasking is used (#define GUI_OS 1)
N//
Nvoid GUI_X_Unlock   (void);
Nvoid GUI_X_Lock     (void);
NU32  GUI_X_GetTaskId(void);
Xunsigned long  GUI_X_GetTaskId(void);
Nvoid GUI_X_InitOS   (void);
N
N//
N// Event driving (optional with multitasking)
N//
Nvoid GUI_X_ExecIdle      (void);
Nvoid GUI_X_WaitEvent     (void);
Nvoid GUI_X_WaitEventTimed(int Period);
Nvoid GUI_X_SignalEvent   (void);
N
N//
N// Recording (logs/warnings and errors) - required only for higher levels
N//
Nvoid GUI_X_Log     (const char * s);
Nvoid GUI_X_Warn    (const char * s);
Nvoid GUI_X_ErrorOut(const char * s);
N
N/*********************************************************************
N*
N*       Constants for fonts and bitmaps
N*/
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE4;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE4Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE8;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE8Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE16Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEM16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEM16Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE32;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE32Ex;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEAlpha;
N
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods444_12;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM444_12;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods444_12_1;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM444_12_1;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods444_16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM444_16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods24;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods8888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM8888I;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsA565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsAM565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsA555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsAM555;
N
N#define GUI_COMPRESS_RLE4 0
N#define GUI_COMPRESS_RLE8 0
N
N#define GUI_DRAW_RLE4         &GUI_BitmapMethodsRLE4       /* Method table ! */
N#define GUI_DRAW_RLE8         &GUI_BitmapMethodsRLE8       /* Method table ! */
N#define GUI_DRAW_RLE16        &GUI_BitmapMethodsRLE16      /* Method table ! */
N#define GUI_DRAW_RLEM16       &GUI_BitmapMethodsRLEM16     /* Method table ! */
N#define GUI_DRAW_RLE32        &GUI_BitmapMethodsRLE32      /* Method table ! */
N#define GUI_DRAW_RLEALPHA     &GUI_BitmapMethodsRLEAlpha   /* Method table ! */
N
N#define GUI_DRAW_BMP444_12    &GUI_BitmapMethods444_12     /* Method table ! */
N#define GUI_DRAW_BMPM444_12   &GUI_BitmapMethodsM444_12    /* Method table ! */
N#define GUI_DRAW_BMP444_12_1  &GUI_BitmapMethods444_12_1   /* Method table ! */
N#define GUI_DRAW_BMPM444_12_1 &GUI_BitmapMethodsM444_12_1  /* Method table ! */
N#define GUI_DRAW_BMP444_16    &GUI_BitmapMethods444_16     /* Method table ! */
N#define GUI_DRAW_BMPM444_16   &GUI_BitmapMethodsM444_16    /* Method table ! */
N#define GUI_DRAW_BMP555       &GUI_BitmapMethods555        /* Method table ! */
N#define GUI_DRAW_BMPM555      &GUI_BitmapMethodsM555       /* Method table ! */
N#define GUI_DRAW_BMP565       &GUI_BitmapMethods565        /* Method table ! */
N#define GUI_DRAW_BMPM565      &GUI_BitmapMethodsM565       /* Method table ! */
N#define GUI_DRAW_BMP24        &GUI_BitmapMethods24         /* Method table ! */
N#define GUI_DRAW_BMP888       &GUI_BitmapMethods888        /* Method table ! */
N#define GUI_DRAW_BMPM888      &GUI_BitmapMethodsM888       /* Method table ! */
N#define GUI_DRAW_BMP8888      &GUI_BitmapMethods8888       /* Method table ! */
N#define GUI_DRAW_BMPM8888I    &GUI_BitmapMethodsM8888I     /* Method table ! */
N#define GUI_DRAW_BMPA555      &GUI_BitmapMethodsA555       /* Method table ! */
N#define GUI_DRAW_BMPAM555     &GUI_BitmapMethodsAM555      /* Method table ! */
N#define GUI_DRAW_BMPA565      &GUI_BitmapMethodsA565       /* Method table ! */
N#define GUI_DRAW_BMPAM565     &GUI_BitmapMethodsAM565      /* Method table ! */
N
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_Ext;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_Frm;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA2;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA4;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA2_EXT;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA4_EXT;
N
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_Ext;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_Frm;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_AA2_Ext;
Nextern const tGUI_XBF_APIList GUI_XBF_APIList_Prop_AA4_Ext;
N
N/*********************************************************************
N*
N*       GUI_KEY_...
N*
N* These ID values are basically meant to be used with widgets
N* Note that we have chosen the values to be close to existing
N* "standards", so do not change them unless forced to.
N*
N*/
N#define GUI_KEY_BACKSPACE         8         /* ASCII: BACKSPACE Crtl-H */
N#define GUI_KEY_TAB               9         /* ASCII: TAB       Crtl-I */
N#define GUI_KEY_BACKTAB           10
N#define GUI_KEY_ENTER             13        /* ASCII: ENTER     Crtl-M */
N#define GUI_KEY_LEFT              16
N#define GUI_KEY_UP                17
N#define GUI_KEY_RIGHT             18
N#define GUI_KEY_DOWN              19
N#define GUI_KEY_HOME              23
N#define GUI_KEY_END               24
N#define GUI_KEY_SHIFT             25
N#define GUI_KEY_CONTROL           26
N#define GUI_KEY_ESCAPE            27        /* ASCII: ESCAPE    0x1b   */
N#define GUI_KEY_INSERT            29
N#define GUI_KEY_DELETE            30
N#define GUI_KEY_SPACE             32
N#define GUI_KEY_PGUP              33
N#define GUI_KEY_PGDOWN            34
N
N#define GUI_KEY_F1                40
N#define GUI_KEY_F2                41
N
N/*********************************************************************
N*
N*       Dialog item IDs
N*
N*  The IDs below are arbitrary values. They just have to be unique
N*  within the dialog.
N*
N*  If you use your own Ids, we recommend to use values above GUI_ID_USER.
N*/
N#define GUI_ID_OK                1
N#define GUI_ID_CANCEL            2
N#define GUI_ID_YES               3
N#define GUI_ID_NO                4
N#define GUI_ID_CLOSE             5
N#define GUI_ID_HELP              6
N#define GUI_ID_MAXIMIZE          7
N#define GUI_ID_MINIMIZE          8
N
N#define GUI_ID_VSCROLL    0xFE
N#define GUI_ID_HSCROLL    0xFF
N
N#define GUI_ID_EDIT0      0x100
N#define GUI_ID_EDIT1      0x101
N#define GUI_ID_EDIT2      0x102
N#define GUI_ID_EDIT3      0x103
N#define GUI_ID_EDIT4      0x104
N#define GUI_ID_EDIT5      0x105
N#define GUI_ID_EDIT6      0x106
N#define GUI_ID_EDIT7      0x107
N#define GUI_ID_EDIT8      0x108
N#define GUI_ID_EDIT9      0x109
N
N#define GUI_ID_LISTBOX0   0x110
N#define GUI_ID_LISTBOX1   0x111
N#define GUI_ID_LISTBOX2   0x112
N#define GUI_ID_LISTBOX3   0x113
N#define GUI_ID_LISTBOX4   0x114
N#define GUI_ID_LISTBOX5   0x115
N#define GUI_ID_LISTBOX6   0x116
N#define GUI_ID_LISTBOX7   0x117
N#define GUI_ID_LISTBOX8   0x118
N#define GUI_ID_LISTBOX9   0x119
N
N#define GUI_ID_CHECK0     0x120
N#define GUI_ID_CHECK1     0x121
N#define GUI_ID_CHECK2     0x122
N#define GUI_ID_CHECK3     0x123
N#define GUI_ID_CHECK4     0x124
N#define GUI_ID_CHECK5     0x125
N#define GUI_ID_CHECK6     0x126
N#define GUI_ID_CHECK7     0x127
N#define GUI_ID_CHECK8     0x128
N#define GUI_ID_CHECK9     0x129
N
N#define GUI_ID_SLIDER0    0x130
N#define GUI_ID_SLIDER1    0x131
N#define GUI_ID_SLIDER2    0x132
N#define GUI_ID_SLIDER3    0x133
N#define GUI_ID_SLIDER4    0x134
N#define GUI_ID_SLIDER5    0x135
N#define GUI_ID_SLIDER6    0x136
N#define GUI_ID_SLIDER7    0x137
N#define GUI_ID_SLIDER8    0x138
N#define GUI_ID_SLIDER9    0x139
N
N#define GUI_ID_SCROLLBAR0 0x140
N#define GUI_ID_SCROLLBAR1 0x141
N#define GUI_ID_SCROLLBAR2 0x142
N#define GUI_ID_SCROLLBAR3 0x143
N
N#define GUI_ID_RADIO0     0x150
N#define GUI_ID_RADIO1     0x151
N#define GUI_ID_RADIO2     0x152
N#define GUI_ID_RADIO3     0x153
N#define GUI_ID_RADIO4     0x154
N#define GUI_ID_RADIO5     0x155
N#define GUI_ID_RADIO6     0x156
N#define GUI_ID_RADIO7     0x157
N
N#define GUI_ID_TEXT0      0x160
N#define GUI_ID_TEXT1      0x161
N#define GUI_ID_TEXT2      0x162
N#define GUI_ID_TEXT3      0x163
N#define GUI_ID_TEXT4      0x164
N#define GUI_ID_TEXT5      0x165
N#define GUI_ID_TEXT6      0x166
N#define GUI_ID_TEXT7      0x167
N#define GUI_ID_TEXT8      0x168
N#define GUI_ID_TEXT9      0x169
N
N#define GUI_ID_BUTTON0    0x170
N#define GUI_ID_BUTTON1    0x171
N#define GUI_ID_BUTTON2    0x172
N#define GUI_ID_BUTTON3    0x173
N#define GUI_ID_BUTTON4    0x174
N#define GUI_ID_BUTTON5    0x175
N#define GUI_ID_BUTTON6    0x176
N#define GUI_ID_BUTTON7    0x177
N#define GUI_ID_BUTTON8    0x178
N#define GUI_ID_BUTTON9    0x179
N
N#define GUI_ID_DROPDOWN0  0x180
N#define GUI_ID_DROPDOWN1  0x181
N#define GUI_ID_DROPDOWN2  0x182
N#define GUI_ID_DROPDOWN3  0x183
N
N#define GUI_ID_MULTIEDIT0 0x190
N#define GUI_ID_MULTIEDIT1 0x191
N#define GUI_ID_MULTIEDIT2 0x192
N#define GUI_ID_MULTIEDIT3 0x193
N
N#define GUI_ID_LISTVIEW0  0x200
N#define GUI_ID_LISTVIEW1  0x201
N#define GUI_ID_LISTVIEW2  0x202
N#define GUI_ID_LISTVIEW3  0x203
N
N#define GUI_ID_PROGBAR0   0x210
N#define GUI_ID_PROGBAR1   0x211
N#define GUI_ID_PROGBAR2   0x212
N#define GUI_ID_PROGBAR3   0x213
N
N#define GUI_ID_GRAPH0     0x220
N#define GUI_ID_GRAPH1     0x221
N#define GUI_ID_GRAPH2     0x222
N#define GUI_ID_GRAPH3     0x223
N
N#define GUI_ID_MULTIPAGE0 0x230
N#define GUI_ID_MULTIPAGE1 0x231
N#define GUI_ID_MULTIPAGE2 0x232
N#define GUI_ID_MULTIPAGE3 0x233
N
N#define GUI_ID_TREEVIEW0  0x240
N#define GUI_ID_TREEVIEW1  0x241
N#define GUI_ID_TREEVIEW2  0x242
N#define GUI_ID_TREEVIEW3  0x243
N
N#define GUI_ID_ICONVIEW0  0x250
N#define GUI_ID_ICONVIEW1  0x251
N#define GUI_ID_ICONVIEW2  0x252
N#define GUI_ID_ICONVIEW3  0x253
N
N#define GUI_ID_LISTWHEEL0 0x260
N#define GUI_ID_LISTWHEEL1 0x261
N#define GUI_ID_LISTWHEEL2 0x262
N#define GUI_ID_LISTWHEEL3 0x263
N
N#define GUI_ID_IMAGE0     0x270
N#define GUI_ID_IMAGE1     0x271
N#define GUI_ID_IMAGE2     0x272
N#define GUI_ID_IMAGE3     0x273
N#define GUI_ID_IMAGE4     0x274
N#define GUI_ID_IMAGE5     0x275
N#define GUI_ID_IMAGE6     0x276
N#define GUI_ID_IMAGE7     0x277
N#define GUI_ID_IMAGE8     0x278
N#define GUI_ID_IMAGE9     0x279
N
N#define GUI_ID_SPINBOX0   0x280
N#define GUI_ID_SPINBOX1   0x281
N#define GUI_ID_SPINBOX2   0x282
N#define GUI_ID_SPINBOX3   0x283
N#define GUI_ID_SPINBOX4   0x284
N#define GUI_ID_SPINBOX5   0x285
N#define GUI_ID_SPINBOX6   0x286
N#define GUI_ID_SPINBOX7   0x287
N#define GUI_ID_SPINBOX8   0x288
N#define GUI_ID_SPINBOX9   0x289
N
N#define GUI_ID_CALENDAR0  0x290
N
N#define GUI_ID_KNOB0      0x300
N#define GUI_ID_KNOB1      0x301
N#define GUI_ID_KNOB2      0x302
N#define GUI_ID_KNOB3      0x303
N#define GUI_ID_KNOB4      0x304
N#define GUI_ID_KNOB5      0x305
N#define GUI_ID_KNOB6      0x306
N#define GUI_ID_KNOB7      0x307
N#define GUI_ID_KNOB8      0x308
N#define GUI_ID_KNOB9      0x309
N
N#define GUI_ID_SWIPELIST0 0x320
N#define GUI_ID_SWIPELIST1 0x321
N#define GUI_ID_SWIPELIST2 0x322
N
N#define GUI_ID_USER       0x800
N
N/*********************************************************************
N*
N*       Mouse buttons
N*/
N#define GUI_LBUTTON (1 << 0) /* Left button */
N#define GUI_RBUTTON (1 << 1) /* Right button */
N#define GUI_MBUTTON (1 << 2) /* Middle button */
N#define GUI_DBUTTON (1 << 7) /* Double-click button */
N
N/*********************************************************************
N*
N*       Text styles
N*/
N#define GUI_TS_NORMAL           (0)
N#define GUI_TS_UNDERLINE        (1 << 0)
N#define GUI_TS_STRIKETHRU       (1 << 1)
N#define GUI_TS_OVERLINE         (1 << 2)
N
N/*********************************************************************
N*
N*       Line styles
N*/
N#define GUI_LS_SOLID        (0)
N#define GUI_LS_DASH         (1)
N#define GUI_LS_DOT          (2)
N#define GUI_LS_DASHDOT      (3)
N#define GUI_LS_DASHDOTDOT   (4)
N
N/*********************************************************************
N*
N*       Pen shapes
N*/
N#define GUI_PS_ROUND        (0)
N#define GUI_PS_FLAT         (1)
N#define GUI_PS_SQUARE       (2)
N
N/*********************************************************************
N*
N*       Standard colors
N*/
N#define GUI_INVALID_COLOR ((((U32)GUI_TRANS_BYTE) << 24) | 0x12345678ul)  /* Invalid color (transparency + determined color) */
N
N#if (GUI_USE_ARGB)
X#if (1)
N  #define GUI_MAKE_COLOR(ABGR)  (((((U32)ABGR) & 0xFF000000ul) ^ 0xFF000000ul) | ((((U32)ABGR) & 0x00FF0000ul) >> 16) | (((U32)ABGR) & 0x0000FF00ul) | ((((U32)ABGR) & 0x000000FFul) << 16))
N  #define GUI_MAKE_TRANS(Alpha) (255 - (Alpha))
N#else
S  #define GUI_MAKE_COLOR(ABGR)  (ABGR)
S  #define GUI_MAKE_TRANS(Alpha) (Alpha)
N#endif
N
N#if (GUI_USE_ARGB)
X#if (1)
N  #define GUI_TRANS_BYTE 0x00
N#else
S  #define GUI_TRANS_BYTE 0xFF
N#endif
N
N#define GUI_BLUE          GUI_MAKE_COLOR(0x00FF0000)
N#define GUI_GREEN         GUI_MAKE_COLOR(0x0000FF00)
N#define GUI_RED           GUI_MAKE_COLOR(0x000000FF)
N#define GUI_CYAN          GUI_MAKE_COLOR(0x00FFFF00)
N#define GUI_MAGENTA       GUI_MAKE_COLOR(0x00FF00FF)
N#define GUI_YELLOW        GUI_MAKE_COLOR(0x0000FFFF)
N#define GUI_LIGHTBLUE     GUI_MAKE_COLOR(0x00FF8080)
N#define GUI_LIGHTGREEN    GUI_MAKE_COLOR(0x0080FF80)
N#define GUI_LIGHTRED      GUI_MAKE_COLOR(0x008080FF)
N#define GUI_LIGHTCYAN     GUI_MAKE_COLOR(0x00FFFF80)
N#define GUI_LIGHTMAGENTA  GUI_MAKE_COLOR(0x00FF80FF)
N#define GUI_LIGHTYELLOW   GUI_MAKE_COLOR(0x0080FFFF)
N#define GUI_DARKBLUE      GUI_MAKE_COLOR(0x00800000)
N#define GUI_DARKGREEN     GUI_MAKE_COLOR(0x00008000)
N#define GUI_DARKRED       GUI_MAKE_COLOR(0x00000080)
N#define GUI_DARKCYAN      GUI_MAKE_COLOR(0x00808000)
N#define GUI_DARKMAGENTA   GUI_MAKE_COLOR(0x00800080)
N#define GUI_DARKYELLOW    GUI_MAKE_COLOR(0x00008080)
N#define GUI_WHITE         GUI_MAKE_COLOR(0x00FFFFFF)
N#define GUI_LIGHTGRAY     GUI_MAKE_COLOR(0x00D3D3D3)
N#define GUI_GRAY          GUI_MAKE_COLOR(0x00808080)
N#define GUI_DARKGRAY      GUI_MAKE_COLOR(0x00404040)
N#define GUI_BLACK         GUI_MAKE_COLOR(0x00000000)
N#define GUI_BROWN         GUI_MAKE_COLOR(0x002A2AA5)
N#define GUI_ORANGE        GUI_MAKE_COLOR(0x0000A5FF)
N#define GUI_TRANSPARENT   GUI_MAKE_COLOR(0xFF000000)
N
N#define GUI_GRAY_3F       GUI_MAKE_COLOR(0x003F3F3F)
N#define GUI_GRAY_50       GUI_MAKE_COLOR(0x00505050)
N#define GUI_GRAY_55       GUI_MAKE_COLOR(0x00555555)
N#define GUI_GRAY_60       GUI_MAKE_COLOR(0x00606060)
N#define GUI_GRAY_7C       GUI_MAKE_COLOR(0x007C7C7C)
N#define GUI_GRAY_9A       GUI_MAKE_COLOR(0x009A9A9A)
N#define GUI_GRAY_AA       GUI_MAKE_COLOR(0x00AAAAAA)
N#define GUI_GRAY_C0       GUI_MAKE_COLOR(0x00C0C0C0)
N#define GUI_GRAY_C8       GUI_MAKE_COLOR(0x00C8C8C8)
N#define GUI_GRAY_D0       GUI_MAKE_COLOR(0x00D0D0D0)
N#define GUI_GRAY_E7       GUI_MAKE_COLOR(0x00E7E7E7)
N#define GUI_BLUE_98       GUI_MAKE_COLOR(0x00980000)
N
N/*********************************************************************
N*
N*       MultiTouch-Support
N*/
N//
N// Defines
N//
N#define GUI_MTOUCH_FLAG_DOWN (1 << 0)
N#define GUI_MTOUCH_FLAG_MOVE (1 << 1)
N#define GUI_MTOUCH_FLAG_UP   (1 << 2)
N
N//
N// Variables
N//
Nextern T_GUI_MTOUCH_STOREEVENT GUI_MTOUCH__pStoreEvent;
N
N//
N// Interface
N//
Nvoid GUI_MTOUCH_Enable          (int OnOff);
Nint  GUI_MTOUCH_GetEvent        (GUI_MTOUCH_EVENT * pEvent);
Nint  GUI_MTOUCH_GetTouchInput   (GUI_MTOUCH_EVENT * pEvent, GUI_MTOUCH_INPUT * pBuffer, unsigned Index);
Nint  GUI_MTOUCH_IsEmpty         (void);
Nvoid GUI_MTOUCH_SetOrientation  (int Orientation);
Nvoid GUI_MTOUCH_SetOrientationEx(int Orientation, int LayerIndex);
Nvoid GUI_MTOUCH_StoreEvent      (GUI_MTOUCH_EVENT * pEvent, GUI_MTOUCH_INPUT * pInput);
N
N/*********************************************************************
N*
N*       Coordinates used in touch driver
N*/
N#define GUI_COORD_X 0
N#define GUI_COORD_Y 1
N
N/*********************************************************************
N*
N*       Addresses of standard fonts
N*/
N//
N// Proportional fonts
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Xextern const GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Xextern const GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Xextern const GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Xextern const GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Xextern const GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Xextern const GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Xextern const GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Xextern const GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Xextern const GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20_ASCII,       GUI_Font20_1;
Xextern const GUI_FONT GUI_Font20_ASCII,       GUI_Font20_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20B_ASCII,      GUI_Font20B_1;
Xextern const GUI_FONT GUI_Font20B_ASCII,      GUI_Font20B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Xextern const GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Xextern const GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Xextern const GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
Xextern const GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
N
N//
N// Proportional fonts, framed
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font20F_ASCII;
Xextern const GUI_FONT GUI_Font20F_ASCII;
N
N//
N// Monospaced
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font4x6;
Xextern const GUI_FONT GUI_Font4x6;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Xextern const GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font6x8_ASCII,      GUI_Font6x8_1;
Xextern const GUI_FONT GUI_Font6x8_ASCII,      GUI_Font6x8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Xextern const GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x8_ASCII,      GUI_Font8x8_1;
Xextern const GUI_FONT GUI_Font8x8_ASCII,      GUI_Font8x8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x10_ASCII;
Xextern const GUI_FONT GUI_Font8x10_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x12_ASCII;
Xextern const GUI_FONT GUI_Font8x12_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Xextern const GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Xextern const GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Xextern const GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
Xextern const GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16_ASCII,     GUI_Font8x16_1;
Xextern const GUI_FONT GUI_Font8x16_ASCII,     GUI_Font8x16_1;
N
N//
N// Digits
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD24x32;
Xextern const GUI_FONT GUI_FontD24x32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD32;
Xextern const GUI_FONT GUI_FontD32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD36x48;
Xextern const GUI_FONT GUI_FontD36x48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48;
Xextern const GUI_FONT GUI_FontD48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48x64;
Xextern const GUI_FONT GUI_FontD48x64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD64;
Xextern const GUI_FONT GUI_FontD64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD60x80;
Xextern const GUI_FONT GUI_FontD60x80;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD80;
Xextern const GUI_FONT GUI_FontD80;
N
N//
N// Comic fonts
N//
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Xextern const GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
Xextern const GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
N
N/*********************************************************************
N*
N*       Macros to be used
N*/
N//
N// Proportional fonts
N//
N#define GUI_FONT_8_ASCII        &GUI_Font8_ASCII
N#define GUI_FONT_8_1            &GUI_Font8_1
N#define GUI_FONT_10S_ASCII      &GUI_Font10S_ASCII
N#define GUI_FONT_10S_1          &GUI_Font10S_1
N#define GUI_FONT_10_ASCII       &GUI_Font10_ASCII
N#define GUI_FONT_10_1           &GUI_Font10_1
N#define GUI_FONT_13_ASCII       &GUI_Font13_ASCII
N#define GUI_FONT_13_1           &GUI_Font13_1
N#define GUI_FONT_13B_ASCII      &GUI_Font13B_ASCII
N#define GUI_FONT_13B_1          &GUI_Font13B_1
N#define GUI_FONT_13H_ASCII      &GUI_Font13H_ASCII
N#define GUI_FONT_13H_1          &GUI_Font13H_1
N#define GUI_FONT_13HB_ASCII     &GUI_Font13HB_ASCII
N#define GUI_FONT_13HB_1         &GUI_Font13HB_1
N#define GUI_FONT_16_ASCII       &GUI_Font16_ASCII
N#define GUI_FONT_16_1           &GUI_Font16_1
N#define GUI_FONT_16_HK          &GUI_Font16_HK
N#define GUI_FONT_16_1HK         &GUI_Font16_1HK
N#define GUI_FONT_16B_ASCII      &GUI_Font16B_ASCII
N#define GUI_FONT_16B_1          &GUI_Font16B_1
N#define GUI_FONT_20_ASCII       &GUI_Font20_ASCII
N#define GUI_FONT_20_1           &GUI_Font20_1
N#define GUI_FONT_20B_ASCII      &GUI_Font20B_ASCII
N#define GUI_FONT_20B_1          &GUI_Font20B_1
N#define GUI_FONT_24_ASCII       &GUI_Font24_ASCII
N#define GUI_FONT_24_1           &GUI_Font24_1
N#define GUI_FONT_24B_ASCII      &GUI_Font24B_ASCII
N#define GUI_FONT_24B_1          &GUI_Font24B_1
N#define GUI_FONT_32_ASCII       &GUI_Font32_ASCII
N#define GUI_FONT_32_1           &GUI_Font32_1
N#define GUI_FONT_32B_ASCII      &GUI_Font32B_ASCII
N#define GUI_FONT_32B_1          &GUI_Font32B_1
N
N//
N// Proportional fonts, framed
N//
N#define GUI_FONT_20F_ASCII      &GUI_Font20F_ASCII
N
N//
N// Monospaced
N//
N#define GUI_FONT_4X6            &GUI_Font4x6
N#define GUI_FONT_6X8            &GUI_Font6x8
N#define GUI_FONT_6X8_ASCII      &GUI_Font6x8_ASCII
N#define GUI_FONT_6X8_1          &GUI_Font6x8_1
N#define GUI_FONT_6X9            &GUI_Font6x9
N#define GUI_FONT_8X8            &GUI_Font8x8
N#define GUI_FONT_8X8_ASCII      &GUI_Font8x8_ASCII
N#define GUI_FONT_8X8_1          &GUI_Font8x8_1
N#define GUI_FONT_8X9            &GUI_Font8x9
N#define GUI_FONT_8X10_ASCII     &GUI_Font8x10_ASCII
N#define GUI_FONT_8X12_ASCII     &GUI_Font8x12_ASCII
N#define GUI_FONT_8X13_ASCII     &GUI_Font8x13_ASCII
N#define GUI_FONT_8X13_1         &GUI_Font8x13_1
N#define GUI_FONT_8X15B_ASCII    &GUI_Font8x15B_ASCII
N#define GUI_FONT_8X15B_1        &GUI_Font8x15B_1
N#define GUI_FONT_8X16           &GUI_Font8x16
N#define GUI_FONT_8X17           &GUI_Font8x17
N#define GUI_FONT_8X18           &GUI_Font8x18
N#define GUI_FONT_8X16X1X2       &GUI_Font8x16x1x2
N#define GUI_FONT_8X16X2X2       &GUI_Font8x16x2x2
N#define GUI_FONT_8X16X3X3       &GUI_Font8x16x3x3
N#define GUI_FONT_8X16_ASCII     &GUI_Font8x16_ASCII
N#define GUI_FONT_8X16_1         &GUI_Font8x16_1
N
N//
N// Digits
N//
N#define GUI_FONT_D24X32         &GUI_FontD24x32
N#define GUI_FONT_D32            &GUI_FontD32
N#define GUI_FONT_D36X48         &GUI_FontD36x48
N#define GUI_FONT_D48            &GUI_FontD48
N#define GUI_FONT_D48X64         &GUI_FontD48x64
N#define GUI_FONT_D64            &GUI_FontD64
N#define GUI_FONT_D60X80         &GUI_FontD60x80
N#define GUI_FONT_D80            &GUI_FontD80
N
N//
N// Comic fonts
N//
N#define GUI_FONT_COMIC18B_ASCII &GUI_FontComic18B_ASCII
N#define GUI_FONT_COMIC18B_1     &GUI_FontComic18B_1
N#define GUI_FONT_COMIC24B_ASCII &GUI_FontComic24B_ASCII
N#define GUI_FONT_COMIC24B_1     &GUI_FontComic24B_1
N
N/*********************************************************************
N*
N*       Text and drawing modes
N*
N* These defines come in two flavors: the long version (.._DRAWMODE_..)
N* and the short ones (.._DM_..). They are identical, feel free to use
N* which ever one you like best.
N*/
N#define GUI_DRAWMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_DRAWMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_DRAWMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_DRAWMODE_REV     LCD_DRAWMODE_REV
N#define GUI_DM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_DM_XOR           LCD_DRAWMODE_XOR
N#define GUI_DM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_DM_REV           LCD_DRAWMODE_REV
N
N#define GUI_TEXTMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_TEXTMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_TEXTMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_TEXTMODE_REV     LCD_DRAWMODE_REV
N#define GUI_TM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_TM_XOR           LCD_DRAWMODE_XOR
N#define GUI_TM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_TM_REV           LCD_DRAWMODE_REV
N
N/* Text alignment flags, horizontal */
N#define GUI_TA_LEFT       (0)
N#define GUI_TA_HORIZONTAL (3 << 0)
N#define GUI_TA_RIGHT      (1 << 0)
N#define GUI_TA_CENTER     (2 << 0)
N#define GUI_TA_HCENTER    GUI_TA_CENTER  /* easier to remember :-)  */
N
N/* Text alignment flags, vertical */
N#define GUI_TA_TOP        (0)
N#define GUI_TA_VERTICAL   (3 << 2)
N#define GUI_TA_BOTTOM     (1 << 2)
N#define GUI_TA_BASELINE   (2 << 2)
N#define GUI_TA_VCENTER    (3 << 2)
N
N/* General alignment flags */
N#define GUI_ALIGN_LEFT       GUI_TA_LEFT
N#define GUI_ALIGN_HCENTER    GUI_TA_HCENTER
N#define GUI_ALIGN_RIGHT      GUI_TA_RIGHT
N#define GUI_ALIGN_TOP        GUI_TA_TOP
N#define GUI_ALIGN_VCENTER    GUI_TA_VCENTER
N#define GUI_ALIGN_BOTTOM     GUI_TA_BOTTOM
N#define GUI_ALIGN_HORIZONTAL GUI_TA_HORIZONTAL
N#define GUI_ALIGN_VERTICAL   GUI_TA_VERTICAL
N
N/* General orientation flags */
N#define GUI_MIRROR_X (1 << 0)
N#define GUI_MIRROR_Y (1 << 1)
N#define GUI_SWAP_XY  (1 << 2)
N
N#define GUI_ROTATION_0   (0)
N#define GUI_ROTATION_CW  (GUI_MIRROR_X | GUI_SWAP_XY)
N#define GUI_ROTATION_180 (GUI_MIRROR_X | GUI_MIRROR_Y)
N#define GUI_ROTATION_CCW (GUI_MIRROR_Y | GUI_SWAP_XY)
N
N/*********************************************************************
N*
N*       Min/Max coordinates
N*
N* Define minimum and maximum coordinates in x and y
N*/
N#define GUI_XMIN -16383
N#define GUI_XMAX  16383
N#define GUI_YMIN -16383
N#define GUI_YMAX  16383
N
N/*********************************************************************
N*
N*       Defines for constants
N*/
N#define	________	0x0
N#define	_______X	0x1
N#define	______X_	0x2
N#define	______XX	0x3
N#define	_____X__	0x4
N#define	_____X_X	0x5
N#define	_____XX_	0x6
N#define	_____XXX	0x7
N#define	____X___	0x8
N#define	____X__X	0x9
N#define	____X_X_	0xa
N#define	____X_XX	0xb
N#define	____XX__	0xc
N#define	____XX_X	0xd
N#define	____XXX_	0xe
N#define	____XXXX	0xf
N#define	___X____	0x10
N#define	___X___X	0x11
N#define	___X__X_	0x12
N#define	___X__XX	0x13
N#define	___X_X__	0x14
N#define	___X_X_X	0x15
N#define	___X_XX_	0x16
N#define	___X_XXX	0x17
N#define	___XX___	0x18
N#define	___XX__X	0x19
N#define	___XX_X_	0x1a
N#define	___XX_XX	0x1b
N#define	___XXX__	0x1c
N#define	___XXX_X	0x1d
N#define	___XXXX_	0x1e
N#define	___XXXXX	0x1f
N#define	__X_____	0x20
N#define	__X____X	0x21
N#define	__X___X_	0x22
N#define	__X___XX	0x23
N#define	__X__X__	0x24
N#define	__X__X_X	0x25
N#define	__X__XX_	0x26
N#define	__X__XXX	0x27
N#define	__X_X___	0x28
N#define	__X_X__X	0x29
N#define	__X_X_X_	0x2a
N#define	__X_X_XX	0x2b
N#define	__X_XX__	0x2c
N#define	__X_XX_X	0x2d
N#define	__X_XXX_	0x2e
N#define	__X_XXXX	0x2f
N#define	__XX____	0x30
N#define	__XX___X	0x31
N#define	__XX__X_	0x32
N#define	__XX__XX	0x33
N#define	__XX_X__	0x34
N#define	__XX_X_X	0x35
N#define	__XX_XX_	0x36
N#define	__XX_XXX	0x37
N#define	__XXX___	0x38
N#define	__XXX__X	0x39
N#define	__XXX_X_	0x3a
N#define	__XXX_XX	0x3b
N#define	__XXXX__	0x3c
N#define	__XXXX_X	0x3d
N#define	__XXXXX_	0x3e
N#define	__XXXXXX	0x3f
N#define	_X______	0x40
N#define	_X_____X	0x41
N#define	_X____X_	0x42
N#define	_X____XX	0x43
N#define	_X___X__	0x44
N#define	_X___X_X	0x45
N#define	_X___XX_	0x46
N#define	_X___XXX	0x47
N#define	_X__X___	0x48
N#define	_X__X__X	0x49
N#define	_X__X_X_	0x4a
N#define	_X__X_XX	0x4b
N#define	_X__XX__	0x4c
N#define	_X__XX_X	0x4d
N#define	_X__XXX_	0x4e
N#define	_X__XXXX	0x4f
N#define	_X_X____	0x50
N#define	_X_X___X	0x51
N#define	_X_X__X_	0x52
N#define	_X_X__XX	0x53
N#define	_X_X_X__	0x54
N#define	_X_X_X_X	0x55
N#define	_X_X_XX_	0x56
N#define	_X_X_XXX	0x57
N#define	_X_XX___	0x58
N#define	_X_XX__X	0x59
N#define	_X_XX_X_	0x5a
N#define	_X_XX_XX	0x5b
N#define	_X_XXX__	0x5c
N#define	_X_XXX_X	0x5d
N#define	_X_XXXX_	0x5e
N#define	_X_XXXXX	0x5f
N#define	_XX_____	0x60
N#define	_XX____X	0x61
N#define	_XX___X_	0x62
N#define	_XX___XX	0x63
N#define	_XX__X__	0x64
N#define	_XX__X_X	0x65
N#define	_XX__XX_	0x66
N#define	_XX__XXX	0x67
N#define	_XX_X___	0x68
N#define	_XX_X__X	0x69
N#define	_XX_X_X_	0x6a
N#define	_XX_X_XX	0x6b
N#define	_XX_XX__	0x6c
N#define	_XX_XX_X	0x6d
N#define	_XX_XXX_	0x6e
N#define	_XX_XXXX	0x6f
N#define	_XXX____	0x70
N#define	_XXX___X	0x71
N#define	_XXX__X_	0x72
N#define	_XXX__XX	0x73
N#define	_XXX_X__	0x74
N#define	_XXX_X_X	0x75
N#define	_XXX_XX_	0x76
N#define	_XXX_XXX	0x77
N#define	_XXXX___	0x78
N#define	_XXXX__X	0x79
N#define	_XXXX_X_	0x7a
N#define	_XXXX_XX	0x7b
N#define	_XXXXX__	0x7c
N#define	_XXXXX_X	0x7d
N#define	_XXXXXX_	0x7e
N#define	_XXXXXXX	0x7f
N#define	X_______	0x80
N#define	X______X	0x81
N#define	X_____X_	0x82
N#define	X_____XX	0x83
N#define	X____X__	0x84
N#define	X____X_X	0x85
N#define	X____XX_	0x86
N#define	X____XXX	0x87
N#define	X___X___	0x88
N#define	X___X__X	0x89
N#define	X___X_X_	0x8a
N#define	X___X_XX	0x8b
N#define	X___XX__	0x8c
N#define	X___XX_X	0x8d
N#define	X___XXX_	0x8e
N#define	X___XXXX	0x8f
N#define	X__X____	0x90
N#define	X__X___X	0x91
N#define	X__X__X_	0x92
N#define	X__X__XX	0x93
N#define	X__X_X__	0x94
N#define	X__X_X_X	0x95
N#define	X__X_XX_	0x96
N#define	X__X_XXX	0x97
N#define	X__XX___	0x98
N#define	X__XX__X	0x99
N#define	X__XX_X_	0x9a
N#define X__XX_XX	0x9b
N#define X__XXX__	0x9c
N#define X__XXX_X	0x9d
N#define	X__XXXX_	0x9e
N#define	X__XXXXX	0x9f
N#define	X_X_____	0xa0
N#define	X_X____X	0xa1
N#define	X_X___X_	0xa2
N#define	X_X___XX	0xa3
N#define	X_X__X__	0xa4
N#define	X_X__X_X	0xa5
N#define	X_X__XX_	0xa6
N#define	X_X__XXX	0xa7
N#define	X_X_X___	0xa8
N#define	X_X_X__X	0xa9
N#define	X_X_X_X_	0xaa
N#define	X_X_X_XX	0xab
N#define	X_X_XX__	0xac
N#define	X_X_XX_X	0xad
N#define	X_X_XXX_	0xae
N#define	X_X_XXXX	0xaf
N#define	X_XX____	0xb0
N#define X_XX___X	0xb1
N#define	X_XX__X_	0xb2
N#define	X_XX__XX	0xb3
N#define	X_XX_X__	0xb4
N#define	X_XX_X_X	0xb5
N#define	X_XX_XX_	0xb6
N#define	X_XX_XXX	0xb7
N#define	X_XXX___	0xb8
N#define	X_XXX__X	0xb9
N#define	X_XXX_X_	0xba
N#define	X_XXX_XX	0xbb
N#define	X_XXXX__	0xbc
N#define	X_XXXX_X	0xbd
N#define	X_XXXXX_	0xbe
N#define	X_XXXXXX	0xbf
N#define	XX______	0xc0
N#define	XX_____X	0xc1
N#define	XX____X_	0xc2
N#define	XX____XX	0xc3
N#define	XX___X__	0xc4
N#define	XX___X_X	0xc5
N#define	XX___XX_	0xc6
N#define	XX___XXX	0xc7
N#define	XX__X___	0xc8
N#define	XX__X__X	0xc9
N#define	XX__X_X_	0xca
N#define	XX__X_XX	0xcb
N#define	XX__XX__	0xcc
N#define	XX__XX_X	0xcd
N#define	XX__XXX_	0xce
N#define XX__XXXX	0xcf
N#define	XX_X____	0xd0
N#define	XX_X___X	0xd1
N#define	XX_X__X_	0xd2
N#define	XX_X__XX	0xd3
N#define	XX_X_X__	0xd4
N#define	XX_X_X_X	0xd5
N#define	XX_X_XX_	0xd6
N#define	XX_X_XXX	0xd7
N#define	XX_XX___	0xd8
N#define	XX_XX__X	0xd9
N#define	XX_XX_X_	0xda
N#define	XX_XX_XX	0xdb
N#define	XX_XXX__	0xdc
N#define	XX_XXX_X	0xdd
N#define	XX_XXXX_	0xde
N#define	XX_XXXXX	0xdf
N#define	XXX_____	0xe0
N#define	XXX____X	0xe1
N#define	XXX___X_	0xe2
N#define	XXX___XX	0xe3
N#define	XXX__X__	0xe4
N#define	XXX__X_X	0xe5
N#define	XXX__XX_	0xe6
N#define	XXX__XXX	0xe7
N#define	XXX_X___	0xe8
N#define	XXX_X__X	0xe9
N#define	XXX_X_X_	0xea
N#define	XXX_X_XX	0xeb
N#define	XXX_XX__	0xec
N#define	XXX_XX_X	0xed
N#define	XXX_XXX_	0xee
N#define	XXX_XXXX	0xef
N#define	XXXX____	0xf0
N#define	XXXX___X	0xf1
N#define	XXXX__X_	0xf2
N#define	XXXX__XX	0xf3
N#define	XXXX_X__	0xf4
N#define	XXXX_X_X	0xf5
N#define	XXXX_XX_	0xf6
N#define	XXXX_XXX	0xf7
N#define	XXXXX___	0xf8
N#define	XXXXX__X	0xf9
N#define	XXXXX_X_	0xfa
N#define	XXXXX_XX	0xfb
N#define	XXXXXX__	0xfc
N#define	XXXXXX_X	0xfd
N#define	XXXXXXX_	0xfe
N#define	XXXXXXXX	0xff
N
N/*********************************************************************
N*
N*       Compatibility with older versions
N*/
N#define GUI_DispString_UC      GUI_UC_DispString
N#define TOUCH_X_ActivateX      GUI_TOUCH_X_ActivateX
N#define TOUCH_X_ActivateY      GUI_TOUCH_X_ActivateY
N#define TOUCH_X_Disable        GUI_TOUCH_X_Disable
N#define TOUCH_X_MeasureX       GUI_TOUCH_X_MeasureX
N#define TOUCH_X_MeasureY       GUI_TOUCH_X_MeasureY
N#define GUI_SelLayer           GUI_SelectLayer
N#define GUI_MEMDEV_FadeDevices GUI_MEMDEV_FadeInDevices
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif   /* ifdef GUI_H */
N
N/*************************** End of file ****************************/
L 28 "..\main.c" 2
N#include "wm.h"
L 1 "..\..\..\ThirdParty\emWin\Include\wm.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WM.h
NPurpose     : Windows manager include
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_H            /* Make sure we only include it once */
N#define WM_H
N
N
N#include "GUI_ConfDefaults.h"
N#include "GUI_Type.h"      /* Needed because of typedefs only */
N#include "WM_GUI.h"       /* Some functions needed by GUI routines */
L 1 "..\..\..\ThirdParty\emWin\Include\WM_GUI.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WM_GUI.h
NPurpose     : Windows manager include for low level GUI routines
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_GUI_H            /* Make sure we only include it once */
N#define WM_GUI_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
Nint       WM__InitIVRSearch(const GUI_RECT* pMaxRect);
Nint       WM__GetNextIVR   (void);
Nint       WM__GetOrgX_AA(void);
Nint       WM__GetOrgY_AA(void);
N
N#define WM_ITERATE_START(pRect)                   \
N  {                                               \
N    if (WM__InitIVRSearch(pRect))                 \
N      do {
X#define WM_ITERATE_START(pRect)                     {                                                   if (WM__InitIVRSearch(pRect))                       do {
N
N#define WM_ITERATE_END()                          \
N    } while (WM__GetNextIVR());                   \
N  }
X#define WM_ITERATE_END()                              } while (WM__GetNextIVR());                     }
N
N#define WM_ADDORGX(x)       (x += GUI_pContext->xOff)
N#define WM_ADDORGY(y)       (y += GUI_pContext->yOff)
N#define WM_ADDORG(x0,y0)    WM_ADDORGX(x0); WM_ADDORGY(y0)
N#define WM_ADDORGX_AA(x)    (x += WM__GetOrgX_AA())
N#define WM_ADDORGY_AA(y)    (y += WM__GetOrgY_AA())
N#define WM_ADDORG_AA(x0,y0) WM_ADDORGX_AA(x0); WM_ADDORGY_AA(y0)
N#define WM_SUBORGX(x)       (x -= GUI_pContext->xOff)
N#define WM_SUBORGY(y)       (y -= GUI_pContext->yOff)
N#define WM_SUBORG(x0,y0)    WM_SUBORGX(x0); WM_SUBORGY(y0)
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
L 51 "..\..\..\ThirdParty\emWin\Include\wm.h" 2
N#include "GUI.h"
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/* Static memory devices */
N#ifndef   WM_SUPPORT_STATIC_MEMDEV
N  #define WM_SUPPORT_STATIC_MEMDEV GUI_SUPPORT_MEMDEV
N#endif
N
N/* Support for transparency. Switching it off makes Wm smaller and faster */
N#ifndef   WM_SUPPORT_TRANSPARENCY
N  #define WM_SUPPORT_TRANSPARENCY 1 /* Should be defined outside of GUI_WINSUPPORT because of '#if GUI_WINSUPPORT && WM_SUPPORT_TRANSPARENCY' in some files */
N#endif
N
N/* This is for tests only. It will fill the invalid area of a window.
N   Can be used for debugging. */
N#ifndef WM_SUPPORT_DIAG
N  #ifdef WIN32   /* In simulation */
S    #define WM_SUPPORT_DIAG GUI_WINSUPPORT
N  #else
N    #define WM_SUPPORT_DIAG 0
N  #endif
N#endif
N
N/* Make sure we actually have configured windows. If we have not,
N  there is no point for a windows manager and it will therefor not
N  generate any code !
N*/
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Config defaults
N*/
N#ifndef   WM_ASSERT
N  #define WM_ASSERT(expr) GUI_DEBUG_ASSERT(expr)
N#endif
N
N#ifndef   WM_SUPPORT_TOUCH
N  #define WM_SUPPORT_TOUCH        GUI_SUPPORT_TOUCH
N#endif
N
N/* Allow older API calls */
N#ifndef   WM_COMPATIBLE_MODE
N  #define WM_COMPATIBLE_MODE 1
N#endif
N
N/* Send a message if visibility of a window has changed */
N#ifndef   WM_SUPPORT_NOTIFY_VIS_CHANGED
N  #define WM_SUPPORT_NOTIFY_VIS_CHANGED 0
N#endif
N
N#ifndef   WM_SUPPORT_CPP
N  #if defined (_MSC_VER)
X  #if 0L
S    #define WM_SUPPORT_CPP 1
N  #else
N    #define WM_SUPPORT_CPP 0
N  #endif
N#endif
N
N/*********************************************************************
N*
N*       Locking macros
N*/
N#define WM_LOCK()   GUI_LOCK()
N#define WM_UNLOCK() GUI_UNLOCK()
N
N#define WM_LOCK_H(hWin) (WM_Obj *)GUI_LOCK_H(hWin)
N
N/*********************************************************************
N*
N*       Data types
N*/
Ntypedef struct WM_WINDOW_INFO WM_WINDOW_INFO;
N
Nstruct WM_WINDOW_INFO {
N  GUI_HMEM hWin;
X  signed long hWin;
N  GUI_HMEM hParent;
X  signed long hParent;
N  GUI_HMEM hFirstChild;
X  signed long hFirstChild;
N  GUI_HMEM hNext;
X  signed long hNext;
N  GUI_RECT Rect;
N  U32      Status;
X  unsigned long      Status;
N  U32      DebugId;
X  unsigned long      DebugId;
N  WM_WINDOW_INFO * pNext;
N};
N
Ntypedef struct {
N  int Key, PressedCnt;
N} WM_KEY_INFO;
N
Ntypedef struct {
N  int NumItems, v, PageSize;
N} WM_SCROLL_STATE;
N
Ntypedef struct {
N  int Done;
N  int ReturnValue;
N} WM_DIALOG_STATUS;
N
Ntypedef struct {
N  int x,y;
N  U8  State;
X  unsigned char  State;
N  U8  StatePrev;
X  unsigned char  StatePrev;
N} WM_PID_STATE_CHANGED_INFO;
N
Ntypedef struct {
N  U8  Cmd;
X  unsigned char  Cmd;
N  U8  FinalMove;
X  unsigned char  FinalMove;
N  U8  StopMotion;
X  unsigned char  StopMotion;
N  U8  IsDragging;
X  unsigned char  IsDragging;
N  int dx, dy, da;
N  int xPos, yPos;
N  int Period;
N  int SnapX;
N  int SnapY;
N  U8  IsOutside;
X  unsigned char  IsOutside;
N  unsigned Overlap;
N  U32 Flags;
X  unsigned long Flags;
N  GUI_PID_STATE * pState;
N  GUI_HMEM hContext;
X  signed long hContext;
N} WM_MOTION_INFO;
N
Ntypedef struct {
N  I32       FactorMin;   // Minimum factor to be used (<< 16)
X  signed long       FactorMin;   
N  I32       FactorMax;   // Maximum factor to be used (<< 16)
X  signed long       FactorMax;   
N  U32       xSize;       // Native xSize of window to be zoomed in pixels
X  unsigned long       xSize;       
N  U32       ySize;       // Native ySize of window to be zoomed in pixels
X  unsigned long       ySize;       
N  U32       xSizeParent; // xSize of parent window
X  unsigned long       xSizeParent; 
N  U32       ySizeParent; // ySize of parent window
X  unsigned long       ySizeParent; 
N  I32       Factor0;     // Primary factor when starting zoom gesture (<< 16)
X  signed long       Factor0;     
N  int       xPos0;       // Primary window position in x when starting the gesture
N  int       yPos0;       // Primary window position in y when starting the gesture
N  GUI_POINT Center0;     // Primary center point when starting the gesture
N} WM_ZOOM_INFO;
N
Ntypedef struct {
N  int            Flags;     // Information regarding gesture type
N  GUI_POINT      Point;     // Relative movement
N  GUI_POINT      Center;    // Center point for zooming
N  I32            Angle;     // Angle between the touch points
X  signed long            Angle;     
N  I32            Factor;    // Current zoom factor
X  signed long            Factor;    
N  WM_ZOOM_INFO * pZoomInfo; // Pointer to WM_ZOOM_INFO structure
N} WM_GESTURE_INFO;
N
Ntypedef struct {
N  int dx, dy;
N} WM_MOVE_INFO;
N
N/*********************************************************************
N*
N*       Gesture flags for multi touch support
N*/
N#define WM_GF_BEGIN  (1 << 0)
N#define WM_GF_END    (1 << 1)
N#define WM_GF_PAN    (1 << 2)
N#define WM_GF_ZOOM   (1 << 3)
N#define WM_GF_ROTATE (1 << 4)
N#define WM_GF_DTAP   (1 << 5)
N
N/*********************************************************************
N*
N*       Messages Ids
N*
N* The following is the list of windows messages.
N*/
N#define WM_CREATE                   0x0001  /* The first message received, right after client has actually been created */
N#define WM_MOVE                     0x0003  /* window has been moved (Same as WIN32) */
N
N#define WM_SIZE                     0x0005  /* Is sent to a window after its size has changed (Same as WIN32, do not change !) */
N
N#define WM_DELETE                   11      /* Delete (Destroy) command: This tells the client to free its data strutures since the window
N                                               it is associates with no longer exists.*/
N#define WM_TOUCH                    0x0240  /* Touch screen message */
N#define WM_TOUCH_CHILD              13      /* Touch screen message to ancestors */
N#define WM_KEY                      14      /* Key has been pressed */
N
N#define WM_PAINT                    0x000F  /* Repaint window (because content is (partially) invalid */
N
N#if GUI_SUPPORT_MOUSE
X#if 1
N#define WM_MOUSEOVER                16      /* Mouse has moved, no key pressed */
N#define WM_MOUSEOVER_END            18      /* Mouse has moved, no key pressed */
N#endif
N
N#define WM_PID_STATE_CHANGED        17      /* Pointer input device state has changed */
N
N#define WM_GET_INSIDE_RECT          20      /* get inside rectangle: client rectangle minus pixels lost to effect */
N#define WM_GET_ID                   21      /* Get id of widget */
N#define WM_SET_ID                   22      /* Set id of widget */
N#define WM_GET_CLIENT_WINDOW        23      /* Get window handle of client window. Default is the same as window */
N#define WM_CAPTURE_RELEASED         24      /* Let window know that mouse capture is over */
N
N#define WM_INIT_DIALOG              29      /* Inform dialog that it is ready for init */
N
N#define WM_SET_FOCUS                30      /* Inform window that it has gotten or lost the focus */
N#define WM_GET_ACCEPT_FOCUS         31      /* Find out if window can accept the focus */
N#define WM_NOTIFY_CHILD_HAS_FOCUS   32      /* Sent to parent when child receives / loses focus */
N
N#define WM_NOTIFY_OWNER_KEY         33      /* Some widgets (e.g. listbox) notify owner when receiving key messages */
N
N#define WM_GET_BKCOLOR              34      /* Return back ground color (only frame window and similar) */
N#define WM_GET_SCROLL_STATE         35      /* Query state of scroll bar */
N
N#define WM_SET_SCROLL_STATE         36      /* Set scroll info ... only effective for scrollbars */
N
N#define WM_NOTIFY_CLIENTCHANGE      37      /* Client area may have changed */
N#define WM_NOTIFY_PARENT            38      /* Notify parent. Information is detailed as notification code */
N#define WM_NOTIFY_PARENT_REFLECTION 39      /* Notify parent reflection.
N                                               Sometimes send back as a result of the WM_NOTIFY_PARENT message
N                                               to let child react on behalf of its parent.
N                                               Information is detailed as notification code */
N#define WM_NOTIFY_ENABLE            40      /* Enable or disable widget */
N#define WM_NOTIFY_VIS_CHANGED       41      /* Visibility of a window has or may have changed */
N
N#define WM_HANDLE_DIALOG_STATUS     42      /* Set or get dialog status */
N#define WM_GET_RADIOGROUP           43      /* Send to all siblings and children of a radio control when
N                                               selection changed */
N#define WM_MENU                     44      /* Send to owner window of menu widget */
N#define WM_SCREENSIZE_CHANGED       45      /* Send to all windows when size of screen has changed */
N#define WM_PRE_PAINT                46      /* Send to a window before it receives a WM_PAINT message */
N#define WM_POST_PAINT               47      /* Send to a window after (the last) WM_PAINT message */
N
N#define WM_MOTION                   48      /* Automatic motion messages */
N
N#define WM_GET_WINDOW_ID            49      /* Return widget type specific Id (DebugId) */
N
N#define WM_PRE_BANDING              50      /* Send before starting banding process */
N#define WM_POST_BANDING             51      /* Send after finishing banding process */
N
N#define WM_USER_DATA                52      /* Send immediately after setting user data */
N#define WM_SET_CALLBACK             53      /* Send immediately after setting user data */
N
N#define WM_GESTURE                  0x0119  /* Gesture message */
N
N#define WM_TIMER                    0x0113  /* Timer has expired              (Keep the same as WIN32) */
N#define WM_WIDGET                   0x0300  /* 256 messages reserved for Widget messages */
N#define WM_USER                     0x0400  /* Reserved for user messages ... (Keep the same as WIN32) */
N
N/*********************************************************************
N*
N*       Motion messages
N*/
N#define WM_MOTION_INIT    0
N#define WM_MOTION_MOVE    1
N#define WM_MOTION_GETPOS  2
N#define WM_MOTION_GETCONTEXT 3
N
N/*********************************************************************
N*
N*       Motion flags
N*/
N#define WM_MOTION_MANAGE_BY_WINDOW   (1 << 0) // Window movement is managed by window itself
N
N/*********************************************************************
N*
N*       Notification codes
N*
N* The following is the list of notification codes send
N* with the WM_NOTIFY_PARENT message
N*/
N#define WM_NOTIFICATION_CLICKED             1
N#define WM_NOTIFICATION_RELEASED            2
N#define WM_NOTIFICATION_MOVED_OUT           3
N#define WM_NOTIFICATION_SEL_CHANGED         4
N#define WM_NOTIFICATION_VALUE_CHANGED       5
N#define WM_NOTIFICATION_SCROLLBAR_ADDED     6      /* Scroller added */
N#define WM_NOTIFICATION_CHILD_DELETED       7      /* Inform window that child is about to be deleted */
N#define WM_NOTIFICATION_GOT_FOCUS           8
N#define WM_NOTIFICATION_LOST_FOCUS          9
N#define WM_NOTIFICATION_SCROLL_CHANGED     10
N
N#define WM_NOTIFICATION_WIDGET             11      /* Space for widget defined notifications */
N#define WM_NOTIFICATION_USER               16      /* Space for  application (user) defined notifications */
N
N/*********************************************************************
N*
N*       Memory management
N*/
N#define WM_HWIN        GUI_HWIN
N#define WM_HWIN_NULL   GUI_HMEM_NULL
N#define WM_HMEM        GUI_HMEM
N#define WM_HMEM_NULL   GUI_HMEM_NULL
N#define WM_HTIMER      GUI_HMEM
N
N/*********************************************************************
N*
N*       Window defines
N*/
N#define WM_HBKWIN      WM_GetDesktopWindow()                /* Handle of background window */
N#define WM_UNATTACHED  ((WM_HMEM) - 1)                      /* Do not attach to a window */
N
N/*********************************************************************
N*
N*       Window create flags.
N*
N* These flags can be passed to the create window
N* function as flag-parameter. The flags are combinable using the
N* binary or operator.
N*/
N#define WM_CF_HASTRANS         (1UL << 0)  /* Has transparency. Needs to be defined for windows which do not fill the entire
N                                          section of their (client) rectangle. */
N#define WM_CF_HIDE             (0UL << 1)  /* Hide window after creation (default !) */
N#define WM_CF_SHOW             (1UL << 1)  /* Show window after creation */
N#define WM_CF_MEMDEV           (1UL << 2)  /* Use memory device for redraws */
N#define WM_CF_STAYONTOP        (1UL << 3)  /* Stay on top */
N#define WM_CF_DISABLED         (1UL << 4)  /* Disabled: Does not receive PID (mouse & touch) input */
N
N/* Create only flags ... Not available as status flags */
N#define WM_CF_ACTIVATE         (1UL << 5)  /* If automatic activation upon creation of window is desired */
N#define WM_CF_FGND             (0UL << 6)  /* Put window in foreground after creation (default !) */
N#define WM_CF_BGND             (1UL << 6)  /* Put window in background after creation */
N
N/* Anchor flags */
N#define WM_CF_ANCHOR_RIGHT     (1UL << 7)  /* Right anchor ...  If parent is resized, distance to right  will remain const (left is default) */
N#define WM_CF_ANCHOR_BOTTOM    (1UL << 8)  /* Bottom anchor ... If parent is resized, distance to bottom will remain const (top  is default) */
N#define WM_CF_ANCHOR_LEFT      (1UL << 9)  /* Left anchor ...   If parent is resized, distance to left   will remain const (left is default) */
N#define WM_CF_ANCHOR_TOP       (1UL << 10) /* Top anchor ...    If parent is resized, distance to top    will remain const (top  is default) */
N
N#define WM_CF_CONST_OUTLINE    (1UL << 11) /* Constant outline. This is relevant for transparent windows only. If a window is transparent
N                                              and does not have a constant outline, its background is invalided instead of the window itself.
N                                              This causes add. computation time when redrawing. */
N#define WM_CF_LATE_CLIP        (1UL << 12)
N#define WM_CF_MEMDEV_ON_REDRAW (1UL << 13)
N
N#define WM_SF_INVALID_DRAW     (1UL << 14)
N#define WM_SF_DELETE           (1UL << 15) /* Marks the window to be deleted within WM_Exec() when no callback routine is executed */
N
N#define WM_CF_STATIC           (1UL << 16) /* Use static memory device for redraws */
N
N#define WM_CF_MOTION_X         (1UL << 17) /* Window can be moved automatically in X axis */
N#define WM_CF_MOTION_Y         (1UL << 18) /* Window can be moved automatically in Y axis */
N
N#define WM_CF_GESTURE          (1UL << 19) /* Marks the window to be a able to receive gesture messages */
N
N#define WM_CF_ZOOM             (1UL << 20) /* Window can be scaled automatically by multi touch gesture input */
N
N#define WM_CF_MOTION_R         (1UL << 21) // Window can be rotated
N
N/*********************************************************************
N*
N*       Window manager types
N*/
Ntypedef struct WM_Obj     WM_Obj;
Ntypedef struct WM_MESSAGE WM_MESSAGE;
N
Ntypedef void WM_CALLBACK( WM_MESSAGE * pMsg);
N
Nstruct WM_MESSAGE {
N  int MsgId;            /* type of message */
N  WM_HWIN hWin;         /* Destination window */
X  GUI_HWIN hWin;          
N  WM_HWIN hWinSrc;      /* Source window  */
X  GUI_HWIN hWinSrc;       
N  union {
N    const void * p;     /* Message specific data pointer */
N    int v;
N    PTR_ADDR u;
X    unsigned long u;
N    GUI_COLOR Color;
N    void (* pFunc)(void);
N  } Data;
N};
N
Nstruct WM_Obj {
N  GUI_RECT Rect;        /* Outer dimensions of window */
N  GUI_RECT InvalidRect; /* Invalid rectangle */
N  WM_CALLBACK* cb;      /* Ptr to notification callback */
N  WM_HWIN hNextLin;     /* Next window in linear list */
X  GUI_HWIN hNextLin;      
N  WM_HWIN hParent;
X  GUI_HWIN hParent;
N  WM_HWIN hFirstChild;
X  GUI_HWIN hFirstChild;
N  WM_HWIN hNext;
X  GUI_HWIN hNext;
N  #if WM_SUPPORT_STATIC_MEMDEV
X  #if 1
N    GUI_MEMDEV_Handle hMem; /* Static memory device */
N  #endif
N  U32 Status;           /* Status flags */
X  unsigned long Status;            
N  #if WM_SUPPORT_CPP
X  #if 0
S    void * ObjPtr;
N  #endif
N};
N
Ntypedef void WM_tfPollPID(void);
Ntypedef void WM_tfForEach(WM_HWIN hWin, void * pData);
Xtypedef void WM_tfForEach(GUI_HWIN hWin, void * pData);
N
Ntypedef void (* WM_tfInvalidateParent)  (const GUI_RECT * pInvalidRect, WM_HWIN hParent, WM_HWIN hStop);
Xtypedef void (* WM_tfInvalidateParent)  (const GUI_RECT * pInvalidRect, GUI_HWIN hParent, GUI_HWIN hStop);
Ntypedef void (* WM_tfInvalidateDrawFunc)(WM_HWIN hWin);
Xtypedef void (* WM_tfInvalidateDrawFunc)(GUI_HWIN hWin);
Ntypedef void (* WM_tfPaint1Func)        (WM_HWIN hWin);
Xtypedef void (* WM_tfPaint1Func)        (GUI_HWIN hWin);
N
Ntypedef struct {
N  WM_HMEM  hTimer;
X  signed long  hTimer;
N  WM_HWIN  hWin;
X  GUI_HWIN  hWin;
N  int      UserId;
N} WM_TIMER_OBJ;
N
N/*********************************************************************
N*
N*       General control routines
N*/
Nvoid WM_Activate  (void);
Nvoid WM_Deactivate(void);
Nvoid WM_Init      (void);
Nint  WM_Exec      (void);    /* Execute all jobs ... Return 0 if nothing was done. */
Nint  WM_Exec1     (void);    // Execute only one job
NU32  WM_SetCreateFlags(U32 Flags);
Xunsigned long  WM_SetCreateFlags(unsigned long Flags);
NWM_tfPollPID * WM_SetpfPollPID(WM_tfPollPID * pf);
N
N/*********************************************************************
N*
N*       Window manager interface
N*/
Nvoid    WM_AttachWindow              (WM_HWIN hWin, WM_HWIN hParent);
Xvoid    WM_AttachWindow              (GUI_HWIN hWin, GUI_HWIN hParent);
Nvoid    WM_AttachWindowAt            (WM_HWIN hWin, WM_HWIN hParent, int x, int y);
Xvoid    WM_AttachWindowAt            (GUI_HWIN hWin, GUI_HWIN hParent, int x, int y);
Nint     WM_CheckScrollPos            (WM_SCROLL_STATE * pScrollState, int Pos, int LowerDist, int UpperDist); /* not to be documented (may change in future version) */
Nvoid    WM_ClrHasTrans               (WM_HWIN hWin);
Xvoid    WM_ClrHasTrans               (GUI_HWIN hWin);
NWM_HWIN WM_CreateWindow              (int x0, int y0, int xSize, int ySize, U32 Style, WM_CALLBACK * cb, int NumExtraBytes);
XGUI_HWIN WM_CreateWindow              (int x0, int y0, int xSize, int ySize, unsigned long Style, WM_CALLBACK * cb, int NumExtraBytes);
NWM_HWIN WM_CreateWindowAsChild       (int x0, int y0, int xSize, int ySize, WM_HWIN hWinParent, U32 Style, WM_CALLBACK* cb, int NumExtraBytes);
XGUI_HWIN WM_CreateWindowAsChild       (int x0, int y0, int xSize, int ySize, GUI_HWIN hWinParent, unsigned long Style, WM_CALLBACK* cb, int NumExtraBytes);
Nvoid    WM_DeleteWindow              (WM_HWIN hWin);
Xvoid    WM_DeleteWindow              (GUI_HWIN hWin);
Nvoid    WM_DetachWindow              (WM_HWIN hWin);
Xvoid    WM_DetachWindow              (GUI_HWIN hWin);
Nvoid    WM_EnableGestures            (WM_HWIN hWin, int OnOff);
Xvoid    WM_EnableGestures            (GUI_HWIN hWin, int OnOff);
Nint     WM_GetHasTrans               (WM_HWIN hWin);
Xint     WM_GetHasTrans               (GUI_HWIN hWin);
NWM_HWIN WM_GetFocusedWindow          (void);
XGUI_HWIN WM_GetFocusedWindow          (void);
Nint     WM_GetInvalidRect            (WM_HWIN hWin, GUI_RECT * pRect);
Xint     WM_GetInvalidRect            (GUI_HWIN hWin, GUI_RECT * pRect);
Nint     WM_GetStayOnTop              (WM_HWIN hWin);
Xint     WM_GetStayOnTop              (GUI_HWIN hWin);
Nvoid    WM_HideWindow                (WM_HWIN hWin);
Xvoid    WM_HideWindow                (GUI_HWIN hWin);
Nvoid    WM_InvalidateArea            (const GUI_RECT * pRect);
Nvoid    WM_InvalidateRect            (WM_HWIN hWin, const GUI_RECT * pRect);
Xvoid    WM_InvalidateRect            (GUI_HWIN hWin, const GUI_RECT * pRect);
Nvoid    WM_InvalidateWindow          (WM_HWIN hWin);
Xvoid    WM_InvalidateWindow          (GUI_HWIN hWin);
Nvoid    WM_InvalidateWindowAndDescsEx(WM_HWIN hWin, const GUI_RECT * pInvalidRect, U16 Flags);
Xvoid    WM_InvalidateWindowAndDescsEx(GUI_HWIN hWin, const GUI_RECT * pInvalidRect, unsigned short Flags);
Nvoid    WM_InvalidateWindowAndDescs  (WM_HWIN hWin);    /* not to be documented (may change in future version) */
Xvoid    WM_InvalidateWindowAndDescs  (GUI_HWIN hWin);     
Nint     WM_IsEnabled                 (WM_HWIN hObj);
Xint     WM_IsEnabled                 (GUI_HWIN hObj);
Nchar    WM_IsCompletelyCovered       (WM_HWIN hWin);    /* Checks if the window is completely covered by other windows */
Xchar    WM_IsCompletelyCovered       (GUI_HWIN hWin);     
Nchar    WM_IsCompletelyVisible       (WM_HWIN hWin);    /* Is the window completely visible ? */
Xchar    WM_IsCompletelyVisible       (GUI_HWIN hWin);     
Nint     WM_IsFocusable               (WM_HWIN hWin);
Xint     WM_IsFocusable               (GUI_HWIN hWin);
Nint     WM_IsVisible                 (WM_HWIN hWin);
Xint     WM_IsVisible                 (GUI_HWIN hWin);
Nint     WM_IsWindow                  (WM_HWIN hWin);    /* Check validity */
Xint     WM_IsWindow                  (GUI_HWIN hWin);     
Nvoid    WM_Rect2Screen               (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid    WM_Rect2Screen               (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid    WM_Rect2Client               (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid    WM_Rect2Client               (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid    WM_SetAnchor                 (WM_HWIN hWin, U16 AnchorFlags);
Xvoid    WM_SetAnchor                 (GUI_HWIN hWin, unsigned short AnchorFlags);
Nvoid    WM_SetHasTrans               (WM_HWIN hWin);
Xvoid    WM_SetHasTrans               (GUI_HWIN hWin);
Nvoid    WM_SetId                     (WM_HWIN hObj, int Id);
Xvoid    WM_SetId                     (GUI_HWIN hObj, int Id);
Nvoid    WM_SetStayOnTop              (WM_HWIN hWin, int OnOff);
Xvoid    WM_SetStayOnTop              (GUI_HWIN hWin, int OnOff);
Nvoid    WM_SetTransState             (WM_HWIN hWin, unsigned State);
Xvoid    WM_SetTransState             (GUI_HWIN hWin, unsigned State);
Nvoid    WM_ShowWindow                (WM_HWIN hWin);
Xvoid    WM_ShowWindow                (GUI_HWIN hWin);
Nvoid    WM_ValidateRect              (WM_HWIN hWin, const GUI_RECT * pRect);
Xvoid    WM_ValidateRect              (GUI_HWIN hWin, const GUI_RECT * pRect);
Nvoid    WM_ValidateWindow            (WM_HWIN hWin);
Xvoid    WM_ValidateWindow            (GUI_HWIN hWin);
Nvoid    WM_XY2Screen                 (WM_HWIN hWin, int * px, int * py);
Xvoid    WM_XY2Screen                 (GUI_HWIN hWin, int * px, int * py);
Nvoid    WM_XY2Client                 (WM_HWIN hWin, int * px, int * py);
Xvoid    WM_XY2Client                 (GUI_HWIN hWin, int * px, int * py);
N
N#define WM_GetFocussedWindow WM_GetFocusedWindow
N#define WM_IsFocussable      WM_IsFocusable
N
N/* Gesture support */
Nvoid WM_GESTURE_Enable  (int OnOff);
Nint  WM_GESTURE_EnableEx(int OnOff, int MaxFactor);
Nvoid WM_GESTURE_Exec    (void);
NI32  WM_GESTURE_SetThresholdAngle(I32 ThresholdAngle);
Xsigned long  WM_GESTURE_SetThresholdAngle(signed long ThresholdAngle);
NI32  WM_GESTURE_SetThresholdDist (I32 ThresholdDist);
Xsigned long  WM_GESTURE_SetThresholdDist (signed long ThresholdDist);
N
N/* Motion support */
Nvoid     WM_MOTION_Enable          (int OnOff);
Nvoid     WM_MOTION_SetMovement     (WM_HWIN hWin, int Axis, I32 Speed, I32 Dist);
Xvoid     WM_MOTION_SetMovement     (GUI_HWIN hWin, int Axis, signed long Speed, signed long Dist);
Nvoid     WM_MOTION_SetMotion       (WM_HWIN hWin, int Axis, I32 Speed, I32 Deceleration);
Xvoid     WM_MOTION_SetMotion       (GUI_HWIN hWin, int Axis, signed long Speed, signed long Deceleration);
Nvoid     WM_MOTION_SetMoveable     (WM_HWIN hWin, U32 Flags, int OnOff);
Xvoid     WM_MOTION_SetMoveable     (GUI_HWIN hWin, unsigned long Flags, int OnOff);
Nvoid     WM_MOTION_SetDeceleration (WM_HWIN hWin, int Axis, I32 Deceleration);
Xvoid     WM_MOTION_SetDeceleration (GUI_HWIN hWin, int Axis, signed long Deceleration);
Nunsigned WM_MOTION_SetDefaultPeriod(unsigned Period);
Nvoid     WM_MOTION_SetSpeed        (WM_HWIN hWin, int Axis, I32 Velocity);
Xvoid     WM_MOTION_SetSpeed        (GUI_HWIN hWin, int Axis, signed long Velocity);
Nvoid     WM_MOTION_SetMinMotion    (unsigned MinMotion);
Nvoid     WM_MOTION_SetThreshold    (unsigned Threshold);
N
N/* Motion support, private interface */
NWM_HMEM WM_MOTION__CreateContext(void);
Xsigned long WM_MOTION__CreateContext(void);
Nvoid    WM_MOTION__DeleteContext(WM_HMEM hContext);
Xvoid    WM_MOTION__DeleteContext(signed long hContext);
N
N/* Motion support, private function(s) */
Nvoid     WM__SetMotionCallback (void(* cbMotion) (GUI_PID_STATE * pState, void * p));
N
N/* Static memory devices */
N#if (GUI_SUPPORT_MEMDEV)
X#if (1)
N  #define GUI_MEMDEV_EDGE_LEFT   0
N  #define GUI_MEMDEV_EDGE_RIGHT  1
N  #define GUI_MEMDEV_EDGE_TOP    2
N  #define GUI_MEMDEV_EDGE_BOTTOM 3
N
N  int               GUI_MEMDEV_BlendWinBk       (WM_HWIN hWin, int Period, U32 BlendColor, U8 BlendIntens);
X  int               GUI_MEMDEV_BlendWinBk       (GUI_HWIN hWin, int Period, unsigned long BlendColor, unsigned char BlendIntens);
N  int               GUI_MEMDEV_BlurAndBlendWinBk(WM_HWIN hWin, int Period, U8 BlurDepth, U32 BlendColor, U8 BlendIntens);
X  int               GUI_MEMDEV_BlurAndBlendWinBk(GUI_HWIN hWin, int Period, unsigned char BlurDepth, unsigned long BlendColor, unsigned char BlendIntens);
N  int               GUI_MEMDEV_BlurWinBk        (WM_HWIN hWin, int Period, U8 BlurDepth);
X  int               GUI_MEMDEV_BlurWinBk        (GUI_HWIN hWin, int Period, unsigned char BlurDepth);
N  void              GUI_MEMDEV_CreateStatic     (WM_HWIN hWin);
X  void              GUI_MEMDEV_CreateStatic     (GUI_HWIN hWin);
N  GUI_MEMDEV_Handle GUI_MEMDEV_CreateWindowDevice(WM_HWIN hWin);
X  GUI_MEMDEV_Handle GUI_MEMDEV_CreateWindowDevice(GUI_HWIN hWin);
N  int               GUI_MEMDEV_FadeInWindow     (WM_HWIN hWin, int Period);
X  int               GUI_MEMDEV_FadeInWindow     (GUI_HWIN hWin, int Period);
N  int               GUI_MEMDEV_FadeOutWindow    (WM_HWIN hWin, int Period);
X  int               GUI_MEMDEV_FadeOutWindow    (GUI_HWIN hWin, int Period);
N  GUI_MEMDEV_Handle GUI_MEMDEV_GetStaticDevice  (WM_HWIN hWin);
X  GUI_MEMDEV_Handle GUI_MEMDEV_GetStaticDevice  (GUI_HWIN hWin);
N  GUI_MEMDEV_Handle GUI_MEMDEV_GetWindowDevice  (WM_HWIN hWin);
X  GUI_MEMDEV_Handle GUI_MEMDEV_GetWindowDevice  (GUI_HWIN hWin);
N  int               GUI_MEMDEV_MoveInWindow     (WM_HWIN hWin, int x, int y, int a180, int Period);
X  int               GUI_MEMDEV_MoveInWindow     (GUI_HWIN hWin, int x, int y, int a180, int Period);
N  int               GUI_MEMDEV_MoveOutWindow    (WM_HWIN hWin, int x, int y, int a180, int Period);
X  int               GUI_MEMDEV_MoveOutWindow    (GUI_HWIN hWin, int x, int y, int a180, int Period);
N  void              GUI_MEMDEV_Paint1Static     (WM_HWIN hWin);                                     /* not to be documented */
X  void              GUI_MEMDEV_Paint1Static     (GUI_HWIN hWin);                                      
N  int               GUI_MEMDEV_ShiftInWindow    (WM_HWIN hWin, int Period, int Direction);
X  int               GUI_MEMDEV_ShiftInWindow    (GUI_HWIN hWin, int Period, int Direction);
N  int               GUI_MEMDEV_ShiftOutWindow   (WM_HWIN hWin, int Period, int Direction);
X  int               GUI_MEMDEV_ShiftOutWindow   (GUI_HWIN hWin, int Period, int Direction);
N  int               GUI_MEMDEV_SwapWindow       (WM_HWIN hWin, int Period, int Edge);
X  int               GUI_MEMDEV_SwapWindow       (GUI_HWIN hWin, int Period, int Edge);
N
N  void              GUI_MEMDEV__CreateStatic    (WM_HWIN hWin);
X  void              GUI_MEMDEV__CreateStatic    (GUI_HWIN hWin);
N#endif
N
N/* Move/resize windows */
Nvoid WM_MoveWindow                (WM_HWIN hWin, int dx, int dy);
Xvoid WM_MoveWindow                (GUI_HWIN hWin, int dx, int dy);
Nvoid WM_ResizeWindow              (WM_HWIN hWin, int dx, int dy);
Xvoid WM_ResizeWindow              (GUI_HWIN hWin, int dx, int dy);
Nvoid WM_MoveTo                    (WM_HWIN hWin, int x, int y);
Xvoid WM_MoveTo                    (GUI_HWIN hWin, int x, int y);
Nvoid WM_MoveChildTo               (WM_HWIN hWin, int x, int y);
Xvoid WM_MoveChildTo               (GUI_HWIN hWin, int x, int y);
Nvoid WM_SetSize                   (WM_HWIN hWin, int XSize, int YSize);
Xvoid WM_SetSize                   (GUI_HWIN hWin, int XSize, int YSize);
Nvoid WM_SetWindowPos              (WM_HWIN hWin, int xPos, int yPos, int xSize, int ySize);
Xvoid WM_SetWindowPos              (GUI_HWIN hWin, int xPos, int yPos, int xSize, int ySize);
Nint  WM_SetXSize                  (WM_HWIN hWin, int xSize);
Xint  WM_SetXSize                  (GUI_HWIN hWin, int xSize);
Nint  WM_SetYSize                  (WM_HWIN hWin, int ySize);
Xint  WM_SetYSize                  (GUI_HWIN hWin, int ySize);
Nint  WM_SetScrollbarH             (WM_HWIN hWin, int OnOff); /* not to be documented (may change in future version) */
Xint  WM_SetScrollbarH             (GUI_HWIN hWin, int OnOff);  
Nint  WM_SetScrollbarV             (WM_HWIN hWin, int OnOff); /* not to be documented (may change in future version) */
Xint  WM_SetScrollbarV             (GUI_HWIN hWin, int OnOff);  
N
N/* ToolTip support */
N#define WM_TOOLTIP_PI_FIRST 0
N#define WM_TOOLTIP_PI_SHOW  1
N#define WM_TOOLTIP_PI_NEXT  2
N
N#define WM_TOOLTIP_CI_BK    0
N#define WM_TOOLTIP_CI_FRAME 1
N#define WM_TOOLTIP_CI_TEXT  2
N
Ntypedef WM_HMEM WM_TOOLTIP_HANDLE;
Xtypedef signed long WM_TOOLTIP_HANDLE;
N
Ntypedef struct {
N  int          Id;
N  const char * pText;
N} TOOLTIP_INFO;
N
Nint               WM_TOOLTIP_AddTool         (WM_TOOLTIP_HANDLE hToolTip, WM_HWIN hTool, const char * pText);
Xint               WM_TOOLTIP_AddTool         (WM_TOOLTIP_HANDLE hToolTip, GUI_HWIN hTool, const char * pText);
NWM_TOOLTIP_HANDLE WM_TOOLTIP_Create          (WM_HWIN hDlg, const TOOLTIP_INFO * pInfo, unsigned NumItems);
XWM_TOOLTIP_HANDLE WM_TOOLTIP_Create          (GUI_HWIN hDlg, const TOOLTIP_INFO * pInfo, unsigned NumItems);
Nvoid              WM_TOOLTIP_Delete          (WM_TOOLTIP_HANDLE hToolTip);
NGUI_COLOR         WM_TOOLTIP_SetDefaultColor (unsigned Index, GUI_COLOR Color);
Nconst GUI_FONT *  WM_TOOLTIP_SetDefaultFont  (const GUI_FONT * pFont);
Nunsigned          WM_TOOLTIP_SetDefaultPeriod(unsigned Index, unsigned Period);
N
N/* ToolTip support, private */
Nvoid WM__SetToolTipCallback(void(* cbToolTip)(GUI_PID_STATE * pState, WM_HWIN));
Xvoid WM__SetToolTipCallback(void(* cbToolTip)(GUI_PID_STATE * pState, GUI_HWIN));
N
N/* Timer */
N#ifdef GUI_X_CREATE_TIMER
S  int  WM_CreateTimer    (WM_HWIN hWin, int UserID, int Period, int Mode); /* not to be documented (may change in future version) */
S  void WM_DeleteTimer    (WM_HWIN hWin, int UserId); /* not to be documented (may change in future version) */
N#else
N  WM_HMEM WM_CreateTimer (WM_HWIN hWin, int UserID, int Period, int Mode); /* not to be documented (may change in future version) */
X  signed long WM_CreateTimer (GUI_HWIN hWin, int UserID, int Period, int Mode);  
N  void    WM_DeleteTimer (WM_HMEM hTimer); /* not to be documented (may change in future version) */
X  void    WM_DeleteTimer (signed long hTimer);  
N  void    WM_RestartTimer(WM_HMEM hTimer, int Period);
X  void    WM_RestartTimer(signed long hTimer, int Period);
N#endif
Nint WM_GetTimerId(WM_HTIMER hTimer);
Xint WM_GetTimerId(signed long hTimer);
N
N/* Diagnostics */
Nint WM_GetNumWindows(void);
Nint WM_GetNumInvalidWindows(void);
N
N/* Scroll state related functions */
Nvoid WM_CheckScrollBounds(WM_SCROLL_STATE * pScrollState); /* not to be documented (may change in future version) */
Nint  WM_GetScrollPosH    (WM_HWIN hWin);
Xint  WM_GetScrollPosH    (GUI_HWIN hWin);
Nint  WM_GetScrollPosV    (WM_HWIN hWin);
Xint  WM_GetScrollPosV    (GUI_HWIN hWin);
Nvoid WM_SetScrollPosH    (WM_HWIN hWin, unsigned ScrollPos);
Xvoid WM_SetScrollPosH    (GUI_HWIN hWin, unsigned ScrollPos);
Nvoid WM_SetScrollPosV    (WM_HWIN hWin, unsigned ScrollPos);
Xvoid WM_SetScrollPosV    (GUI_HWIN hWin, unsigned ScrollPos);
Nint  WM_SetScrollValue   (WM_SCROLL_STATE * pScrollState, int v); /* not to be documented (may change in future version) */
N
N/* Get / Set (new) callback function */
NWM_CALLBACK * WM_SetCallback(WM_HWIN hWin, WM_CALLBACK * cb);
XWM_CALLBACK * WM_SetCallback(GUI_HWIN hWin, WM_CALLBACK * cb);
NWM_CALLBACK * WM_GetCallback(WM_HWIN hWin);
XWM_CALLBACK * WM_GetCallback(GUI_HWIN hWin);
N
N/* Get size/origin of a window */
Nvoid      WM_GetClientRect           (GUI_RECT * pRect);
Nvoid      WM_GetClientRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid      WM_GetClientRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid      WM_GetInsideRect           (GUI_RECT * pRect);
Nvoid      WM_GetInsideRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid      WM_GetInsideRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid      WM_GetInsideRectExScrollbar(WM_HWIN hWin, GUI_RECT * pRect); /* not to be documented (may change in future version) */
Xvoid      WM_GetInsideRectExScrollbar(GUI_HWIN hWin, GUI_RECT * pRect);  
Nvoid      WM_GetWindowRect           (GUI_RECT * pRect);
Nvoid      WM_GetWindowRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid      WM_GetWindowRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
Nint       WM_GetOrgX                 (void);
Nint       WM_GetOrgY                 (void);
Nint       WM_GetWindowOrgX           (WM_HWIN hWin);
Xint       WM_GetWindowOrgX           (GUI_HWIN hWin);
Nint       WM_GetWindowOrgY           (WM_HWIN hWin);
Xint       WM_GetWindowOrgY           (GUI_HWIN hWin);
Nint       WM_GetWindowSizeX          (WM_HWIN hWin);
Xint       WM_GetWindowSizeX          (GUI_HWIN hWin);
Nint       WM_GetWindowSizeY          (WM_HWIN hWin);
Xint       WM_GetWindowSizeY          (GUI_HWIN hWin);
NWM_HWIN   WM_GetFirstChild           (WM_HWIN hWin);
XGUI_HWIN   WM_GetFirstChild           (GUI_HWIN hWin);
NWM_HWIN   WM_GetNextSibling          (WM_HWIN hWin);
XGUI_HWIN   WM_GetNextSibling          (GUI_HWIN hWin);
NWM_HWIN   WM_GetParent               (WM_HWIN hWin);
XGUI_HWIN   WM_GetParent               (GUI_HWIN hWin);
NWM_HWIN   WM_GetPrevSibling          (WM_HWIN hWin);
XGUI_HWIN   WM_GetPrevSibling          (GUI_HWIN hWin);
Nint       WM_GetId                   (WM_HWIN hWin);
Xint       WM_GetId                   (GUI_HWIN hWin);
NWM_HWIN   WM_GetScrollbarV           (WM_HWIN hWin);
XGUI_HWIN   WM_GetScrollbarV           (GUI_HWIN hWin);
NWM_HWIN   WM_GetScrollbarH           (WM_HWIN hWin);
XGUI_HWIN   WM_GetScrollbarH           (GUI_HWIN hWin);
NWM_HWIN   WM_GetScrollPartner        (WM_HWIN hWin);
XGUI_HWIN   WM_GetScrollPartner        (GUI_HWIN hWin);
NWM_HWIN   WM_GetClientWindow         (WM_HWIN hObj);
XGUI_HWIN   WM_GetClientWindow         (GUI_HWIN hObj);
NGUI_COLOR WM_GetBkColor              (WM_HWIN hObj);
XGUI_COLOR WM_GetBkColor              (GUI_HWIN hObj);
N
N/* Change Z-Order of windows */
Nvoid WM_BringToBottom(WM_HWIN hWin);
Xvoid WM_BringToBottom(GUI_HWIN hWin);
Nvoid WM_BringToTop(WM_HWIN hWin);
Xvoid WM_BringToTop(GUI_HWIN hWin);
N
NGUI_COLOR WM_SetDesktopColor  (GUI_COLOR Color);
NGUI_COLOR WM_SetDesktopColorEx(GUI_COLOR Color, unsigned int LayerIndex);
Nvoid      WM_SetDesktopColors (GUI_COLOR Color);
N
N/* Select window used for drawing operations */
NWM_HWIN WM_SelectWindow           (WM_HWIN  hWin);
XGUI_HWIN WM_SelectWindow           (GUI_HWIN  hWin);
NWM_HWIN WM_GetActiveWindow        (void);
XGUI_HWIN WM_GetActiveWindow        (void);
Nvoid    WM_Paint                  (WM_HWIN hObj);
Xvoid    WM_Paint                  (GUI_HWIN hObj);
Nvoid    WM_Update                 (WM_HWIN hWin);
Xvoid    WM_Update                 (GUI_HWIN hWin);
Nvoid    WM_PaintWindowAndDescs    (WM_HWIN hWin);
Xvoid    WM_PaintWindowAndDescs    (GUI_HWIN hWin);
Nvoid    WM_UpdateWindowAndDescs   (WM_HWIN hWin);
Xvoid    WM_UpdateWindowAndDescs   (GUI_HWIN hWin);
N
N/* Get foreground/background windows */
NWM_HWIN WM_GetDesktopWindow  (void);
XGUI_HWIN WM_GetDesktopWindow  (void);
NWM_HWIN WM_GetDesktopWindowEx(unsigned int LayerIndex);
XGUI_HWIN WM_GetDesktopWindowEx(unsigned int LayerIndex);
N
N/* Reduce clipping area of a window */
Nconst GUI_RECT * WM_SetUserClipRect(const GUI_RECT * pRect);
Nvoid             WM_SetDefault     (void);
N
N/* Use of memory devices */
Nvoid WM_EnableMemdev              (WM_HWIN hWin);
Xvoid WM_EnableMemdev              (GUI_HWIN hWin);
Nvoid WM_DisableMemdev             (WM_HWIN hWin);
Xvoid WM_DisableMemdev             (GUI_HWIN hWin);
N
N/* Automatic use of multiple buffers */
Nint WM_MULTIBUF_Enable  (int OnOff);
Nint WM_MULTIBUF_EnableEx(int OnOff, U32 LayerMask);
Xint WM_MULTIBUF_EnableEx(int OnOff, unsigned long LayerMask);
N
Nextern const GUI_MULTIBUF_API * WM_MULTIBUF__pAPI;
N
Ntypedef void (* T_WM_EXEC_GESTURE)(void);
N
Nextern T_WM_EXEC_GESTURE WM__pExecGestures;
N
N/* ... */
Nint WM_OnKey(int Key, int Pressed);
Nvoid WM_MakeModal(WM_HWIN hWin);
Xvoid WM_MakeModal(GUI_HWIN hWin);
Nint WM_SetModalLayer(int LayerIndex);
Nint WM_GetModalLayer(void);
N
N/*********************************************************************
N*
N*       Message related functions
N*
N*  Please note that some of these functions do not yet show up in the
N*  documentation, as they should not be required by application program.
N*/
Nvoid      WM_NotifyParent         (WM_HWIN hWin, int Notification);
Xvoid      WM_NotifyParent         (GUI_HWIN hWin, int Notification);
Nvoid      WM_SendMessage          (WM_HWIN hWin, WM_MESSAGE * p);
Xvoid      WM_SendMessage          (GUI_HWIN hWin, WM_MESSAGE * p);
Nvoid      WM_SendMessageNoPara    (WM_HWIN hWin, int MsgId);             /* not to be documented (may change in future */
Xvoid      WM_SendMessageNoPara    (GUI_HWIN hWin, int MsgId);              
Nvoid      WM_DefaultProc          (WM_MESSAGE * pMsg);
Nint       WM_BroadcastMessage     (WM_MESSAGE * pMsg);
Nvoid      WM_SetScrollState       (WM_HWIN hWin, const WM_SCROLL_STATE * pState);
Xvoid      WM_SetScrollState       (GUI_HWIN hWin, const WM_SCROLL_STATE * pState);
Nvoid      WM_SetEnableState       (WM_HWIN hItem, int State);
Xvoid      WM_SetEnableState       (GUI_HWIN hItem, int State);
Nvoid      WM_SendToParent         (WM_HWIN hWin, WM_MESSAGE * pMsg);
Xvoid      WM_SendToParent         (GUI_HWIN hWin, WM_MESSAGE * pMsg);
Nint       WM_HasFocus             (WM_HWIN hWin);
Xint       WM_HasFocus             (GUI_HWIN hWin);
Nint       WM_SetFocus             (WM_HWIN hWin);
Xint       WM_SetFocus             (GUI_HWIN hWin);
NWM_HWIN   WM_SetFocusOnNextChild  (WM_HWIN hParent);     /* Set the focus to the next child */
XGUI_HWIN   WM_SetFocusOnNextChild  (GUI_HWIN hParent);      
NWM_HWIN   WM_SetFocusOnPrevChild  (WM_HWIN hParent);     /* Set the focus to the previous child */
XGUI_HWIN   WM_SetFocusOnPrevChild  (GUI_HWIN hParent);      
NWM_HWIN   WM_GetDialogItem        (WM_HWIN hWin, int Id);
XGUI_HWIN   WM_GetDialogItem        (GUI_HWIN hWin, int Id);
Nvoid      WM_EnableWindow         (WM_HWIN hWin);
Xvoid      WM_EnableWindow         (GUI_HWIN hWin);
Nvoid      WM_DisableWindow        (WM_HWIN hWin);
Xvoid      WM_DisableWindow        (GUI_HWIN hWin);
Nvoid      WM_GetScrollState       (WM_HWIN hObj, WM_SCROLL_STATE * pScrollState);
Xvoid      WM_GetScrollState       (GUI_HWIN hObj, WM_SCROLL_STATE * pScrollState);
N
N/*********************************************************************
N*
N*       Managing user data
N*/
Nint       WM_GetUserData   (WM_HWIN hWin, void * pDest, int SizeOfBuffer);
Xint       WM_GetUserData   (GUI_HWIN hWin, void * pDest, int SizeOfBuffer);
Nint       WM_SetUserData   (WM_HWIN hWin, const void * pSrc, int SizeOfBuffer);
Xint       WM_SetUserData   (GUI_HWIN hWin, const void * pSrc, int SizeOfBuffer);
Nint       WM__GetUserDataEx(WM_HWIN hWin, void * pDest, int NumBytes, int SizeOfObject);
Xint       WM__GetUserDataEx(GUI_HWIN hWin, void * pDest, int NumBytes, int SizeOfObject);
Nint       WM__SetUserDataEx(WM_HWIN hWin, const void * pSrc, int NumBytes, int SizeOfObject);
Xint       WM__SetUserDataEx(GUI_HWIN hWin, const void * pSrc, int NumBytes, int SizeOfObject);
N
N/*********************************************************************
N*
N*       Capturing input focus
N*/
Nint  WM_HasCaptured   (WM_HWIN hWin);
Xint  WM_HasCaptured   (GUI_HWIN hWin);
Nvoid WM_SetCapture    (WM_HWIN hObj, int AutoRelease);
Xvoid WM_SetCapture    (GUI_HWIN hObj, int AutoRelease);
Nvoid WM_SetCaptureMove(WM_HWIN hWin, const GUI_PID_STATE * pState, int MinVisibility, int LimitTop); /* Not yet documented */
Xvoid WM_SetCaptureMove(GUI_HWIN hWin, const GUI_PID_STATE * pState, int MinVisibility, int LimitTop);  
Nvoid WM_ReleaseCapture(void);
N
N/*********************************************************************
N*
N*       Misc routines
N*/
Nint       WM_HandlePID      (void);
NWM_HWIN   WM_Screen2hWin    (int x, int y);
XGUI_HWIN   WM_Screen2hWin    (int x, int y);
NWM_HWIN   WM_Screen2hWinEx  (WM_HWIN hStop, int x, int y);
XGUI_HWIN   WM_Screen2hWinEx  (GUI_HWIN hStop, int x, int y);
Nvoid      WM_ForEachDesc    (WM_HWIN hWin, WM_tfForEach * pcb, void * pData);
Xvoid      WM_ForEachDesc    (GUI_HWIN hWin, WM_tfForEach * pcb, void * pData);
Nvoid      WM_SetScreenSize  (int xSize, int ySize);
Nint       WM_PollSimMsg     (void);
Nint       WM_GetWindowInfo  (WM_WINDOW_INFO * pInfo, int FirstWindow);
N
N/*********************************************************************
N*
N*       Diagnostics routines
N*/
N#if (WM_SUPPORT_DIAG)
X#if (0)
Svoid WM_DIAG_EnableInvalidationColoring(int OnOff);
N#endif
N
N/*********************************************************************
N*
N*       Macros for compatibility with older versions
N*/
N#if WM_COMPATIBLE_MODE
X#if 1
N  #define HBWIN             WM_HWIN
N  #define HBWIN_NULL        WM_HWIN_NULL
N
N  #define WM_HideWin        WM_HideWindow
N  #define WM_ShowWin        WM_ShowWindow
N  #define WM_GetKey         GUI_GetKey
N  #define WM_WaitKey        GUI_WaitKey
N
N  #define WM_ExecIdle       WM_Exec
N  #define WM_ExecIdle1      WM_Exec1
N
N  #define WM_Invalidate     WM_InvalidateWindow
N  #define WM_GetWinRect     WM_GetWindowRect
N  #define WM_GetWinOrgX     WM_GetWindowOrgX
N  #define WM_GetWinOrgY     WM_GetWindowOrgY
N  #define WM_GetWinSizeX    WM_GetWindowSizeX
N  #define WM_GetWinSizeY    WM_GetWindowSizeY
N  #define WM_GetXSize       WM_GetWindowSizeX
N  #define WM_GetYSize       WM_GetWindowSizeY
N  #define WM_SelWin         WM_SelectWindow
N  #define WM_GetBackgroundWindow  WM_GetDesktopWindow
N  #define WM_GetForegroundWindow    0
N  #define WM_SetForegroundWindow    WM_BringToTop
N  #define WM_SetUserClipArea WM_SetUserClipRect
N
N
N  #define WM_Start()
N  #define WM_Stop()
N  #define WM_SetBkWindowColor(Color)  WM_SetDesktopColor(Color)
N
N#endif
N
N
N#endif   /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif   /* WM_H */
N
N/*************************** End of file ****************************/
L 29 "..\main.c" 2
N#include "FRAMEWIN.h"
L 1 "..\..\..\ThirdParty\emWin\Include\FRAMEWIN.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : FRAMEWIN.h
NPurpose     : Frame window include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef FRAMEWIN_H
N#define FRAMEWIN_H
N
N#include "WM.h"
N#include "WIDGET.h"             /* Req. for WIDGET_DRAW_ITEM_FUNC */
L 1 "..\..\..\ThirdParty\emWin\Include\WIDGET.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WIDGET.h
NPurpose     : Widget interface
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef WIDGET_H        /* Avoid multiple inclusion  */
N#define WIDGET_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#include "WM_Intern.h"  /* Window manager, including some internals, which speed things up */
L 1 "..\..\..\ThirdParty\emWin\Include\WM_Intern.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WM_Intern.h
NPurpose     : Windows manager internal include
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_INTERN_H            /* Make sure we only include it once */
N#define WM_INTERN_H            /* Make sure we only include it once */
N
N#include "WM.h"
N#include "GUI_Private.h"
L 1 "..\..\..\ThirdParty\emWin\Include\GUI_Private.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_Private.h
NPurpose     : GUI internal declarations
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef GUI_PRIVATE_H
N#define GUI_PRIVATE_H
N
N#include "GUI.h"
N#include "LCD_Protected.h"
L 1 "..\..\..\ThirdParty\emWin\Include\LCD_Protected.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : LCD_Protected.h
NPurpose     : LCD level - To be used only internally by the GUI
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_PROTECTED_H
N#define LCD_PROTECTED_H
N
N#include "LCD.h"
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Data types
N*/
Ntypedef struct {
N  LCD_COLOR * paColor;
N  I16         NumEntries;
X  signed short         NumEntries;
N} LCD_LUT_INFO;
N
Ntypedef struct {
N  tLCDDEV_DrawPixel  * pfDrawPixel;
N  tLCDDEV_DrawHLine  * pfDrawHLine;
N  tLCDDEV_DrawVLine  * pfDrawVLine;
N  tLCDDEV_FillRect   * pfFillRect;
N  tLCDDEV_DrawBitmap * pfDrawBitmap;
N} LCD_API_LIST;
N
N/*********************************************************************
N*
N*       External data
N*/
Nextern GUI_CONST_STORAGE U8 LCD_aMirror[256];
Xextern const unsigned char LCD_aMirror[256];
Nextern LCD_PIXELINDEX * LCD__aConvTable;
Xextern unsigned long * LCD__aConvTable;
N
N/*********************************************************************
N*
N*       Misc functions
N*/
Nvoid LCD_UpdateColorIndices   (void);
Nint  LCD_PassingBitmapsAllowed(void);
Nvoid LCD_EnableCursor         (int OnOff);
Nvoid LCD_SelectLCD            (void);
N
Nvoid LCD_DrawBitmap(int x0,    int y0,
N                    int xsize, int ysize,
N                    int xMul,  int yMul,
N                    int BitsPerPixel,
N                    int BytesPerLine,
N                    const U8 * pPixel,
X                    const unsigned char * pPixel,
N                    const LCD_PIXELINDEX * pTrans);
X                    const unsigned long * pTrans);
N
Nvoid LCD__DrawBitmap_1bpp(int x0,    int y0,
N                          int xsize, int ysize,
N                          int xMul,  int yMul,
N                          int BitsPerPixel,
N                          int BytesPerLine,
N                          const U8 * pPixel,
X                          const unsigned char * pPixel,
N                          const LCD_PIXELINDEX * pTrans,
X                          const unsigned long * pTrans,
N                          int OffData);
N
N/*********************************************************************
N*
N*       Internal used color conversion routines
N*/
NtLCDDEV_Index2Color LCD_Index2Color_444_12;
NtLCDDEV_Index2Color LCD_Index2Color_M444_12;
NtLCDDEV_Index2Color LCD_Index2Color_444_12_1;
NtLCDDEV_Index2Color LCD_Index2Color_M444_12_1;
NtLCDDEV_Index2Color LCD_Index2Color_444_16;
NtLCDDEV_Index2Color LCD_Index2Color_M444_16;
NtLCDDEV_Index2Color LCD_Index2Color_555;
NtLCDDEV_Index2Color LCD_Index2Color_565;
NtLCDDEV_Index2Color LCD_Index2Color_8666;
NtLCDDEV_Index2Color LCD_Index2Color_888;
NtLCDDEV_Index2Color LCD_Index2Color_8888;
NtLCDDEV_Index2Color LCD_Index2Color_M8888I;
NtLCDDEV_Index2Color LCD_Index2Color_M555;
NtLCDDEV_Index2Color LCD_Index2Color_M565;
NtLCDDEV_Index2Color LCD_Index2Color_M888;
N
NtLCDDEV_Color2Index LCD_Color2Index_8666;
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif /* LCD_PROTECTED_H */
N
N/*************************** End of file ****************************/
N
L 49 "..\..\..\ThirdParty\emWin\Include\GUI_Private.h" 2
N#include "GUI_Debug.h"
L 1 "..\..\..\ThirdParty\emWin\Include\GUI_Debug.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : GUI_Debug.h
NPurpose     : Debug macros
N----------------------------------------------------------------------
N   Debug macros for logging
N
N In the GUI Simulation, all output is transferred into the log window.
N*/
N
N#ifndef GUI_DEBUG_H
N#define GUI_DEBUG_H
N
N#include <stddef.h>
N
N#include "GUI.h"
N
N#define GUI_DEBUG_LEVEL_NOCHECK       0  /* No run time checks are performed */
N#define GUI_DEBUG_LEVEL_CHECK_PARA    1  /* Parameter checks are performed to avoid crashes */
N#define GUI_DEBUG_LEVEL_CHECK_ALL     2  /* Parameter checks and consistency checks are performed */
N#define GUI_DEBUG_LEVEL_LOG_ERRORS    3  /* Errors are recorded */
N#define GUI_DEBUG_LEVEL_LOG_WARNINGS  4  /* Errors & Warnings are recorded */
N#define GUI_DEBUG_LEVEL_LOG_ALL       5  /* Errors, Warnings and Messages are recorded. */
N
N#ifndef GUI_DEBUG_LEVEL
N  #ifdef WIN32
S    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_LOG_WARNINGS  /* Simulation should log all warnings */
N  #else
N    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_NOCHECK       /* For most targets, min. size is important */
N  #endif
N#endif
N
N#define GUI_LOCK_H(hMem)   GUI_ALLOC_LockH(hMem)
N#define GUI_UNLOCK_H(pMem) GUI_ALLOC_UnlockH((void **)&pMem)
N
N/*******************************************************************
N*
N*               Commandline
N*
N********************************************************************
N*/
N
N#ifdef WIN32
S  #define GUI_DEBUG_GETCMDLINE() SIM_GetCmdLine()
N#else
N  #define GUI_DEBUG_GETCMDLINE() 0
N#endif
N
N/*******************************************************************
N*
N*               Error macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ERRORS
X#if 0 >= 3
S  #define GUI_DEBUG_ERROROUT(s)              GUI_ErrorOut(s)
S  #define GUI_DEBUG_ERROROUT1(s,p0)          GUI_ErrorOut1(s,p0)
S  #define GUI_DEBUG_ERROROUT2(s,p0,p1)       GUI_ErrorOut2(s,p0,p1)
S  #define GUI_DEBUG_ERROROUT3(s,p0,p1,p2)    GUI_ErrorOut3(s,p0,p1,p2)
S  #define GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3) GUI_ErrorOut4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_ERROROUT_IF(exp,s)              { if (exp) GUI_DEBUG_ERROROUT(s); }
S  #define GUI_DEBUG_ERROROUT1_IF(exp,s,p0)          { if (exp) GUI_DEBUG_ERROROUT1(s,p0); }
S  #define GUI_DEBUG_ERROROUT2_IF(exp,s,p0,p1)       { if (exp) GUI_DEBUG_ERROROUT2(s,p0,p1); }
S  #define GUI_DEBUG_ERROROUT3_IF(exp,s,p0,p1,p2)    { if (exp) GUI_DEBUG_ERROROUT3(s,p0,p1,p2); }
S  #define GUI_DEBUG_ERROROUT4_IF(exp,s,p0,p1,p2,p3) { if (exp) GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_ERROROUT(s)
N  #define GUI_DEBUG_ERROROUT1(s,p0)
N  #define GUI_DEBUG_ERROROUT2(s,p0,p1)
N  #define GUI_DEBUG_ERROROUT3(s,p0,p1,p2)
N  #define GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_ERROROUT_IF(exp,s)
N  #define GUI_DEBUG_ERROROUT1_IF(exp,s,p0)
N  #define GUI_DEBUG_ERROROUT2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_ERROROUT3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_ERROROUT4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Warning macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_WARNINGS
X#if 0 >= 4
S  #define GUI_DEBUG_WARN(s)              GUI_Warn(s)
S  #define GUI_DEBUG_WARN1(s,p0)          GUI_Warn1(s,p0)
S  #define GUI_DEBUG_WARN2(s,p0,p1)       GUI_Warn2(s,p0,p1)
S  #define GUI_DEBUG_WARN3(s,p0,p1,p2)    GUI_Warn3(s,p0,p1,p2)
S  #define GUI_DEBUG_WARN4(s,p0,p1,p2,p3) GUI_Warn4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_WARN_IF(exp,s)                  { if (exp) GUI_DEBUG_WARN(s); }
S  #define GUI_DEBUG_WARN1_IF(exp,s,p0)              { if (exp) GUI_DEBUG_WARN1(s,p0); }
S  #define GUI_DEBUG_WARN2_IF(exp,s,p0,p1)           { if (exp) GUI_DEBUG_WARN2(s,p0,p1); }
S  #define GUI_DEBUG_WARN3_IF(exp,s,p0,p1,p2)        { if (exp) GUI_DEBUG_WARN3(s,p0,p1,p2); }
S  #define GUI_DEBUG_WARN4_IF(exp,s,p0,p1,p2,p3)     { if (exp) GUI_DEBUG_WARN4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_WARN(s)
N  #define GUI_DEBUG_WARN1(s,p0)
N  #define GUI_DEBUG_WARN2(s,p0,p1)
N  #define GUI_DEBUG_WARN3(s,p0,p1,p2)
N  #define GUI_DEBUG_WARN4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_WARN_IF(exp,s)
N  #define GUI_DEBUG_WARN1_IF(exp,s,p0)
N  #define GUI_DEBUG_WARN2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_WARN3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_WARN4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Logging macros
N*
N********************************************************************
N*/
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ALL
X#if 0 >= 5
S  #define GUI_DEBUG_LOG(s)              GUI_Log(s)
S  #define GUI_DEBUG_LOG1(s,p0)          GUI_Log1(s,p0)
S  #define GUI_DEBUG_LOG2(s,p0,p1)       GUI_Log2(s,p0,p1)
S  #define GUI_DEBUG_LOG3(s,p0,p1,p2)    GUI_Log3(s,p0,p1,p2)
S  #define GUI_DEBUG_LOG4(s,p0,p1,p2,p3) GUI_Log4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_LOG_IF(exp,s)                   { if (exp) GUI_DEBUG_LOG(s); }
S  #define GUI_DEBUG_LOG1_IF(exp,s,p0)               { if (exp) GUI_DEBUG_LOG1(s,p0); }
S  #define GUI_DEBUG_LOG2_IF(exp,s,p0,p1)            { if (exp) GUI_DEBUG_LOG2(s,p0,p1); }
S  #define GUI_DEBUG_LOG3_IF(exp,s,p0,p1,p2)         { if (exp) GUI_DEBUG_LOG3(s,p0,p1,p2); }
S  #define GUI_DEBUG_LOG4_IF(exp,s,p0,p1,p2,p3)      { if (exp) GUI_DEBUG_LOG4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_LOG(s)
N  #define GUI_DEBUG_LOG1(s,p0)
N  #define GUI_DEBUG_LOG2(s,p0,p1)
N  #define GUI_DEBUG_LOG3(s,p0,p1,p2)
N  #define GUI_DEBUG_LOG4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_LOG_IF(exp,s)
N  #define GUI_DEBUG_LOG1_IF(exp,s,p0)
N  #define GUI_DEBUG_LOG2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_LOG3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_LOG4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Asserts
N*
N********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ERRORS
X#if 0 >= 3
S  #define GUI_DEBUG_ASSERT(exp)                     { if (!exp) GUI_DEBUG_ERROROUT(#exp); }
N#else
N  #define GUI_DEBUG_ASSERT(exp)
N#endif
N
N#endif /* LCD_H */
N
N
N
N
N/*************************** End of file ****************************/
L 50 "..\..\..\ThirdParty\emWin\Include\GUI_Private.h" 2
N#if GUI_WINSUPPORT
X#if 1
N  #include "WM_GUI.h"
N#endif
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defaults for config switches
N*
N**********************************************************************
N
N  The config switches below do not affect the interface in GUI.h and
N  are therefor not required to be in GUI.h.
N*/
N
N/* Short address area.
N   For  most compilers, this is "near" or "__near"
N   We do not use this except for some CPUs which we know to always have some
N   near memory, because the GUI_Context and some other data will be declared
N   to be in this short address (near) memory area as it has a major effect
N   on performance.
N   Please define in GUIConf.h (if you want to use it)
N*/
N#ifndef GUI_SADDR
N  #define GUI_SADDR
N#endif
N
N#ifndef GUI_DEFAULT_FONT
S  #define GUI_DEFAULT_FONT    &GUI_Font6x8
N#endif
N
N#ifndef GUI_DEFAULT_CURSOR
N  #define GUI_DEFAULT_CURSOR  &GUI_CursorArrowM
N#endif
N
N#ifndef GUI_DEFAULT_BKCOLOR
N  #define GUI_DEFAULT_BKCOLOR GUI_BLACK
N#endif
N
N#ifndef GUI_DEFAULT_COLOR
N  #define GUI_DEFAULT_COLOR   GUI_WHITE
N#endif
N
N/*********************************************************************
N*
N*       Angles
N*
N**********************************************************************
N*/
N#define GUI_45DEG  512
N#define GUI_90DEG  (2 * GUI_45DEG)
N#define GUI_180DEG (4 * GUI_45DEG)
N#define GUI_360DEG (8 * GUI_45DEG)
N
N/*********************************************************************
N*
N*       Locking checks
N*
N**********************************************************************
N*/
N#if defined (WIN32) && defined (_DEBUG) && GUI_OS
X#if 0L && 0L && (1)
S  #define GUI_ASSERT_LOCK()    GUITASK_AssertLock()
S  #define GUI_ASSERT_NO_LOCK() GUITASK_AssertNoLock()
S  void GUITASK_AssertLock(void);
S  void GUITASK_AssertNoLock(void);
N#else
N  #define GUI_ASSERT_LOCK()
N  #define GUI_ASSERT_NO_LOCK()
N#endif
N
N/*********************************************************************
N*
N*       Division tables
N*
N**********************************************************************
N*/
Nextern const U8 GUI__aConvert_15_255[(1 << 4)];
Xextern const unsigned char GUI__aConvert_15_255[(1 << 4)];
Nextern const U8 GUI__aConvert_31_255[(1 << 5)];
Xextern const unsigned char GUI__aConvert_31_255[(1 << 5)];
Nextern const U8 GUI__aConvert_63_255[(1 << 6)];
Xextern const unsigned char GUI__aConvert_63_255[(1 << 6)];
Nextern const U8 GUI__aConvert_255_15[(1 << 8)];
Xextern const unsigned char GUI__aConvert_255_15[(1 << 8)];
Nextern const U8 GUI__aConvert_255_31[(1 << 8)];
Xextern const unsigned char GUI__aConvert_255_31[(1 << 8)];
Nextern const U8 GUI__aConvert_255_63[(1 << 8)];
Xextern const unsigned char GUI__aConvert_255_63[(1 << 8)];
N
N/*********************************************************************
N*
N*       Usage internals
N*
N**********************************************************************
N*/
Ntypedef GUI_HMEM GUI_USAGE_Handle;
Xtypedef signed long GUI_USAGE_Handle;
Ntypedef struct tsUSAGE_APIList tUSAGE_APIList;
Ntypedef struct GUI_Usage GUI_USAGE;
N#define GUI_USAGE_h GUI_USAGE_Handle
N
Ntypedef GUI_USAGE_h tUSAGE_CreateCompatible(GUI_USAGE * p);
Xtypedef GUI_USAGE_Handle tUSAGE_CreateCompatible(GUI_USAGE * p);
Ntypedef void        tUSAGE_AddPixel        (GUI_USAGE * p, int x, int y);
Ntypedef void        tUSAGE_AddHLine        (GUI_USAGE * p, int x0, int y0, int len);
Ntypedef void        tUSAGE_Clear           (GUI_USAGE * p);
Ntypedef void        tUSAGE_Delete          (GUI_USAGE_h h);
Xtypedef void        tUSAGE_Delete          (GUI_USAGE_Handle h);
Ntypedef int         tUSAGE_GetNextDirty    (GUI_USAGE * p, int * pxOff, int yOff);
N#define GUI_USAGE_LOCK_H(h) ((GUI_USAGE *)GUI_LOCK_H(h))
N
Nvoid GUI_USAGE_DecUseCnt(GUI_USAGE_Handle  hUsage);
N
NGUI_USAGE_Handle GUI_USAGE_BM_Create(int x0, int y0, int xsize, int ysize, int Flags);
Nvoid    GUI_USAGE_Select(GUI_USAGE_Handle hUsage);
Nvoid    GUI_USAGE_AddRect(GUI_USAGE * pUsage, int x0, int y0, int xSize, int ySize);
N#define GUI_USAGE_AddPixel(p, x,y)            p->pAPI->pfAddPixel(p,x,y)
N#define GUI_USAGE_AddHLine(p,x,y,len)         p->pAPI->pfAddHLine(p,x,y,len)
N#define GUI_USAGE_Clear(p)                    p->pAPI->pfClear(p)
N#define GUI_USAGE_Delete(p)                   p->pAPI->pfDelete(p)
N#define GUI_USAGE_GetNextDirty(p,pxOff, yOff) p->pAPI->pfGetNextDirty(p,pxOff, yOff)
N
Nstruct tsUSAGE_APIList {
N  tUSAGE_AddPixel         * pfAddPixel;
N  tUSAGE_AddHLine         * pfAddHLine;
N  tUSAGE_Clear            * pfClear;
N  tUSAGE_CreateCompatible * pfCreateCompatible;
N  tUSAGE_Delete           * pfDelete;
N  tUSAGE_GetNextDirty     * pfGetNextDirty;
N} ;
N
Nstruct GUI_Usage {
N  I16P x0, y0, XSize, YSize;
X  signed short x0, y0, XSize, YSize;
N  const tUSAGE_APIList * pAPI;
N  I16 UseCnt;
X  signed short UseCnt;
N};
N
N/*********************************************************************
N*
N*       GUI_MEMDEV
N*
N**********************************************************************
N*/
N#if GUI_SUPPORT_MEMDEV
X#if 1
N
Ntypedef struct {
N  GUI_DEVICE * pDevice;
N  I16P                   x0, y0, XSize, YSize;
X  signed short                   x0, y0, XSize, YSize;
N  unsigned               BytesPerLine;
N  unsigned               BitsPerPixel;
N  GUI_HMEM               hUsage;
X  signed long               hUsage;
N} GUI_MEMDEV;
N
N#define      GUI_MEMDEV_LOCK_H(h) ((GUI_MEMDEV *)GUI_LOCK_H(h))
N
Nvoid         GUI_MEMDEV__CopyFromLCD (GUI_MEMDEV_Handle hMem);
Nvoid         GUI_MEMDEV__GetRect     (GUI_RECT * pRect);
Nunsigned     GUI_MEMDEV__Color2Index (LCD_COLOR Color);
NLCD_COLOR    GUI_MEMDEV__Index2Color (int Index);
Nunsigned int GUI_MEMDEV__GetIndexMask(void);
Nvoid         GUI_MEMDEV__SetAlphaCallback(unsigned(* pcbSetAlpha)(U8));
Xvoid         GUI_MEMDEV__SetAlphaCallback(unsigned(* pcbSetAlpha)(unsigned char));
N
NGUI_MEMDEV_Handle GUI_MEMDEV__CreateFixed(int x0, int y0, int xSize, int ySize, int Flags,
N                                          const GUI_DEVICE_API     * pDeviceAPI,
N                                          const LCD_API_COLOR_CONV * pColorConvAPI);
N
Nvoid              GUI_MEMDEV__DrawSizedAt        (GUI_MEMDEV_Handle hMem, int xPos, int yPos, int xSize, int ySize);
NGUI_MEMDEV_Handle GUI_MEMDEV__GetEmptyCopy32     (GUI_MEMDEV_Handle hMem, int * pxSize, int * pySize, int * pxPos, int * pyPos);
Nvoid              GUI_MEMDEV__ReadLine           (int x0, int y, int x1, LCD_PIXELINDEX * pBuffer);
Xvoid              GUI_MEMDEV__ReadLine           (int x0, int y, int x1, unsigned long * pBuffer);
Nvoid              GUI_MEMDEV__WriteToActiveAlpha (GUI_MEMDEV_Handle hMem,int x, int y);
Nvoid              GUI_MEMDEV__WriteToActiveAt    (GUI_MEMDEV_Handle hMem,int x, int y);
Nvoid              GUI_MEMDEV__WriteToActiveOpaque(GUI_MEMDEV_Handle hMem,int x, int y);
Nvoid            * GUI_MEMDEV__XY2PTR             (int x,int y);
Nvoid            * GUI_MEMDEV__XY2PTREx           (GUI_MEMDEV * pDev, int x,int y);
Nvoid              GUI_MEMDEV__BlendColor32       (GUI_MEMDEV_Handle hMem, U32 BlendColor, U8 BlendIntens);
Xvoid              GUI_MEMDEV__BlendColor32       (GUI_MEMDEV_Handle hMem, unsigned long BlendColor, unsigned char BlendIntens);
N
Nunsigned GUI__AlphaPreserveTrans(int OnOff);
N
Nextern unsigned GUI_MEMDEV__TimePerFrame;
N
N#define GUI_TIME_PER_FRAME (GUI_TIMER_TIME)GUI_MEMDEV__TimePerFrame
N
N#define GUI_POS_AUTO -4095   /* Position value for auto-pos */
N
N#endif
N
N/*********************************************************************
N*
N*       LCD_HL_ level defines
N*
N**********************************************************************
N*/
N#define LCD_HL_DrawHLine             GUI_pContext->pLCD_HL->pfDrawHLine
N#define LCD_HL_DrawPixel             GUI_pContext->pLCD_HL->pfDrawPixel
N
N/*********************************************************************
N*
N*       Helper functions
N*
N**********************************************************************
N*/
N#define GUI_ZEROINIT(Obj) GUI__MEMSET(Obj, 0, sizeof(Obj))
Nint  GUI_cos(int angle);
Nint  GUI_sin(int angle);
Nextern const U32 GUI_Pow10[10];
Xextern const unsigned long GUI_Pow10[10];
N
N/* Multi-touch */
Nvoid GUI_MTOUCH__ManagePID(int OnOff);
N
N/* Anti-aliased drawing */
Nint  GUI_AA_Init       (int x0, int x1);
Nint  GUI_AA_Init_HiRes (int x0, int x1);
Nvoid GUI_AA_Exit       (void);
NI16  GUI_AA_HiRes2Pixel(int HiRes);
Xsigned short  GUI_AA_HiRes2Pixel(int HiRes);
N
Nvoid GL_DrawCircleAA_HiRes(int x0, int y0, int r);
Nvoid GL_FillCircleAA_HiRes (int x0, int y0, int r);
Nvoid GL_FillEllipseAA_HiRes(int x0, int y0, int rx, int ry);
N
Nvoid GUI_AA__DrawCharAA2(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8 * pData);
Xvoid GUI_AA__DrawCharAA2(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char * pData);
Nvoid GUI_AA__DrawCharAA4(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8 * pData);
Xvoid GUI_AA__DrawCharAA4(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char * pData);
Nvoid GUI_AA__DrawCharAA8(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8 * pData);
Xvoid GUI_AA__DrawCharAA8(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char * pData);
N
N/* Alpha blending helper functions */
N#define GUI_ALPHABLENDING_DONE  (1 << 0)
N
Nint      GUI__GetAlphaBuffer    (U32 ** ppCurrent, U32 ** ppConvert, U32 ** ppData, int * pVXSizeMax);
Xint      GUI__GetAlphaBuffer    (unsigned long ** ppCurrent, unsigned long ** ppConvert, unsigned long ** ppData, int * pVXSizeMax);
Nint      GUI__AllocAlphaBuffer  (int AllocDataBuffer);
NU32    * GUI__DoAlphaBlending   (int x, int y, U32 * pData, int xSize, tLCDDEV_Index2Color * pfIndex2Color_DEV, int * pDone);
Xunsigned long    * GUI__DoAlphaBlending   (int x, int y, unsigned long * pData, int xSize, tLCDDEV_Index2Color * pfIndex2Color_DEV, int * pDone);
Nunsigned GUI__SetAlphaBufferSize(int xSize);
N
N/* System independent font routines */
Nint        GUI_SIF__GetCharDistX       (U16P c, int * pSizeX);
Xint        GUI_SIF__GetCharDistX       (unsigned short c, int * pSizeX);
Nvoid       GUI_SIF__GetFontInfo        (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Nchar       GUI_SIF__IsInFont           (const GUI_FONT * pFont, U16 c);
Xchar       GUI_SIF__IsInFont           (const GUI_FONT * pFont, unsigned short c);
Nconst U8 * GUI_SIF__GetpCharInfo       (const GUI_FONT * pFont, U16P c, unsigned SizeOfCharInfo);
Xconst unsigned char * GUI_SIF__GetpCharInfo       (const GUI_FONT * pFont, unsigned short c, unsigned SizeOfCharInfo);
Nint        GUI_SIF__GetNumCharAreas    (const GUI_FONT * pFont);
Nint        GUI_SIF__GetCharDistX_ExtFrm(U16P c, int * pSizeX);
Xint        GUI_SIF__GetCharDistX_ExtFrm(unsigned short c, int * pSizeX);
Nvoid       GUI_SIF__GetFontInfo_ExtFrm (const GUI_FONT * pFont, GUI_FONTINFO * pfi);
Nchar       GUI_SIF__IsInFont_ExtFrm    (const GUI_FONT * pFont, U16 c);
Xchar       GUI_SIF__IsInFont_ExtFrm    (const GUI_FONT * pFont, unsigned short c);
Nint        GUI_SIF__GetCharInfo_ExtFrm (U16P c, GUI_CHARINFO_EXT * pInfo);
Xint        GUI_SIF__GetCharInfo_ExtFrm (unsigned short c, GUI_CHARINFO_EXT * pInfo);
Nvoid       GUI_SIF__ClearLine_ExtFrm   (const char * s, int Len);
N
N/* External binary font routines */
Nint        GUI_XBF__GetOff       (const GUI_XBF_DATA * pXBF_Data, unsigned c, U32 * pOff);
Xint        GUI_XBF__GetOff       (const GUI_XBF_DATA * pXBF_Data, unsigned c, unsigned long * pOff);
Nint        GUI_XBF__GetOffAndSize(const GUI_XBF_DATA * pXBF_Data, unsigned c, U32 * pOff, U16 * pSize);
Xint        GUI_XBF__GetOffAndSize(const GUI_XBF_DATA * pXBF_Data, unsigned c, unsigned long * pOff, unsigned short * pSize);
Nint        GUI_XBF__GetCharDistX (U16P c, int * pSizeX);
Xint        GUI_XBF__GetCharDistX (unsigned short c, int * pSizeX);
Nvoid       GUI_XBF__GetFontInfo  (const GUI_FONT * pFont, GUI_FONTINFO * pInfo);
Nchar       GUI_XBF__IsInFont     (const GUI_FONT * pFont, U16 c);
Xchar       GUI_XBF__IsInFont     (const GUI_FONT * pFont, unsigned short c);
Nint        GUI_XBF__GetCharInfo  (U16P c, GUI_CHARINFO_EXT * pInfo);
Xint        GUI_XBF__GetCharInfo  (unsigned short c, GUI_CHARINFO_EXT * pInfo);
Nvoid       GUI_XBF__ClearLine    (const char * s, int Len);
N
N/* Conversion routines */
Nvoid GUI_AddHex     (U32 v, U8 Len, char ** ps);
Xvoid GUI_AddHex     (unsigned long v, unsigned char Len, char ** ps);
Nvoid GUI_AddBin     (U32 v, U8 Len, char ** ps);
Xvoid GUI_AddBin     (unsigned long v, unsigned char Len, char ** ps);
Nvoid GUI_AddDecMin  (I32 v, char ** ps);
Xvoid GUI_AddDecMin  (signed long v, char ** ps);
Nvoid GUI_AddDecShift(I32 v, U8 Len, U8 Shift, char ** ps);
Xvoid GUI_AddDecShift(signed long v, unsigned char Len, unsigned char Shift, char ** ps);
Nlong GUI_AddSign    (long v, char ** ps);
Nint  GUI_Long2Len   (I32 v);
Xint  GUI_Long2Len   (signed long v);
N
N#define GUI_UC__GetCharSize(sText)  GUI_pUC_API->pfGetCharSize(sText)
N#define GUI_UC__GetCharCode(sText)  GUI_pUC_API->pfGetCharCode(sText)
N
Nint   GUI_UC__CalcSizeOfChar   (U16 Char);
Xint   GUI_UC__CalcSizeOfChar   (unsigned short Char);
NU16   GUI_UC__GetCharCodeInc   (const char ** ps);
Xunsigned short   GUI_UC__GetCharCodeInc   (const char ** ps);
Nint   GUI_UC__NumChars2NumBytes(const char * s, int NumChars);
Nint   GUI_UC__NumBytes2NumChars(const char * s, int NumBytes);
N
Nint  GUI__GetLineNumChars  (const char * s, int MaxNumChars);
Nint  GUI__GetNumChars      (const char * s);
Nint  GUI__GetOverlap       (U16 Char);
Xint  GUI__GetOverlap       (unsigned short Char);
Nint  GUI__GetLineDistX     (const char * s, int Len);
Nint  GUI__GetFontSizeY     (void);
Nint  GUI__HandleEOLine     (const char ** ps);
Nvoid GUI__InvertRectColors (int x0, int y0, int x1, int y1);
Nvoid GUI__DispLine         (const char * s, int Len, const GUI_RECT * pr);
Nvoid GUI__AddSpaceHex      (U32 v, U8 Len, char ** ps);
Xvoid GUI__AddSpaceHex      (unsigned long v, unsigned char Len, char ** ps);
Nvoid GUI__CalcTextRect     (const char * pText, const GUI_RECT * pTextRectIn, GUI_RECT * pTextRectOut, int TextAlign);
N
Nvoid GUI__ClearTextBackground(int xDist, int yDist);
N
Nint  GUI__WrapGetNumCharsDisp       (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint  GUI__WrapGetNumCharsToNextLine (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint  GUI__WrapGetNumBytesToNextLine (const char * pText, int xSize, GUI_WRAPMODE WrapMode);
N//void GUI__memset    (U8  * p, U8 Fill, int NumBytes);
Nvoid GUI__memset16  (U16 * p, U16 Fill, int NumWords);
Xvoid GUI__memset16  (unsigned short * p, unsigned short Fill, int NumWords);
Nint  GUI__strlen    (const char * s);
Nint  GUI__strcmp    (const char * s0, const char * s1);
Nint  GUI__strcmp_hp (GUI_HMEM hs0, const char * s1);
Xint  GUI__strcmp_hp (signed long hs0, const char * s1);
N
N/* Get cursor position */
Nint  GUI__GetCursorPosX     (const char * s, int Index, int MaxNumChars);
Nint  GUI__GetCursorPosChar  (const char * s, int x, int NumCharsToNextLine);
NU16  GUI__GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
N
N/* Arabic support (tbd) */
NU16  GUI__GetPresentationForm     (U16 Char, U16 Next, U16 Prev, int * pIgnoreNext, const char * s);
Xunsigned short  GUI__GetPresentationForm     (unsigned short Char, unsigned short Next, unsigned short Prev, int * pIgnoreNext, const char * s);
Nint  GUI__IsArabicCharacter       (U16 c);
Xint  GUI__IsArabicCharacter       (unsigned short c);
N
N/* BiDi support */
Nint  GUI__BIDI_Log2Vis           (const char * s, int NumChars, char * pBuffer, int BufferSize);
Nint  GUI__BIDI_GetCursorPosX     (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCursorPosChar  (const char * s, int NumChars, int x);
NU16  GUI__BIDI_GetLogChar        (const char * s, int NumChars, int Index);
Xunsigned short  GUI__BIDI_GetLogChar        (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCharDir        (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_IsNSM             (U16 Char);
Xint  GUI__BIDI_IsNSM             (unsigned short Char);
NU16  GUI__BIDI_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__BIDI_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Nint  GUI__BIDI_GetWordWrap       (const char * s, int xSize, int * pxDist);
Nint  GUI__BIDI_GetCharWrap       (const char * s, int xSize);
N
N#if (GUI_USE_BIDI2)
X#if (1)
N
N#define GUI__BIDI_Log2Vis            GUI__BIDI2_Log2Vis
N#define GUI__BIDI_GetCursorPosX      GUI__BIDI2_GetCursorPosX
N#define GUI__BIDI_GetCursorPosChar   GUI__BIDI2_GetCursorPosChar
N#define GUI__BIDI_GetLogChar         GUI__BIDI2_GetLogChar
N#define GUI__BIDI_GetCharDir         GUI__BIDI2_GetCharDir
N#define GUI__BIDI_IsNSM              GUI__BIDI2_IsNSM
N#define GUI__BIDI_GetCursorCharacter GUI__BIDI2_GetCursorCharacter
N#define GUI__BIDI_GetWordWrap        GUI__BIDI2_GetWordWrap
N#define GUI__BIDI_GetCharWrap        GUI__BIDI2_GetCharWrap
N#define GUI__BIDI_SetBaseDir         GUI__BIDI2_SetBaseDir
N#define GUI__BIDI_GetBaseDir         GUI__BIDI2_GetBaseDir
N
Nint  GUI__BIDI_Log2Vis           (const char * s, int NumChars, char * pBuffer, int BufferSize);
Xint  GUI__BIDI2_Log2Vis           (const char * s, int NumChars, char * pBuffer, int BufferSize);
Nint  GUI__BIDI_GetCursorPosX     (const char * s, int NumChars, int Index);
Xint  GUI__BIDI2_GetCursorPosX     (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCursorPosChar  (const char * s, int NumChars, int x);
Xint  GUI__BIDI2_GetCursorPosChar  (const char * s, int NumChars, int x);
NU16  GUI__BIDI_GetLogChar        (const char * s, int NumChars, int Index);
Xunsigned short  GUI__BIDI2_GetLogChar        (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_GetCharDir        (const char * s, int NumChars, int Index);
Xint  GUI__BIDI2_GetCharDir        (const char * s, int NumChars, int Index);
Nint  GUI__BIDI_IsNSM             (U16 Char);
Xint  GUI__BIDI2_IsNSM             (unsigned short Char);
NU16  GUI__BIDI_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__BIDI2_GetCursorCharacter(const char * s, int Index, int MaxNumChars, int * pIsRTL);
Nint  GUI__BIDI_GetWordWrap       (const char * s, int xSize, int * pxDist);
Xint  GUI__BIDI2_GetWordWrap       (const char * s, int xSize, int * pxDist);
Nint  GUI__BIDI_GetCharWrap       (const char * s, int xSize);
Xint  GUI__BIDI2_GetCharWrap       (const char * s, int xSize);
Nvoid GUI__BIDI_SetBaseDir        (int Dir);
Xvoid GUI__BIDI2_SetBaseDir        (int Dir);
Nint  GUI__BIDI_GetBaseDir        (void);
Xint  GUI__BIDI2_GetBaseDir        (void);
N
N#else
S
S#define GUI__BIDI_SetBaseDir
S#define GUI__BIDI_GetBaseDir
S
N#endif
N
Nconst char * GUI__BIDI_Log2VisBuffered(const char * s, int * pMaxNumChars, int Mode);
N
Nextern int GUI__BIDI_Enabled;
N
Nextern int (* _pfGUI__BIDI_Log2Vis         )(const char * s, int NumChars, char * pBuffer, int BufferSize);
Nextern int (* _pfGUI__BIDI_GetCursorPosX   )(const char * s, int NumChars, int Index);
Nextern int (* _pfGUI__BIDI_GetCursorPosChar)(const char * s, int NumChars, int x);
Nextern U16 (* _pfGUI__BIDI_GetLogChar      )(const char * s, int NumChars, int Index);
Xextern unsigned short (* _pfGUI__BIDI_GetLogChar      )(const char * s, int NumChars, int Index);
Nextern int (* _pfGUI__BIDI_GetCharDir      )(const char * s, int NumChars, int Index);
Nextern int (* _pfGUI__BIDI_IsNSM           )(U16 Char);
Xextern int (* _pfGUI__BIDI_IsNSM           )(unsigned short Char);
N
N/* BiDi-related function pointers */
Nextern const char * (* GUI_CharLine_pfLog2Vis)(const char * s, int * pMaxNumChars, int Mode);
N
Nextern int (* GUI__GetCursorPos_pfGetPosX)     (const char * s, int MaxNumChars, int Index);
Nextern int (* GUI__GetCursorPos_pfGetPosChar)  (const char * s, int MaxNumChars, int x);
Nextern U16 (* GUI__GetCursorPos_pfGetCharacter)(const char * s, int MaxNumChars, int Index, int * pIsRTL);
Xextern unsigned short (* GUI__GetCursorPos_pfGetCharacter)(const char * s, int MaxNumChars, int Index, int * pIsRTL);
N
Nextern int (* GUI__Wrap_pfGetWordWrap)(const char * s, int xSize, int * pxDist);
Nextern int (* GUI__Wrap_pfGetCharWrap)(const char * s, int xSize);
N
N/* Proportional  font support */
Nconst GUI_FONT_PROP * GUIPROP__FindChar(const GUI_FONT_PROP * pProp, U16P c);
Xconst GUI_FONT_PROP * GUIPROP__FindChar(const GUI_FONT_PROP * pProp, unsigned short c);
N
N/* Extended proportional font support */
Nconst GUI_FONT_PROP_EXT * GUIPROP_EXT__FindChar(const GUI_FONT_PROP_EXT * pPropExt, U16P c);
Xconst GUI_FONT_PROP_EXT * GUIPROP_EXT__FindChar(const GUI_FONT_PROP_EXT * pPropExt, unsigned short c);
Nvoid  GUIPROP_EXT__DispLine      (const char * s, int Len);
Nvoid  GUIPROP_EXT__ClearLine     (const char * s, int Len);
Nvoid  GUIPROP_EXT__SetfpClearLine(void (* fpClearLine)(const char * s, int Len));
N
N/* Reading data routines */
NU16 GUI__Read16(const U8 ** ppData);
Xunsigned short GUI__Read16(const unsigned char ** ppData);
NU32 GUI__Read32(const U8 ** ppData);
Xunsigned long GUI__Read32(const unsigned char ** ppData);
N
N/* Virtual screen support */
Nvoid GUI__GetOrg(int * px, int * py);
Nvoid GUI__SetOrgHook(void(* pfHook)(int x, int y));
N
N/* Timer support */
Nint              GUI_TIMER__IsActive       (void);
NGUI_TIMER_TIME   GUI_TIMER__GetPeriod      (void);
Xint   GUI_TIMER__GetPeriod      (void);
NGUI_TIMER_HANDLE GUI_TIMER__GetFirstTimer  (PTR_ADDR * pContext);
XGUI_TIMER_HANDLE GUI_TIMER__GetFirstTimer  (unsigned long * pContext);
NGUI_TIMER_HANDLE GUI_TIMER__GetNextTimerLin(GUI_TIMER_HANDLE hTimer, PTR_ADDR * pContext);
XGUI_TIMER_HANDLE GUI_TIMER__GetNextTimerLin(GUI_TIMER_HANDLE hTimer, unsigned long * pContext);
N
N/* Get function pointers for color conversion */
NtLCDDEV_Index2Color * GUI_GetpfIndex2ColorEx(int LayerIndex);
NtLCDDEV_Color2Index * GUI_GetpfColor2IndexEx(int LayerIndex);
N
Nint GUI_GetBitsPerPixelEx(int LayerIndex);
N
NLCD_PIXELINDEX * LCD_GetpPalConvTable        (const LCD_LOGPALETTE * pLogPal);
Xunsigned long * LCD_GetpPalConvTable        (const LCD_LOGPALETTE * pLogPal);
NLCD_PIXELINDEX * LCD_GetpPalConvTableUncached(const LCD_LOGPALETTE * pLogPal);
Xunsigned long * LCD_GetpPalConvTableUncached(const LCD_LOGPALETTE * pLogPal);
NLCD_PIXELINDEX * LCD_GetpPalConvTableBM      (const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
Xunsigned long * LCD_GetpPalConvTableBM      (const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
N
N/* Setting a function for converting a color palette to an array of index values */
Nvoid GUI_SetFuncGetpPalConvTable(LCD_PIXELINDEX * (* pFunc)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex));
Xvoid GUI_SetFuncGetpPalConvTable(unsigned long * (* pFunc)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex));
N
N/*********************************************************************
N*
N*       Format definitions used by streamed bitmaps
N*
N*   IMPORTANT: DO NOT CHANGE THESE VALUES!
N*   THEY HAVE TO CORRESPOND TO THE DEFINITIONS WITHIN THE CODE OF THE BITMAPCONVERTER!
N*/
N#define GUI_STREAM_FORMAT_INDEXED    100 /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE4       6   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE8       7   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_565        8   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M565       9   /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_555        10  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M555       11  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE16      12  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLEM16     13  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_8888       16  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLE32      15  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_24         17  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_RLEALPHA   18  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_444_12     19  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M444_12    20  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_444_12_1   21  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M444_12_1  22  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_444_16     23  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M444_16    24  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_A555       25  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_AM555      26  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_A565       27  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_AM565      28  /* DO NOT CHANGE */
N#define GUI_STREAM_FORMAT_M8888I     29  /* DO NOT CHANGE */
N
Nvoid GUI__ReadHeaderFromStream  (GUI_BITMAP_STREAM * pBitmapHeader, const U8 * pData);
Xvoid GUI__ReadHeaderFromStream  (GUI_BITMAP_STREAM * pBitmapHeader, const unsigned char * pData);
Nvoid GUI__CreateBitmapFromStream(const GUI_BITMAP_STREAM * pBitmapHeader, const void * pData, GUI_BITMAP * pBMP, GUI_LOGPALETTE * pPAL, const GUI_BITMAP_METHODS * pMethods);
N
N/* Cache management */
Nint GUI__ManageCache  (int Cmd);
Nint GUI__ManageCacheEx(int LayerIndex, int Cmd);
N
N/*********************************************************************
N*
N*       2d - GL
N*
N**********************************************************************
N*/
Nvoid GL_DispChar         (U16 c);
Xvoid GL_DispChar         (unsigned short c);
Nvoid GL_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GL_DrawBitmap       (const GUI_BITMAP * pBM, int x0, int y0);
Nvoid GL_DrawCircle       (int x0, int y0, int r);
Nvoid GL_DrawEllipse      (int x0, int y0, int rx, int ry, int w);
Nvoid GL_DrawHLine        (int y0, int x0, int x1);
Nvoid GL_DrawPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GL_DrawPoint        (int x,  int y);
Nvoid GL_DrawLine1        (int x0, int y0, int x1, int y1);
Nvoid GL_DrawLine1Ex      (int x0, int y0, int x1, int y1, unsigned * pPixelCnt);
Nvoid GL_DrawLineRel      (int dx, int dy);
Nvoid GL_DrawLineTo       (int x,  int y);
Nvoid GL_DrawLineToEx     (int x,  int y, unsigned * pPixelCnt);
Nvoid GL_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GL_DrawLineEx       (int x0, int y0, int x1, int y1, unsigned * pPixelCnt);
Nvoid GL_MoveTo           (int x,  int y);
Nvoid GL_FillCircle       (int x0, int y0, int r);
Nvoid GL_FillCircleAA     (int x0, int y0, int r);
Nvoid GL_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GL_FillPolygon      (const GUI_POINT * pPoints, int NumPoints, int x0, int y0);
Nvoid GL_SetDefault       (void);
N
N/*********************************************************************
N*
N*       Replacement of memcpy() and memset()
N*
N**********************************************************************
N*/
N//
N// Configurable function pointers
N//
Nextern void * (* GUI__pfMemset)(void * pDest, int Fill, size_t Cnt);
Nextern void * (* GUI__pfMemcpy)(void * pDest, const void * pSrc, size_t Cnt);
N
Nextern int    (* GUI__pfStrcmp)(const char *, const char *);
Nextern size_t (* GUI__pfStrlen)(const char *);
Nextern char * (* GUI__pfStrcpy)(char *, const char *);
N//
N// Macros for typesave use of function pointers
N//
N#define GUI__MEMSET(pDest, Fill, Cnt) GUI__pfMemset((void *)(pDest), (int)(Fill), (size_t)(Cnt))
N#define GUI__MEMCPY(pDest, pSrc, Cnt) GUI__pfMemcpy((void *)(pDest), (const void *)(pSrc), (size_t)(Cnt))
N
N/*********************************************************************
N*
N*       Callback pointers for dynamic linkage
N*
N**********************************************************************
NDynamic linkage pointers reduces configuration hassles.
N*/
Ntypedef int  GUI_tfTimer(void);
Ntypedef int  WM_tfHandlePID(void);
N
N/*********************************************************************
N*
N*       Text rotation
N*
N**********************************************************************
N*/
Nextern GUI_RECT  GUI_RectDispString; /* Used by LCD_Rotate...() and GUI_DispStringInRect() */
N
N/*********************************************************************
N*
N*       Flag for setting transparency for 'EXT' fonts
N*
N**********************************************************************
N*/
Nextern U8 GUI__CharHasTrans;
Xextern unsigned char GUI__CharHasTrans;
N
N/*********************************************************************
N*
N*       Multitasking support
N*
N**********************************************************************
N*/
Nextern int GUITASK__EntranceCnt;
N
N/*********************************************************************
N*
N*       Bitmap related functions
N*
N**********************************************************************
N*/
N
Nint       GUI_GetBitmapPixelIndex(const GUI_BITMAP * pBMP, unsigned x, unsigned y);
NGUI_COLOR GUI_GetBitmapPixelColor(const GUI_BITMAP * pBMP, unsigned x, unsigned y);
Nint       GUI_GetBitmapPixelIndexEx(int BitsPerPixel, int BytesPerLine, const U8 * pData, unsigned x, unsigned y);
Xint       GUI_GetBitmapPixelIndexEx(int BitsPerPixel, int BytesPerLine, const unsigned char * pData, unsigned x, unsigned y);
N
Nvoid      GUI__DrawBitmap16bpp (int x0, int y0, int xsize, int ysize, const U8 * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color, const LCD_API_COLOR_CONV * pColorConvAPI);
Xvoid      GUI__DrawBitmap16bpp (int x0, int y0, int xsize, int ysize, const unsigned char * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color, const LCD_API_COLOR_CONV * pColorConvAPI);
Nvoid      GUI__DrawBitmapA16bpp(int x0, int y0, int xSize, int ySize, const U8 * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color);
Xvoid      GUI__DrawBitmapA16bpp(int x0, int y0, int xSize, int ySize, const unsigned char * pPixel, const LCD_LOGPALETTE * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color);
Nvoid      GUI__SetPixelAlpha   (int x, int y, U8 Alpha, LCD_COLOR Color);
Xvoid      GUI__SetPixelAlpha   (int x, int y, unsigned char Alpha, LCD_COLOR Color);
NLCD_COLOR GUI__MixColors       (LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR GUI__MixColors       (LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
Nvoid      GUI__MixColorsBulk   (U32 * pFG, U32 * pBG, U32 * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, U8 Intens);
Xvoid      GUI__MixColorsBulk   (unsigned long * pFG, unsigned long * pBG, unsigned long * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, unsigned char Intens);
N
Nextern const GUI_UC_ENC_APILIST GUI_UC_None;
N
N/*********************************************************************
N*
N*       LCDDEV_L0_xxx
N*
N**********************************************************************
N*/
N#define LCDDEV_L0_Color2Index         GUI__apDevice[GUI_pContext->SelLayer]->pColorConvAPI->pfColor2Index
N#define LCDDEV_L0_Index2Color         GUI__apDevice[GUI_pContext->SelLayer]->pColorConvAPI->pfIndex2Color
N
N#define LCDDEV_L0_DrawBitmap          GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawBitmap
N#define LCDDEV_L0_DrawHLine           GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawHLine
N#define LCDDEV_L0_DrawVLine           GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawVLine
N#define LCDDEV_L0_DrawPixel           GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfDrawPixel
N#define LCDDEV_L0_FillRect            GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfFillRect
N#define LCDDEV_L0_GetPixel            GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetPixel
N#define LCDDEV_L0_GetRect             GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetRect
N#define LCDDEV_L0_GetPixelIndex       GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetPixelIndex
N#define LCDDEV_L0_SetPixelIndex       GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfSetPixelIndex
N#define LCDDEV_L0_XorPixel            GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfXorPixel
N#define LCDDEV_L0_GetDevFunc          GUI__apDevice[GUI_pContext->SelLayer]->pDeviceAPI->pfGetDevFunc
N
Nvoid LCD_ReadRect  (int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid LCD_ReadRect  (int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
Nvoid GUI_ReadRect  (int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid GUI_ReadRect  (int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
Nvoid GUI_ReadRectEx(int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid GUI_ReadRectEx(int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
N
Nvoid LCD_ReadRectNoClip(int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, GUI_DEVICE * pDevice);
Xvoid LCD_ReadRectNoClip(int x0, int y0, int x1, int y1, unsigned long * pBuffer, GUI_DEVICE * pDevice);
N
N/*********************************************************************
N*
N*       Internal color management
N*
N**********************************************************************
N*/
Ntypedef struct {
N  void         (* pfSetColor)   (LCD_COLOR Index);
N  void         (* pfSetBkColor) (LCD_COLOR Index);
N  LCD_DRAWMODE (* pfSetDrawMode)(LCD_DRAWMODE dm);
N} LCD_SET_COLOR_API;
N
Nextern const LCD_SET_COLOR_API * LCD__pSetColorAPI;
N
N#define LCD__SetBkColorIndex(Index) (*GUI_pContext->LCD_pBkColorIndex = Index)
N#define LCD__SetColorIndex(Index)   (*GUI_pContext->LCD_pColorIndex   = Index)
N#define LCD__GetBkColorIndex()      (*GUI_pContext->LCD_pBkColorIndex)
N#define LCD__GetColorIndex()        (*GUI_pContext->LCD_pColorIndex)
N
N/* The following 2 defines are only required for compatibility to older versions of the TTF library */
N#define LCD_BKCOLORINDEX (*GUI_pContext->LCD_pBkColorIndex)
N#define LCD_COLORINDEX   (*GUI_pContext->LCD_pColorIndex)
N
N/*********************************************************************
N*
N*       EXTERNs for GL_CORE
N*
N**********************************************************************
N*/
Nextern const GUI_FONT * GUI__pFontDefault;
Nextern GUI_COLOR        GUI__ColorDefault;
Nextern GUI_COLOR        GUI__BkColorDefault;
N
Nextern GUI_SADDR GUI_CONTEXT * GUI_pContext;
Xextern  GUI_CONTEXT * GUI_pContext;
N
Nextern GUI_DEVICE * GUI__apDevice[GUI_NUM_LAYERS];
Xextern GUI_DEVICE * GUI__apDevice[1];
N
N//
N// Function pointer for converting a palette containing a color array into an index array
N//
Nextern LCD_PIXELINDEX * (* GUI_pfGetpPalConvTable)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
Xextern unsigned long * (* GUI_pfGetpPalConvTable)(const LCD_LOGPALETTE * pLogPal, const GUI_BITMAP * pBitmap, int LayerIndex);
N
N//
N// Function pointer for mixing up 2 colors
N//
Nextern LCD_COLOR (* GUI__pfMixColors)(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
Xextern LCD_COLOR (* GUI__pfMixColors)(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
N
N//
N// Function pointer for mixing up arrays of colors
N//
Nextern void (* GUI__pfMixColorsBulk)(U32 * pFG, U32 * pBG, U32 * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, U8 Intens);
Xextern void (* GUI__pfMixColorsBulk)(unsigned long * pFG, unsigned long * pBG, unsigned long * pDst, unsigned OffFG, unsigned OffBG, unsigned OffDest, unsigned xSize, unsigned ySize, unsigned char Intens);
N
N//
N// Function pointer for mixing color and gamma values
N//
Nextern LCD_COLOR (* LCD_AA_pfMixColors16)(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
Xextern LCD_COLOR (* LCD_AA_pfMixColors16)(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
N
N//
N// Function pointer for drawing alpha memory devices
N//
Nextern GUI_DRAWMEMDEV_FUNC   * GUI__pfDrawAlphaMemdevFunc;
Xextern GUI_DRAWMEMDEV_16BPP_FUNC   * GUI__pfDrawAlphaMemdevFunc;
Nextern GUI_DRAWMEMDEV_FUNC   * GUI__pfDrawM565MemdevFunc;
Xextern GUI_DRAWMEMDEV_16BPP_FUNC   * GUI__pfDrawM565MemdevFunc;
N
N//
N// Function pointer for drawing alpha bitmaps
N//
Nextern GUI_DRAWBITMAP_FUNC * GUI__pfDrawAlphaBitmapFunc;
Nextern GUI_DRAWBITMAP_FUNC * GUI__pfDrawM565BitmapFunc;
N
Nextern U8 GUI__DrawStreamedBitmap;
Xextern unsigned char GUI__DrawStreamedBitmap;
N
N//
N// API list to be used for MultiBuffering
N//
Nextern const GUI_MULTIBUF_API    GUI_MULTIBUF_APIList;
Nextern const GUI_MULTIBUF_API    GUI_MULTIBUF_APIListMasked;
Nextern const GUI_MULTIBUF_API_EX GUI_MULTIBUF_APIListEx;
N
N#ifdef  GL_CORE_C
S  #define GUI_EXTERN
N#else
N  #define GUI_EXTERN extern
N#endif
N
NGUI_EXTERN   void (* GUI_pfExecAnimations)(void);
Xextern   void (* GUI_pfExecAnimations)(void);
NGUI_EXTERN   int  (* GUI_pfUpdateSoftLayer)(void);
Xextern   int  (* GUI_pfUpdateSoftLayer)(void);
N
N#ifdef WIN32
S  GUI_EXTERN void (* GUI_pfSoftlayerGetPixel)(int x, int y, void * p);
N#endif
N
NGUI_EXTERN void (* GUI_pfHookMTOUCH)(const GUI_MTOUCH_STATE * pState);
Xextern void (* GUI_pfHookMTOUCH)(const GUI_MTOUCH_STATE * pState);
N
NGUI_EXTERN const GUI_UC_ENC_APILIST * GUI_pUC_API; /* Unicode encoding API */
Xextern const GUI_UC_ENC_APILIST * GUI_pUC_API;  
N
NGUI_EXTERN GUI_SADDR char             GUI_DecChar;
Xextern  char             GUI_DecChar;
NGUI_EXTERN           GUI_tfTimer    * GUI_pfTimerExec;
Xextern           GUI_tfTimer    * GUI_pfTimerExec;
NGUI_EXTERN           WM_tfHandlePID * WM_pfHandlePID;
Xextern           WM_tfHandlePID * WM_pfHandlePID;
NGUI_EXTERN   void (* GUI_pfDispCharStyle)(U16 Char);
Xextern   void (* GUI_pfDispCharStyle)(unsigned short Char);
NGUI_EXTERN   void (* GUI_pfDispCharLine)(int x0);
Xextern   void (* GUI_pfDispCharLine)(int x0);
N
NGUI_EXTERN           int GUI__BufferSize; // Required buffer size in pixels for alpha blending and/or antialiasing
Xextern           int GUI__BufferSize; 
NGUI_EXTERN           int GUI_AA__ClipX0;  // x0-clipping value for AA module
Xextern           int GUI_AA__ClipX0;  
N
NGUI_EXTERN           I8  GUI__aNumBuffers[GUI_NUM_LAYERS]; // Number of buffers used per layer
Xextern           signed char  GUI__aNumBuffers[1]; 
NGUI_EXTERN           U8  GUI__PreserveTrans;
Xextern           unsigned char  GUI__PreserveTrans;
NGUI_EXTERN           U8  GUI__IsInitialized;
Xextern           unsigned char  GUI__IsInitialized;
N
NGUI_EXTERN           U8  GUI__NumLayersInUse;
Xextern           unsigned char  GUI__NumLayersInUse;
NGUI_EXTERN           U32 GUI__LayerMask;
Xextern           unsigned long GUI__LayerMask;
N
N#if GUI_SUPPORT_ROTATION
X#if 1
N  GUI_EXTERN const tLCD_APIList * GUI_pLCD_APIList; /* Used for rotating text */
X  extern const tLCD_APIList * GUI_pLCD_APIList;  
N#endif
N
NGUI_EXTERN I16 GUI_OrgX, GUI_OrgY;
Xextern signed short GUI_OrgX, GUI_OrgY;
N
N#undef GUI_EXTERN
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N
N#endif /* GUI_PRIVATE_H */
N
N/*************************** End of file ****************************/
L 49 "..\..\..\ThirdParty\emWin\Include\WM_Intern.h" 2
N
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       defines
N*
N**********************************************************************
N
N  The following could be placed in a file of its own as it is not
N  used outside of the window manager
N
N*/
N/* Basic Windows status flags.
N   For module-internally use only !
N*/
N#define WM_SF_HASTRANS          WM_CF_HASTRANS
N#define WM_SF_MEMDEV            WM_CF_MEMDEV
N#define WM_SF_MEMDEV_ON_REDRAW  WM_CF_MEMDEV_ON_REDRAW
N#define WM_SF_DISABLED          WM_CF_DISABLED  /* Disabled: Does not receive PID (mouse & touch) input */
N#define WM_SF_ISVIS             WM_CF_SHOW      /* Is visible flag */
N
N#define WM_SF_STAYONTOP         WM_CF_STAYONTOP
N#define WM_SF_LATE_CLIP         WM_CF_LATE_CLIP
N#define WM_SF_ANCHOR_RIGHT      WM_CF_ANCHOR_RIGHT
N#define WM_SF_ANCHOR_BOTTOM     WM_CF_ANCHOR_BOTTOM
N#define WM_SF_ANCHOR_LEFT       WM_CF_ANCHOR_LEFT
N#define WM_SF_ANCHOR_TOP        WM_CF_ANCHOR_TOP
N
N#define WM_SF_INVALID           WM_CF_ACTIVATE  /* We reuse this flag, as it is create only and Invalid is status only */
N
N#define WM_SF_CONST_OUTLINE     WM_CF_CONST_OUTLINE       /* Constant outline.*/
N
N#define WM_H2P(hWin)            ((WM_Obj*)GUI_ALLOC_h2p(hWin))
N
N
N#if GUI_DEBUG_LEVEL  >= GUI_DEBUG_LEVEL_LOG_WARNINGS
X#if 0  >= 4
S  #define WM_ASSERT_NOT_IN_PAINT() { if (WM__PaintCallbackCnt) \
S                                       GUI_DEBUG_ERROROUT("Function may not be called from within a paint event"); \
S                                   }
X  #define WM_ASSERT_NOT_IN_PAINT() { if (WM__PaintCallbackCnt)                                        GUI_DEBUG_ERROROUT("Function may not be called from within a paint event");                                    }
N#else
N  #define WM_ASSERT_NOT_IN_PAINT()
N#endif
N
N/*********************************************************************
N*
N*       Data types & structures
N*
N**********************************************************************
N*/
Ntypedef struct {
N  WM_HWIN hOld;
X  GUI_HWIN hOld;
N  WM_HWIN hNew;
X  GUI_HWIN hNew;
N} WM_NOTIFY_CHILD_HAS_FOCUS_INFO;
N
Ntypedef struct WM_CRITICAL_HANDLE {
N  struct  WM_CRITICAL_HANDLE * pNext;
N  volatile WM_HWIN hWin;
X  volatile GUI_HWIN hWin;
N} WM_CRITICAL_HANDLE;
N
N/*********************************************************************
N*
N*       Data (extern)
N*
N**********************************************************************
N*/
Nextern U32            WM__CreateFlags;
Xextern unsigned long            WM__CreateFlags;
Nextern WM_HWIN        WM__ahCapture[GUI_NUM_LAYERS];
Xextern GUI_HWIN        WM__ahCapture[1];
Nextern WM_HWIN        WM__ahWinFocus[GUI_NUM_LAYERS];
Xextern GUI_HWIN        WM__ahWinFocus[1];
Nextern char           WM__CaptureReleaseAuto;
Nextern WM_tfPollPID * WM_pfPollPID;
Nextern U8             WM__PaintCallbackCnt;      /* Public for assertions only */
Xextern unsigned char             WM__PaintCallbackCnt;       
Nextern WM_HWIN        WM__hCreateStatic;
Xextern GUI_HWIN        WM__hCreateStatic;
N
N#if WM_SUPPORT_TRANSPARENCY
X#if 1
N  extern int     WM__TransWindowCnt;
N  extern WM_HWIN WM__hATransWindow;
X  extern GUI_HWIN WM__hATransWindow;
N#endif
N
N#if WM_SUPPORT_DIAG
X#if 0
S  extern void (*WM__pfShowInvalid)(WM_HWIN hWin);
N#endif
N
Nextern WM_CRITICAL_HANDLE     WM__aCHWinModal[GUI_NUM_LAYERS];
Xextern WM_CRITICAL_HANDLE     WM__aCHWinModal[1];
Nextern WM_CRITICAL_HANDLE     WM__aCHWinLast[GUI_NUM_LAYERS];
Xextern WM_CRITICAL_HANDLE     WM__aCHWinLast[1];
Nextern int                    WM__ModalLayer;
N
N#if GUI_SUPPORT_MOUSE
X#if 1
N  extern WM_CRITICAL_HANDLE   WM__aCHWinMouseOver[GUI_NUM_LAYERS];
X  extern WM_CRITICAL_HANDLE   WM__aCHWinMouseOver[1];
N#endif
N
N#ifdef WM_C
S  #define GUI_EXTERN
N#else
N  #define GUI_EXTERN extern
N#endif
N
N#if (GUI_NUM_LAYERS > 1)
X#if (1 > 1)
S  GUI_EXTERN U32                       WM__InvalidLayerMask;
S  GUI_EXTERN unsigned                  WM__TouchedLayer;
S  #define WM__TOUCHED_LAYER            WM__TouchedLayer
N#else
N  #define WM__TOUCHED_LAYER            GUI_CURSOR_LAYER
N#endif
N
NGUI_EXTERN U16     WM__NumWindows;
Xextern unsigned short     WM__NumWindows;
NGUI_EXTERN U16     WM__NumInvalidWindows;
Xextern unsigned short     WM__NumInvalidWindows;
NGUI_EXTERN WM_HWIN WM__FirstWin;
Xextern GUI_HWIN WM__FirstWin;
NGUI_EXTERN WM_CRITICAL_HANDLE * WM__pFirstCriticalHandle;
Xextern WM_CRITICAL_HANDLE * WM__pFirstCriticalHandle;
N
NGUI_EXTERN WM_HWIN   WM__ahDesktopWin[GUI_NUM_LAYERS];
Xextern GUI_HWIN   WM__ahDesktopWin[1];
NGUI_EXTERN GUI_COLOR WM__aBkColor[GUI_NUM_LAYERS];
Xextern GUI_COLOR WM__aBkColor[1];
N
N#undef GUI_EXTERN
N
N/*********************************************************************
N*
N*       Prototypes
N*
N**********************************************************************
N*/
Nvoid    WM__ActivateClipRect        (void);
Nint     WM__ClipAtParentBorders     (GUI_RECT * pRect, WM_HWIN hWin);
Xint     WM__ClipAtParentBorders     (GUI_RECT * pRect, GUI_HWIN hWin);
Nvoid    WM__Client2Screen           (const WM_Obj * pWin, GUI_RECT * pRect);
Nvoid    WM__DeleteAssocTimer        (WM_HWIN hWin);
Xvoid    WM__DeleteAssocTimer        (GUI_HWIN hWin);
Nvoid    WM__DeleteSecure            (WM_HWIN hWin);
Xvoid    WM__DeleteSecure            (GUI_HWIN hWin);
Nvoid    WM__DetachWindow            (WM_HWIN hChild);
Xvoid    WM__DetachWindow            (GUI_HWIN hChild);
Nvoid    WM__ForEachDesc             (WM_HWIN hWin, WM_tfForEach * pcb, void * pData);
Xvoid    WM__ForEachDesc             (GUI_HWIN hWin, WM_tfForEach * pcb, void * pData);
Nvoid    WM__GetClientRectWin        (const WM_Obj * pWin, GUI_RECT * pRect);
Nvoid    WM__GetClientRectEx         (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid    WM__GetClientRectEx         (GUI_HWIN hWin, GUI_RECT * pRect);
NWM_HWIN WM__GetFirstSibling         (WM_HWIN hWin);
XGUI_HWIN WM__GetFirstSibling         (GUI_HWIN hWin);
NWM_HWIN WM__GetFocusedChild         (WM_HWIN hWin);
XGUI_HWIN WM__GetFocusedChild         (GUI_HWIN hWin);
Nint     WM__GetHasFocus             (WM_HWIN hWin);
Xint     WM__GetHasFocus             (GUI_HWIN hWin);
NWM_HWIN WM__GetLastSibling          (WM_HWIN hWin);
XGUI_HWIN WM__GetLastSibling          (GUI_HWIN hWin);
NWM_HWIN WM__GetPrevSibling          (WM_HWIN hWin);
XGUI_HWIN WM__GetPrevSibling          (GUI_HWIN hWin);
Nint     WM__GetTopLevelLayer        (WM_HWIN hWin);
Xint     WM__GetTopLevelLayer        (GUI_HWIN hWin);
Nint     WM__GetWindowSizeX          (const WM_Obj * pWin);
Nint     WM__GetWindowSizeY          (const WM_Obj * pWin);
Nvoid    WM__InsertWindowIntoList    (WM_HWIN hWin, WM_HWIN hParent);
Xvoid    WM__InsertWindowIntoList    (GUI_HWIN hWin, GUI_HWIN hParent);
Nvoid    WM__Invalidate1Abs          (WM_HWIN hWin, const GUI_RECT * pRect);
Xvoid    WM__Invalidate1Abs          (GUI_HWIN hWin, const GUI_RECT * pRect);
Nvoid    WM__InvalidateAreaBelow     (const GUI_RECT * pRect, WM_HWIN StopWin);
Xvoid    WM__InvalidateAreaBelow     (const GUI_RECT * pRect, GUI_HWIN StopWin);
Nvoid    WM__InvalidateRectEx        (const GUI_RECT * pInvalidRect, WM_HWIN hParent, WM_HWIN hStop);
Xvoid    WM__InvalidateRectEx        (const GUI_RECT * pInvalidRect, GUI_HWIN hParent, GUI_HWIN hStop);
Nvoid    WM__InvalidateTransAreaAbove(const GUI_RECT * pRect, WM_HWIN StopWin);
Xvoid    WM__InvalidateTransAreaAbove(const GUI_RECT * pRect, GUI_HWIN StopWin);
Nint     WM__IntersectRect           (GUI_RECT * pDest, const GUI_RECT * pr0, const GUI_RECT * pr1);
Nint     WM__IsAncestor              (WM_HWIN hChild, WM_HWIN hParent);
Xint     WM__IsAncestor              (GUI_HWIN hChild, GUI_HWIN hParent);
Nint     WM__IsAncestorOrSelf        (WM_HWIN hChild, WM_HWIN hParent);
Xint     WM__IsAncestorOrSelf        (GUI_HWIN hChild, GUI_HWIN hParent);
Nint     WM__IsChild                 (WM_HWIN hWin, WM_HWIN hParent);
Xint     WM__IsChild                 (GUI_HWIN hWin, GUI_HWIN hParent);
Nint     WM__IsEnabled               (WM_HWIN hWin);
Xint     WM__IsEnabled               (GUI_HWIN hWin);
Nint     WM__IsInModalArea           (WM_HWIN hWin);
Xint     WM__IsInModalArea           (GUI_HWIN hWin);
Nint     WM__IsInWindow              (WM_Obj * pWin, int x, int y);
Nint     WM__IsWindow                (WM_HWIN hWin);
Xint     WM__IsWindow                (GUI_HWIN hWin);
Nvoid    WM__LeaveIVRSearch          (void);
Nvoid    WM__MoveTo                  (WM_HWIN hWin, int x, int y);
Xvoid    WM__MoveTo                  (GUI_HWIN hWin, int x, int y);
Nvoid    WM__MoveWindow              (WM_HWIN hWin, int dx, int dy);
Xvoid    WM__MoveWindow              (GUI_HWIN hWin, int dx, int dy);
Nvoid    WM__NotifyVisChanged        (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid    WM__NotifyVisChanged        (GUI_HWIN hWin, GUI_RECT * pRect);
Nint     WM__RectIsNZ                (const GUI_RECT * pr);
Nvoid    WM__RemoveWindowFromList    (WM_HWIN hWin);
Xvoid    WM__RemoveWindowFromList    (GUI_HWIN hWin);
Nvoid    WM__Screen2Client           (const WM_Obj * pWin, GUI_RECT * pRect);
Nvoid    WM__SelectTopLevelLayer     (WM_HWIN  hWin);
Xvoid    WM__SelectTopLevelLayer     (GUI_HWIN  hWin);
Nvoid    WM__SendMsgNoData           (WM_HWIN hWin, U8 MsgId);
Xvoid    WM__SendMsgNoData           (GUI_HWIN hWin, unsigned char MsgId);
Nvoid    WM__SendMessage             (WM_HWIN hWin, WM_MESSAGE * pm);
Xvoid    WM__SendMessage             (GUI_HWIN hWin, WM_MESSAGE * pm);
Nvoid    WM__SendMessageIfEnabled    (WM_HWIN hWin, WM_MESSAGE * pm);
Xvoid    WM__SendMessageIfEnabled    (GUI_HWIN hWin, WM_MESSAGE * pm);
Nvoid    WM__SendMessageNoPara       (WM_HWIN hWin, int MsgId);
Xvoid    WM__SendMessageNoPara       (GUI_HWIN hWin, int MsgId);
Nvoid    WM__SendPIDMessage          (WM_HWIN hWin, WM_MESSAGE * pMsg);
Xvoid    WM__SendPIDMessage          (GUI_HWIN hWin, WM_MESSAGE * pMsg);
Nint     WM__SetScrollbarH           (WM_HWIN hWin, int OnOff);
Xint     WM__SetScrollbarH           (GUI_HWIN hWin, int OnOff);
Nint     WM__SetScrollbarV           (WM_HWIN hWin, int OnOff);
Xint     WM__SetScrollbarV           (GUI_HWIN hWin, int OnOff);
Nvoid    WM__UpdateChildPositions    (WM_Obj * pObj, int dx0, int dy0, int dx1, int dy1);
Nvoid    WM_PID__GetPrevState        (GUI_PID_STATE * pPrevState, int Layer);
Nvoid    WM_PID__SetPrevState        (GUI_PID_STATE * pPrevState, int Layer);
Nvoid    WM__SendTouchMessage        (WM_HWIN hWin, WM_MESSAGE * pMsg);
Xvoid    WM__SendTouchMessage        (GUI_HWIN hWin, WM_MESSAGE * pMsg);
N
NU16     WM_GetFlags                 (WM_HWIN hWin);
Xunsigned short     WM_GetFlags                 (GUI_HWIN hWin);
Nint     WM__Paint                   (WM_HWIN hWin);
Xint     WM__Paint                   (GUI_HWIN hWin);
Nvoid    WM__Paint1                  (WM_HWIN hWin);
Xvoid    WM__Paint1                  (GUI_HWIN hWin);
Nvoid    WM__AddCriticalHandle       (WM_CRITICAL_HANDLE * pCH);
Nvoid    WM__RemoveCriticalHandle    (WM_CRITICAL_HANDLE * pCH);
Nvoid    WM__SetLastTouched          (WM_HWIN hWin);
Xvoid    WM__SetLastTouched          (GUI_HWIN hWin);
N
N#if WM_SUPPORT_STATIC_MEMDEV
X#if 1
N  void    WM__InvalidateDrawAndDescs(WM_HWIN hWin);
X  void    WM__InvalidateDrawAndDescs(GUI_HWIN hWin);
N#else
S  #define WM__InvalidateDrawAndDescs(hWin)
N#endif
N
N/* Static memory devices */
N#if (GUI_SUPPORT_MEMDEV)
X#if (1)
N  typedef struct {
N    int xSize, ySize; // Size of bk window
N  } EFFECT_CONTEXT;
N
N  int  GUI_MEMDEV__CalcParaFadeIn    (int Period, int TimeUsed);
N  void GUI_MEMDEV__ClipBK            (EFFECT_CONTEXT * pContext);
N  void GUI_MEMDEV__RemoveStaticDevice(WM_HWIN hWin);
X  void GUI_MEMDEV__RemoveStaticDevice(GUI_HWIN hWin);
N  void GUI_MEMDEV__UndoClipBK        (EFFECT_CONTEXT * pContext);
N#endif
N
Nvoid WM__InvalidateParent(const GUI_RECT * pInvalidRect, WM_HWIN hParent, WM_HWIN hStop);
Xvoid WM__InvalidateParent(const GUI_RECT * pInvalidRect, GUI_HWIN hParent, GUI_HWIN hStop);
Nvoid WM__InvalidateRect  (const GUI_RECT * pInvalidRect, WM_HWIN hParent, WM_HWIN hStop, U16 Flags);
Xvoid WM__InvalidateRect  (const GUI_RECT * pInvalidRect, GUI_HWIN hParent, GUI_HWIN hStop, unsigned short Flags);
N
NWM_tfInvalidateParent   WM__SetInvalidateParentFunc(WM_tfInvalidateParent pfInvalidateParentFunc);
NWM_tfInvalidateDrawFunc WM__SetInvalidateDrawFunc  (WM_tfInvalidateDrawFunc pfInvalidateDrawFunc);
NWM_tfPaint1Func         WM__SetPaint1Func          (WM_tfPaint1Func pfPaint1Func);
N
N#endif   /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* WM_INTERN_H */
N
N/*************************** End of file ****************************/
L 52 "..\..\..\ThirdParty\emWin\Include\WIDGET.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Typedefs
N*
N**********************************************************************
N*/
Ntypedef struct {
N  WM_HWIN    hWin;
X  GUI_HWIN    hWin;
N  int        Cmd;         /* WIDGET_ITEM_GET_XSIZE, WIDGET_ITEM_GET_YSIZE, WIDGET_ITEM_DRAW, */
N  int        ItemIndex;
N  int        Col;
N  int        x0, y0, x1, y1;
N  void     * p;
N} WIDGET_ITEM_DRAW_INFO;
N
Ntypedef int  WIDGET_DRAW_ITEM_FUNC(const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Ntypedef void WIDGET_PAINT         (WM_HWIN hObj);
Xtypedef void WIDGET_PAINT         (GUI_HWIN hObj);
Ntypedef void WIDGET_CREATE        (WM_HWIN hObj);
Xtypedef void WIDGET_CREATE        (GUI_HWIN hObj);
N
Ntypedef struct {
N  WIDGET_PAINT  * pfPaint;
N  WIDGET_CREATE * pfCreate;
N  void          * pSkinPrivate;
N} WIDGET_SKIN;
N
N/*********************************************************************
N*
N*       Important: WIDGET_DRAW_ITEM_FUNC needs to be defined
N*                  in SCROLLBAR.h!
N*
N**********************************************************************
N*/
N#include "SCROLLBAR.h"
L 1 "..\..\..\ThirdParty\emWin\Include\SCROLLBAR.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : SCROLLBAR.h
NPurpose     : SCROLLBAR include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef SCROLLBAR_H
N#define SCROLLBAR_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
L 1 "..\..\..\ThirdParty\emWin\Include\DIALOG_Intern.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : Dialog.h
NPurpose     : Dialog box include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef DIALOG_INTERN_H
N#define DIALOG_INTERN_H
N
N#include "WM.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {        // Make sure we have C-declarations in C++ programs
N#endif
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef struct  GUI_WIDGET_CREATE_INFO_struct GUI_WIDGET_CREATE_INFO;
Ntypedef WM_HWIN GUI_WIDGET_CREATE_FUNC        (const GUI_WIDGET_CREATE_INFO * pCreate, WM_HWIN hWin, int x0, int y0, WM_CALLBACK * cb);
Xtypedef GUI_HWIN GUI_WIDGET_CREATE_FUNC        (const GUI_WIDGET_CREATE_INFO * pCreate, GUI_HWIN hWin, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       Structures
N*
N**********************************************************************
N*/
Nstruct GUI_WIDGET_CREATE_INFO_struct {
N  GUI_WIDGET_CREATE_FUNC * pfCreateIndirect;
N  const char             * pName;            // Text ... Not used on all widgets
N  I16                      Id;               // ID ... should be unique in a dialog
X  signed short                      Id;               
N  I16                      x0;               // x position
X  signed short                      x0;               
N  I16                      y0;               // y position
X  signed short                      y0;               
N  I16                      xSize;            // x size
X  signed short                      xSize;            
N  I16                      ySize;            // y size
X  signed short                      ySize;            
N  U16                      Flags;            // Widget specific create flags (opt.)
X  unsigned short                      Flags;            
N  I32                      Para;             // Widget specific parameter (opt.)
X  signed long                      Para;             
N  U32                      NumExtraBytes;    // Number of extra bytes usable with <WIDGET>_SetUserData & <WIDGET>_GetUserData
X  unsigned long                      NumExtraBytes;    
N};
N
N/*********************************************************************
N*
N*       Public API functions
N*
N**********************************************************************
N*/
NWM_HWIN            GUI_CreateDialogBox   (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, WM_HWIN hParent, int x0, int y0);
XGUI_HWIN            GUI_CreateDialogBox   (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, GUI_HWIN hParent, int x0, int y0);
Nvoid               GUI_EndDialog         (WM_HWIN hWin, int r);
Xvoid               GUI_EndDialog         (GUI_HWIN hWin, int r);
Nint                GUI_ExecDialogBox     (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, WM_HWIN hParent, int x0, int y0);
Xint                GUI_ExecDialogBox     (const GUI_WIDGET_CREATE_INFO * paWidget, int NumWidgets, WM_CALLBACK * cb, GUI_HWIN hParent, int x0, int y0);
Nint                GUI_ExecCreatedDialog (WM_HWIN hDialog);
Xint                GUI_ExecCreatedDialog (GUI_HWIN hDialog);
NWM_DIALOG_STATUS * GUI_GetDialogStatusPtr(WM_HWIN hDialog);                                    // Not to be documented
XWM_DIALOG_STATUS * GUI_GetDialogStatusPtr(GUI_HWIN hDialog);                                    
Nvoid               GUI_SetDialogStatusPtr(WM_HWIN hDialog, WM_DIALOG_STATUS * pDialogStatus);  // Not to be documented
Xvoid               GUI_SetDialogStatusPtr(GUI_HWIN hDialog, WM_DIALOG_STATUS * pDialogStatus);  
N
N/*********************************************************************
N*
N*       Obsolete
N*/
NLCD_COLOR          DIALOG_GetBkColor(void);
NLCD_COLOR          DIALOG_SetBkColor(LCD_COLOR BkColor);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // DIALOG_INTERN_H
N
N/*************************** End of file ****************************/
L 49 "..\..\..\ThirdParty\emWin\Include\SCROLLBAR.h" 2
N#include "WIDGET.h"
L 1 "..\..\..\ThirdParty\emWin\Include\WIDGET.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : WIDGET.h
NPurpose     : Widget interface
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef WIDGET_H        /* Avoid multiple inclusion  */
S#define WIDGET_H
S
S#if defined(__cplusplus)
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
S#endif
S
S#include "WM_Intern.h"  /* Window manager, including some internals, which speed things up */
S
S#if GUI_WINSUPPORT
S
S/*********************************************************************
S*
S*       Typedefs
S*
S**********************************************************************
S*/
Stypedef struct {
S  WM_HWIN    hWin;
S  int        Cmd;         /* WIDGET_ITEM_GET_XSIZE, WIDGET_ITEM_GET_YSIZE, WIDGET_ITEM_DRAW, */
S  int        ItemIndex;
S  int        Col;
S  int        x0, y0, x1, y1;
S  void     * p;
S} WIDGET_ITEM_DRAW_INFO;
S
Stypedef int  WIDGET_DRAW_ITEM_FUNC(const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Stypedef void WIDGET_PAINT         (WM_HWIN hObj);
Stypedef void WIDGET_CREATE        (WM_HWIN hObj);
S
Stypedef struct {
S  WIDGET_PAINT  * pfPaint;
S  WIDGET_CREATE * pfCreate;
S  void          * pSkinPrivate;
S} WIDGET_SKIN;
S
S/*********************************************************************
S*
S*       Important: WIDGET_DRAW_ITEM_FUNC needs to be defined
S*                  in SCROLLBAR.h!
S*
S**********************************************************************
S*/
S#include "SCROLLBAR.h"
S
S/*********************************************************************
S*
S*       Defines
S*
S**********************************************************************
S*/
S/*********************************************************************
S*
S*       Unique widget id's
S*/
S#define BUTTON_ID    0x42555454UL /* BUTT */
S#define CHECKBOX_ID  0x43484543UL /* CHEC */
S#define DROPDOWN_ID  0x44524f50UL /* DROP */
S#define EDIT_ID      0x45444954UL /* EDIT */
S#define FRAMEWIN_ID  0x4652414dUL /* FRAM */
S#define FRAMECLNT_ID 0x46524143UL /* FRAC */
S#define GRAPH_ID     0x47524150UL /* GRAP */
S#define HEADER_ID    0x48454144UL /* HEAD */
S#define LISTBOX_ID   0x4C495342UL /* LISB */
S#define LISTVIEW_ID  0x4C495356UL /* LISV */
S#define LISTWHEEL_ID 0x4C495357UL /* LISW */
S#define MENU_ID      0x4d454e55UL /* MENU */
S#define MULTIEDIT_ID 0x4d554c45UL /* MULE */
S#define MULTIPAGE_ID 0x4d554c50UL /* MULP */
S#define MPAGECLNT_ID 0x4d50434CUL /* MPCL */
S#define PROGBAR_ID   0x50524f47UL /* PROG */
S#define RADIO_ID     0x52414449UL /* RADI */
S#define SCROLLBAR_ID 0x5343524fUL /* SCRO */
S#define SLIDER_ID    0x534c4944UL /* SLID */
S#define SWIPELIST_ID 0x53574950UL /* SWIP */
S#define TEXT_ID      0x54455854UL /* TEXT */
S#define TREEVIEW_ID  0x54524545UL /* TREE */
S#define ICONVIEW_ID  0x49434f4eUL /* ICON */
S#define IMAGE_ID     0x494d4147UL /* IMAG */
S#define SPINBOX_ID   0x5350494eUL /* SPIN */
S#define KNOB_ID      0x4b4e4f42UL /* KNOB */
S#define WINDOW_ID    0x57494e44UL /* WIND */
S
S#define WIDGET_LOCK(hWin)       ((WIDGET*)GUI_LOCK_H(hWin))
S
S/*********************************************************************
S*
S*       Config switches
S*/
S
S#ifndef   WIDGET_USE_PARENT_EFFECT
S  #define WIDGET_USE_PARENT_EFFECT 0
S#endif
S#ifndef   WIDGET_USE_FLEX_SKIN
S  #if WM_SUPPORT_TRANSPARENCY
S    #define WIDGET_USE_FLEX_SKIN     1
S  #else
S    #define WIDGET_USE_FLEX_SKIN     0
S  #endif
S#endif
S#if !defined(WIDGET_USE_SCHEME_SMALL) && !defined(WIDGET_USE_SCHEME_MEDIUM) && !defined(WIDGET_USE_SCHEME_LARGE)
S  #define WIDGET_USE_SCHEME_SMALL  1
S  #define WIDGET_USE_SCHEME_MEDIUM 0
S  #define WIDGET_USE_SCHEME_LARGE  0
S#endif
S#ifndef   WIDGET_USE_SCHEME_SMALL
S  #define WIDGET_USE_SCHEME_SMALL  0
S#endif
S#ifndef   WIDGET_USE_SCHEME_MEDIUM
S  #define WIDGET_USE_SCHEME_MEDIUM 0
S#endif
S#ifndef   WIDGET_USE_SCHEME_LARGE
S  #define WIDGET_USE_SCHEME_LARGE  0
S#endif
S#if (WIDGET_USE_SCHEME_SMALL + WIDGET_USE_SCHEME_MEDIUM + WIDGET_USE_SCHEME_LARGE) > 1
S  #error Only one scheme can be selected!
S#endif
S
S/*********************************************************************
S*
S*       States
S*/
S
S#define WIDGET_STATE_FOCUS              (1 << 0)
S#define WIDGET_STATE_VERTICAL           (1 << 3)
S#define WIDGET_STATE_FOCUSABLE          (1 << 4)
S
S#define WIDGET_STATE_USER0              (1 << 8)    /* Freely available for derived widget */
S#define WIDGET_STATE_USER1              (1 << 9)    /* Freely available for derived widget */
S#define WIDGET_STATE_USER2              (1 << 10)   /* Freely available for derived widget */
S
S#define WIDGET_STATE_FOCUSSABLE         WIDGET_STATE_FOCUSABLE
S
S/*********************************************************************
S*
S*       Skinning message identifiers
S*/
S#define WIDGET_ITEM_CREATE              0
S#define WIDGET_ITEM_DRAW                1
S#define WIDGET_ITEM_DRAW_ARROW          2
S#define WIDGET_ITEM_DRAW_ARROW_L        3
S#define WIDGET_ITEM_DRAW_ARROW_R        4
S#define WIDGET_ITEM_DRAW_BACKGROUND     5
S#define WIDGET_ITEM_DRAW_BITMAP         6
S#define WIDGET_ITEM_DRAW_BUTTON         7
S#define WIDGET_ITEM_DRAW_BUTTON_L       8
S#define WIDGET_ITEM_DRAW_BUTTON_R       9
S#define WIDGET_ITEM_DRAW_FOCUS         10
S#define WIDGET_ITEM_DRAW_FRAME         11
S#define WIDGET_ITEM_DRAW_OVERLAP       12
S#define WIDGET_ITEM_DRAW_OVERLAY       13
S#define WIDGET_ITEM_DRAW_SEP           14
S#define WIDGET_ITEM_DRAW_SHAFT         15
S#define WIDGET_ITEM_DRAW_SHAFT_L       16
S#define WIDGET_ITEM_DRAW_SHAFT_R       17
S#define WIDGET_ITEM_DRAW_TEXT          18
S#define WIDGET_ITEM_DRAW_THUMB         19
S#define WIDGET_ITEM_DRAW_TICKS         20
S#define WIDGET_ITEM_GET_BORDERSIZE_B   21
S#define WIDGET_ITEM_GET_BORDERSIZE_L   22
S#define WIDGET_ITEM_GET_BORDERSIZE_R   23
S#define WIDGET_ITEM_GET_BORDERSIZE_T   24
S#define WIDGET_ITEM_GET_BUTTONSIZE     25
S#define WIDGET_ITEM_GET_XSIZE          26
S#define WIDGET_ITEM_GET_YSIZE          27
S#define WIDGET_ITEM_GET_RADIUS         28
S#define WIDGET_ITEM_APPLY_PROPS        29  // Not to be documented. Use this message identifier to update the
S                                           // properties of attached widgets from <WIDGET>_DrawSkinFlex().
S#define WIDGET_DRAW_BACKGROUND         30
S
S#define WIDGET_DRAW_OVERLAY    WIDGET_ITEM_DRAW_OVERLAY
S
S/*********************************************************************
S*
S*       Messages
S*/
S
S#define WM_WIDGET_SET_EFFECT    (WM_WIDGET + 0)
S
S/*********************************************************************
S*
S*       Create flags
S*/
S
S#define WIDGET_CF_VERTICAL      WIDGET_STATE_VERTICAL
S
S/*********************************************************************
S*
S*        Widget object
S*
S* The widget object is the base class for most widgets
S*/
Stypedef struct {
S  int EffectSize;
S  void (* pfDrawUp)      (void);
S  void (* pfDrawUpRect)  (const GUI_RECT * pRect);
S  void (* pfDrawDown)    (void);
S  void (* pfDrawDownRect)(const GUI_RECT * pRect);
S  void (* pfDrawFlat)    (void);
S  void (* pfDrawFlatRect)(const GUI_RECT * pRect);
S} WIDGET_EFFECT;
S
Stypedef struct {
S  WM_Obj      Win;
S  const WIDGET_EFFECT* pEffect;
S  I16 Id;
S  U16 State;
S  #if GUI_DEBUG_LEVEL > 1
S    U32 DebugId;
S  #endif  
S} WIDGET;
S
S
S/*********************************************************************
S*
S*         GUI_DRAW
S*
S* The GUI_DRAW object is used as base class for selfdrawing,
S* non-windows objects. They are used as content of different widgets,
S* such as the bitmap or header widgets.
S*/
S/* Declare Object struct */
Stypedef struct GUI_DRAW GUI_DRAW;
Stypedef void   GUI_DRAW_SELF_CB (WM_HWIN hWin);
Stypedef WM_HMEM GUI_DRAW_HANDLE;
S
S/* Declare Object constants (member functions etc)  */
Stypedef struct {
S  void (* pfDraw)    (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
S  int  (* pfGetXSize)(GUI_DRAW_HANDLE hDrawObj);
S  int  (* pfGetYSize)(GUI_DRAW_HANDLE hDrawObj);
S} GUI_DRAW_CONSTS;
S
S/* Declare Object */
Sstruct GUI_DRAW {
S  const GUI_DRAW_CONSTS* pConsts;
S  union {
S    const void * pData;
S    GUI_DRAW_SELF_CB* pfDraw;
S  } Data;
S  I16 xOff, yOff;
S};
S
S/* GUI_DRAW_ API */
Svoid GUI_DRAW__Draw    (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
Sint  GUI_DRAW__GetXSize(GUI_DRAW_HANDLE hDrawObj);
Sint  GUI_DRAW__GetYSize(GUI_DRAW_HANDLE hDrawObj);
S
Svoid GUI_DrawStreamedEnableAuto(void);
S
S/* GUI_DRAW_ Constructurs for different objects */
SWM_HMEM GUI_DRAW_BITMAP_Create  (const GUI_BITMAP* pBitmap, int x, int y);
SWM_HMEM GUI_DRAW_BMP_Create     (const void* pBMP, int x, int y);
SWM_HMEM GUI_DRAW_STREAMED_Create(const GUI_BITMAP_STREAM * pBitmap, int x, int y);
SWM_HMEM GUI_DRAW_SELF_Create(GUI_DRAW_SELF_CB* pfDraw, int x, int y);
S
S/*********************************************************************
S*
S*       Global data
S*
S**********************************************************************
S*/
S
Sextern const WIDGET_EFFECT WIDGET_Effect_3D;
Sextern const WIDGET_EFFECT WIDGET_Effect_3D1L;
Sextern const WIDGET_EFFECT WIDGET_Effect_3D2L;
Sextern const WIDGET_EFFECT WIDGET_Effect_None;
Sextern const WIDGET_EFFECT WIDGET_Effect_Simple;
S
S/*********************************************************************
S*
S*       Internal API routines
S*
S**********************************************************************
S*/
S
Svoid      WIDGET__DrawFocusRect      (WIDGET * pWidget, const GUI_RECT * pRect, int Dist);
Svoid      WIDGET__DrawHLine          (WIDGET * pWidget, int y, int x0, int x1);
Svoid      WIDGET__DrawTriangle       (WIDGET * pWidget, int x, int y, int Size, int Inc);
Svoid      WIDGET__DrawVLine          (WIDGET * pWidget, int x, int y0, int y1);
Svoid      WIDGET__EFFECT_DrawDownRect(WIDGET * pWidget, GUI_RECT * pRect);
Svoid      WIDGET__EFFECT_DrawDown    (WIDGET * pWidget);
Svoid      WIDGET__EFFECT_DrawUpRect  (WIDGET * pWidget, GUI_RECT * pRect);
Svoid      WIDGET__FillRectEx         (WIDGET * pWidget, const GUI_RECT * pRect);
Sint       WIDGET__GetWindowSizeX     (WM_HWIN hWin);
SGUI_COLOR WIDGET__GetBkColor         (WM_HWIN hObj);
Sint       WIDGET__GetXSize           (const WIDGET * pWidget);
Sint       WIDGET__GetYSize           (const WIDGET * pWidget);
Svoid      WIDGET__GetClientRect      (WIDGET * pWidget, GUI_RECT * pRect);
Svoid      WIDGET__GetInsideRect      (WIDGET * pWidget, GUI_RECT * pRect);
Svoid      WIDGET__Init               (WIDGET * pWidget, int Id, U16 State);
Svoid      WIDGET__RotateRect90       (WIDGET * pWidget, GUI_RECT * pDest, const GUI_RECT * pRect);
Svoid      WIDGET__SetScrollState     (WM_HWIN hWin, const WM_SCROLL_STATE * pVState, const WM_SCROLL_STATE * pState);
Svoid      WIDGET__FillStringInRect   (const char * pText, const GUI_RECT * pFillRect, const GUI_RECT * pTextRectMax, const GUI_RECT * pTextRectAct);
S
S//
S// Function pointers for drawing streamed bitmaps
S//
Sextern void (* GUI__pfDrawStreamedBitmap)  (const void * p, int x, int y);
Sextern int  (* GUI__pfDrawStreamedBitmapEx)(GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
S
S/*********************************************************************
S*
S*       API routines
S*
S**********************************************************************
S*/
Svoid  WIDGET_SetState     (WM_HWIN hObj, int State);
Svoid  WIDGET_AndState     (WM_HWIN hObj, int State);
Svoid  WIDGET_OrState      (WM_HWIN hObj, int State);
Sint   WIDGET_HandleActive (WM_HWIN hObj, WM_MESSAGE* pMsg);
Sint   WIDGET_GetState     (WM_HWIN hObj);
Sint   WIDGET_SetWidth     (WM_HWIN hObj, int Width);
Svoid  WIDGET_SetFocusable (WM_HWIN hObj, int State);
S
Svoid  WIDGET_EFFECT_3D_DrawUp(void);
S
Sconst WIDGET_EFFECT* WIDGET_SetDefaultEffect(const WIDGET_EFFECT* pEffect);
S
Svoid  WIDGET_SetEffect              (WM_HWIN hObj, const WIDGET_EFFECT* pEffect);
S
Sconst WIDGET_EFFECT* WIDGET_GetDefaultEffect(void);
S
Svoid WIDGET_EFFECT_3D_SetColor    (unsigned Index, GUI_COLOR Color);
Svoid WIDGET_EFFECT_3D1L_SetColor  (unsigned Index, GUI_COLOR Color);
Svoid WIDGET_EFFECT_3D2L_SetColor  (unsigned Index, GUI_COLOR Color);
Svoid WIDGET_EFFECT_Simple_SetColor(unsigned Index, GUI_COLOR Color);
S
SGUI_COLOR WIDGET_EFFECT_3D_GetColor    (unsigned Index);
SGUI_COLOR WIDGET_EFFECT_3D1L_GetColor  (unsigned Index);
SGUI_COLOR WIDGET_EFFECT_3D2L_GetColor  (unsigned Index);
SGUI_COLOR WIDGET_EFFECT_Simple_GetColor(unsigned Index);
S
Sint WIDGET_EFFECT_3D_GetNumColors(void);
Sint WIDGET_EFFECT_3D1L_GetNumColors(void);
Sint WIDGET_EFFECT_3D2L_GetNumColors(void);
Sint WIDGET_EFFECT_Simple_GetNumColors(void);
S
S/*********************************************************************
S*
S*       Compatibility macros
S*
S**********************************************************************
S*/
S#define WIDGET_EnableStreamAuto() GUI_DrawStreamedEnableAuto()
S
S#define WIDGET_SetDefaultEffect_3D()     WIDGET_SetDefaultEffect(&WIDGET_Effect_3D)
S#define WIDGET_SetDefaultEffect_3D1L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D1L)
S#define WIDGET_SetDefaultEffect_3D2L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D2L)
S#define WIDGET_SetDefaultEffect_None()   WIDGET_SetDefaultEffect(&WIDGET_Effect_None)
S#define WIDGET_SetDefaultEffect_Simple() WIDGET_SetDefaultEffect(&WIDGET_Effect_Simple)
S
S#endif /* GUI_WINSUPPORT */
S
S#if defined(__cplusplus)
S  }
S#endif
S
N#endif   /* SLIDER_H */
N
N/*************************** End of file ****************************/
L 50 "..\..\..\ThirdParty\emWin\Include\SCROLLBAR.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define SCROLLBAR_CI_THUMB 0
N#define SCROLLBAR_CI_SHAFT 1
N#define SCROLLBAR_CI_ARROW 2
N
N/*********************************************************************
N*
N*       States
N*/
N#define SCROLLBAR_STATE_PRESSED   WIDGET_STATE_USER0
N
N/*********************************************************************
N*
N*       Create / Status flags
N*/
N#define SCROLLBAR_CF_VERTICAL     WIDGET_CF_VERTICAL
N#define SCROLLBAR_CF_FOCUSABLE    WIDGET_STATE_FOCUSABLE
N
N#define SCROLLBAR_CF_FOCUSSABLE   SCROLLBAR_CF_FOCUSABLE
N
N/************************************************************
N*
N*       Skinning property indices
N*/
N#define SCROLLBAR_SKINFLEX_PI_PRESSED   0
N#define SCROLLBAR_SKINFLEX_PI_UNPRESSED 1
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM SCROLLBAR_Handle;
Xtypedef signed long SCROLLBAR_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorUpper[2];
N  GUI_COLOR aColorLower[2];
N  GUI_COLOR aColorShaft[2];
N  GUI_COLOR ColorArrow;
N  GUI_COLOR ColorGrasp;
N} SCROLLBAR_SKINFLEX_PROPS;
N
Ntypedef struct {
N  int IsVertical;
N  int State;
N} SCROLLBAR_SKINFLEX_INFO;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NSCROLLBAR_Handle SCROLLBAR_Create        (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
XSCROLLBAR_Handle SCROLLBAR_Create        (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
NSCROLLBAR_Handle SCROLLBAR_CreateAttached(WM_HWIN hParent, int SpecialFlags);
XSCROLLBAR_Handle SCROLLBAR_CreateAttached(GUI_HWIN hParent, int SpecialFlags);
NSCROLLBAR_Handle SCROLLBAR_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id);
XSCROLLBAR_Handle SCROLLBAR_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id);
NSCROLLBAR_Handle SCROLLBAR_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
XSCROLLBAR_Handle SCROLLBAR_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, int NumExtraBytes);
NSCROLLBAR_Handle SCROLLBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XSCROLLBAR_Handle SCROLLBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid SCROLLBAR_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
N/* Methods changing properties */
N
Nvoid      SCROLLBAR_AddValue   (SCROLLBAR_Handle hObj, int Add);
Nvoid      SCROLLBAR_Dec        (SCROLLBAR_Handle hObj);
Nvoid      SCROLLBAR_Inc        (SCROLLBAR_Handle hObj);
Nint       SCROLLBAR_GetUserData(SCROLLBAR_Handle hObj, void * pDest, int NumBytes);
NGUI_COLOR SCROLLBAR_SetColor   (SCROLLBAR_Handle hObj, int Index, GUI_COLOR Color);
Nvoid      SCROLLBAR_SetNumItems(SCROLLBAR_Handle hObj, int NumItems);
Nvoid      SCROLLBAR_SetPageSize(SCROLLBAR_Handle hObj, int PageSize);
Nvoid      SCROLLBAR_SetValue   (SCROLLBAR_Handle hObj, int v);
Nint       SCROLLBAR_SetWidth   (SCROLLBAR_Handle hObj, int Width);
Nvoid      SCROLLBAR_SetState   (SCROLLBAR_Handle hObj, const WM_SCROLL_STATE* pState);
Nint       SCROLLBAR_SetUserData(SCROLLBAR_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid SCROLLBAR_GetSkinFlexProps     (SCROLLBAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid SCROLLBAR_SetSkinClassic       (SCROLLBAR_Handle hObj);
Nvoid SCROLLBAR_SetSkin              (SCROLLBAR_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  SCROLLBAR_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid SCROLLBAR_SetSkinFlexProps     (const SCROLLBAR_SKINFLEX_PROPS * pProps, int Index);
Nvoid SCROLLBAR_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * SCROLLBAR_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define SCROLLBAR_SKIN_FLEX    SCROLLBAR_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
Nint       SCROLLBAR_GetDefaultWidth(void);
NGUI_COLOR SCROLLBAR_SetDefaultColor(GUI_COLOR Color, unsigned int Index); /* Not yet documented */
Nint       SCROLLBAR_SetDefaultWidth(int DefaultWidth);
N
N/*********************************************************************
N*
N*       Global functions
N*
N**********************************************************************
N*/
Nint       SCROLLBAR_GetThumbSizeMin(void);
Nint       SCROLLBAR_SetThumbSizeMin(int ThumbSizeMin);
N
N/*********************************************************************
N*
N*       Query state
N*
N**********************************************************************
N*/
NGUI_COLOR SCROLLBAR_GetColor   (SCROLLBAR_Handle hObj, int Index);
Nint       SCROLLBAR_GetNumItems(SCROLLBAR_Handle hObj);
Nint       SCROLLBAR_GetPageSize(SCROLLBAR_Handle hObj);
Nint       SCROLLBAR_GetValue   (SCROLLBAR_Handle hObj);
N
N/*********************************************************************
N*
N*       Macros for compatibility
N*
N**********************************************************************
N*/
N#define SCROLLBAR_BKCOLOR0_DEFAULT SCROLLBAR_COLOR_ARROW_DEFAULT
N#define SCROLLBAR_BKCOLOR1_DEFAULT SCROLLBAR_COLOR_SHAFT_DEFAULT
N#define SCROLLBAR_COLOR0_DEFAULT   SCROLLBAR_COLOR_THUMB_DEFAULT
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // SCROLLBAR_H
N
N/*************************** End of file ****************************/
L 88 "..\..\..\ThirdParty\emWin\Include\WIDGET.h" 2
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Unique widget id's
N*/
N#define BUTTON_ID    0x42555454UL /* BUTT */
N#define CHECKBOX_ID  0x43484543UL /* CHEC */
N#define DROPDOWN_ID  0x44524f50UL /* DROP */
N#define EDIT_ID      0x45444954UL /* EDIT */
N#define FRAMEWIN_ID  0x4652414dUL /* FRAM */
N#define FRAMECLNT_ID 0x46524143UL /* FRAC */
N#define GRAPH_ID     0x47524150UL /* GRAP */
N#define HEADER_ID    0x48454144UL /* HEAD */
N#define LISTBOX_ID   0x4C495342UL /* LISB */
N#define LISTVIEW_ID  0x4C495356UL /* LISV */
N#define LISTWHEEL_ID 0x4C495357UL /* LISW */
N#define MENU_ID      0x4d454e55UL /* MENU */
N#define MULTIEDIT_ID 0x4d554c45UL /* MULE */
N#define MULTIPAGE_ID 0x4d554c50UL /* MULP */
N#define MPAGECLNT_ID 0x4d50434CUL /* MPCL */
N#define PROGBAR_ID   0x50524f47UL /* PROG */
N#define RADIO_ID     0x52414449UL /* RADI */
N#define SCROLLBAR_ID 0x5343524fUL /* SCRO */
N#define SLIDER_ID    0x534c4944UL /* SLID */
N#define SWIPELIST_ID 0x53574950UL /* SWIP */
N#define TEXT_ID      0x54455854UL /* TEXT */
N#define TREEVIEW_ID  0x54524545UL /* TREE */
N#define ICONVIEW_ID  0x49434f4eUL /* ICON */
N#define IMAGE_ID     0x494d4147UL /* IMAG */
N#define SPINBOX_ID   0x5350494eUL /* SPIN */
N#define KNOB_ID      0x4b4e4f42UL /* KNOB */
N#define WINDOW_ID    0x57494e44UL /* WIND */
N
N#define WIDGET_LOCK(hWin)       ((WIDGET*)GUI_LOCK_H(hWin))
N
N/*********************************************************************
N*
N*       Config switches
N*/
N
N#ifndef   WIDGET_USE_PARENT_EFFECT
N  #define WIDGET_USE_PARENT_EFFECT 0
N#endif
N#ifndef   WIDGET_USE_FLEX_SKIN
N  #if WM_SUPPORT_TRANSPARENCY
X  #if 1
N    #define WIDGET_USE_FLEX_SKIN     1
N  #else
S    #define WIDGET_USE_FLEX_SKIN     0
N  #endif
N#endif
N#if !defined(WIDGET_USE_SCHEME_SMALL) && !defined(WIDGET_USE_SCHEME_MEDIUM) && !defined(WIDGET_USE_SCHEME_LARGE)
X#if !0L && !0L && !0L
N  #define WIDGET_USE_SCHEME_SMALL  1
N  #define WIDGET_USE_SCHEME_MEDIUM 0
N  #define WIDGET_USE_SCHEME_LARGE  0
N#endif
N#ifndef   WIDGET_USE_SCHEME_SMALL
S  #define WIDGET_USE_SCHEME_SMALL  0
N#endif
N#ifndef   WIDGET_USE_SCHEME_MEDIUM
S  #define WIDGET_USE_SCHEME_MEDIUM 0
N#endif
N#ifndef   WIDGET_USE_SCHEME_LARGE
S  #define WIDGET_USE_SCHEME_LARGE  0
N#endif
N#if (WIDGET_USE_SCHEME_SMALL + WIDGET_USE_SCHEME_MEDIUM + WIDGET_USE_SCHEME_LARGE) > 1
X#if (1 + 0 + 0) > 1
S  #error Only one scheme can be selected!
N#endif
N
N/*********************************************************************
N*
N*       States
N*/
N
N#define WIDGET_STATE_FOCUS              (1 << 0)
N#define WIDGET_STATE_VERTICAL           (1 << 3)
N#define WIDGET_STATE_FOCUSABLE          (1 << 4)
N
N#define WIDGET_STATE_USER0              (1 << 8)    /* Freely available for derived widget */
N#define WIDGET_STATE_USER1              (1 << 9)    /* Freely available for derived widget */
N#define WIDGET_STATE_USER2              (1 << 10)   /* Freely available for derived widget */
N
N#define WIDGET_STATE_FOCUSSABLE         WIDGET_STATE_FOCUSABLE
N
N/*********************************************************************
N*
N*       Skinning message identifiers
N*/
N#define WIDGET_ITEM_CREATE              0
N#define WIDGET_ITEM_DRAW                1
N#define WIDGET_ITEM_DRAW_ARROW          2
N#define WIDGET_ITEM_DRAW_ARROW_L        3
N#define WIDGET_ITEM_DRAW_ARROW_R        4
N#define WIDGET_ITEM_DRAW_BACKGROUND     5
N#define WIDGET_ITEM_DRAW_BITMAP         6
N#define WIDGET_ITEM_DRAW_BUTTON         7
N#define WIDGET_ITEM_DRAW_BUTTON_L       8
N#define WIDGET_ITEM_DRAW_BUTTON_R       9
N#define WIDGET_ITEM_DRAW_FOCUS         10
N#define WIDGET_ITEM_DRAW_FRAME         11
N#define WIDGET_ITEM_DRAW_OVERLAP       12
N#define WIDGET_ITEM_DRAW_OVERLAY       13
N#define WIDGET_ITEM_DRAW_SEP           14
N#define WIDGET_ITEM_DRAW_SHAFT         15
N#define WIDGET_ITEM_DRAW_SHAFT_L       16
N#define WIDGET_ITEM_DRAW_SHAFT_R       17
N#define WIDGET_ITEM_DRAW_TEXT          18
N#define WIDGET_ITEM_DRAW_THUMB         19
N#define WIDGET_ITEM_DRAW_TICKS         20
N#define WIDGET_ITEM_GET_BORDERSIZE_B   21
N#define WIDGET_ITEM_GET_BORDERSIZE_L   22
N#define WIDGET_ITEM_GET_BORDERSIZE_R   23
N#define WIDGET_ITEM_GET_BORDERSIZE_T   24
N#define WIDGET_ITEM_GET_BUTTONSIZE     25
N#define WIDGET_ITEM_GET_XSIZE          26
N#define WIDGET_ITEM_GET_YSIZE          27
N#define WIDGET_ITEM_GET_RADIUS         28
N#define WIDGET_ITEM_APPLY_PROPS        29  // Not to be documented. Use this message identifier to update the
N                                           // properties of attached widgets from <WIDGET>_DrawSkinFlex().
N#define WIDGET_DRAW_BACKGROUND         30
N
N#define WIDGET_DRAW_OVERLAY    WIDGET_ITEM_DRAW_OVERLAY
N
N/*********************************************************************
N*
N*       Messages
N*/
N
N#define WM_WIDGET_SET_EFFECT    (WM_WIDGET + 0)
N
N/*********************************************************************
N*
N*       Create flags
N*/
N
N#define WIDGET_CF_VERTICAL      WIDGET_STATE_VERTICAL
N
N/*********************************************************************
N*
N*        Widget object
N*
N* The widget object is the base class for most widgets
N*/
Ntypedef struct {
N  int EffectSize;
N  void (* pfDrawUp)      (void);
N  void (* pfDrawUpRect)  (const GUI_RECT * pRect);
N  void (* pfDrawDown)    (void);
N  void (* pfDrawDownRect)(const GUI_RECT * pRect);
N  void (* pfDrawFlat)    (void);
N  void (* pfDrawFlatRect)(const GUI_RECT * pRect);
N} WIDGET_EFFECT;
N
Ntypedef struct {
N  WM_Obj      Win;
N  const WIDGET_EFFECT* pEffect;
N  I16 Id;
X  signed short Id;
N  U16 State;
X  unsigned short State;
N  #if GUI_DEBUG_LEVEL > 1
X  #if 0 > 1
S    U32 DebugId;
N  #endif  
N} WIDGET;
N
N
N/*********************************************************************
N*
N*         GUI_DRAW
N*
N* The GUI_DRAW object is used as base class for selfdrawing,
N* non-windows objects. They are used as content of different widgets,
N* such as the bitmap or header widgets.
N*/
N/* Declare Object struct */
Ntypedef struct GUI_DRAW GUI_DRAW;
Ntypedef void   GUI_DRAW_SELF_CB (WM_HWIN hWin);
Xtypedef void   GUI_DRAW_SELF_CB (GUI_HWIN hWin);
Ntypedef WM_HMEM GUI_DRAW_HANDLE;
Xtypedef signed long GUI_DRAW_HANDLE;
N
N/* Declare Object constants (member functions etc)  */
Ntypedef struct {
N  void (* pfDraw)    (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
X  void (* pfDraw)    (GUI_DRAW_HANDLE hDrawObj, GUI_HWIN hObj, int x, int y);
N  int  (* pfGetXSize)(GUI_DRAW_HANDLE hDrawObj);
N  int  (* pfGetYSize)(GUI_DRAW_HANDLE hDrawObj);
N} GUI_DRAW_CONSTS;
N
N/* Declare Object */
Nstruct GUI_DRAW {
N  const GUI_DRAW_CONSTS* pConsts;
N  union {
N    const void * pData;
N    GUI_DRAW_SELF_CB* pfDraw;
N  } Data;
N  I16 xOff, yOff;
X  signed short xOff, yOff;
N};
N
N/* GUI_DRAW_ API */
Nvoid GUI_DRAW__Draw    (GUI_DRAW_HANDLE hDrawObj, WM_HWIN hObj, int x, int y);
Xvoid GUI_DRAW__Draw    (GUI_DRAW_HANDLE hDrawObj, GUI_HWIN hObj, int x, int y);
Nint  GUI_DRAW__GetXSize(GUI_DRAW_HANDLE hDrawObj);
Nint  GUI_DRAW__GetYSize(GUI_DRAW_HANDLE hDrawObj);
N
Nvoid GUI_DrawStreamedEnableAuto(void);
N
N/* GUI_DRAW_ Constructurs for different objects */
NWM_HMEM GUI_DRAW_BITMAP_Create  (const GUI_BITMAP* pBitmap, int x, int y);
Xsigned long GUI_DRAW_BITMAP_Create  (const GUI_BITMAP* pBitmap, int x, int y);
NWM_HMEM GUI_DRAW_BMP_Create     (const void* pBMP, int x, int y);
Xsigned long GUI_DRAW_BMP_Create     (const void* pBMP, int x, int y);
NWM_HMEM GUI_DRAW_STREAMED_Create(const GUI_BITMAP_STREAM * pBitmap, int x, int y);
Xsigned long GUI_DRAW_STREAMED_Create(const GUI_BITMAP_STREAM * pBitmap, int x, int y);
NWM_HMEM GUI_DRAW_SELF_Create(GUI_DRAW_SELF_CB* pfDraw, int x, int y);
Xsigned long GUI_DRAW_SELF_Create(GUI_DRAW_SELF_CB* pfDraw, int x, int y);
N
N/*********************************************************************
N*
N*       Global data
N*
N**********************************************************************
N*/
N
Nextern const WIDGET_EFFECT WIDGET_Effect_3D;
Nextern const WIDGET_EFFECT WIDGET_Effect_3D1L;
Nextern const WIDGET_EFFECT WIDGET_Effect_3D2L;
Nextern const WIDGET_EFFECT WIDGET_Effect_None;
Nextern const WIDGET_EFFECT WIDGET_Effect_Simple;
N
N/*********************************************************************
N*
N*       Internal API routines
N*
N**********************************************************************
N*/
N
Nvoid      WIDGET__DrawFocusRect      (WIDGET * pWidget, const GUI_RECT * pRect, int Dist);
Nvoid      WIDGET__DrawHLine          (WIDGET * pWidget, int y, int x0, int x1);
Nvoid      WIDGET__DrawTriangle       (WIDGET * pWidget, int x, int y, int Size, int Inc);
Nvoid      WIDGET__DrawVLine          (WIDGET * pWidget, int x, int y0, int y1);
Nvoid      WIDGET__EFFECT_DrawDownRect(WIDGET * pWidget, GUI_RECT * pRect);
Nvoid      WIDGET__EFFECT_DrawDown    (WIDGET * pWidget);
Nvoid      WIDGET__EFFECT_DrawUpRect  (WIDGET * pWidget, GUI_RECT * pRect);
Nvoid      WIDGET__FillRectEx         (WIDGET * pWidget, const GUI_RECT * pRect);
Nint       WIDGET__GetWindowSizeX     (WM_HWIN hWin);
Xint       WIDGET__GetWindowSizeX     (GUI_HWIN hWin);
NGUI_COLOR WIDGET__GetBkColor         (WM_HWIN hObj);
XGUI_COLOR WIDGET__GetBkColor         (GUI_HWIN hObj);
Nint       WIDGET__GetXSize           (const WIDGET * pWidget);
Nint       WIDGET__GetYSize           (const WIDGET * pWidget);
Nvoid      WIDGET__GetClientRect      (WIDGET * pWidget, GUI_RECT * pRect);
Nvoid      WIDGET__GetInsideRect      (WIDGET * pWidget, GUI_RECT * pRect);
Nvoid      WIDGET__Init               (WIDGET * pWidget, int Id, U16 State);
Xvoid      WIDGET__Init               (WIDGET * pWidget, int Id, unsigned short State);
Nvoid      WIDGET__RotateRect90       (WIDGET * pWidget, GUI_RECT * pDest, const GUI_RECT * pRect);
Nvoid      WIDGET__SetScrollState     (WM_HWIN hWin, const WM_SCROLL_STATE * pVState, const WM_SCROLL_STATE * pState);
Xvoid      WIDGET__SetScrollState     (GUI_HWIN hWin, const WM_SCROLL_STATE * pVState, const WM_SCROLL_STATE * pState);
Nvoid      WIDGET__FillStringInRect   (const char * pText, const GUI_RECT * pFillRect, const GUI_RECT * pTextRectMax, const GUI_RECT * pTextRectAct);
N
N//
N// Function pointers for drawing streamed bitmaps
N//
Nextern void (* GUI__pfDrawStreamedBitmap)  (const void * p, int x, int y);
Nextern int  (* GUI__pfDrawStreamedBitmapEx)(GUI_GET_DATA_FUNC * pfGetData, const void * p, int x, int y);
N
N/*********************************************************************
N*
N*       API routines
N*
N**********************************************************************
N*/
Nvoid  WIDGET_SetState     (WM_HWIN hObj, int State);
Xvoid  WIDGET_SetState     (GUI_HWIN hObj, int State);
Nvoid  WIDGET_AndState     (WM_HWIN hObj, int State);
Xvoid  WIDGET_AndState     (GUI_HWIN hObj, int State);
Nvoid  WIDGET_OrState      (WM_HWIN hObj, int State);
Xvoid  WIDGET_OrState      (GUI_HWIN hObj, int State);
Nint   WIDGET_HandleActive (WM_HWIN hObj, WM_MESSAGE* pMsg);
Xint   WIDGET_HandleActive (GUI_HWIN hObj, WM_MESSAGE* pMsg);
Nint   WIDGET_GetState     (WM_HWIN hObj);
Xint   WIDGET_GetState     (GUI_HWIN hObj);
Nint   WIDGET_SetWidth     (WM_HWIN hObj, int Width);
Xint   WIDGET_SetWidth     (GUI_HWIN hObj, int Width);
Nvoid  WIDGET_SetFocusable (WM_HWIN hObj, int State);
Xvoid  WIDGET_SetFocusable (GUI_HWIN hObj, int State);
N
Nvoid  WIDGET_EFFECT_3D_DrawUp(void);
N
Nconst WIDGET_EFFECT* WIDGET_SetDefaultEffect(const WIDGET_EFFECT* pEffect);
N
Nvoid  WIDGET_SetEffect              (WM_HWIN hObj, const WIDGET_EFFECT* pEffect);
Xvoid  WIDGET_SetEffect              (GUI_HWIN hObj, const WIDGET_EFFECT* pEffect);
N
Nconst WIDGET_EFFECT* WIDGET_GetDefaultEffect(void);
N
Nvoid WIDGET_EFFECT_3D_SetColor    (unsigned Index, GUI_COLOR Color);
Nvoid WIDGET_EFFECT_3D1L_SetColor  (unsigned Index, GUI_COLOR Color);
Nvoid WIDGET_EFFECT_3D2L_SetColor  (unsigned Index, GUI_COLOR Color);
Nvoid WIDGET_EFFECT_Simple_SetColor(unsigned Index, GUI_COLOR Color);
N
NGUI_COLOR WIDGET_EFFECT_3D_GetColor    (unsigned Index);
NGUI_COLOR WIDGET_EFFECT_3D1L_GetColor  (unsigned Index);
NGUI_COLOR WIDGET_EFFECT_3D2L_GetColor  (unsigned Index);
NGUI_COLOR WIDGET_EFFECT_Simple_GetColor(unsigned Index);
N
Nint WIDGET_EFFECT_3D_GetNumColors(void);
Nint WIDGET_EFFECT_3D1L_GetNumColors(void);
Nint WIDGET_EFFECT_3D2L_GetNumColors(void);
Nint WIDGET_EFFECT_Simple_GetNumColors(void);
N
N/*********************************************************************
N*
N*       Compatibility macros
N*
N**********************************************************************
N*/
N#define WIDGET_EnableStreamAuto() GUI_DrawStreamedEnableAuto()
N
N#define WIDGET_SetDefaultEffect_3D()     WIDGET_SetDefaultEffect(&WIDGET_Effect_3D)
N#define WIDGET_SetDefaultEffect_3D1L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D1L)
N#define WIDGET_SetDefaultEffect_3D2L()   WIDGET_SetDefaultEffect(&WIDGET_Effect_3D2L)
N#define WIDGET_SetDefaultEffect_None()   WIDGET_SetDefaultEffect(&WIDGET_Effect_None)
N#define WIDGET_SetDefaultEffect_Simple() WIDGET_SetDefaultEffect(&WIDGET_Effect_Simple)
N
N#endif /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* SLIDER_H */
N
N/*************************** End of file ****************************/
L 49 "..\..\..\ThirdParty\emWin\Include\FRAMEWIN.h" 2
N#if GUI_WINSUPPORT
X#if 1
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Configuration
N*/
N#ifndef   FRAMEWIN_ALLOW_DRAG_ON_FRAME
N  #define FRAMEWIN_ALLOW_DRAG_ON_FRAME 1
N#endif
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define FRAMEWIN_CI_INACTIVE 0
N#define FRAMEWIN_CI_ACTIVE   1
N
N/*********************************************************************
N*
N*       Create / Status flags
N*/
N#define FRAMEWIN_CF_ACTIVE     (1<<3)
N#define FRAMEWIN_CF_MOVEABLE   (1<<4)
N#define FRAMEWIN_CF_TITLEVIS   (1<<5)
N#define FRAMEWIN_CF_MINIMIZED  (1<<6)
N#define FRAMEWIN_CF_MAXIMIZED  (1<<7)
N#define FRAMEWIN_CF_DRAGGING   (1<<8)
N
N#define FRAMEWIN_SF_ACTIVE     FRAMEWIN_CF_ACTIVE
N#define FRAMEWIN_SF_MOVEABLE   FRAMEWIN_CF_MOVEABLE
N#define FRAMEWIN_SF_TITLEVIS   FRAMEWIN_CF_TITLEVIS
N#define FRAMEWIN_SF_MINIMIZED  FRAMEWIN_CF_MINIMIZED
N#define FRAMEWIN_SF_MAXIMIZED  FRAMEWIN_CF_MAXIMIZED
N#define FRAMEWIN_SF_DRAGGING   FRAMEWIN_CF_DRAGGING
N
N/*********************************************************************
N*
N*       BUTTON Flags
N*/
N#define FRAMEWIN_BUTTON_RIGHT   (1<<0)
N#define FRAMEWIN_BUTTON_LEFT    (1<<1)
N
N/*********************************************************************
N*
N*       Skinning property indices
N*/
N#define FRAMEWIN_SKINFLEX_PI_ACTIVE   0
N#define FRAMEWIN_SKINFLEX_PI_INACTIVE 1
N
N/*********************************************************************
N*
N*       Getting border size
N*/
N#define FRAMEWIN_BORDERSIZE_T 0
N#define FRAMEWIN_BORDERSIZE_L 1
N#define FRAMEWIN_BORDERSIZE_B 2
N#define FRAMEWIN_BORDERSIZE_R 3
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM FRAMEWIN_Handle;
Xtypedef signed long FRAMEWIN_Handle;
N
Ntypedef struct {
N  GUI_COLOR aColorFrame[3];
N  GUI_COLOR aColorTitle[2];
N  int Radius;
N  int SpaceX;
N  int BorderSizeL;
N  int BorderSizeR;
N  int BorderSizeT;
N  int BorderSizeB;
N} FRAMEWIN_SKINFLEX_PROPS;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NFRAMEWIN_Handle FRAMEWIN_Create        (const char * pTitle, WM_CALLBACK * cb, int Flags, int x0, int y0, int xSize, int ySize);
NFRAMEWIN_Handle FRAMEWIN_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, const char * pText, WM_CALLBACK * cb, int Flags);
XFRAMEWIN_Handle FRAMEWIN_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, const char * pText, WM_CALLBACK * cb, int Flags);
NFRAMEWIN_Handle FRAMEWIN_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb);
XFRAMEWIN_Handle FRAMEWIN_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb);
NFRAMEWIN_Handle FRAMEWIN_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb, int NumExtraBytes);
XFRAMEWIN_Handle FRAMEWIN_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pTitle, WM_CALLBACK * cb, int NumExtraBytes);
NFRAMEWIN_Handle FRAMEWIN_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XFRAMEWIN_Handle FRAMEWIN_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid FRAMEWIN_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions: Set Properties
N*
N**********************************************************************
N*/
NWM_HWIN FRAMEWIN_AddButton     (FRAMEWIN_Handle hObj, int Flags, int Off, int Id);
XGUI_HWIN FRAMEWIN_AddButton     (FRAMEWIN_Handle hObj, int Flags, int Off, int Id);
NWM_HWIN FRAMEWIN_AddCloseButton(FRAMEWIN_Handle hObj, int Flags, int Off);
XGUI_HWIN FRAMEWIN_AddCloseButton(FRAMEWIN_Handle hObj, int Flags, int Off);
NWM_HWIN FRAMEWIN_AddMaxButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
XGUI_HWIN FRAMEWIN_AddMaxButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
Nvoid    FRAMEWIN_AddMenu       (FRAMEWIN_Handle hObj, WM_HWIN hMenu);
Xvoid    FRAMEWIN_AddMenu       (FRAMEWIN_Handle hObj, GUI_HWIN hMenu);
NWM_HWIN FRAMEWIN_AddMinButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
XGUI_HWIN FRAMEWIN_AddMinButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
Nvoid    FRAMEWIN_Minimize      (FRAMEWIN_Handle hObj);
Nvoid    FRAMEWIN_Maximize      (FRAMEWIN_Handle hObj);
Nvoid    FRAMEWIN_Restore       (FRAMEWIN_Handle hObj);
Nvoid    FRAMEWIN_SetActive     (FRAMEWIN_Handle hObj, int State);
Nvoid    FRAMEWIN_SetBarColor   (FRAMEWIN_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetBorderSize (FRAMEWIN_Handle hObj, unsigned Size);
Nvoid    FRAMEWIN_SetClientColor(FRAMEWIN_Handle hObj, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetFont       (FRAMEWIN_Handle hObj, const GUI_FONT * pFont);
Nvoid    FRAMEWIN_SetMoveable   (FRAMEWIN_Handle hObj, int State);
Nvoid    FRAMEWIN_SetOwnerDraw  (FRAMEWIN_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawItem);
Nvoid    FRAMEWIN_SetResizeable (FRAMEWIN_Handle hObj, int State);
Nvoid    FRAMEWIN_SetText       (FRAMEWIN_Handle hObj, const char* s);
Nvoid    FRAMEWIN_SetTextAlign  (FRAMEWIN_Handle hObj, int Align);
Nvoid    FRAMEWIN_SetTextColor  (FRAMEWIN_Handle hObj, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetTextColorEx(FRAMEWIN_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid    FRAMEWIN_SetTitleVis   (FRAMEWIN_Handle hObj, int Show);
Nint     FRAMEWIN_SetTitleHeight(FRAMEWIN_Handle hObj, int Height);
Nint     FRAMEWIN_SetUserData   (FRAMEWIN_Handle hObj, const void * pSrc, int NumBytes);
N
N/*********************************************************************
N*
N*       Member functions: Skinning
N*
N**********************************************************************
N*/
Nvoid FRAMEWIN_GetSkinFlexProps     (FRAMEWIN_SKINFLEX_PROPS * pProps, int Index);
Nvoid FRAMEWIN_SetSkinClassic       (FRAMEWIN_Handle hObj);
Nvoid FRAMEWIN_SetSkin              (FRAMEWIN_Handle hObj, WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
Nint  FRAMEWIN_DrawSkinFlex         (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid FRAMEWIN_SetSkinFlexProps     (const FRAMEWIN_SKINFLEX_PROPS * pProps, int Index);
Nvoid FRAMEWIN_SetDefaultSkinClassic(void);
NWIDGET_DRAW_ITEM_FUNC * FRAMEWIN_SetDefaultSkin(WIDGET_DRAW_ITEM_FUNC * pfDrawSkin);
N
N#define FRAMEWIN_SKIN_FLEX    FRAMEWIN_DrawSkinFlex
N
N/*********************************************************************
N*
N*       Member functions: Get Properties
N*
N**********************************************************************
N*/
Nconst GUI_FONT * FRAMEWIN_GetFont(FRAMEWIN_Handle hObj);
N
Nint       FRAMEWIN_GetActive      (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_GetTitleHeight (FRAMEWIN_Handle hObj);
NGUI_COLOR FRAMEWIN_GetBarColor    (FRAMEWIN_Handle hObj, unsigned Index);
Nint       FRAMEWIN_GetBorderSize  (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_GetBorderSizeEx(FRAMEWIN_Handle hObj, unsigned Edge);
Nvoid      FRAMEWIN_GetText        (FRAMEWIN_Handle hObj, char * pBuffer, int MaxLen);
Nint       FRAMEWIN_GetTextAlign   (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_GetUserData    (FRAMEWIN_Handle hObj, void * pDest, int NumBytes);
Nint       FRAMEWIN_IsMinimized    (FRAMEWIN_Handle hObj);
Nint       FRAMEWIN_IsMaximized    (FRAMEWIN_Handle hObj);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
NGUI_COLOR        FRAMEWIN_GetDefaultBarColor   (unsigned Index);
Nint              FRAMEWIN_GetDefaultBorderSize (void);
Nint              FRAMEWIN_GetDefaultTitleHeight(void);
NGUI_COLOR        FRAMEWIN_GetDefaultClientColor(void);
Nconst GUI_FONT * FRAMEWIN_GetDefaultFont       (void);
NGUI_COLOR        FRAMEWIN_GetDefaultTextColor  (unsigned Index);
Nint              FRAMEWIN_OwnerDraw            (const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
Nvoid             FRAMEWIN_SetDefaultBarColor   (unsigned Index, GUI_COLOR Color);
Nvoid             FRAMEWIN_SetDefaultBorderSize (int DefaultBorderSize);
Nvoid             FRAMEWIN_SetDefaultTitleHeight(int DefaultTitleHeight);
Nvoid             FRAMEWIN_SetDefaultClientColor(GUI_COLOR Color);
Nvoid             FRAMEWIN_SetDefaultFont       (const GUI_FONT * pFont);
Nint              FRAMEWIN_SetDefaultTextAlign  (int TextAlign);
Nvoid             FRAMEWIN_SetDefaultTextColor  (unsigned Index, GUI_COLOR Color);
N
N/*********************************************************************
N*
N*       Macros for compatibility
N*
N**********************************************************************
N*/
N#define         FRAMEWIN_SetDefaultCaptionSize(Height)       FRAMEWIN_SetDefaultTitleHeight(Height)
N#define         FRAMEWIN_GetDefaultCaptionSize()             FRAMEWIN_GetDefaultTitleHeight()
N#define         FRAMEWIN_CreateButton(hObj, Flags, Off, Id)  FRAMEWIN_AddButton(hObj, Flags, Off, Id) 
N#define         FRAMEWIN_CreateCloseButton(hObj, Flags, Off) FRAMEWIN_AddCloseButton(hObj, Flags, Off)
N#define         FRAMEWIN_CreateMaxButton(hObj, Flags, Off)   FRAMEWIN_AddMaxButton(hObj, Flags, Off)  
N#define         FRAMEWIN_CreateMinButton(hObj, Flags, Off)   FRAMEWIN_AddMinButton(hObj, Flags, Off)  
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // FRAMEWIN_H
N
N/*************************** End of file ****************************/
L 30 "..\main.c" 2
N#include "LCD_Protected.h"
N#include "LCDconf.h"
L 1 "..\..\..\ThirdParty\emWin\Config\LCDconf.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : LCDConf.h
NPurpose     : Display driver configuration file
N----------------------------------------------------------------------
N*/
N
N#ifndef LCDCONF_H
N#define LCDCONF_H
N
N#define XSIZE_PHYS 800
N#define YSIZE_PHYS 480
N
N#define LCD_XSIZE		XSIZE_PHYS
N#define LCD_YSIZE		YSIZE_PHYS
N
N#endif /* LCDCONF_H */
N
N/*************************** End of file ****************************/
L 32 "..\main.c" 2
N#if GUI_WINSUPPORT
X#if 1
N#include "wm.h"
N#include "text.h"
L 1 "..\..\..\ThirdParty\emWin\Include\text.h" 1
N/*********************************************************************
N*                 SEGGER Software GmbH                               *
N*        Solutions for real time microcontroller applications        *
N**********************************************************************
N*                                                                    *
N*        (c) 1996 - 2018  SEGGER Microcontroller GmbH                *
N*                                                                    *
N*        Internet: www.segger.com    Support:  support@segger.com    *
N*                                                                    *
N**********************************************************************
N
N** emWin V5.48 - Graphical user interface for embedded applications **
NAll  Intellectual Property rights in the Software belongs to  SEGGER.
NemWin is protected by  international copyright laws.  Knowledge of the
Nsource code may not be used to write a similar product. This file may
Nonly be used in accordance with the following terms:
N
NThe  software has  been licensed by SEGGER Software GmbH to Nuvoton Technology Corporationat the address: No. 4, Creation Rd. III, Hsinchu Science Park, Taiwan
Nfor the purposes  of  creating  libraries  for its 
NArm Cortex-M and  Arm9 32-bit microcontrollers, commercialized and distributed by Nuvoton Technology Corporation
Nunder  the terms and conditions  of  an  End  User  
NLicense  Agreement  supplied  with  the libraries.
NFull source code is available at: www.segger.com
N
NWe appreciate your understanding and fairness.
N----------------------------------------------------------------------
NLicensing information
NLicensor:                 SEGGER Software GmbH
NLicensed to:              Nuvoton Technology Corporation, No. 4, Creation Rd. III, Hsinchu Science Park, 30077 Hsinchu City, Taiwan
NLicensed SEGGER software: emWin
NLicense number:           GUI-00735
NLicense model:            emWin License Agreement, signed February 27, 2018
NLicensed platform:        Cortex-M and ARM9 32-bit series microcontroller designed and manufactured by or for Nuvoton Technology Corporation
N----------------------------------------------------------------------
NSupport and Update Agreement (SUA)
NSUA period:               2018-03-26 - 2019-03-27
NContact to extend SUA:    sales@segger.com
N----------------------------------------------------------------------
NFile        : TEXT.h
NPurpose     : TEXT include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef TEXT_H
N#define TEXT_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
N#include "GUI_Debug.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
S  extern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/************************************************************
N*
N*       #defines
N*
N*************************************************************
N*/
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define TEXT_CF_LEFT    GUI_TA_LEFT
N#define TEXT_CF_RIGHT   GUI_TA_RIGHT
N#define TEXT_CF_HCENTER GUI_TA_HCENTER
N
N#define TEXT_CF_VCENTER GUI_TA_VCENTER
N#define TEXT_CF_TOP     GUI_TA_TOP
N#define TEXT_CF_BOTTOM  GUI_TA_BOTTOM
N
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N
N*/
Ntypedef WM_HMEM TEXT_Handle;
Xtypedef signed long TEXT_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NTEXT_Handle TEXT_Create        (int x0, int y0, int xSize, int ySize, int Id, int Flags, const char * s, int Align);
NTEXT_Handle TEXT_CreateAsChild (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int Id, int Flags, const char * s, int Align);
XTEXT_Handle TEXT_CreateAsChild (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int Id, int Flags, const char * s, int Align);
NTEXT_Handle TEXT_CreateEx      (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText);
XTEXT_Handle TEXT_CreateEx      (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText);
NTEXT_Handle TEXT_CreateUser    (int x0, int y0, int xSize, int ySize, WM_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText, int NumExtraBytes);
XTEXT_Handle TEXT_CreateUser    (int x0, int y0, int xSize, int ySize, GUI_HWIN hParent, int WinFlags, int ExFlags, int Id, const char * pText, int NumExtraBytes);
NTEXT_Handle TEXT_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
XTEXT_Handle TEXT_CreateIndirect(const GUI_WIDGET_CREATE_INFO * pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK * cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid TEXT_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
N/* Methods changing properties */
N
NGUI_COLOR        TEXT_GetBkColor  (TEXT_Handle hObj); 
Nconst GUI_FONT * TEXT_GetFont     (TEXT_Handle hObj);
Nint              TEXT_GetNumLines (TEXT_Handle hObj);
Nint              TEXT_GetText     (TEXT_Handle hObj, char * pDest, U32 BufferSize);
Xint              TEXT_GetText     (TEXT_Handle hObj, char * pDest, unsigned long BufferSize);
Nint              TEXT_GetTextAlign(TEXT_Handle hObj);
NGUI_COLOR        TEXT_GetTextColor(TEXT_Handle hObj);
Nint              TEXT_GetUserData (TEXT_Handle hObj, void * pDest, int NumBytes);
NGUI_WRAPMODE     TEXT_GetWrapMode (TEXT_Handle hObj);
Nvoid             TEXT_SetBkColor  (TEXT_Handle hObj, GUI_COLOR Color);
Nvoid             TEXT_SetFont     (TEXT_Handle hObj, const GUI_FONT * pFont);
Nint              TEXT_SetDec      (TEXT_Handle hObj, I32 v, U8 Len, U8 Shift, U8 Signed, U8 Space);
Xint              TEXT_SetDec      (TEXT_Handle hObj, signed long v, unsigned char Len, unsigned char Shift, unsigned char Signed, unsigned char Space);
Nint              TEXT_SetText     (TEXT_Handle hObj, const char * s);
Nvoid             TEXT_SetTextAlign(TEXT_Handle hObj, int Align);
Nvoid             TEXT_SetTextColor(TEXT_Handle hObj, GUI_COLOR Color);
Nint              TEXT_SetUserData (TEXT_Handle hObj, const void * pSrc, int NumBytes);
Nvoid             TEXT_SetWrapMode (TEXT_Handle hObj, GUI_WRAPMODE WrapMode);
N
N/*********************************************************************
N*
N*       Managing default values
N*
N**********************************************************************
N*/
N
Nconst GUI_FONT * TEXT_GetDefaultFont     (void);
NGUI_COLOR        TEXT_GetDefaultTextColor(void);
NGUI_WRAPMODE     TEXT_GetDefaultWrapMode (void);
Nvoid             TEXT_SetDefaultFont     (const GUI_FONT * pFont);
Nvoid             TEXT_SetDefaultTextColor(GUI_COLOR Color);
NGUI_WRAPMODE     TEXT_SetDefaultWrapMode (GUI_WRAPMODE WrapMode);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif  // GUI_WINSUPPORT
N#endif  // TEXT_H
N
N/*************************** End of file ****************************/
L 35 "..\main.c" 2
N#endif
N
N#ifdef __USE_SD__
S#include "diskio.h"
S#include "ff.h"
N#endif
N
N
N/* Scheduler includes. */
N#include "FreeRTOS.h"
L 1 "..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include\FreeRTOS.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef INC_FREERTOS_H
N#define INC_FREERTOS_H
N
N/*
N * Include the generic headers required for the FreeRTOS port being used.
N */
N#include <stddef.h>
N
N/*
N * If stdint.h cannot be located then:
N *   + If using GCC ensure the -nostdint options is *not* being used.
N *   + Ensure the project's include path includes the directory in which your
N *     compiler stores stdint.h.
N *   + Set any compiler options necessary for it to support C99, as technically
N *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any
N *     other way).
N *   + The FreeRTOS download includes a simple stdint.h definition that can be
N *     used in cases where none is provided by the compiler.  The files only
N *     contains the typedefs required to build FreeRTOS.  Read the instructions
N *     in FreeRTOS/source/stdint.readme for more information.
N */
N#include <stdint.h> /* READ COMMENT ABOVE. */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Application specific configuration options. */
N#include "FreeRTOSConfig.h"
L 1 "..\..\FreeRTOS_with_emwin\FreeRTOSConfig.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef FREERTOS_CONFIG_H
N#define FREERTOS_CONFIG_H
N
N/*-----------------------------------------------------------
N * Application specific definitions.
N *
N * These definitions should be adjusted for your particular hardware and
N * application requirements.
N *
N * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
N * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE. 
N *
N * See http://www.freertos.org/a00110.html.
N *----------------------------------------------------------*/
N
N#define configUSE_PREEMPTION		1
N#define configUSE_IDLE_HOOK			0
N#define configUSE_TICK_HOOK			0
N#define configCPU_CLOCK_HZ			( ( unsigned long ) 60000000 )	/* =12.0MHz xtal multiplied by 5 using the PLL. */
N#define configTICK_RATE_HZ			( ( TickType_t ) 1000 )
N#define configMAX_PRIORITIES			( 4 )
N#define configMINIMAL_STACK_SIZE		( ( unsigned short ) (4 * 1024 / 4) )
N#define configTOTAL_HEAP_SIZE			( ( size_t ) 256 * 1024 )
N#define configMAX_TASK_NAME_LEN	( 16 )
N#define configUSE_TRACE_FACILITY		1
N#define configUSE_16_BIT_TICKS		0
N#define configIDLE_SHOULD_YIELD		1
N#define configUSE_MUTEXES               1
N#define configUSE_COUNTING_SEMAPHORES   1
N
N#define configQUEUE_REGISTRY_SIZE 	0
N
N#define configGENERATE_RUN_TIME_STATS	0
N
N
N/* Co-routine definitions. */
N#define configUSE_CO_ROUTINES 		0
N#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )
N
N#define configUSE_MUTEXES           1
N/* Set the following definitions to 1 to include the API function, or zero
Nto exclude the API function. */
N
N#define INCLUDE_vTaskPrioritySet				1
N#define INCLUDE_uxTaskPriorityGet				1
N#define INCLUDE_vTaskDelete					1
N#define INCLUDE_vTaskCleanUpResources			0
N#define INCLUDE_vTaskSuspend					1
N#define INCLUDE_vTaskDelayUntil				1
N#define INCLUDE_vTaskDelay					1
N#define INCLUDE_xTaskGetCurrentTaskHandle 	1
N#define INCLUDE_pcTaskGetTaskName			1
N#define INCLUDE_xTaskGetSchedulerState			1
N
N#endif /* FREERTOS_CONFIG_H */
L 99 "..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/* Basic FreeRTOS definitions. */
N#include "projdefs.h"
L 1 "..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include\projdefs.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef PROJDEFS_H
N#define PROJDEFS_H
N
N/*
N * Defines the prototype to which task functions must conform.  Defined in this
N * file to ensure the type is known before portable.h is included.
N */
Ntypedef void (*TaskFunction_t)( void * );
N
N/* Converts a time in milliseconds to a time in ticks.  This macro can be
Noverridden by a macro of the same name defined in FreeRTOSConfig.h in case the
Ndefinition here is not suitable for your application. */
N#ifndef pdMS_TO_TICKS
N	#define pdMS_TO_TICKS( xTimeInMs ) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )
N#endif
N
N#define pdFALSE			( ( BaseType_t ) 0 )
N#define pdTRUE			( ( BaseType_t ) 1 )
N
N#define pdPASS			( pdTRUE )
N#define pdFAIL			( pdFALSE )
N#define errQUEUE_EMPTY	( ( BaseType_t ) 0 )
N#define errQUEUE_FULL	( ( BaseType_t ) 0 )
N
N/* FreeRTOS error definitions. */
N#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
N#define errQUEUE_BLOCKED						( -4 )
N#define errQUEUE_YIELD							( -5 )
N
N/* Macros used for basic data corruption checks. */
N#ifndef configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES
N	#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0
N#endif
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	#define pdINTEGRITY_CHECK_VALUE 0x5a5a
N#else
N	#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL
N#endif
N
N/* The following errno values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_ERRNO_NONE			0	/* No errors */
N#define	pdFREERTOS_ERRNO_ENOENT			2	/* No such file or directory */
N#define	pdFREERTOS_ERRNO_EINTR			4	/* Interrupted system call */
N#define	pdFREERTOS_ERRNO_EIO			5	/* I/O error */
N#define	pdFREERTOS_ERRNO_ENXIO			6	/* No such device or address */
N#define	pdFREERTOS_ERRNO_EBADF			9	/* Bad file number */
N#define	pdFREERTOS_ERRNO_EAGAIN			11	/* No more processes */
N#define	pdFREERTOS_ERRNO_EWOULDBLOCK	11	/* Operation would block */
N#define	pdFREERTOS_ERRNO_ENOMEM			12	/* Not enough memory */
N#define	pdFREERTOS_ERRNO_EACCES			13	/* Permission denied */
N#define	pdFREERTOS_ERRNO_EFAULT			14	/* Bad address */
N#define	pdFREERTOS_ERRNO_EBUSY			16	/* Mount device busy */
N#define	pdFREERTOS_ERRNO_EEXIST			17	/* File exists */
N#define	pdFREERTOS_ERRNO_EXDEV			18	/* Cross-device link */
N#define	pdFREERTOS_ERRNO_ENODEV			19	/* No such device */
N#define	pdFREERTOS_ERRNO_ENOTDIR		20	/* Not a directory */
N#define	pdFREERTOS_ERRNO_EISDIR			21	/* Is a directory */
N#define	pdFREERTOS_ERRNO_EINVAL			22	/* Invalid argument */
N#define	pdFREERTOS_ERRNO_ENOSPC			28	/* No space left on device */
N#define	pdFREERTOS_ERRNO_ESPIPE			29	/* Illegal seek */
N#define	pdFREERTOS_ERRNO_EROFS			30	/* Read only file system */
N#define	pdFREERTOS_ERRNO_EUNATCH		42	/* Protocol driver not attached */
N#define	pdFREERTOS_ERRNO_EBADE			50	/* Invalid exchange */
N#define	pdFREERTOS_ERRNO_EFTYPE			79	/* Inappropriate file type or format */
N#define	pdFREERTOS_ERRNO_ENMFILE		89	/* No more files */
N#define	pdFREERTOS_ERRNO_ENOTEMPTY		90	/* Directory not empty */
N#define	pdFREERTOS_ERRNO_ENAMETOOLONG 	91	/* File or path name too long */
N#define	pdFREERTOS_ERRNO_EOPNOTSUPP		95	/* Operation not supported on transport endpoint */
N#define	pdFREERTOS_ERRNO_ENOBUFS		105	/* No buffer space available */
N#define	pdFREERTOS_ERRNO_ENOPROTOOPT	109	/* Protocol not available */
N#define	pdFREERTOS_ERRNO_EADDRINUSE		112	/* Address already in use */
N#define	pdFREERTOS_ERRNO_ETIMEDOUT		116	/* Connection timed out */
N#define	pdFREERTOS_ERRNO_EINPROGRESS	119	/* Connection already in progress */
N#define	pdFREERTOS_ERRNO_EALREADY		120	/* Socket already connected */
N#define	pdFREERTOS_ERRNO_EADDRNOTAVAIL 	125	/* Address not available */
N#define	pdFREERTOS_ERRNO_EISCONN		127	/* Socket is already connected */
N#define	pdFREERTOS_ERRNO_ENOTCONN		128	/* Socket is not connected */
N#define	pdFREERTOS_ERRNO_ENOMEDIUM		135	/* No medium inserted */
N#define	pdFREERTOS_ERRNO_EILSEQ			138	/* An invalid UTF-16 sequence was encountered. */
N#define	pdFREERTOS_ERRNO_ECANCELED		140	/* Operation canceled. */
N
N/* The following endian values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_LITTLE_ENDIAN	0
N#define pdFREERTOS_BIG_ENDIAN		1
N
N#endif /* PROJDEFS_H */
N
N
N
L 102 "..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/* Definitions specific to the port being used. */
N#include "portable.h"
L 1 "..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include\portable.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*-----------------------------------------------------------
N * Portable layer API.  Each function must be defined for each port.
N *----------------------------------------------------------*/
N
N#ifndef PORTABLE_H
N#define PORTABLE_H
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.
NPurely for reasons of backward compatibility the old method is still valid, but
Nto make it clear that new projects should not use it, support for the port
Nspecific constants has been moved into the deprecated_definitions.h header
Nfile. */
N#include "deprecated_definitions.h"
L 1 "..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include\deprecated_definitions.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef DEPRECATED_DEFINITIONS_H
N#define DEPRECATED_DEFINITIONS_H
N
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.  The
Ndefinitions below remain in the code for backward compatibility only.  New
Nprojects should not use them. */
N
N#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef GCC_MEGA_AVR
S	#include "../portable/GCC/ATMega323/portmacro.h"
N#endif
N
N#ifdef IAR_MEGA_AVR
S	#include "../portable/IAR/ATMega323/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC24_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_DSPIC_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC18F_PORT
S	#include "../../Source/portable/MPLAB/PIC18F/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC32MX_PORT
S	#include "../../Source/portable/MPLAB/PIC32MX/portmacro.h"
N#endif
N
N#ifdef _FEDPICC
S	#include "libFreeRTOS/Include/portmacro.h"
N#endif
N
N#ifdef SDCC_CYGNAL
S	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7
S	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7_ECLIPSE
S	#include "portmacro.h"
N#endif
N
N#ifdef ROWLEY_LPC23xx
S	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
N#endif
N
N#ifdef IAR_MSP430
S	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"
N#endif
N
N#ifdef GCC_MSP430
S	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ROWLEY_MSP430
S	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ARM7_LPC21xx_KEIL_RVDS
S	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
N#endif
N
N#ifdef SAM7_GCC
S	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
N#endif
N
N#ifdef SAM7_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
N#endif
N
N#ifdef SAM9XE_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
N#endif
N
N#ifdef LPC2000_IAR
S	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
N#endif
N
N#ifdef STR71X_IAR
S	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
N#endif
N
N#ifdef STR75X_IAR
S	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
N#endif
N
N#ifdef STR75X_GCC
S	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
N#endif
N
N#ifdef STR91X_IAR
S	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
N#endif
N
N#ifdef GCC_H8S
S	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
N#endif
N
N#ifdef GCC_AT91FR40008
S	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
N#endif
N
N#ifdef RVDS_ARMCM3_LM3S102
S	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3_LM3S102
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARM_CM3
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARMCM3_LM
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef HCS12_CODE_WARRIOR
S	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
N#endif
N
N#ifdef MICROBLAZE_GCC
S	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
N#endif
N
N#ifdef TERN_EE
S	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
N#endif
N
N#ifdef GCC_HCS12
S	#include "../../Source/portable/GCC/HCS12/portmacro.h"
N#endif
N
N#ifdef GCC_MCF5235
S    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_GCC
S	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_CODEWARRIOR
S	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef GCC_PPC405
S	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
N#endif
N
N#ifdef GCC_PPC440
S	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
N#endif
N
N#ifdef _16FX_SOFTUNE
S	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
N#endif
N
N#ifdef BCC_INDUSTRIAL_PC_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef BCC_FLASH_LITE_186_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef __GNUC__
S   #ifdef __AVR32_AVR32A__
S	   #include "portmacro.h"
S   #endif
N#endif
N
N#ifdef __ICCAVR32__
S   #ifdef __CORE__
S      #if __CORE__ == __AVR32A__
S	      #include "portmacro.h"
S      #endif
S   #endif
N#endif
N
N#ifdef __91467D
S	#include "portmacro.h"
N#endif
N
N#ifdef __96340
S	#include "portmacro.h"
N#endif
N
N
N#ifdef __IAR_V850ES_Fx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3_L__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Hx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3L__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#endif /* DEPRECATED_DEFINITIONS_H */
N
L 88 "..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include\portable.h" 2
N
N/* If portENTER_CRITICAL is not defined then including deprecated_definitions.h
Ndid not result in a portmacro.h header file being included - and it should be
Nincluded here.  In this case the path to the correct portmacro.h header file
Nmust be set in the compiler's include path. */
N#ifndef portENTER_CRITICAL
N	#include "portmacro.h"
L 1 "..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\portable\RVDS\ARM9_N9H30\portmacro.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef PORTMACRO_H
N#define PORTMACRO_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * Port specific definitions.
N *
N * The settings in this file configure FreeRTOS correctly for the
N * given hardware and compiler.
N *
N * These settings should not be altered.
N *-----------------------------------------------------------
N */
N
N/* Type definitions. */
N#define portCHAR		char
N#define portFLOAT		float
N#define portDOUBLE		double
N#define portLONG		long
N#define portSHORT		short
N#define portSTACK_TYPE	uint32_t
N#define portBASE_TYPE	long
N
Ntypedef portSTACK_TYPE StackType_t;
Xtypedef uint32_t StackType_t;
Ntypedef long BaseType_t;
Ntypedef unsigned long UBaseType_t;
N
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	typedef uint16_t TickType_t;
S	#define portMAX_DELAY ( TickType_t ) 0xffff
N#else
N	typedef uint32_t TickType_t;
N	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
N#endif
N/*-----------------------------------------------------------*/
N
N/* Hardware specifics. */
N#define portSTACK_GROWTH			( -1 )
N#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
N#define portBYTE_ALIGNMENT			8
N/*-----------------------------------------------------------*/
N
N/* Task utilities. */
N
N/*-----------------------------------------------------------
N * ISR entry and exit macros.  These are only required if a task switch
N * is required from an ISR.
N *----------------------------------------------------------*/
N
N/* If a switch is required then we just need to call */
N/* vTaskSwitchContext() as the context has already been */
N/* saved. */
N
N#define portEXIT_SWITCHING_ISR(SwitchRequired)				 \
N{															 \
Nextern void vTaskSwitchContext(void);						 \
N															 \
N		if(SwitchRequired)									 \
N		{													 \
N			vTaskSwitchContext();							 \
N		}													 \
N}															 \
N
X#define portEXIT_SWITCHING_ISR(SwitchRequired)				 {															 extern void vTaskSwitchContext(void);						 															 		if(SwitchRequired)									 		{													 			vTaskSwitchContext();							 		}													 }															 
Nextern void vPortYield( void );
N#define portYIELD() vPortYield()
N
N
N/* Critical section management. */
N
N/*
N ******************************************************************
N * We don't need to worry about whether we're in ARM or
N * THUMB mode with the Keil Real View compiler when enabling
N * or disabling interrupts as the compiler's intrinsic functions
N * take care of that for us.
N *******************************************************************
N */
N#define portDISABLE_INTERRUPTS()	__disable_irq()
N#define portENABLE_INTERRUPTS()		__enable_irq()
N
N
N/*-----------------------------------------------------------
N * Critical section control
N *
N * The code generated by the Keil compiler does not maintain separate
N * stack and frame pointers. The portENTER_CRITICAL macro cannot therefore
N * use the stack as per other ports.  Instead a variable is used to keep
N * track of the critical section nesting.  This necessitates the use of a
N * function in place of the macro.
N *----------------------------------------------------------*/
N
Nextern void vPortEnterCritical( void );
Nextern void vPortExitCritical( void );
N
N#define portENTER_CRITICAL()		vPortEnterCritical();
N#define portEXIT_CRITICAL()			vPortExitCritical();
N/*-----------------------------------------------------------*/
N
N/* Compiler specifics. */
N#define inline
N#define register
N#define portNOP()	__asm{ NOP }
N/*-----------------------------------------------------------*/
N
N/* Task function macros as described on the FreeRTOS.org WEB site. */
N#define portTASK_FUNCTION_PROTO( vFunction, pvParameters )	void vFunction( void *pvParameters )
N#define portTASK_FUNCTION( vFunction, pvParameters )	void vFunction( void *pvParameters )
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTMACRO_H */
N
L 95 "..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include\portable.h" 2
N#endif
N
N#if portBYTE_ALIGNMENT == 32
X#if 8 == 32
S	#define portBYTE_ALIGNMENT_MASK ( 0x001f )
N#endif
N
N#if portBYTE_ALIGNMENT == 16
X#if 8 == 16
S	#define portBYTE_ALIGNMENT_MASK ( 0x000f )
N#endif
N
N#if portBYTE_ALIGNMENT == 8
X#if 8 == 8
N	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
N#endif
N
N#if portBYTE_ALIGNMENT == 4
X#if 8 == 4
S	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
N#endif
N
N#if portBYTE_ALIGNMENT == 2
X#if 8 == 2
S	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
N#endif
N
N#if portBYTE_ALIGNMENT == 1
X#if 8 == 1
S	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
N#endif
N
N#ifndef portBYTE_ALIGNMENT_MASK
S	#error "Invalid portBYTE_ALIGNMENT definition"
N#endif
N
N#ifndef portNUM_CONFIGURABLE_REGIONS
N	#define portNUM_CONFIGURABLE_REGIONS 1
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "mpu_wrappers.h"
L 1 "..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include\mpu_wrappers.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef MPU_WRAPPERS_H
N#define MPU_WRAPPERS_H
N
N/* This file redefines API functions to be called through a wrapper macro, but
Nonly for ports that are using the MPU. */
N#ifdef portUSING_MPU_WRAPPERS
S
S	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
S	included from queue.c or task.c to prevent it from having an effect within
S	those files. */
S	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
S
S		/*
S		 * Map standard (non MPU) API functions to equivalents that start
S		 * "MPU_".  This will cause the application code to call the MPU_
S		 * version, which wraps the non-MPU version with privilege promoting
S		 * then demoting code, so the kernel code always runs will full
S		 * privileges.
S		 */
S
S		/* Map standard tasks.h API functions to the MPU equivalents. */
S		#define xTaskCreate								MPU_xTaskCreate
S		#define xTaskCreateStatic						MPU_xTaskCreateStatic
S		#define xTaskCreateRestricted					MPU_xTaskCreateRestricted
S		#define vTaskAllocateMPURegions					MPU_vTaskAllocateMPURegions
S		#define vTaskDelete								MPU_vTaskDelete
S		#define vTaskDelay								MPU_vTaskDelay
S		#define vTaskDelayUntil							MPU_vTaskDelayUntil
S		#define xTaskAbortDelay							MPU_xTaskAbortDelay
S		#define uxTaskPriorityGet						MPU_uxTaskPriorityGet
S		#define eTaskGetState							MPU_eTaskGetState
S		#define vTaskGetInfo							MPU_vTaskGetInfo
S		#define vTaskPrioritySet						MPU_vTaskPrioritySet
S		#define vTaskSuspend							MPU_vTaskSuspend
S		#define vTaskResume								MPU_vTaskResume
S		#define vTaskSuspendAll							MPU_vTaskSuspendAll
S		#define xTaskResumeAll							MPU_xTaskResumeAll
S		#define xTaskGetTickCount						MPU_xTaskGetTickCount
S		#define uxTaskGetNumberOfTasks					MPU_uxTaskGetNumberOfTasks
S		#define pcTaskGetName							MPU_pcTaskGetName
S		#define xTaskGetHandle							MPU_xTaskGetHandle
S		#define uxTaskGetStackHighWaterMark				MPU_uxTaskGetStackHighWaterMark
S		#define vTaskSetApplicationTaskTag				MPU_vTaskSetApplicationTaskTag
S		#define xTaskGetApplicationTaskTag				MPU_xTaskGetApplicationTaskTag
S		#define vTaskSetThreadLocalStoragePointer		MPU_vTaskSetThreadLocalStoragePointer
S		#define pvTaskGetThreadLocalStoragePointer		MPU_pvTaskGetThreadLocalStoragePointer
S		#define xTaskCallApplicationTaskHook			MPU_xTaskCallApplicationTaskHook
S		#define xTaskGetIdleTaskHandle					MPU_xTaskGetIdleTaskHandle
S		#define uxTaskGetSystemState					MPU_uxTaskGetSystemState
S		#define vTaskList								MPU_vTaskList
S		#define vTaskGetRunTimeStats					MPU_vTaskGetRunTimeStats
S		#define xTaskGenericNotify						MPU_xTaskGenericNotify
S		#define xTaskNotifyWait							MPU_xTaskNotifyWait
S		#define ulTaskNotifyTake						MPU_ulTaskNotifyTake
S		#define xTaskNotifyStateClear					MPU_xTaskNotifyStateClear
S
S		#define xTaskGetCurrentTaskHandle				MPU_xTaskGetCurrentTaskHandle
S		#define vTaskSetTimeOutState					MPU_vTaskSetTimeOutState
S		#define xTaskCheckForTimeOut					MPU_xTaskCheckForTimeOut
S		#define xTaskGetSchedulerState					MPU_xTaskGetSchedulerState
S
S		/* Map standard queue.h API functions to the MPU equivalents. */
S		#define xQueueGenericSend						MPU_xQueueGenericSend
S		#define xQueueGenericReceive					MPU_xQueueGenericReceive
S		#define uxQueueMessagesWaiting					MPU_uxQueueMessagesWaiting
S		#define uxQueueSpacesAvailable					MPU_uxQueueSpacesAvailable
S		#define vQueueDelete							MPU_vQueueDelete
S		#define xQueueCreateMutex						MPU_xQueueCreateMutex
S		#define xQueueCreateMutexStatic					MPU_xQueueCreateMutexStatic
S		#define xQueueCreateCountingSemaphore			MPU_xQueueCreateCountingSemaphore
S		#define xQueueCreateCountingSemaphoreStatic		MPU_xQueueCreateCountingSemaphoreStatic
S		#define xQueueGetMutexHolder					MPU_xQueueGetMutexHolder
S		#define xQueueTakeMutexRecursive				MPU_xQueueTakeMutexRecursive
S		#define xQueueGiveMutexRecursive				MPU_xQueueGiveMutexRecursive
S		#define xQueueGenericCreate						MPU_xQueueGenericCreate
S		#define xQueueGenericCreateStatic				MPU_xQueueGenericCreateStatic
S		#define xQueueCreateSet							MPU_xQueueCreateSet
S		#define xQueueAddToSet							MPU_xQueueAddToSet
S		#define xQueueRemoveFromSet						MPU_xQueueRemoveFromSet
S		#define xQueueSelectFromSet						MPU_xQueueSelectFromSet
S		#define xQueueGenericReset						MPU_xQueueGenericReset
S
S		#if( configQUEUE_REGISTRY_SIZE > 0 )
S			#define vQueueAddToRegistry						MPU_vQueueAddToRegistry
S			#define vQueueUnregisterQueue					MPU_vQueueUnregisterQueue
S			#define pcQueueGetName							MPU_pcQueueGetName
S		#endif
S
S		/* Map standard timer.h API functions to the MPU equivalents. */
S		#define xTimerCreate							MPU_xTimerCreate
S		#define xTimerCreateStatic						MPU_xTimerCreateStatic
S		#define pvTimerGetTimerID						MPU_pvTimerGetTimerID
S		#define vTimerSetTimerID						MPU_vTimerSetTimerID
S		#define xTimerIsTimerActive						MPU_xTimerIsTimerActive
S		#define xTimerGetTimerDaemonTaskHandle			MPU_xTimerGetTimerDaemonTaskHandle
S		#define xTimerPendFunctionCall					MPU_xTimerPendFunctionCall
S		#define pcTimerGetName							MPU_pcTimerGetName
S		#define xTimerGetPeriod							MPU_xTimerGetPeriod
S		#define xTimerGetExpiryTime						MPU_xTimerGetExpiryTime
S		#define xTimerGenericCommand					MPU_xTimerGenericCommand
S
S		/* Map standard event_group.h API functions to the MPU equivalents. */
S		#define xEventGroupCreate						MPU_xEventGroupCreate
S		#define xEventGroupCreateStatic					MPU_xEventGroupCreateStatic
S		#define xEventGroupWaitBits						MPU_xEventGroupWaitBits
S		#define xEventGroupClearBits					MPU_xEventGroupClearBits
S		#define xEventGroupSetBits						MPU_xEventGroupSetBits
S		#define xEventGroupSync							MPU_xEventGroupSync
S		#define vEventGroupDelete						MPU_vEventGroupDelete
S
S		/* Remove the privileged function macro. */
S		#define PRIVILEGED_FUNCTION
S
S	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
S		/* Ensure API functions go in the privileged execution section. */
S		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
S		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
S
S	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
N#else /* portUSING_MPU_WRAPPERS */
N
N	#define PRIVILEGED_FUNCTION
N	#define PRIVILEGED_DATA
N	#define portUSING_MPU_WRAPPERS 0
N
N#endif /* portUSING_MPU_WRAPPERS */
N
N
N#endif /* MPU_WRAPPERS_H */
N
L 134 "..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include\portable.h" 2
N
N/*
N * Setup the stack of a new task so it is ready to be placed under the
N * scheduler control.  The registers have to be placed on the stack in
N * the order that the port expects to find them.
N *
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;
N#else
N	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
X	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;
N#endif
N
N/* Used by heap_5.c. */
Ntypedef struct HeapRegion
N{
N	uint8_t *pucStartAddress;
N	size_t xSizeInBytes;
N} HeapRegion_t;
N
N/*
N * Used to define multiple heap regions for use by heap_5.c.  This function
N * must be called before any calls to pvPortMalloc() - not creating a task,
N * queue, semaphore, mutex, software timer, event group, etc. will result in
N * pvPortMalloc being called.
N *
N * pxHeapRegions passes in an array of HeapRegion_t structures - each of which
N * defines a region of memory that can be used as the heap.  The array is
N * terminated by a HeapRegions_t structure that has a size of 0.  The region
N * with the lowest start address must appear first in the array.
N */
Nvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) PRIVILEGED_FUNCTION;
Xvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) ;
N
N
N/*
N * Map to the memory management routines required for the port.
N */
Nvoid *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
Xvoid *pvPortMalloc( size_t xSize ) ;
Nvoid vPortFree( void *pv ) PRIVILEGED_FUNCTION;
Xvoid vPortFree( void *pv ) ;
Nvoid vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
Xvoid vPortInitialiseBlocks( void ) ;
Nsize_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetFreeHeapSize( void ) ;
Nsize_t xPortGetMinimumEverFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetMinimumEverFreeHeapSize( void ) ;
N
N/*
N * Setup the hardware ready for the scheduler to take control.  This generally
N * sets up a tick interrupt and sets timers for the correct tick frequency.
N */
NBaseType_t xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
XBaseType_t xPortStartScheduler( void ) ;
N
N/*
N * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
N * the hardware is left in its original condition after the scheduler stops
N * executing.
N */
Nvoid vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vPortEndScheduler( void ) ;
N
N/*
N * The structures and methods of manipulating the MPU are contained within the
N * port layer.
N *
N * Fills the xMPUSettings structure with the memory region information
N * contained in xRegions.
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	struct xMEMORY_REGION;
S	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth ) PRIVILEGED_FUNCTION;
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTABLE_H */
N
L 105 "..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/* Must be defaulted before configUSE_NEWLIB_REENTRANT is used below. */
N#ifndef configUSE_NEWLIB_REENTRANT
N	#define configUSE_NEWLIB_REENTRANT 0
N#endif
N
N/* Required if struct _reent is used. */
N#if ( configUSE_NEWLIB_REENTRANT == 1 )
X#if ( 0 == 1 )
S	#include <reent.h>
N#endif
N/*
N * Check all the required application specific macros have been defined.
N * These macros are application specific and (as downloaded) are defined
N * within FreeRTOSConfig.h.
N */
N
N#ifndef configMINIMAL_STACK_SIZE
S	#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_PREEMPTION
S	#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_IDLE_HOOK
S	#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_TICK_HOOK
S	#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_16_BIT_TICKS
S	#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.
N#endif
N
N#ifndef configUSE_CO_ROUTINES
S	#define configUSE_CO_ROUTINES 0
N#endif
N
N#ifndef INCLUDE_vTaskPrioritySet
S	#define INCLUDE_vTaskPrioritySet 0
N#endif
N
N#ifndef INCLUDE_uxTaskPriorityGet
S	#define INCLUDE_uxTaskPriorityGet 0
N#endif
N
N#ifndef INCLUDE_vTaskDelete
S	#define INCLUDE_vTaskDelete 0
N#endif
N
N#ifndef INCLUDE_vTaskSuspend
S	#define INCLUDE_vTaskSuspend 0
N#endif
N
N#ifndef INCLUDE_vTaskDelayUntil
S	#define INCLUDE_vTaskDelayUntil 0
N#endif
N
N#ifndef INCLUDE_vTaskDelay
S	#define INCLUDE_vTaskDelay 0
N#endif
N
N#ifndef INCLUDE_xTaskGetIdleTaskHandle
N	#define INCLUDE_xTaskGetIdleTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xTaskAbortDelay
N	#define INCLUDE_xTaskAbortDelay 0
N#endif
N
N#ifndef INCLUDE_xQueueGetMutexHolder
N	#define INCLUDE_xQueueGetMutexHolder 0
N#endif
N
N#ifndef INCLUDE_xSemaphoreGetMutexHolder
N	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
N#endif
N
N#ifndef INCLUDE_xTaskGetHandle
N	#define INCLUDE_xTaskGetHandle 0
N#endif
N
N#ifndef INCLUDE_uxTaskGetStackHighWaterMark
N	#define INCLUDE_uxTaskGetStackHighWaterMark 0
N#endif
N
N#ifndef INCLUDE_eTaskGetState
N	#define INCLUDE_eTaskGetState 0
N#endif
N
N#ifndef INCLUDE_xTaskResumeFromISR
N	#define INCLUDE_xTaskResumeFromISR 1
N#endif
N
N#ifndef INCLUDE_xTimerPendFunctionCall
N	#define INCLUDE_xTimerPendFunctionCall 0
N#endif
N
N#ifndef INCLUDE_xTaskGetSchedulerState
S	#define INCLUDE_xTaskGetSchedulerState 0
N#endif
N
N#ifndef INCLUDE_xTaskGetCurrentTaskHandle
S	#define INCLUDE_xTaskGetCurrentTaskHandle 0
N#endif
N
N#if configUSE_CO_ROUTINES != 0
X#if 0 != 0
S	#ifndef configMAX_CO_ROUTINE_PRIORITIES
S		#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.
S	#endif
N#endif
N
N#ifndef configUSE_DAEMON_TASK_STARTUP_HOOK
N	#define configUSE_DAEMON_TASK_STARTUP_HOOK 0
N#endif
N
N#ifndef configUSE_APPLICATION_TASK_TAG
N	#define configUSE_APPLICATION_TASK_TAG 0
N#endif
N
N#ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS
N	#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0
N#endif
N
N#ifndef configUSE_RECURSIVE_MUTEXES
N	#define configUSE_RECURSIVE_MUTEXES 0
N#endif
N
N#ifndef configUSE_MUTEXES
S	#define configUSE_MUTEXES 0
N#endif
N
N#ifndef configUSE_TIMERS
N	#define configUSE_TIMERS 0
N#endif
N
N#ifndef configUSE_COUNTING_SEMAPHORES
S	#define configUSE_COUNTING_SEMAPHORES 0
N#endif
N
N#ifndef configUSE_ALTERNATIVE_API
N	#define configUSE_ALTERNATIVE_API 0
N#endif
N
N#ifndef portCRITICAL_NESTING_IN_TCB
N	#define portCRITICAL_NESTING_IN_TCB 0
N#endif
N
N#ifndef configMAX_TASK_NAME_LEN
S	#define configMAX_TASK_NAME_LEN 16
N#endif
N
N#ifndef configIDLE_SHOULD_YIELD
S	#define configIDLE_SHOULD_YIELD		1
N#endif
N
N#if configMAX_TASK_NAME_LEN < 1
X#if ( 16 ) < 1
S	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
N#endif
N
N#ifndef configASSERT
N	#define configASSERT( x )
N	#define configASSERT_DEFINED 0
N#else
S	#define configASSERT_DEFINED 1
N#endif
N
N/* The timers module relies on xTaskGetSchedulerState(). */
N#if configUSE_TIMERS == 1
X#if 0 == 1
S
S	#ifndef configTIMER_TASK_PRIORITY
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
S	#endif /* configTIMER_TASK_PRIORITY */
S
S	#ifndef configTIMER_QUEUE_LENGTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
S	#endif /* configTIMER_QUEUE_LENGTH */
S
S	#ifndef configTIMER_TASK_STACK_DEPTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
S	#endif /* configTIMER_TASK_STACK_DEPTH */
S
N#endif /* configUSE_TIMERS */
N
N#ifndef portSET_INTERRUPT_MASK_FROM_ISR
N	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
N#endif
N
N#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
N	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
N#endif
N
N#ifndef portCLEAN_UP_TCB
N	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef portPRE_TASK_DELETE_HOOK
N	#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )
N#endif
N
N#ifndef portSETUP_TCB
N	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef configQUEUE_REGISTRY_SIZE
S	#define configQUEUE_REGISTRY_SIZE 0U
N#endif
N
N#if ( configQUEUE_REGISTRY_SIZE < 1 )
X#if ( 0 < 1 )
N	#define vQueueAddToRegistry( xQueue, pcName )
N	#define vQueueUnregisterQueue( xQueue )
N	#define pcQueueGetName( xQueue )
N#endif
N
N#ifndef portPOINTER_SIZE_TYPE
N	#define portPOINTER_SIZE_TYPE uint32_t
N#endif
N
N/* Remove any unused trace macros. */
N#ifndef traceSTART
N	/* Used to perform any necessary initialisation - for example, open a file
N	into which trace is to be written. */
N	#define traceSTART()
N#endif
N
N#ifndef traceEND
N	/* Use to close a trace, for example close a file into which trace has been
N	written. */
N	#define traceEND()
N#endif
N
N#ifndef traceTASK_SWITCHED_IN
N	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the selected task. */
N	#define traceTASK_SWITCHED_IN()
N#endif
N
N#ifndef traceINCREASE_TICK_COUNT
N	/* Called before stepping the tick count after waking from tickless idle
N	sleep. */
N	#define traceINCREASE_TICK_COUNT( x )
N#endif
N
N#ifndef traceLOW_POWER_IDLE_BEGIN
N	/* Called immediately before entering tickless idle. */
N	#define traceLOW_POWER_IDLE_BEGIN()
N#endif
N
N#ifndef	traceLOW_POWER_IDLE_END
N	/* Called when returning to the Idle task after a tickless idle. */
N	#define traceLOW_POWER_IDLE_END()
N#endif
N
N#ifndef traceTASK_SWITCHED_OUT
N	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the task being switched out. */
N	#define traceTASK_SWITCHED_OUT()
N#endif
N
N#ifndef traceTASK_PRIORITY_INHERIT
N	/* Called when a task attempts to take a mutex that is already held by a
N	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
N	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
N	will inherit (the priority of the task that is attempting to obtain the
N	muted. */
N	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
N#endif
N
N#ifndef traceTASK_PRIORITY_DISINHERIT
N	/* Called when a task releases a mutex, the holding of which had resulted in
N	the task inheriting the priority of a higher priority task.
N	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
N	mutex.  uxOriginalPriority is the task's configured (base) priority. */
N	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
N	/* Task is about to block because it cannot read from a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the read. */
N	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_SEND
N	/* Task is about to block because it cannot write to a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the write. */
N	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
N#endif
N
N#ifndef configCHECK_FOR_STACK_OVERFLOW
N	#define configCHECK_FOR_STACK_OVERFLOW 0
N#endif
N
N/* The following event macros are embedded in the kernel API calls. */
N
N#ifndef traceMOVED_TASK_TO_READY_STATE
N	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef tracePOST_MOVED_TASK_TO_READY_STATE
N	#define tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef traceQUEUE_CREATE
N	#define traceQUEUE_CREATE( pxNewQueue )
N#endif
N
N#ifndef traceQUEUE_CREATE_FAILED
N	#define traceQUEUE_CREATE_FAILED( ucQueueType )
N#endif
N
N#ifndef traceCREATE_MUTEX
N	#define traceCREATE_MUTEX( pxNewQueue )
N#endif
N
N#ifndef traceCREATE_MUTEX_FAILED
N	#define traceCREATE_MUTEX_FAILED()
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE
N	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
N	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE
N	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
N	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE
N	#define traceCREATE_COUNTING_SEMAPHORE()
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
N	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
N#endif
N
N#ifndef traceQUEUE_SEND
N	#define traceQUEUE_SEND( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FAILED
N	#define traceQUEUE_SEND_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE
N	#define traceQUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK
N	#define traceQUEUE_PEEK( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR
N	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FAILED
N	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR
N	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
N	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR
N	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
N	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
N	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_DELETE
N	#define traceQUEUE_DELETE( pxQueue )
N#endif
N
N#ifndef traceTASK_CREATE
N	#define traceTASK_CREATE( pxNewTCB )
N#endif
N
N#ifndef traceTASK_CREATE_FAILED
N	#define traceTASK_CREATE_FAILED()
N#endif
N
N#ifndef traceTASK_DELETE
N	#define traceTASK_DELETE( pxTaskToDelete )
N#endif
N
N#ifndef traceTASK_DELAY_UNTIL
N	#define traceTASK_DELAY_UNTIL( x )
N#endif
N
N#ifndef traceTASK_DELAY
N	#define traceTASK_DELAY()
N#endif
N
N#ifndef traceTASK_PRIORITY_SET
N	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
N#endif
N
N#ifndef traceTASK_SUSPEND
N	#define traceTASK_SUSPEND( pxTaskToSuspend )
N#endif
N
N#ifndef traceTASK_RESUME
N	#define traceTASK_RESUME( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_RESUME_FROM_ISR
N	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_INCREMENT_TICK
N	#define traceTASK_INCREMENT_TICK( xTickCount )
N#endif
N
N#ifndef traceTIMER_CREATE
N	#define traceTIMER_CREATE( pxNewTimer )
N#endif
N
N#ifndef traceTIMER_CREATE_FAILED
N	#define traceTIMER_CREATE_FAILED()
N#endif
N
N#ifndef traceTIMER_COMMAND_SEND
N	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
N#endif
N
N#ifndef traceTIMER_EXPIRED
N	#define traceTIMER_EXPIRED( pxTimer )
N#endif
N
N#ifndef traceTIMER_COMMAND_RECEIVED
N	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
N#endif
N
N#ifndef traceMALLOC
N    #define traceMALLOC( pvAddress, uiSize )
N#endif
N
N#ifndef traceFREE
N    #define traceFREE( pvAddress, uiSize )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE
N	#define traceEVENT_GROUP_CREATE( xEventGroup )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE_FAILED
N	#define traceEVENT_GROUP_CREATE_FAILED()
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_BLOCK
N	#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_END
N	#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK
N	#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_END
N	#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS
N	#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR
N	#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS
N	#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR
N	#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_DELETE
N	#define traceEVENT_GROUP_DELETE( xEventGroup )
N#endif
N
N#ifndef tracePEND_FUNC_CALL
N	#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef tracePEND_FUNC_CALL_FROM_ISR
N	#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef traceQUEUE_REGISTRY_ADD
N	#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE_BLOCK
N	#define traceTASK_NOTIFY_TAKE_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE
N	#define traceTASK_NOTIFY_TAKE()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT_BLOCK
N	#define traceTASK_NOTIFY_WAIT_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT
N	#define traceTASK_NOTIFY_WAIT()
N#endif
N
N#ifndef traceTASK_NOTIFY
N	#define traceTASK_NOTIFY()
N#endif
N
N#ifndef traceTASK_NOTIFY_FROM_ISR
N	#define traceTASK_NOTIFY_FROM_ISR()
N#endif
N
N#ifndef traceTASK_NOTIFY_GIVE_FROM_ISR
N	#define traceTASK_NOTIFY_GIVE_FROM_ISR()
N#endif
N
N#ifndef configGENERATE_RUN_TIME_STATS
S	#define configGENERATE_RUN_TIME_STATS 0
N#endif
N
N#if ( configGENERATE_RUN_TIME_STATS == 1 )
X#if ( 0 == 1 )
S
S	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
S		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
S	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
S
S	#ifndef portGET_RUN_TIME_COUNTER_VALUE
S		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
S			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
S		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
S	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
S
N#endif /* configGENERATE_RUN_TIME_STATS */
N
N#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
N	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
N#endif
N
N#ifndef configUSE_MALLOC_FAILED_HOOK
N	#define configUSE_MALLOC_FAILED_HOOK 0
N#endif
N
N#ifndef portPRIVILEGE_BIT
N	#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )
N#endif
N
N#ifndef portYIELD_WITHIN_API
N	#define portYIELD_WITHIN_API portYIELD
N#endif
N
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
N	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
N#endif
N
N#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
N	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
N#endif
N
N#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
X#if 2 < 2
S	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
N#endif
N
N#ifndef configUSE_TICKLESS_IDLE
N	#define configUSE_TICKLESS_IDLE 0
N#endif
N
N#ifndef configPRE_SLEEP_PROCESSING
N	#define configPRE_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configPOST_SLEEP_PROCESSING
N	#define configPOST_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configUSE_QUEUE_SETS
N	#define configUSE_QUEUE_SETS 0
N#endif
N
N#ifndef portTASK_USES_FLOATING_POINT
N	#define portTASK_USES_FLOATING_POINT()
N#endif
N
N#ifndef configUSE_TIME_SLICING
N	#define configUSE_TIME_SLICING 1
N#endif
N
N#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
N	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
N#endif
N
N#ifndef configUSE_STATS_FORMATTING_FUNCTIONS
N	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
N#endif
N
N#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
N	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
N#endif
N
N#ifndef configUSE_TRACE_FACILITY
S	#define configUSE_TRACE_FACILITY 0
N#endif
N
N#ifndef mtCOVERAGE_TEST_MARKER
N	#define mtCOVERAGE_TEST_MARKER()
N#endif
N
N#ifndef mtCOVERAGE_TEST_DELAY
N	#define mtCOVERAGE_TEST_DELAY()
N#endif
N
N#ifndef portASSERT_IF_IN_ISR
N	#define portASSERT_IF_IN_ISR()
N#endif
N
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
N	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
N#endif
N
N#ifndef configAPPLICATION_ALLOCATED_HEAP
N	#define configAPPLICATION_ALLOCATED_HEAP 0
N#endif
N
N#ifndef configUSE_TASK_NOTIFICATIONS
N	#define configUSE_TASK_NOTIFICATIONS 1
N#endif
N
N#ifndef portTICK_TYPE_IS_ATOMIC
N	#define portTICK_TYPE_IS_ATOMIC 0
N#endif
N
N#ifndef configSUPPORT_STATIC_ALLOCATION
N	/* Defaults to 0 for backward compatibility. */
N	#define configSUPPORT_STATIC_ALLOCATION 0
N#endif
N
N#ifndef configSUPPORT_DYNAMIC_ALLOCATION
N	/* Defaults to 1 for backward compatibility. */
N	#define configSUPPORT_DYNAMIC_ALLOCATION 1
N#endif
N
N/* Sanity check the configuration. */
N#if( configUSE_TICKLESS_IDLE != 0 )
X#if( 0 != 0 )
S	#if( INCLUDE_vTaskSuspend != 1 )
S		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
S	#endif /* INCLUDE_vTaskSuspend */
N#endif /* configUSE_TICKLESS_IDLE */
N
N#if( ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 0 ) )
X#if( ( 0 == 0 ) && ( 1 == 0 ) )
S	#error configSUPPORT_STATIC_ALLOCATION and configSUPPORT_DYNAMIC_ALLOCATION cannot both be 0, but can both be 1.
N#endif
N
N#if( ( configUSE_RECURSIVE_MUTEXES == 1 ) && ( configUSE_MUTEXES != 1 ) )
X#if( ( 0 == 1 ) && ( 1 != 1 ) )
S	#error configUSE_MUTEXES must be set to 1 to use recursive mutexes
N#endif
N
N#if( portTICK_TYPE_IS_ATOMIC == 0 )
X#if( 0 == 0 )
N	/* Either variables of tick type cannot be read atomically, or
N	portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
N	the tick count is returned to the standard critical section macros. */
N	#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()
N	#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()
N	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
N	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )
N#else
S	/* The tick type can be read atomically, so critical sections used when the
S	tick count is returned can be defined away. */
S	#define portTICK_TYPE_ENTER_CRITICAL()
S	#define portTICK_TYPE_EXIT_CRITICAL()
S	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
S	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x
N#endif
N
N/* Definitions to allow backward compatibility with FreeRTOS versions prior to
NV8 if desired. */
N#ifndef configENABLE_BACKWARD_COMPATIBILITY
N	#define configENABLE_BACKWARD_COMPATIBILITY 1
N#endif
N
N#if configENABLE_BACKWARD_COMPATIBILITY == 1
X#if 1 == 1
N	#define eTaskStateGet eTaskGetState
N	#define portTickType TickType_t
N	#define xTaskHandle TaskHandle_t
N	#define xQueueHandle QueueHandle_t
N	#define xSemaphoreHandle SemaphoreHandle_t
N	#define xQueueSetHandle QueueSetHandle_t
N	#define xQueueSetMemberHandle QueueSetMemberHandle_t
N	#define xTimeOutType TimeOut_t
N	#define xMemoryRegion MemoryRegion_t
N	#define xTaskParameters TaskParameters_t
N	#define xTaskStatusType	TaskStatus_t
N	#define xTimerHandle TimerHandle_t
N	#define xCoRoutineHandle CoRoutineHandle_t
N	#define pdTASK_HOOK_CODE TaskHookFunction_t
N	#define portTICK_RATE_MS portTICK_PERIOD_MS
N	#define pcTaskGetTaskName pcTaskGetName
N	#define pcTimerGetTimerName pcTimerGetName
N	#define pcQueueGetQueueName pcQueueGetName
N	#define vTaskGetTaskInfo vTaskGetInfo
N
N	/* Backward compatibility within the scheduler code only - these definitions
N	are not really required but are included for completeness. */
N	#define tmrTIMER_CALLBACK TimerCallbackFunction_t
N	#define pdTASK_CODE TaskFunction_t
N	#define xListItem ListItem_t
N	#define xList List_t
N#endif /* configENABLE_BACKWARD_COMPATIBILITY */
N
N#if( configUSE_ALTERNATIVE_API != 0 )
X#if( 0 != 0 )
S	#error The alternative API was deprecated some time ago, and was removed in FreeRTOS V9.0 0
N#endif
N
N/* Set configUSE_TASK_FPU_SUPPORT to 0 to omit floating point support even
Nif floating point hardware is otherwise supported by the FreeRTOS port in use.
NThis constant is not supported by all FreeRTOS ports that include floating
Npoint support. */
N#ifndef configUSE_TASK_FPU_SUPPORT
N	#define configUSE_TASK_FPU_SUPPORT 1
N#endif
N
N/*
N * In line with software engineering best practice, FreeRTOS implements a strict
N * data hiding policy, so the real structures used by FreeRTOS to maintain the
N * state of tasks, queues, semaphores, etc. are not accessible to the application
N * code.  However, if the application writer wants to statically allocate such
N * an object then the size of the object needs to be know.  Dummy structures
N * that are guaranteed to have the same size and alignment requirements of the
N * real objects are used for this purpose.  The dummy list and list item
N * structures below are used for inclusion in such a dummy structure.
N */
Nstruct xSTATIC_LIST_ITEM
N{
N	TickType_t xDummy1;
N	void *pvDummy2[ 4 ];
N};
Ntypedef struct xSTATIC_LIST_ITEM StaticListItem_t;
N
N/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
Nstruct xSTATIC_MINI_LIST_ITEM
N{
N	TickType_t xDummy1;
N	void *pvDummy2[ 2 ];
N};
Ntypedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;
N
N/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
Ntypedef struct xSTATIC_LIST
N{
N	UBaseType_t uxDummy1;
N	void *pvDummy2;
N	StaticMiniListItem_t xDummy3;
N} StaticList_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the Task structure used internally by
N * FreeRTOS is not accessible to application code.  However, if the application
N * writer wants to statically allocate the memory required to create a task then
N * the size of the task object needs to be know.  The StaticTask_t structure
N * below is provided for this purpose.  Its sizes and alignment requirements are
N * guaranteed to match those of the genuine structure, no matter which
N * architecture is being used, and no matter how the values in FreeRTOSConfig.h
N * are set.  Its contents are somewhat obfuscated in the hope users will
N * recognise that it would be unwise to make direct use of the structure members.
N */
Ntypedef struct xSTATIC_TCB
N{
N	void				*pxDummy1;
N	#if ( portUSING_MPU_WRAPPERS == 1 )
X	#if ( 0 == 1 )
S		xMPU_SETTINGS	xDummy2;
N	#endif
N	StaticListItem_t	xDummy3[ 2 ];
N	UBaseType_t			uxDummy5;
N	void				*pxDummy6;
N	uint8_t				ucDummy7[ configMAX_TASK_NAME_LEN ];
X	uint8_t				ucDummy7[ ( 16 ) ];
N	#if ( portSTACK_GROWTH > 0 )
X	#if ( ( -1 ) > 0 )
S		void			*pxDummy8;
N	#endif
N	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t		uxDummy9;
N	#endif
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t		uxDummy10[ 2 ];
N	#endif
N	#if ( configUSE_MUTEXES == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t		uxDummy12[ 2 ];
N	#endif
N	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
X	#if ( 0 == 1 )
S		void			*pxDummy14;
N	#endif
N	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X	#if( 0 > 0 )
S		void			*pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
N	#endif
N	#if ( configGENERATE_RUN_TIME_STATS == 1 )
X	#if ( 0 == 1 )
S		uint32_t		ulDummy16;
N	#endif
N	#if ( configUSE_NEWLIB_REENTRANT == 1 )
X	#if ( 0 == 1 )
S		struct	_reent	xDummy17;
N	#endif
N	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
X	#if ( 1 == 1 )
N		uint32_t 		ulDummy18;
N		uint8_t 		ucDummy19;
N	#endif
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t			uxDummy20;
N	#endif
N
N} StaticTask_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the Queue structure used internally by
N * FreeRTOS is not accessible to application code.  However, if the application
N * writer wants to statically allocate the memory required to create a queue
N * then the size of the queue object needs to be know.  The StaticQueue_t
N * structure below is provided for this purpose.  Its sizes and alignment
N * requirements are guaranteed to match those of the genuine structure, no
N * matter which architecture is being used, and no matter how the values in
N * FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in the hope
N * users will recognise that it would be unwise to make direct use of the
N * structure members.
N */
Ntypedef struct xSTATIC_QUEUE
N{
N	void *pvDummy1[ 3 ];
N
N	union
N	{
N		void *pvDummy2;
N		UBaseType_t uxDummy2;
N	} u;
N
N	StaticList_t xDummy3[ 2 ];
N	UBaseType_t uxDummy4[ 3 ];
N	uint8_t ucDummy5[ 2 ];
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t ucDummy6;
N	#endif
N
N	#if ( configUSE_QUEUE_SETS == 1 )
X	#if ( 0 == 1 )
S		void *pvDummy7;
N	#endif
N
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t uxDummy8;
N		uint8_t ucDummy9;
N	#endif
N
N} StaticQueue_t;
Ntypedef StaticQueue_t StaticSemaphore_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the event group structure used
N * internally by FreeRTOS is not accessible to application code.  However, if
N * the application writer wants to statically allocate the memory required to
N * create an event group then the size of the event group object needs to be
N * know.  The StaticEventGroup_t structure below is provided for this purpose.
N * Its sizes and alignment requirements are guaranteed to match those of the
N * genuine structure, no matter which architecture is being used, and no matter
N * how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
N * obfuscated in the hope users will recognise that it would be unwise to make
N * direct use of the structure members.
N */
Ntypedef struct xSTATIC_EVENT_GROUP
N{
N	TickType_t xDummy1;
N	StaticList_t xDummy2;
N
N	#if( configUSE_TRACE_FACILITY == 1 )
X	#if( 1 == 1 )
N		UBaseType_t uxDummy3;
N	#endif
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S			uint8_t ucDummy4;
N	#endif
N
N} StaticEventGroup_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the software timer structure used
N * internally by FreeRTOS is not accessible to application code.  However, if
N * the application writer wants to statically allocate the memory required to
N * create a software timer then the size of the queue object needs to be know.
N * The StaticTimer_t structure below is provided for this purpose.  Its sizes
N * and alignment requirements are guaranteed to match those of the genuine
N * structure, no matter which architecture is being used, and no matter how the
N * values in FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in
N * the hope users will recognise that it would be unwise to make direct use of
N * the structure members.
N */
Ntypedef struct xSTATIC_TIMER
N{
N	void				*pvDummy1;
N	StaticListItem_t	xDummy2;
N	TickType_t			xDummy3;
N	UBaseType_t			uxDummy4;
N	void 				*pvDummy5[ 2 ];
N	#if( configUSE_TRACE_FACILITY == 1 )
X	#if( 1 == 1 )
N		UBaseType_t		uxDummy6;
N	#endif
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 0 == 1 ) && ( 1 == 1 ) )
S		uint8_t 		ucDummy7;
N	#endif
N
N} StaticTimer_t;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* INC_FREERTOS_H */
N
L 45 "..\main.c" 2
N#include "task.h"
L 1 "..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include\task.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef INC_TASK_H
N#define INC_TASK_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include task.h"
N#endif
N
N#include "list.h"
L 1 "..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include\list.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*
N * This is the list implementation used by the scheduler.  While it is tailored
N * heavily for the schedulers needs, it is also available for use by
N * application code.
N *
N * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
N * numeric value (xItemValue).  Most of the time the lists are sorted in
N * descending item value order.
N *
N * Lists are created already containing one list item.  The value of this
N * item is the maximum possible that can be stored, it is therefore always at
N * the end of the list and acts as a marker.  The list member pxHead always
N * points to this marker - even though it is at the tail of the list.  This
N * is because the tail contains a wrap back pointer to the true head of
N * the list.
N *
N * In addition to it's value, each list item contains a pointer to the next
N * item in the list (pxNext), a pointer to the list it is in (pxContainer)
N * and a pointer to back to the object that contains it.  These later two
N * pointers are included for efficiency of list manipulation.  There is
N * effectively a two way link between the object containing the list item and
N * the list item itself.
N *
N *
N * \page ListIntroduction List Implementation
N * \ingroup FreeRTOSIntro
N */
N
N#ifndef INC_FREERTOS_H
S	#error FreeRTOS.h must be included before list.h
N#endif
N
N#ifndef LIST_H
N#define LIST_H
N
N/*
N * The list structure members are modified from within interrupts, and therefore
N * by rights should be declared volatile.  However, they are only modified in a
N * functionally atomic way (within critical sections of with the scheduler
N * suspended) and are either passed by reference into a function or indexed via
N * a volatile variable.  Therefore, in all use cases tested so far, the volatile
N * qualifier can be omitted in order to provide a moderate performance
N * improvement without adversely affecting functional behaviour.  The assembly
N * instructions generated by the IAR, ARM and GCC compilers when the respective
N * compiler's options were set for maximum optimisation has been inspected and
N * deemed to be as intended.  That said, as compiler technology advances, and
N * especially if aggressive cross module optimisation is used (a use case that
N * has not been exercised to any great extend) then it is feasible that the
N * volatile qualifier will be needed for correct optimisation.  It is expected
N * that a compiler removing essential code because, without the volatile
N * qualifier on the list structure members and with aggressive cross module
N * optimisation, the compiler deemed the code unnecessary will result in
N * complete and obvious failure of the scheduler.  If this is ever experienced
N * then the volatile qualifier can be inserted in the relevant places within the
N * list structures by simply defining configLIST_VOLATILE to volatile in
N * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
N * If configLIST_VOLATILE is not defined then the preprocessor directives below
N * will simply #define configLIST_VOLATILE away completely.
N *
N * To use volatile list structure members then add the following line to
N * FreeRTOSConfig.h (without the quotes):
N * "#define configLIST_VOLATILE volatile"
N */
N#ifndef configLIST_VOLATILE
N	#define configLIST_VOLATILE
N#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Macros that can be used to place known values within the list structures,
Nthen check that the known values do not get corrupted during the execution of
Nthe application.   These may catch the list data structures being overwritten in
Nmemory.  They will not catch data errors caused by incorrect configuration or
Nuse of FreeRTOS.*/
N#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
X#if( 0 == 0 )
N	/* Define the macros to do nothing. */
N	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
N	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
N	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
N	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
N	#define listTEST_LIST_INTEGRITY( pxList )
N#else
S	/* Define macros that add new members into the list structures. */
S	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
S	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
S	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
S	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
S
S	/* Define macros that set the new structure members to known values. */
S	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S
S	/* Define macros that will assert if one of the structure members does not
S	contain its expected value. */
S	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
S	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
N#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
N
N
N/*
N * Definition of the only type of object that a list can contain.
N */
Nstruct xLIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
X	 TickType_t xItemValue;			 
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
X	struct xLIST_ITEM *  pxNext;		 
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
X	struct xLIST_ITEM *  pxPrevious;	 
N	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
N	void * configLIST_VOLATILE pvContainer;				/*< Pointer to the list in which this list item is placed (if any). */
X	void *  pvContainer;				 
N	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N};
Ntypedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
N
Nstruct xMINI_LIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;
X	 TickType_t xItemValue;
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
X	struct xLIST_ITEM *  pxNext;
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
X	struct xLIST_ITEM *  pxPrevious;
N};
Ntypedef struct xMINI_LIST_ITEM MiniListItem_t;
N
N/*
N * Definition of the type of queue used by the scheduler.
N */
Ntypedef struct xLIST
N{
N	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N	configLIST_VOLATILE UBaseType_t uxNumberOfItems;
X	 UBaseType_t uxNumberOfItems;
N	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
X	ListItem_t *  pxIndex;			 
N	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
N	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N} List_t;
N
N/*
N * Access macro to set the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
N
N/*
N * Access macro to get the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
N
N/*
N * Access macro to set the value of the list item.  In most cases the value is
N * used to sort the list in descending order.
N *
N * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
N
N/*
N * Access macro to retrieve the value of the list item.  The value can
N * represent anything - for example the priority of a task, or the time at
N * which a task should be unblocked.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
N
N/*
N * Access macro to retrieve the value of the list item at the head of a given
N * list.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_NEXT listGET_NEXT
N * \ingroup LinkedList
N */
N#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
N
N/*
N * Return the list item that marks the end of the list
N *
N * \page listGET_END_MARKER listGET_END_MARKER
N * \ingroup LinkedList
N */
N#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
N
N/*
N * Access macro to determine if a list contains any items.  The macro will
N * only have the value true if the list is empty.
N *
N * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
N * \ingroup LinkedList
N */
N#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
N
N/*
N * Access macro to return the number of items in the list.
N */
N#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
N
N/*
N * Access function to obtain the owner of the next entry in a list.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
N * and returns that entry's pxOwner parameter.  Using multiple calls to this
N * function it is therefore possible to move through every item contained in
N * a list.
N *
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxTCB pxTCB is set to the address of the owner of the next list item.
N * @param pxList The list from which the next item owner is to be returned.
N *
N * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
N{																							\
NList_t * const pxConstList = ( pxList );													\
N	/* Increment the index to the next item and return the item, ensuring */				\
N	/* we don't return the marker used at the end of the list.  */							\
N	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
N	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
N	{																						\
N		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
N	}																						\
N	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
N}
X#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										{																							List_t * const pxConstList = ( pxList );														 					 								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;								if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )		{																								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							}																							( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											}
N
N
N/*
N * Access function to obtain the owner of the first entry in a list.  Lists
N * are normally sorted in ascending item value order.
N *
N * This function returns the pxOwner member of the first item in the list.
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxList The list from which the owner of the head item is to be
N * returned.
N *
N * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
N
N/*
N * Check to see if a list item is within a list.  The list item maintains a
N * "container" pointer that points to the list it is in.  All this macro does
N * is check to see if the container and the list match.
N *
N * @param pxList The list we want to know if the list item is within.
N * @param pxListItem The list item we want to know if is in the list.
N * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
N */
N#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
N
N/*
N * Return the list a list item is contained within (referenced from).
N *
N * @param pxListItem The list item being queried.
N * @return A pointer to the List_t object that references the pxListItem
N */
N#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
N
N/*
N * This provides a crude means of knowing if a list has been initialised, as
N * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
N * function.
N */
N#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
N
N/*
N * Must be called before a list is used!  This initialises all the members
N * of the list structure and inserts the xListEnd item into the list as a
N * marker to the back of the list.
N *
N * @param pxList Pointer to the list being initialised.
N *
N * \page vListInitialise vListInitialise
N * \ingroup LinkedList
N */
Nvoid vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
Xvoid vListInitialise( List_t * const pxList ) ;
N
N/*
N * Must be called before a list item is used.  This sets the list container to
N * null so the item does not think that it is already contained in a list.
N *
N * @param pxItem Pointer to the list item being initialised.
N *
N * \page vListInitialiseItem vListInitialiseItem
N * \ingroup LinkedList
N */
Nvoid vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
Xvoid vListInitialiseItem( ListItem_t * const pxItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted into the list in
N * a position determined by its item value (descending item value order).
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The item that is to be placed in the list.
N *
N * \page vListInsert vListInsert
N * \ingroup LinkedList
N */
Nvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted in a position
N * such that it will be the last item within the list returned by multiple
N * calls to listGET_OWNER_OF_NEXT_ENTRY.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
N * Placing an item in a list using vListInsertEnd effectively places the item
N * in the list position pointed to by pxIndex.  This means that every other
N * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
N * the pxIndex parameter again points to the item being inserted.
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The list item to be inserted into the list.
N *
N * \page vListInsertEnd vListInsertEnd
N * \ingroup LinkedList
N */
Nvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Remove an item from a list.  The list item has a pointer to the list that
N * it is in, so only the list item need be passed into the function.
N *
N * @param uxListRemove The item to be removed.  The item will remove itself from
N * the list pointed to by it's pxContainer parameter.
N *
N * @return The number of items that remain in the list after the list item has
N * been removed.
N *
N * \page uxListRemove uxListRemove
N * \ingroup LinkedList
N */
NUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
XUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) ;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 79 "..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include\task.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * MACROS AND DEFINITIONS
N *----------------------------------------------------------*/
N
N#define tskKERNEL_VERSION_NUMBER "V9.0.0"
N#define tskKERNEL_VERSION_MAJOR 9
N#define tskKERNEL_VERSION_MINOR 0
N#define tskKERNEL_VERSION_BUILD 0
N
N/**
N * task. h
N *
N * Type by which tasks are referenced.  For example, a call to xTaskCreate
N * returns (via a pointer parameter) an TaskHandle_t variable that can then
N * be used as a parameter to vTaskDelete to delete the task.
N *
N * \defgroup TaskHandle_t TaskHandle_t
N * \ingroup Tasks
N */
Ntypedef void * TaskHandle_t;
N
N/*
N * Defines the prototype to which the application task hook function must
N * conform.
N */
Ntypedef BaseType_t (*TaskHookFunction_t)( void * );
N
N/* Task states returned by eTaskGetState. */
Ntypedef enum
N{
N	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
N	eReady,			/* The task being queried is in a read or pending ready list. */
N	eBlocked,		/* The task being queried is in the Blocked state. */
N	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
N	eDeleted,		/* The task being queried has been deleted, but its TCB has not yet been freed. */
N	eInvalid			/* Used as an 'invalid state' value. */
N} eTaskState;
N
N/* Actions that can be performed when vTaskNotify() is called. */
Ntypedef enum
N{
N	eNoAction = 0,				/* Notify the task without updating its notify value. */
N	eSetBits,					/* Set bits in the task's notification value. */
N	eIncrement,					/* Increment the task's notification value. */
N	eSetValueWithOverwrite,		/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */
N	eSetValueWithoutOverwrite	/* Set the task's notification value if the previous value has been read by the task. */
N} eNotifyAction;
N
N/*
N * Used internally only.
N */
Ntypedef struct xTIME_OUT
N{
N	BaseType_t xOverflowCount;
N	TickType_t xTimeOnEntering;
N} TimeOut_t;
N
N/*
N * Defines the memory ranges allocated to the task when an MPU is used.
N */
Ntypedef struct xMEMORY_REGION
N{
N	void *pvBaseAddress;
N	uint32_t ulLengthInBytes;
N	uint32_t ulParameters;
N} MemoryRegion_t;
N
N/*
N * Parameters required to create an MPU protected task.
N */
Ntypedef struct xTASK_PARAMETERS
N{
N	TaskFunction_t pvTaskCode;
N	const char * const pcName;	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	uint16_t usStackDepth;
N	void *pvParameters;
N	UBaseType_t uxPriority;
N	StackType_t *puxStackBuffer;
N	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];
X	MemoryRegion_t xRegions[ 1 ];
N} TaskParameters_t;
N
N/* Used with the uxTaskGetSystemState() function to return the state of each task
Nin the system. */
Ntypedef struct xTASK_STATUS
N{
N	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
N	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	UBaseType_t xTaskNumber;		/* A number unique to the task. */
N	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
N	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
N	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
N	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
N	StackType_t *pxStackBase;		/* Points to the lowest address of the task's stack area. */
N	uint16_t usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
N} TaskStatus_t;
N
N/* Possible return values for eTaskConfirmSleepModeStatus(). */
Ntypedef enum
N{
N	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
N	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
N	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
N} eSleepModeStatus;
N
N/**
N * Defines the priority used by the idle task.  This must not be modified.
N *
N * \ingroup TaskUtils
N */
N#define tskIDLE_PRIORITY			( ( UBaseType_t ) 0U )
N
N/**
N * task. h
N *
N * Macro for forcing a context switch.
N *
N * \defgroup taskYIELD taskYIELD
N * \ingroup SchedulerControl
N */
N#define taskYIELD()					portYIELD()
N
N/**
N * task. h
N *
N * Macro to mark the start of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskENTER_CRITICAL()		portENTER_CRITICAL()
N#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
N
N/**
N * task. h
N *
N * Macro to mark the end of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
N#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
N/**
N * task. h
N *
N * Macro to disable all maskable interrupts.
N *
N * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
N
N/**
N * task. h
N *
N * Macro to enable microcontroller interrupts.
N *
N * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
N
N/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is
N0 to generate more optimal code when configASSERT() is defined as the constant
Nis used in assert() statements. */
N#define taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 )
N#define taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 )
N#define taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 )
N
N
N/*-----------------------------------------------------------
N * TASK CREATION API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreate(
N							  TaskFunction_t pvTaskCode,
N							  const char * const pcName,
N							  uint16_t usStackDepth,
N							  void *pvParameters,
N							  UBaseType_t uxPriority,
N							  TaskHandle_t *pvCreatedTask
N						  );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * Internally, within the FreeRTOS implementation, tasks use two blocks of
N * memory.  The first block is used to hold the task's data structures.  The
N * second block is used by the task as its stack.  If a task is created using
N * xTaskCreate() then both blocks of memory are automatically dynamically
N * allocated inside the xTaskCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a task is created using
N * xTaskCreateStatic() then the application writer must provide the required
N * memory.  xTaskCreateStatic() therefore allows a task to be created without
N * using any dynamic memory allocation.
N *
N * See xTaskCreateStatic() for a version that does not use any dynamic memory
N * allocation.
N *
N * xTaskCreate() can only be used to create a task that has unrestricted
N * access to the entire microcontroller memory map.  Systems that include MPU
N * support can alternatively create an MPU constrained task using
N * xTaskCreateRestricted().
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default
N * is 16.
N *
N * @param usStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task should run.  Systems that
N * include MPU support can optionally create tasks in a privileged (system)
N * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
N * example, to create a privileged task at priority 2 the uxPriority parameter
N * should be set to ( 2 | portPRIVILEGE_BIT ).
N *
N * @param pvCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N // Task to be created.
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N	 }
N }
N
N // Function that creates a task.
N void vOtherFunction( void )
N {
N static uint8_t ucParameterToPass;
N TaskHandle_t xHandle = NULL;
N
N	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
N	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
N	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
N	 // the new task attempts to access it.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
N     configASSERT( xHandle );
N
N	 // Use the handle to delete the task.
N     if( xHandle != NULL )
N     {
N	     vTaskDelete( xHandle );
N     }
N }
N   </pre>
N * \defgroup xTaskCreate xTaskCreate
N * \ingroup Tasks
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
N							const char * const pcName,
N							const uint16_t usStackDepth,
N							void * const pvParameters,
N							UBaseType_t uxPriority,
N							TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
X							TaskHandle_t * const pxCreatedTask ) ;  
N#endif
N
N/**
N * task. h
N *<pre>
N TaskHandle_t xTaskCreateStatic( TaskFunction_t pvTaskCode,
N								 const char * const pcName,
N								 uint32_t ulStackDepth,
N								 void *pvParameters,
N								 UBaseType_t uxPriority,
N								 StackType_t *pxStackBuffer,
N								 StaticTask_t *pxTaskBuffer );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * Internally, within the FreeRTOS implementation, tasks use two blocks of
N * memory.  The first block is used to hold the task's data structures.  The
N * second block is used by the task as its stack.  If a task is created using
N * xTaskCreate() then both blocks of memory are automatically dynamically
N * allocated inside the xTaskCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a task is created using
N * xTaskCreateStatic() then the application writer must provide the required
N * memory.  xTaskCreateStatic() therefore allows a task to be created without
N * using any dynamic memory allocation.
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  The maximum length of the string is defined by
N * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.
N *
N * @param ulStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 32-bits wide and ulStackDepth is defined as 100 then 400 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task will run.
N *
N * @param pxStackBuffer Must point to a StackType_t array that has at least
N * ulStackDepth indexes - the array will then be used as the task's stack,
N * removing the need for the stack to be allocated dynamically.
N *
N * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will
N * then be used to hold the task's data structures, removing the need for the
N * memory to be allocated dynamically.
N *
N * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will
N * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer
N * are NULL then the task will not be created and
N * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.
N *
N * Example usage:
N   <pre>
N
N    // Dimensions the buffer that the task being created will use as its stack.
N    // NOTE:  This is the number of words the stack will hold, not the number of
N    // bytes.  For example, if each stack item is 32-bits, and this is set to 100,
N    // then 400 bytes (100 * 32-bits) will be allocated.
N    #define STACK_SIZE 200
N
N    // Structure that will hold the TCB of the task being created.
N    StaticTask_t xTaskBuffer;
N
N    // Buffer that the task being created will use as its stack.  Note this is
N    // an array of StackType_t variables.  The size of StackType_t is dependent on
N    // the RTOS port.
N    StackType_t xStack[ STACK_SIZE ];
N
N    // Function that implements the task being created.
N    void vTaskCode( void * pvParameters )
N    {
N        // The parameter value is expected to be 1 as 1 is passed in the
N        // pvParameters value in the call to xTaskCreateStatic().
N        configASSERT( ( uint32_t ) pvParameters == 1UL );
N
N        for( ;; )
N        {
N            // Task code goes here.
N        }
N    }
N
N    // Function that creates a task.
N    void vOtherFunction( void )
N    {
N        TaskHandle_t xHandle = NULL;
N
N        // Create the task without using any dynamic memory allocation.
N        xHandle = xTaskCreateStatic(
N                      vTaskCode,       // Function that implements the task.
N                      "NAME",          // Text name for the task.
N                      STACK_SIZE,      // Stack size in words, not bytes.
N                      ( void * ) 1,    // Parameter passed into the task.
N                      tskIDLE_PRIORITY,// Priority at which the task is created.
N                      xStack,          // Array to use as the task's stack.
N                      &xTaskBuffer );  // Variable to hold the task's data structure.
N
N        // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have
N        // been created, and xHandle will be the task's handle.  Use the handle
N        // to suspend the task.
N        vTaskSuspend( xHandle );
N    }
N   </pre>
N * \defgroup xTaskCreateStatic xTaskCreateStatic
N * \ingroup Tasks
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 0 == 1 )
S	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
S									const char * const pcName,
S									const uint32_t ulStackDepth,
S									void * const pvParameters,
S									UBaseType_t uxPriority,
S									StackType_t * const puxStackBuffer,
S									StaticTask_t * const pxTaskBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
N *
N * xTaskCreateRestricted() should only be used in systems that include an MPU
N * implementation.
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N * The function parameters define the memory regions and associated access
N * permissions allocated to the task.
N *
N * @param pxTaskDefinition Pointer to a structure that contains a member
N * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
N * documentation) plus an optional stack buffer and the memory region
N * definitions.
N *
N * @param pxCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N// Create an TaskParameters_t structure that defines the task to be created.
Nstatic const TaskParameters_t xCheckTaskParameters =
N{
N	vATask,		// pvTaskCode - the function that implements the task.
N	"ATask",	// pcName - just a text name for the task to assist debugging.
N	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
N	NULL,		// pvParameters - passed into the task function as the function parameters.
N	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
N	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
N
N	// xRegions - Allocate up to three separate memory regions for access by
N	// the task, with appropriate access permissions.  Different processors have
N	// different memory alignment requirements - refer to the FreeRTOS documentation
N	// for full information.
N	{
N		// Base address					Length	Parameters
N        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
N        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
N        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
N	}
N};
N
Nint main( void )
N{
NTaskHandle_t xHandle;
N
N	// Create a task from the const structure defined above.  The task handle
N	// is requested (the second parameter is not NULL) but in this case just for
N	// demonstration purposes as its not actually used.
N	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
N
N	// Start the scheduler.
N	vTaskStartScheduler();
N
N	// Will only get here if there was insufficient memory to create the idle
N	// and/or timer task.
N	for( ;; );
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
N#endif
N
N/**
N * task. h
N *<pre>
N void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</pre>
N *
N * Memory regions are assigned to a restricted task when the task is created by
N * a call to xTaskCreateRestricted().  These regions can be redefined using
N * vTaskAllocateMPURegions().
N *
N * @param xTask The handle of the task being updated.
N *
N * @param xRegions A pointer to an MemoryRegion_t structure that contains the
N * new memory region definitions.
N *
N * Example usage:
N   <pre>
N// Define an array of MemoryRegion_t structures that configures an MPU region
N// allowing read/write access for 1024 bytes starting at the beginning of the
N// ucOneKByte array.  The other two of the maximum 3 definable regions are
N// unused so set to zero.
Nstatic const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
N{
N	// Base address		Length		Parameters
N	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
N	{ 0,				0,			0 },
N	{ 0,				0,			0 }
N};
N
Nvoid vATask( void *pvParameters )
N{
N	// This task was created such that it has access to certain regions of
N	// memory as defined by the MPU configuration.  At some point it is
N	// desired that these MPU regions are replaced with that defined in the
N	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
N	// for this purpose.  NULL is used as the task handle to indicate that this
N	// function should modify the MPU regions of the calling task.
N	vTaskAllocateMPURegions( NULL, xAltRegions );
N
N	// Now the task can continue its function, but from this point on can only
N	// access its stack and the ucOneKByte array (unless any other statically
N	// defined or shared regions have been declared elsewhere).
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
Nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;
Xvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelete( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Remove a task from the RTOS real time kernel's management.  The task being
N * deleted will be removed from all ready, blocked, suspended and event lists.
N *
N * NOTE:  The idle task is responsible for freeing the kernel allocated
N * memory from tasks that have been deleted.  It is therefore important that
N * the idle task is not starved of microcontroller processing time if your
N * application makes any calls to vTaskDelete ().  Memory allocated by the
N * task code is not automatically freed, and should be freed before the task
N * is deleted.
N *
N * See the demo application file death.c for sample code that utilises
N * vTaskDelete ().
N *
N * @param xTask The handle of the task to be deleted.  Passing NULL will
N * cause the calling task to be deleted.
N *
N * Example usage:
N   <pre>
N void vOtherFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create the task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // Use the handle to delete the task.
N	 vTaskDelete( xHandle );
N }
N   </pre>
N * \defgroup vTaskDelete vTaskDelete
N * \ingroup Tasks
N */
Nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelete( TaskHandle_t xTaskToDelete ) ;
N
N/*-----------------------------------------------------------
N * TASK CONTROL API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskDelay( const TickType_t xTicksToDelay );</pre>
N *
N * Delay a task for a given number of ticks.  The actual time that the
N * task remains blocked depends on the tick rate.  The constant
N * portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N *
N * vTaskDelay() specifies a time at which the task wishes to unblock relative to
N * the time at which vTaskDelay() is called.  For example, specifying a block
N * period of 100 ticks will cause the task to unblock 100 ticks after
N * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
N * of controlling the frequency of a periodic task as the path taken through the
N * code, as well as other task and interrupt activity, will effect the frequency
N * at which vTaskDelay() gets called and therefore the time at which the task
N * next executes.  See vTaskDelayUntil() for an alternative API function designed
N * to facilitate fixed frequency execution.  It does this by specifying an
N * absolute time (rather than a relative time) at which the calling task should
N * unblock.
N *
N * @param xTicksToDelay The amount of time, in tick periods, that
N * the calling task should block.
N *
N * Example usage:
N
N void vTaskFunction( void * pvParameters )
N {
N // Block for 500ms.
N const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
N
N	 for( ;; )
N	 {
N		 // Simply toggle the LED every 500ms, blocking between each toggle.
N		 vToggleLED();
N		 vTaskDelay( xDelay );
N	 }
N }
N
N * \defgroup vTaskDelay vTaskDelay
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelay( const TickType_t xTicksToDelay ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</pre>
N *
N * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Delay a task until a specified time.  This function can be used by periodic
N * tasks to ensure a constant execution frequency.
N *
N * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
N * cause a task to block for the specified number of ticks from the time vTaskDelay () is
N * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
N * execution frequency as the time between a task starting to execute and that task
N * calling vTaskDelay () may not be fixed [the task may take a different path though the
N * code between calls, or may get interrupted or preempted a different number of times
N * each time it executes].
N *
N * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
N * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
N * unblock.
N *
N * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
N * task was last unblocked.  The variable must be initialised with the current time
N * prior to its first use (see the example below).  Following this the variable is
N * automatically updated within vTaskDelayUntil ().
N *
N * @param xTimeIncrement The cycle time period.  The task will be unblocked at
N * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
N * same xTimeIncrement parameter value will cause the task to execute with
N * a fixed interface period.
N *
N * Example usage:
N   <pre>
N // Perform an action every 10 ticks.
N void vTaskFunction( void * pvParameters )
N {
N TickType_t xLastWakeTime;
N const TickType_t xFrequency = 10;
N
N	 // Initialise the xLastWakeTime variable with the current time.
N	 xLastWakeTime = xTaskGetTickCount ();
N	 for( ;; )
N	 {
N		 // Wait for the next cycle.
N		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
N
N		 // Perform action here.
N	 }
N }
N   </pre>
N * \defgroup vTaskDelayUntil vTaskDelayUntil
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskAbortDelay( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this
N * function to be available.
N *
N * A task will enter the Blocked state when it is waiting for an event.  The
N * event it is waiting for can be a temporal event (waiting for a time), such
N * as when vTaskDelay() is called, or an event on an object, such as when
N * xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task
N * that is in the Blocked state is used in a call to xTaskAbortDelay() then the
N * task will leave the Blocked state, and return from whichever function call
N * placed the task into the Blocked state.
N *
N * @param xTask The handle of the task to remove from the Blocked state.
N *
N * @return If the task referenced by xTask was not in the Blocked state then
N * pdFAIL is returned.  Otherwise pdPASS is returned.
N *
N * \defgroup xTaskAbortDelay xTaskAbortDelay
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskAbortDelay( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskAbortDelay( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the priority of any task.
N *
N * @param xTask Handle of the task to be queried.  Passing a NULL
N * handle results in the priority of the calling task being returned.
N *
N * @return The priority of xTask.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to obtain the priority of the created task.
N	 // It was created with tskIDLE_PRIORITY, but may have changed
N	 // it itself.
N	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
N	 {
N		 // The task has changed it's priority.
N	 }
N
N	 // ...
N
N	 // Is our priority higher than the created task?
N	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
N	 {
N		 // Our priority (obtained using NULL handle) is higher.
N	 }
N }
N   </pre>
N * \defgroup uxTaskPriorityGet uxTaskPriorityGet
N * \ingroup TaskCtrl
N */
NUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask );</pre>
N *
N * A version of uxTaskPriorityGet() that can be used from an ISR.
N */
NUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>eTaskState eTaskGetState( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the state of any task.  States are encoded by the eTaskState
N * enumerated type.
N *
N * @param xTask Handle of the task to be queried.
N *
N * @return The state of xTask at the time the function was called.  Note the
N * state of the task might change between the function being called, and the
N * functions return value being tested by the calling task.
N */
NeTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XeTaskState eTaskGetState( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );</pre>
N *
N * configUSE_TRACE_FACILITY must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * Populates a TaskStatus_t structure with information about a task.
N *
N * @param xTask Handle of the task being queried.  If xTask is NULL then
N * information will be returned about the calling task.
N *
N * @param pxTaskStatus A pointer to the TaskStatus_t structure that will be
N * filled with information about the task referenced by the handle passed using
N * the xTask parameter.
N *
N * @xGetFreeStackSpace The TaskStatus_t structure contains a member to report
N * the stack high water mark of the task being queried.  Calculating the stack
N * high water mark takes a relatively long time, and can make the system
N * temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to
N * allow the high water mark checking to be skipped.  The high watermark value
N * will only be written to the TaskStatus_t structure if xGetFreeStackSpace is
N * not set to pdFALSE;
N *
N * @param eState The TaskStatus_t structure contains a member to report the
N * state of the task being queried.  Obtaining the task state is not as fast as
N * a simple assignment - so the eState parameter is provided to allow the state
N * information to be omitted from the TaskStatus_t structure.  To obtain state
N * information then set eState to eInvalid - otherwise the value passed in
N * eState will be reported as the task state in the TaskStatus_t structure.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N TaskStatus_t xTaskDetails;
N
N    // Obtain the handle of a task from its name.
N    xHandle = xTaskGetHandle( "Task_Name" );
N
N    // Check the handle is not NULL.
N    configASSERT( xHandle );
N
N    // Use the handle to obtain further information about the task.
N    vTaskGetInfo( xHandle,
N                  &xTaskDetails,
N                  pdTRUE, // Include the high water mark in xTaskDetails.
N                  eInvalid ); // Include the task state in xTaskDetails.
N }
N   </pre>
N * \defgroup vTaskGetInfo vTaskGetInfo
N * \ingroup TaskCtrl
N */
Nvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) PRIVILEGED_FUNCTION;
Xvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) ;
N
N/**
N * task. h
N * <pre>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</pre>
N *
N * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Set the priority of any task.
N *
N * A context switch will occur before the function returns if the priority
N * being set is higher than the currently executing task.
N *
N * @param xTask Handle to the task for which the priority is being set.
N * Passing a NULL handle results in the priority of the calling task being set.
N *
N * @param uxNewPriority The priority to which the task will be set.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to raise the priority of the created task.
N	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
N
N	 // ...
N
N	 // Use a NULL handle to raise our priority to the same value.
N	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
N }
N   </pre>
N * \defgroup vTaskPrioritySet vTaskPrioritySet
N * \ingroup TaskCtrl
N */
Nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;
Xvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Suspend any task.  When suspended a task will never get any microcontroller
N * processing time, no matter what its priority.
N *
N * Calls to vTaskSuspend are not accumulative -
N * i.e. calling vTaskSuspend () twice on the same task still only requires one
N * call to vTaskResume () to ready the suspended task.
N *
N * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
N * handle will cause the calling task to be suspended.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Suspend ourselves.
N	 vTaskSuspend( NULL );
N
N	 // We cannot get here unless another task calls vTaskResume
N	 // with our handle as the parameter.
N }
N   </pre>
N * \defgroup vTaskSuspend vTaskSuspend
N * \ingroup TaskCtrl
N */
Nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;
N
N/**
N * task. h
N * <pre>void vTaskResume( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Resumes a suspended task.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * vTaskResume ().
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Resume the suspended task ourselves.
N	 vTaskResume( xHandle );
N
N	 // The created task will once again get microcontroller processing
N	 // time in accordance with its priority within the system.
N }
N   </pre>
N * \defgroup vTaskResume vTaskResume
N * \ingroup TaskCtrl
N */
Nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
Xvoid vTaskResume( TaskHandle_t xTaskToResume ) ;
N
N/**
N * task. h
N * <pre>void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * An implementation of vTaskResume() that can be called from within an ISR.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * xTaskResumeFromISR ().
N *
N * xTaskResumeFromISR() should not be used to synchronise a task with an
N * interrupt if there is a chance that the interrupt could arrive prior to the
N * task being suspended - as this can lead to interrupts being missed. Use of a
N * semaphore as a synchronisation mechanism would avoid this eventuality.
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * @return pdTRUE if resuming the task should result in a context switch,
N * otherwise pdFALSE. This is used by the ISR to determine if a context switch
N * may be required following the ISR.
N *
N * \defgroup vTaskResumeFromISR vTaskResumeFromISR
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;
N
N/*-----------------------------------------------------------
N * SCHEDULER CONTROL
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskStartScheduler( void );</pre>
N *
N * Starts the real time kernel tick processing.  After calling the kernel
N * has control over which tasks are executed and when.
N *
N * See the demo application file main.c for an example of creating
N * tasks and starting the kernel.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will not get here unless a task calls vTaskEndScheduler ()
N }
N   </pre>
N *
N * \defgroup vTaskStartScheduler vTaskStartScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskStartScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskEndScheduler( void );</pre>
N *
N * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
N * in place of DOS, implements this function.
N *
N * Stops the real time kernel tick.  All created tasks will be automatically
N * deleted and multitasking (either preemptive or cooperative) will
N * stop.  Execution then resumes from the point where vTaskStartScheduler ()
N * was called, as if vTaskStartScheduler () had just returned.
N *
N * See the demo application file main. c in the demo/PC directory for an
N * example that uses vTaskEndScheduler ().
N *
N * vTaskEndScheduler () requires an exit function to be defined within the
N * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
N * performs hardware specific operations such as stopping the kernel tick.
N *
N * vTaskEndScheduler () will cause all of the resources allocated by the
N * kernel to be freed - but will not free resources allocated by application
N * tasks.
N *
N * Example usage:
N   <pre>
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // At some point we want to end the real time kernel processing
N		 // so call ...
N		 vTaskEndScheduler ();
N	 }
N }
N
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will only get here when the vTaskCode () task has called
N	 // vTaskEndScheduler ().  When we get here we are back to single task
N	 // execution.
N }
N   </pre>
N *
N * \defgroup vTaskEndScheduler vTaskEndScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskEndScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspendAll( void );</pre>
N *
N * Suspends the scheduler without disabling interrupts.  Context switches will
N * not occur while the scheduler is suspended.
N *
N * After calling vTaskSuspendAll () the calling task will continue to execute
N * without risk of being swapped out until a call to xTaskResumeAll () has been
N * made.
N *
N * API functions that have the potential to cause a context switch (for example,
N * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
N * is suspended.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the kernel
N		 // tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.
N		 xTaskResumeAll ();
N	 }
N }
N   </pre>
N * \defgroup vTaskSuspendAll vTaskSuspendAll
N * \ingroup SchedulerControl
N */
Nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspendAll( void ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskResumeAll( void );</pre>
N *
N * Resumes scheduler activity after it was suspended by a call to
N * vTaskSuspendAll().
N *
N * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
N * that were previously suspended by a call to vTaskSuspend().
N *
N * @return If resuming the scheduler caused a context switch then pdTRUE is
N *		  returned, otherwise pdFALSE is returned.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the real
N		 // time kernel tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.  We want to force
N		 // a context switch - but there is no point if resuming the scheduler
N		 // caused a context switch already.
N		 if( !xTaskResumeAll () )
N		 {
N			  taskYIELD ();
N		 }
N	 }
N }
N   </pre>
N * \defgroup xTaskResumeAll xTaskResumeAll
N * \ingroup SchedulerControl
N */
NBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeAll( void ) ;
N
N/*-----------------------------------------------------------
N * TASK UTILITIES
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCount( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * \defgroup xTaskGetTickCount xTaskGetTickCount
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCount( void ) ;
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCountFromISR( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * This is a version of xTaskGetTickCount() that is safe to be called from an
N * ISR - provided that TickType_t is the natural word size of the
N * microcontroller being used or interrupt nesting is either not supported or
N * not being used.
N *
N * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCountFromISR( void ) ;
N
N/**
N * task. h
N * <PRE>uint16_t uxTaskGetNumberOfTasks( void );</PRE>
N *
N * @return The number of tasks that the real time kernel is currently managing.
N * This includes all ready, blocked and suspended tasks.  A task that
N * has been deleted but not yet freed by the idle task will also be
N * included in the count.
N *
N * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
N * \ingroup TaskUtils
N */
NUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetNumberOfTasks( void ) ;
N
N/**
N * task. h
N * <PRE>char *pcTaskGetName( TaskHandle_t xTaskToQuery );</PRE>
N *
N * @return The text (human readable) name of the task referenced by the handle
N * xTaskToQuery.  A task can query its own name by either passing in its own
N * handle, or by setting xTaskToQuery to NULL.
N *
N * \defgroup pcTaskGetName pcTaskGetName
N * \ingroup TaskUtils
N */
Nchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) ;  
N
N/**
N * task. h
N * <PRE>TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );</PRE>
N *
N * NOTE:  This function takes a relatively long time to complete and should be
N * used sparingly.
N *
N * @return The handle of the task that has the human readable name pcNameToQuery.
N * NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle
N * must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.
N *
N * \defgroup pcTaskGetHandle pcTaskGetHandle
N * \ingroup TaskUtils
N */
NTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
XTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) ;  
N
N/**
N * task.h
N * <PRE>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</PRE>
N *
N * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
N * this function to be available.
N *
N * Returns the high water mark of the stack associated with xTask.  That is,
N * the minimum free stack space there has been (in words, so on a 32 bit machine
N * a value of 1 means 4 bytes) since the task started.  The smaller the returned
N * number the closer the task has come to overflowing its stack.
N *
N * @param xTask Handle of the task associated with the stack to be checked.
N * Set xTask to NULL to check the stack of the calling task.
N *
N * @return The smallest amount of free stack space there has been (in words, so
N * actual spaces on the stack rather than bytes) since the task referenced by
N * xTask was created.
N */
NUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;
N
N/* When using trace macros it is sometimes necessary to include task.h before
NFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,
Nso the following two prototypes will cause a compilation error.  This can be
Nfixed by simply guarding against the inclusion of these two prototypes unless
Nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
Nconstant. */
N#ifdef configUSE_APPLICATION_TASK_TAG
N	#if configUSE_APPLICATION_TASK_TAG == 1
X	#if 0 == 1
S		/**
S		 * task.h
S		 * <pre>void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );</pre>
S		 *
S		 * Sets pxHookFunction to be the task hook function used by the task xTask.
S		 * Passing xTask as NULL has the effect of setting the calling tasks hook
S		 * function.
S		 */
S		void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;
S
S		/**
S		 * task.h
S		 * <pre>void xTaskGetApplicationTaskTag( TaskHandle_t xTask );</pre>
S		 *
S		 * Returns the pxHookFunction value assigned to the task xTask.
S		 */
S		TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
N	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
N#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
N
N#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X#if( 0 > 0 )
S
S	/* Each task contains an array of pointers that is dimensioned by the
S	configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The
S	kernel does not use the pointers itself, so the application writer can use
S	the pointers for any purpose they wish.  The following two functions are
S	used to set and query a pointer respectively. */
S	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;
S	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;
S
N#endif
N
N/**
N * task.h
N * <pre>BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</pre>
N *
N * Calls the hook function associated with xTask.  Passing xTask as NULL has
N * the effect of calling the Running tasks (the calling task) hook function.
N *
N * pvParameter is passed to the hook function for the task to interpret as it
N * wants.  The return value is the value returned by the task hook function
N * registered by the user.
N */
NBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) ;
N
N/**
N * xTaskGetIdleTaskHandle() is only available if
N * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
N *
N * Simply returns the handle of the idle task.  It is not valid to call
N * xTaskGetIdleTaskHandle() before the scheduler has been started.
N */
NTaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetIdleTaskHandle( void ) ;
N
N/**
N * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for
N * uxTaskGetSystemState() to be available.
N *
N * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in
N * the system.  TaskStatus_t structures contain, among other things, members
N * for the task handle, task name, task priority, task state, and total amount
N * of run time consumed by the task.  See the TaskStatus_t structure
N * definition in this file for the full member list.
N *
N * NOTE:  This function is intended for debugging use only as its use results in
N * the scheduler remaining suspended for an extended period.
N *
N * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.
N * The array must contain at least one TaskStatus_t structure for each task
N * that is under the control of the RTOS.  The number of tasks under the control
N * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
N *
N * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
N * parameter.  The size is specified as the number of indexes in the array, or
N * the number of TaskStatus_t structures contained in the array, not by the
N * number of bytes in the array.
N *
N * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
N * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
N * total run time (as defined by the run time stats clock, see
N * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.
N * pulTotalRunTime can be set to NULL to omit the total run time information.
N *
N * @return The number of TaskStatus_t structures that were populated by
N * uxTaskGetSystemState().  This should equal the number returned by the
N * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
N * in the uxArraySize parameter was too small.
N *
N * Example usage:
N   <pre>
N    // This example demonstrates how a human readable table of run time stats
N	// information is generated from raw data provided by uxTaskGetSystemState().
N	// The human readable table is written to pcWriteBuffer
N	void vTaskGetRunTimeStats( char *pcWriteBuffer )
N	{
N	TaskStatus_t *pxTaskStatusArray;
N	volatile UBaseType_t uxArraySize, x;
N	uint32_t ulTotalRunTime, ulStatsAsPercentage;
N
N		// Make sure the write buffer does not contain a string.
N		*pcWriteBuffer = 0x00;
N
N		// Take a snapshot of the number of tasks in case it changes while this
N		// function is executing.
N		uxArraySize = uxTaskGetNumberOfTasks();
N
N		// Allocate a TaskStatus_t structure for each task.  An array could be
N		// allocated statically at compile time.
N		pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );
N
N		if( pxTaskStatusArray != NULL )
N		{
N			// Generate raw status information about each task.
N			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
N
N			// For percentage calculations.
N			ulTotalRunTime /= 100UL;
N
N			// Avoid divide by zero errors.
N			if( ulTotalRunTime > 0 )
N			{
N				// For each populated position in the pxTaskStatusArray array,
N				// format the raw data as human readable ASCII data
N				for( x = 0; x < uxArraySize; x++ )
N				{
N					// What percentage of the total run time has the task used?
N					// This will always be rounded down to the nearest integer.
N					// ulTotalRunTimeDiv100 has already been divided by 100.
N					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
N
N					if( ulStatsAsPercentage > 0UL )
N					{
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
N					}
N					else
N					{
N						// If the percentage is zero here then the task has
N						// consumed less than 1% of the total run time.
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
N					}
N
N					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
N				}
N			}
N
N			// The array is no longer needed, free the memory it consumes.
N			vPortFree( pxTaskStatusArray );
N		}
N	}
N	</pre>
N */
NUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) ;
N
N/**
N * task. h
N * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
N *
N * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
N * both be defined as 1 for this function to be available.  See the
N * configuration section of the FreeRTOS.org website for more information.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Lists all the current tasks, along with their current state and stack
N * usage high water mark.
N *
N * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
N * suspended ('S').
N *
N * PLEASE NOTE:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskList() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays task
N * names, states and stack usage.
N *
N * vTaskList() has a dependency on the sprintf() C library function that might
N * bloat the code size, use a lot of stack, and provide different results on
N * different platforms.  An alternative, tiny, third party, and limited
N * functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState()
N * directly to get access to raw stats data, rather than indirectly through a
N * call to vTaskList().
N *
N * @param pcWriteBuffer A buffer into which the above mentioned details
N * will be written, in ASCII form.  This buffer is assumed to be large
N * enough to contain the generated report.  Approximately 40 bytes per
N * task should be sufficient.
N *
N * \defgroup vTaskList vTaskList
N * \ingroup TaskUtils
N */
Nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskList( char * pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
N *
N * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
N * must both be defined as 1 for this function to be available.  The application
N * must also then provide definitions for
N * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
N * to configure a peripheral timer/counter and return the timers current count
N * value respectively.  The counter should be at least 10 times the frequency of
N * the tick count.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
N * accumulated execution time being stored for each task.  The resolution
N * of the accumulated time value depends on the frequency of the timer
N * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
N * Calling vTaskGetRunTimeStats() writes the total execution time of each
N * task into a buffer, both as an absolute count value and as a percentage
N * of the total system execution time.
N *
N * NOTE 2:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays the
N * amount of time each task has spent in the Running state in both absolute and
N * percentage terms.
N *
N * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
N * that might bloat the code size, use a lot of stack, and provide different
N * results on different platforms.  An alternative, tiny, third party, and
N * limited functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState() directly
N * to get access to raw stats data, rather than indirectly through a call to
N * vTaskGetRunTimeStats().
N *
N * @param pcWriteBuffer A buffer into which the execution times will be
N * written, in ASCII form.  This buffer is assumed to be large enough to
N * contain the generated report.  Approximately 40 bytes per task should
N * be sufficient.
N *
N * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
N * \ingroup TaskUtils
N */
Nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N *  pulPreviousNotificationValue -
N *  Can be used to pass out the subject task's notification value before any
N *  bits are modified by the notify function.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) ;
N#define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
N#define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotify() that can be used from an interrupt service routine
N * (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
N * be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) ;
N#define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
N#define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
N * will be cleared in the calling task's notification value before the task
N * checks to see if any notifications are pending, and optionally blocks if no
N * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
N * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have
N * the effect of resetting the task's notification value to 0.  Setting
N * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.
N *
N * @param ulBitsToClearOnExit If a notification is pending or received before
N * the calling task exits the xTaskNotifyWait() function then the task's
N * notification value (see the xTaskNotify() API function) is passed out using
N * the pulNotificationValue parameter.  Then any bits that are set in
N * ulBitsToClearOnExit will be cleared in the task's notification value (note
N * *pulNotificationValue is set before any bits are cleared).  Setting
N * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
N * (if limits.h is not included) will have the effect of resetting the task's
N * notification value to 0 before the function exits.  Setting
N * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
N * when the function exits (in which case the value passed out in
N * pulNotificationValue will match the task's notification value).
N *
N * @param pulNotificationValue Used to pass the task's notification value out
N * of the function.  Note the value passed out will not be effected by the
N * clearing of any bits caused by ulBitsToClearOnExit being non-zero.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for a notification to be received, should a notification
N * not already be pending when xTaskNotifyWait() was called.  The task
N * will not consume any processing time while it is in the Blocked state.  This
N * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be
N * used to convert a time specified in milliseconds to a time specified in
N * ticks.
N *
N * @return If a notification was received (including notifications that were
N * already pending when xTaskNotifyWait was called) then pdPASS is
N * returned.  Otherwise pdFAIL is returned.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * xTaskNotifyGive() is a helper macro intended for use when task notifications
N * are used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,
N * the equivalent action that instead uses a task notification is
N * xTaskNotifyGive().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the
N * eAction parameter set to eIncrement - so pdPASS is always returned.
N *
N * \defgroup xTaskNotifyGive xTaskNotifyGive
N * \ingroup TaskNotifications
N */
N#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
N
N/**
N * task. h
N * <PRE>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotifyGive() that can be called from an interrupt service
N * routine (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * vTaskNotifyGiveFromISR() is intended for use when task notifications are
N * used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given from an ISR using the
N * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
N * a task notification is vTaskNotifyGiveFromISR().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
N * should be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
Nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
Xvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) ;
N
N/**
N * task. h
N * <PRE>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * ulTaskNotifyTake() is intended for use when a task notification is used as a
N * faster and lighter weight binary or counting semaphore alternative.  Actual
N * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the
N * equivalent action that instead uses a task notification is
N * ulTaskNotifyTake().
N *
N * When a task is using its notification value as a binary or counting semaphore
N * other tasks should send notifications to it using the xTaskNotifyGive()
N * macro, or xTaskNotify() function with the eAction parameter set to
N * eIncrement.
N *
N * ulTaskNotifyTake() can either clear the task's notification value to
N * zero on exit, in which case the notification value acts like a binary
N * semaphore, or decrement the task's notification value on exit, in which case
N * the notification value acts like a counting semaphore.
N *
N * A task can use ulTaskNotifyTake() to [optionally] block to wait for a
N * the task's notification value to be non-zero.  The task does not consume any
N * CPU time while it is in the Blocked state.
N *
N * Where as xTaskNotifyWait() will return when a notification is pending,
N * ulTaskNotifyTake() will return when the task's notification value is
N * not zero.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
N * notification value is decremented when the function exits.  In this way the
N * notification value acts like a counting semaphore.  If xClearCountOnExit is
N * not pdFALSE then the task's notification value is cleared to zero when the
N * function exits.  In this way the notification value acts like a binary
N * semaphore.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for the task's notification value to be greater than zero,
N * should the count not already be greater than zero when
N * ulTaskNotifyTake() was called.  The task will not consume any processing
N * time while it is in the Blocked state.  This is specified in kernel ticks,
N * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time
N * specified in milliseconds to a time specified in ticks.
N *
N * @return The task's notification count before it is either cleared to zero or
N * decremented (see the xClearCountOnExit parameter).
N *
N * \defgroup ulTaskNotifyTake ulTaskNotifyTake
N * \ingroup TaskNotifications
N */
Nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );</pre>
N *
N * If the notification state of the task referenced by the handle xTask is
N * eNotified, then set the task's notification state to eNotWaitingNotification.
N * The task's notification value is not altered.  Set xTask to NULL to clear the
N * notification state of the calling task.
N *
N * @return pdTRUE if the task's notification state was set to
N * eNotWaitingNotification, otherwise pdFALSE.
N * \defgroup xTaskNotifyStateClear xTaskNotifyStateClear
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
N
N/*-----------------------------------------------------------
N * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
N *----------------------------------------------------------*/
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Called from the real time kernel tick (either preemptive or cooperative),
N * this increments the tick count and checks if any tasks that are blocked
N * for a finite period required removing from a blocked list and placing on
N * a ready list.  If a non-zero value is returned then a context switch is
N * required because either:
N *   + A task was removed from a blocked list because its timeout had expired,
N *     or
N *   + Time slicing is in use and there is a task of equal priority to the
N *     currently running task.
N */
NBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskIncrementTick( void ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes the calling task from the ready list and places it both
N * on the list of tasks waiting for a particular event, and the
N * list of delayed tasks.  The task will be removed from both lists
N * and replaced on the ready list should either the event occur (and
N * there be no higher priority tasks waiting on the same event) or
N * the delay period expires.
N *
N * The 'unordered' version replaces the event list item value with the
N * xItemValue value, and inserts the list item at the end of the list.
N *
N * The 'ordered' version uses the existing event list item value (which is the
N * owning tasks priority) to insert the list item into the event list is task
N * priority order.
N *
N * @param pxEventList The list containing tasks that are blocked waiting
N * for the event to occur.
N *
N * @param xItemValue The item value to use for the event list item when the
N * event list is not ordered by task priority.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait
N * for the event to occur.  This is specified in kernel ticks,the constant
N * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time
N * period.
N */
Nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
Nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * This function performs nearly the same function as vTaskPlaceOnEventList().
N * The difference being that this function does not permit tasks to block
N * indefinitely, whereas vTaskPlaceOnEventList() does.
N *
N */
Nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes a task from both the specified event list and the list of blocked
N * tasks, and places it on a ready queue.
N *
N * xTaskRemoveFromEventList()/xTaskRemoveFromUnorderedEventList() will be called
N * if either an event occurs to unblock a task, or the block timeout period
N * expires.
N *
N * xTaskRemoveFromEventList() is used when the event list is in task priority
N * order.  It removes the list item from the head of the event list as that will
N * have the highest priority owning task of all the tasks on the event list.
N * xTaskRemoveFromUnorderedEventList() is used when the event list is not
N * ordered and the event list items hold something other than the owning tasks
N * priority.  In this case the event list item value is updated to the value
N * passed in the xItemValue parameter.
N *
N * @return pdTRUE if the task being removed has a higher priority than the task
N * making the call, otherwise pdFALSE.
N */
NBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
NBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Sets the pointer to the current TCB to the TCB of the highest priority task
N * that is ready to run.
N */
Nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSwitchContext( void ) ;
N
N/*
N * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY
N * THE EVENT BITS MODULE.
N */
NTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;
XTickType_t uxTaskResetEventItemValue( void ) ;
N
N/*
N * Return the handle of the calling task.
N */
NTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetCurrentTaskHandle( void ) ;
N
N/*
N * Capture the current time status for future reference.
N */
Nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;
N
N/*
N * Compare the time status now with that previously captured to see if the
N * timeout has expired.
N */
NBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) ;
N
N/*
N * Shortcut used by the queue implementation to prevent unnecessary call to
N * taskYIELD();
N */
Nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskMissedYield( void ) ;
N
N/*
N * Returns the scheduler state as taskSCHEDULER_RUNNING,
N * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
N */
NBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGetSchedulerState( void ) ;
N
N/*
N * Raises the priority of the mutex holder to that of the calling task should
N * the mutex holder have a priority less than the calling task.
N */
Nvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
Xvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Set the priority of a task back to its proper priority in the case that it
N * inherited a higher priority while it was holding a semaphore.
N */
NBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
N */
NUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;
N
N/*
N * Set the uxTaskNumber of the task referenced by the xTask parameter to
N * uxHandle.
N */
Nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) ;
N
N/*
N * Only available when configUSE_TICKLESS_IDLE is set to 1.
N * If tickless mode is being used, or a low power mode is implemented, then
N * the tick interrupt will not execute during idle periods.  When this is the
N * case, the tick count value maintained by the scheduler needs to be kept up
N * to date with the actual execution time by being skipped forward by a time
N * equal to the idle period.
N */
Nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;
Xvoid vTaskStepTick( const TickType_t xTicksToJump ) ;
N
N/*
N * Only avilable when configUSE_TICKLESS_IDLE is set to 1.
N * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
N * specific sleep function to determine if it is ok to proceed with the sleep,
N * and if it is ok to proceed, if it is ok to sleep indefinitely.
N *
N * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
N * called with the scheduler suspended, not from within a critical section.  It
N * is therefore possible for an interrupt to request a context switch between
N * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
N * entered.  eTaskConfirmSleepModeStatus() should be called from a short
N * critical section between the timer being stopped and the sleep mode being
N * entered to ensure it is ok to proceed into the sleep mode.
N */
NeSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;
XeSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;
N
N/*
N * For internal use only.  Increment the mutex held count when a mutex is
N * taken and return the handle of the task that has taken the mutex.
N */
Nvoid *pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;
Xvoid *pvTaskIncrementMutexHeldCount( void ) ;
N
N#ifdef __cplusplus
S}
N#endif
N#endif /* INC_TASK_H */
N
N
N
L 46 "..\main.c" 2
N
N/* Priorities for the demo application tasks. */
N#define setDEFAULT_PRIORITY		( tskIDLE_PRIORITY )
N#define setLOW_PRIORITY			( setDEFAULT_PRIORITY + 1 )
N#define setMEDIUM_PRIORITY 		( setLOW_PRIORITY + 1 )
N#define setHIGH_PRIORITY 			( setMEDIUM_PRIORITY + 1 )
N
N
NTaskHandle_t xTaskemWinHandle, xTaskLogMsg1sHandle, xTaskLogMsg5sHandle;
N
Nuint8_t *g_VAFrameBuf;
N
N//volatile int ts_flag;
Nextern void TouchTask(void);
N
N#ifdef __USE_SD__
SFATFS FatFs[_VOLUMES];      /* File system object for logical drive */
S
S__align(32) BYTE Buff[1024] ;       /* Working buffer */
S
SFIL hFile;
N#else
Nuint32_t * g_pu32Res;
Nuint8_t DestArray[1024];
N#endif
N
Nextern int ts_writefile(void);
Nextern int ts_readfile(void);
Nextern int ts_calibrate(int xsize, int ysize);
Nextern int ts_phy2log(int *sumx, int *sumy);
Nextern int ts_test(int xsize, int ysize);
N
N#ifdef __USE_SD__
S/*---------------------------------------------------------*/
S/* User Provided RTC Function for FatFs module             */
S/*---------------------------------------------------------*/
S/* This is a real time clock service to be called from     */
S/* FatFs module. Any valid time must be returned even if   */
S/* the system does not support an RTC.                     */
S/* This function is not required in read-only cfg.         */
S
Sunsigned long get_fattime (void)
S{
S    unsigned long tmr;
S
S    tmr=0x00000;
S
S    return tmr;
S}
N#endif
N
Nvoid LCD_initial(void)
N{
N    // Configure multi-function pin for LCD interface
N    //GPG6 (CLK), GPG7 (HSYNC)
N    outpw(REG_SYS_GPG_MFPL, (inpw(REG_SYS_GPG_MFPL)& ~0xFF000000) | 0x22000000);
X    *((volatile unsigned int *)((0xB0000000+0x0A0))) = ((*((volatile unsigned int *)((0xB0000000+0x0A0))))& ~0xFF000000) | 0x22000000;
N    //GPG8 (VSYNC), GPG9 (DEN)
N    outpw(REG_SYS_GPG_MFPH, (inpw(REG_SYS_GPG_MFPH)& ~0xFF) | 0x22);
X    *((volatile unsigned int *)((0xB0000000+0x0A4))) = ((*((volatile unsigned int *)((0xB0000000+0x0A4))))& ~0xFF) | 0x22;
N
N    //DATA pin
N    //GPA0 ~ GPA7 (DATA0~7)
N    outpw(REG_SYS_GPA_MFPL, 0x22222222);
X    *((volatile unsigned int *)((0xB0000000+0x070))) = 0x22222222;
N    //GPA8 ~ GPA15 (DATA8~15)
N    outpw(REG_SYS_GPA_MFPH, 0x22222222);
X    *((volatile unsigned int *)((0xB0000000+0x074))) = 0x22222222;
N#ifdef _PANEL_FW070TFT_24BPP_
S    //GPD8 ~ GPD15 (DATA16~23)
S    outpw(REG_SYS_GPD_MFPH, 0x22222222);
N#endif
N
N#ifdef _PANEL_E50A2V1_16BPP_
N    // LCD clock is selected from UPLL and divide to 20MHz
N    outpw(REG_CLK_DIVCTL1, (inpw(REG_CLK_DIVCTL1) & ~0xff1f) | 0xe18);
X    *((volatile unsigned int *)((0xB0000200+0x24))) = ((*((volatile unsigned int *)((0xB0000200+0x24)))) & ~0xff1f) | 0xe18;
N#endif
N#ifdef _PANEL_FW070TFT_24BPP_
S    // LCD clock is selected from UPLL and divide to 30MHz
S    outpw(REG_CLK_DIVCTL1, (inpw(REG_CLK_DIVCTL1) & ~0xff1f) | 0x918);
N#endif
N
N#ifdef _PANEL_E50A2V1_16BPP_
N    // Init LCD interface for E50A2V1 LCD module
N    vpostLCMInit(DIS_PANEL_E50A2V1);
X    vpostLCMInit(0);
N#endif
N#ifdef _PANEL_FW070TFT_24BPP_
S    // Init LCD interface for FW070TFT LCD module
S    vpostLCMInit(DIS_PANEL_FW070TFT);
N#endif
N    // Set scale to 1:1
N    vpostVAScalingCtrl(1, 0, 1, 0, VA_SCALE_INTERPOLATION);
X    vpostVAScalingCtrl(1, 0, 1, 0, (0));
N
N    // Set display color depth
N#ifdef _PANEL_E50A2V1_16BPP_
N    vpostSetVASrc(VA_SRC_RGB565);
X    vpostSetVASrc((4<<8 ));
N#endif
N#ifdef _PANEL_FW070TFT_24BPP_
S    vpostSetVASrc(VA_SRC_RGB888);
N#endif
N
N    // Get pointer of video frame buffer
N    // Note: before get pointer of frame buffer, must set display color depth first
N    g_VAFrameBuf = vpostGetFrameBuffer();
N    if(g_VAFrameBuf == NULL)
X    if(g_VAFrameBuf == 0)
N    {
N        sysprintf("Get buffer error !!\n");
N        while(1);
N    }
N
N    if((UINT32)g_VAFrameBuf == BIT31)
X    if((UINT32)g_VAFrameBuf == (0x80000000))
N    {
N        sysprintf("Get buffer error !!\n");
N        while(1);
N    }
N
N#ifdef _PANEL_E50A2V1_16BPP_
N    memset((void *)g_VAFrameBuf, 0, LCD_XSIZE*LCD_YSIZE*2);
X    memset((void *)g_VAFrameBuf, 0, 800*480*2);
N#endif
N#ifdef _PANEL_FW070TFT_24BPP_
S    memset((void *)g_VAFrameBuf, 0, LCD_XSIZE*LCD_YSIZE*4);
N#endif
N
N    // Start video
N    //vpostVAStartTrigger();
N}
N
N//extern volatile int OS_TimeMS;
Nvolatile int g_enable_Touch;
N
N//void TMR0_IRQHandler(void)
N//{
N//    OS_TimeMS++;
N//}
N
Nvoid TMR0_IRQHandler_TouchTask(void)
N{
N    //sysprintf("g_enable_Touch=%d\n", g_enable_Touch);
N    if ( g_enable_Touch == 1 )
N    {
N        //sysprintf("enable_Touch=%d\n", g_enable_Touch);
N        TouchTask();
N    }
N}
N
N#ifdef __USE_SD__
SBYTE SD_Drv; // select SD0
Sunsigned int volatile gCardInit = 0;
Svoid SDH_IRQHandler(void)
S{
S    unsigned int volatile isr;
S
S    // FMI data abort interrupt
S    if (inpw(REG_SDH_GINTSTS) & SDH_GINTSTS_DTAIF_Msk)
S    {
S        /* ResetAllEngine() */
S        outpw(REG_SDH_GCTL, inpw(REG_SDH_GCTL) | SDH_GCTL_GCTLRST_Msk);
S        outpw(REG_SDH_GINTSTS, SDH_GINTSTS_DTAIF_Msk);
S    }
S
S    //----- SD interrupt status
S    isr = inpw(REG_SDH_INTSTS);
S    if (isr & SDH_INTSTS_BLKDIF_Msk)        // block down
S    {
S        _sd_SDDataReady = TRUE;
S        outpw(REG_SDH_INTSTS, SDH_INTSTS_BLKDIF_Msk);
S    }
S
S    if (isr & SDH_INTSTS_CDIF0_Msk)   // port 0 card detect
S    {
S        //----- SD interrupt status
S        // it is work to delay 50 times for SD_CLK = 200KHz
S        {
S            volatile int i;         // delay 30 fail, 50 OK
S            for (i=0; i<0x500; i++);   // delay to make sure got updated value from REG_SDISR.
S            isr = inpw(REG_SDH_INTSTS);
S        }
S
S#ifdef _USE_DAT3_DETECT_
S        if (!(isr & SDH_INTSTS_CDSTS0_Msk))
S        {
S            SD0.IsCardInsert = FALSE;
S            sysprintf("\nCard Remove!\n");
S            SD_Close_Disk(0);
S        }
S        else
S        {
S            SD_Open_Disk(SD_PORT0 | CardDetect_From_DAT3);
S        }
S#else
S        if (isr & SDH_INTSTS_CDSTS0_Msk)
S        {
S            SD0.IsCardInsert = FALSE;   // SDISR_CD_Card = 1 means card remove for GPIO mode
S            gCardInit = 0;
S            sysprintf("\nCard Remove!\n");
S            SD_Close_Disk(0);
S        }
S        else
S        {
S            gCardInit = 1;
S            //SD_Open_Disk(SD_PORT0 | CardDetect_From_GPIO);
S        }
S#endif
S
S        outpw(REG_SDH_INTSTS, SDH_INTSTS_CDIF0_Msk);
S    }
S
S    if (isr & SDH_INTSTS_CDIF1_Msk)   // port 1 card detect
S    {
S        //----- SD interrupt status
S        // it is work to delay 50 times for SD_CLK = 200KHz
S        {
S            volatile int i;         // delay 30 fail, 50 OK
S            for (i=0; i<0x500; i++);   // delay to make sure got updated value from REG_SDISR.
S            isr = inpw(REG_SDH_INTSTS);
S        }
S
S#ifdef _USE_DAT3_DETECT_
S        if (!(isr & SDH_INTSTS_CDSTS1_Msk))
S        {
S            SD0.IsCardInsert = FALSE;
S            sysprintf("\nCard Remove!\n");
S            SD_Close_Disk(1);
S        }
S        else
S        {
S            SD_Open_Disk(SD_PORT1 | CardDetect_From_DAT3);
S        }
S#else
S        if (isr & SDH_INTSTS_CDSTS1_Msk)
S        {
S            SD0.IsCardInsert = FALSE;   // SDISR_CD_Card = 1 means card remove for GPIO mode
S            sysprintf("\nCard Remove!\n");
S            SD_Close_Disk(1);
S        }
S        else
S        {
S            SD_Open_Disk(SD_PORT1 | CardDetect_From_GPIO);
S        }
S#endif
S
S        outpw(REG_SDH_INTSTS, SDH_INTSTS_CDIF1_Msk);
S    }
S
S    // CRC error interrupt
S    if (isr & SDH_INTSTS_CRCIF_Msk)
S    {
S        if (!(isr & SDH_INTSTS_CRC16_Msk))
S        {
S            //sysprintf("***** ISR sdioIntHandler(): CRC_16 error !\n");
S            // handle CRC error
S        }
S        else if (!(isr & SDH_INTSTS_CRC7_Msk))
S        {
S            extern unsigned int _sd_uR3_CMD;
S            if (! _sd_uR3_CMD)
S            {
S                //sysprintf("***** ISR sdioIntHandler(): CRC_7 error !\n");
S                // handle CRC error
S            }
S        }
S        outpw(REG_SDH_INTSTS, SDH_INTSTS_CRCIF_Msk);      // clear interrupt flag
S    }
S}
N#endif
N
Nvoid SYS_Init(void)
N{
N#ifdef __USE_SD__
S    /* enable SDH */
S    outpw(REG_CLK_HCLKEN, inpw(REG_CLK_HCLKEN) | 0x40000000);
S
S    /* select multi-function-pin */
S    /* SD Port 0 -> PD0~7 */
S    outpw(REG_SYS_GPD_MFPL, 0x66666666);
S    SD_Drv = 0;
N#endif
N
N#if 0 // port 1
S    /* initial SD1 pin -> PI5~10, 12~13 */
S    outpw(REG_SYS_GPI_MFPL, inpw(REG_SYS_GPI_MFPL) & ~0xfff00000 | 0x44400000);
S    outpw(REG_SYS_GPI_MFPH, inpw(REG_SYS_GPI_MFPH) & ~0x00ff0fff | 0x00440444);
S    SD_Drv = 1;
N#endif
N
N}
N
Nvoid vTaskLogMsg500ms( void *pvParameters )
N{	
N	static uint32_t Cnt_LogMsg = 0;
N	uint32_t millisec = 500;
N
N//	portTickType xLastWakeTime;
N//	xLastWakeTime = xTaskGetTickCount();
N
N	(void) pvParameters;
N	for( ;; )
N	{
N//        vTaskDelayUntil( &xLastWakeTime, ( millisec *configTICK_RATE_HZ / ( ( TickType_t ) 1000 ) ));
N		GUI_X_Delay(millisec);			
N		sysprintf("vTaskLogMsg500ms:Log(%4dms):%4d (%4d bytes,%4d bytes)\r\n" ,millisec ,++Cnt_LogMsg,xPortGetFreeHeapSize(),GUI_ALLOC_GetNumFreeBytes());
N
N	}
N  
N}
N
Nvoid vTaskLogMsg5s( void *pvParameters )
N{	
N	static uint32_t Cnt_LogMsg = 0;
N	uint32_t millisec = 5000;
N
N//	portTickType xLastWakeTime;
N//	xLastWakeTime = xTaskGetTickCount();
N
N	(void) pvParameters;
N	for( ;; )
N	{
N//        vTaskDelayUntil( &xLastWakeTime, ( millisec *configTICK_RATE_HZ / ( ( TickType_t ) 1000 ) ));
N		GUI_X_Delay(millisec);			
N		sysprintf("vTaskLogMsg5s:Log(%4dms):%4d (%4d bytes,%4d bytes)\r\n" ,millisec ,++Cnt_LogMsg,xPortGetFreeHeapSize(),GUI_ALLOC_GetNumFreeBytes());
N
N	}
N  
N}
N
Nvoid vTaskLogMsg1s( void *pvParameters )
N{	
N	static uint32_t Cnt_LogMsg = 0;
N	uint32_t millisec = 1000;
N
N//	portTickType xLastWakeTime;
N//	xLastWakeTime = xTaskGetTickCount();
N
N	(void) pvParameters;
N	for( ;; )
N	{
N//        vTaskDelayUntil( &xLastWakeTime, ( millisec *configTICK_RATE_HZ / ( ( TickType_t ) 1000 ) ));
N		GUI_X_Delay(millisec);		
N		sysprintf("vTaskLogMsg1s:Log(%4dms):%4d (%4d bytes,%4d bytes)\r\n" ,millisec ,++Cnt_LogMsg,xPortGetFreeHeapSize(),GUI_ALLOC_GetNumFreeBytes());
N
N	}
N  
N}
N
N
NWM_HWIN CreateFramewin(void);
XGUI_HWIN CreateFramewin(void);
Nvoid MainTask(void)
N{
N    WM_HWIN hWin;
X    GUI_HWIN hWin;
N    char     acVersion[40] = "Framewin: Version of emWin: ";
N//	static uint32_t cnt = 0;
N
N    GUI_Init();
N    hWin = CreateFramewin();
N    strcat(acVersion, GUI_GetVersionString());
N    FRAMEWIN_SetText(hWin, acVersion);
N
N    while (1)
N    {
N		//Below API both work
N        GUI_Delay(100);
N//		GUI_Exec();
N
N//		sysprintf("MainTask:%d (%4d)\r\n" ,eTaskGetState(xTaskemWinHandle),cnt++);
N
N    }
N}
N
N
Nvoid prvSetupHardware( void )
N{
N    /* Perform the hardware setup required.  This is minimal as most of the
N    setup is managed by the settings in the project file. */
N
N#ifdef __USE_SD__
S    FRESULT     res;
N#else
N    uint16_t u16ID;
N#endif
N
N    *((volatile unsigned int *)REG_AIC_MDCR)=0xFFFFFFFF;  // disable all interrupt channel
X    *((volatile unsigned int *)(0xB8002000+0x138))=0xFFFFFFFF;  
N    *((volatile unsigned int *)REG_AIC_MDCRH)=0xFFFFFFFF;  // disable all interrupt channel
X    *((volatile unsigned int *)(0xB8002000+0x13C))=0xFFFFFFFF;  
N    *(volatile unsigned int *)(CLK_BA+0x18) |= (1<<16); /* Enable UART0 */
X    *(volatile unsigned int *)(0xB0000200+0x18) |= (1<<16);  
N    *(volatile unsigned int *)(CLK_BA+0x18) |= (1<<3); /* Enable GPIO */
X    *(volatile unsigned int *)(0xB0000200+0x18) |= (1<<3);  
N    sysDisableCache();
N    sysFlushCache(I_D_CACHE);
X    sysFlushCache(8);
N    sysEnableCache(CACHE_WRITE_BACK);
X    sysEnableCache(0);
N    sysInitializeUART();
N
N#ifdef GUI_SUPPORT_TOUCH
N    g_enable_Touch = 0;
N#endif
N
N//    OS_TimeMS = 0;
N
N    SYS_Init();
N
N    sysSetTimerReferenceClock(TIMER0, 12000000);
X    sysSetTimerReferenceClock(0, 12000000);
N    sysStartTimer(TIMER0, 1000, PERIODIC_MODE);         /* 1000 ticks/per sec ==> 1tick/1ms */
X    sysStartTimer(0, 1000, 1);          
N//    sysSetTimerEvent(TIMER0,  1, (PVOID)TMR0_IRQHandler);           /*  1 tick  per call back */
N    sysSetTimerEvent(TIMER0, 10, (PVOID)TMR0_IRQHandler_TouchTask); /* 10 ticks per call back */
X    sysSetTimerEvent(0, 10, (PVOID)TMR0_IRQHandler_TouchTask);  
N
N#ifdef __USE_SD__
S    sysInstallISR(HIGH_LEVEL_SENSITIVE|IRQ_LEVEL_1, SDH_IRQn, (PVOID)SDH_IRQHandler);
S    sysEnableInterrupt(SDH_IRQn);
N#endif
N
N    sysSetLocalInterrupt(ENABLE_IRQ);
X    sysSetLocalInterrupt(0x7F);
N
N    sysprintf("+-------------------------------------------------+\n");
N    sysprintf("|                 Tslib Sample Code               |\n");
N    sysprintf("+-------------------------------------------------+\n\n");
N    LCD_initial();
N
N#ifdef GUI_SUPPORT_TOUCH
N    Init_TouchPanel();
N
N#ifdef __USE_SD__
S    SD_SetReferenceClock(300000);
S    SD_Open_Disk(SD_PORT0 | CardDetect_From_GPIO);
S    if (gCardInit)
S    {
S        gCardInit = 0;
S        SD_Open_Disk(SD_PORT0 | CardDetect_From_GPIO);
S    }
S
S    if(!(SD_CardDetection(SD_Drv)))
S        while(1);
S    sysprintf("rc=%d\n", (WORD)disk_initialize(0));
S    disk_read(0, Buff, 2, 1);
S    f_mount(&FatFs[0], "", 0);  // for FATFS v0.11
N#endif
N
N    GUI_Init();
N
N#ifdef __USE_SD__
S    res = f_open(&hFile, "0:\\ts_calib", FA_OPEN_EXISTING | FA_READ);
S    if (res)
S    {
S        // file does not exists, so do calibration
S        res = f_open(&hFile, "0:\\ts_calib", FA_CREATE_ALWAYS | FA_WRITE);
S        if ( res )
S        {
S            f_close(&hFile);
S            GUI_DispStringAt("CANNOT create the calibration file.\nPlease insert a SD card then reboot.", 0, 0);
S            while(1);
S        }
S
S        ts_calibrate(__DEMO_TS_WIDTH__, __DEMO_TS_HEIGHT__);
S        //GUI_SetDrawMode(GUI_DRAWMODE_NORMAL);
S        ts_writefile();
S    }
S    else
S    {
S        ts_readfile();
S    }
S    f_close(&hFile);
N#else
N    _DemoSpiInit();
N
N    // check flash id
N    if((u16ID = SpiFlash_ReadMidDid()) == 0xEF17)
N        sysprintf("Flash found: W25Q128BV ...\n");
N    else
N        sysprintf("Flash ID, 0x%x\n", u16ID);
N
N    SpiFlash_NormalRead(__DEMO_TSFILE_ADDR__, DestArray, 32);
X    SpiFlash_NormalRead(0x00180000, DestArray, 32);
N    g_pu32Res = (uint32_t *)DestArray;
N    sysprintf("%x\n", g_pu32Res[7]);
N    if (g_pu32Res[7] != 0x55AAA55A)
N    {
N        ts_calibrate(XSIZE_PHYS, YSIZE_PHYS);
X        ts_calibrate(800, 480);
N        //GUI_SetDrawMode(GUI_DRAWMODE_NORMAL);
N        sysprintf("Sector Erase ...");
N
N        /* Sector erase SPI flash */
N        SpiFlash_SectorErase(__DEMO_TSFILE_ADDR__);
X        SpiFlash_SectorErase(0x00180000);
N
N        /* Wait ready */
N        SpiFlash_WaitReady();
N
N        ts_writefile();
N        sysprintf("[OK]\n");
N    }
N    else
N        ts_readfile();
N#endif
N
N//    ts_test(__DEMO_TS_WIDTH__, __DEMO_TS_HEIGHT__);
N
N    g_enable_Touch = 1;
N#endif
N
N}
N
Nvoid vTaskemWin( void *pvParameters )
N{
N
N    /* Parameters are not used. */
N    ( void ) pvParameters;
N	MainTask();
N	
N}
N
Nint main(void)
N{
N	prvSetupHardware();
N
N    xTaskCreate( vTaskemWin, "emWin", configMINIMAL_STACK_SIZE*8 , NULL, setMEDIUM_PRIORITY, &xTaskemWinHandle );
X    xTaskCreate( vTaskemWin, "emWin", ( ( unsigned short ) (4 * 1024 / 4) )*8 , 0, ( ( ( ( ( UBaseType_t ) 0U ) ) + 1 ) + 1 ), &xTaskemWinHandle );
N    xTaskCreate( vTaskLogMsg1s, "LogMsg1s", configMINIMAL_STACK_SIZE , NULL, setMEDIUM_PRIORITY, &xTaskLogMsg1sHandle );
X    xTaskCreate( vTaskLogMsg1s, "LogMsg1s", ( ( unsigned short ) (4 * 1024 / 4) ) , 0, ( ( ( ( ( UBaseType_t ) 0U ) ) + 1 ) + 1 ), &xTaskLogMsg1sHandle );
N    xTaskCreate( vTaskLogMsg5s, "LogMsg5s", configMINIMAL_STACK_SIZE , NULL, setMEDIUM_PRIORITY, &xTaskLogMsg5sHandle );
X    xTaskCreate( vTaskLogMsg5s, "LogMsg5s", ( ( unsigned short ) (4 * 1024 / 4) ) , 0, ( ( ( ( ( UBaseType_t ) 0U ) ) + 1 ) + 1 ), &xTaskLogMsg5sHandle );
N    xTaskCreate( vTaskLogMsg500ms, "LogMsg500ms", configMINIMAL_STACK_SIZE , NULL, setMEDIUM_PRIORITY, NULL );
X    xTaskCreate( vTaskLogMsg500ms, "LogMsg500ms", ( ( unsigned short ) (4 * 1024 / 4) ) , 0, ( ( ( ( ( UBaseType_t ) 0U ) ) + 1 ) + 1 ), 0 );
N	
N    vTaskStartScheduler();
N
N    for( ;; );
N	
N//    return 0;
N}
