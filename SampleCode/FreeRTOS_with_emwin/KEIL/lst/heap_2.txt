; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\heap_2.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\heap_2.d --cpu=ARM926EJ-S --apcs=interwork --diag_suppress=9931 -I..\..\..\Driver\Source -I..\..\..\Driver\Include -I..\..\..\ThirdParty\FATFS\src -I..\..\..\ThirdParty\emWin\Config -I..\..\..\ThirdParty\emWin\Include -I..\..\FreeRTOS_with_emwin -I..\tslib -I..\Application -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\portable\RVDS\ARM9_N9H30 -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Demo\Common\include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\Toshiba -D__UVISION_VERSION=526 -D_PANEL_E50A2V1_16BPP_ --omf_browse=.\obj\heap_2.crf ..\..\..\ThirdParty\FreeRTOSV9.0.0\FreeRTOS\Source\portable\MemMang\heap_2.c]
                          ARM

                          AREA ||i.pvPortMalloc||, CODE, READONLY, ALIGN=2

                  pvPortMalloc PROC
;;;159    
;;;160    void *pvPortMalloc( size_t xWantedSize )
000000  e92d4070          PUSH     {r4-r6,lr}
;;;161    {
000004  e1a04000          MOV      r4,r0
;;;162    BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
;;;163    static BaseType_t xHeapHasBeenInitialised = pdFALSE;
;;;164    void *pvReturn = NULL;
000008  e3a05000          MOV      r5,#0
;;;165    
;;;166    	vTaskSuspendAll();
00000c  ebfffffe          BL       vTaskSuspendAll
;;;167    	{
;;;168    		/* If this is the first call to malloc then the heap will require
;;;169    		initialisation to setup the list of free blocks. */
;;;170    		if( xHeapHasBeenInitialised == pdFALSE )
000010  e59f6100          LDR      r6,|L1.280|
000014  e5960004          LDR      r0,[r6,#4]  ; xHeapHasBeenInitialised
000018  e2861008          ADD      r1,r6,#8
00001c  e3500000          CMP      r0,#0
000020  e2863010          ADD      r3,r6,#0x10
000024  1a00000a          BNE      |L1.84|
000028  e59f00ec          LDR      r0,|L1.284|
00002c  e3a0c000          MOV      r12,#0
000030  e3c00007          BIC      r0,r0,#7
000034  e59f20e4          LDR      r2,|L1.288|
000038  e8811001          STM      r1,{r0,r12}
00003c  e5832004          STR      r2,[r3,#4]  ; xEnd, xEnd
000040  e583c000          STR      r12,[r3,#0]
000044  e5802004          STR      r2,[r0,#4]
000048  e5803000          STR      r3,[r0,#0]
;;;171    		{
;;;172    			prvHeapInit();
;;;173    			xHeapHasBeenInitialised = pdTRUE;
00004c  e3a00001          MOV      r0,#1
000050  e5860004          STR      r0,[r6,#4]  ; xHeapHasBeenInitialised
                  |L1.84|
;;;174    		}
;;;175    
;;;176    		/* The wanted size is increased so it can contain a BlockLink_t
;;;177    		structure in addition to the requested amount of bytes. */
;;;178    		if( xWantedSize > 0 )
000054  e3540000          CMP      r4,#0
000058  12844008          ADDNE    r4,r4,#8
;;;179    		{
;;;180    			xWantedSize += heapSTRUCT_SIZE;
;;;181    
;;;182    			/* Ensure that blocks are always aligned to the required number of bytes. */
;;;183    			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
00005c  13140007          TSTNE    r4,#7
;;;184    			{
;;;185    				/* Byte alignment required. */
;;;186    				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
000060  12040007          ANDNE    r0,r4,#7
000064  12600008          RSBNE    r0,r0,#8
;;;187    			}
;;;188    		}
;;;189    
;;;190    		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
000068  e59f20b4          LDR      r2,|L1.292|
00006c  10844000          ADDNE    r4,r4,r0              ;186
000070  e2440001          SUB      r0,r4,#1
000074  e1500002          CMP      r0,r2
;;;191    		{
;;;192    			/* Blocks are stored in byte order - traverse the list from the start
;;;193    			(smallest) block until one of adequate size is found. */
;;;194    			pxPreviousBlock = &xStart;
000078  359f20a8          LDRCC    r2,|L1.296|
;;;195    			pxBlock = xStart.pxNextFreeBlock;
00007c  35911000          LDRCC    r1,[r1,#0]  ; xStart
000080  2a000021          BCS      |L1.268|
                  |L1.132|
;;;196    			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
000084  e5910004          LDR      r0,[r1,#4]
000088  e1500004          CMP      r0,r4
00008c  2a000004          BCS      |L1.164|
000090  e5910000          LDR      r0,[r1,#0]
000094  e3500000          CMP      r0,#0
;;;197    			{
;;;198    				pxPreviousBlock = pxBlock;
000098  11a02001          MOVNE    r2,r1
;;;199    				pxBlock = pxBlock->pxNextFreeBlock;
00009c  11a01000          MOVNE    r1,r0
0000a0  1afffff7          BNE      |L1.132|
                  |L1.164|
;;;200    			}
;;;201    
;;;202    			/* If we found the end marker then a block of adequate size was not found. */
;;;203    			if( pxBlock != &xEnd )
0000a4  e1510003          CMP      r1,r3
0000a8  0a000017          BEQ      |L1.268|
;;;204    			{
;;;205    				/* Return the memory space - jumping over the BlockLink_t structure
;;;206    				at its start. */
;;;207    				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
0000ac  e5920000          LDR      r0,[r2,#0]
0000b0  e2805008          ADD      r5,r0,#8
;;;208    
;;;209    				/* This block is being returned for use so must be taken out of the
;;;210    				list of free blocks. */
;;;211    				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
0000b4  e5910000          LDR      r0,[r1,#0]
;;;212    
;;;213    				/* If the block is larger than required it can be split into two. */
;;;214    				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
0000b8  e5820000          STR      r0,[r2,#0]
0000bc  e5910004          LDR      r0,[r1,#4]
0000c0  e0400004          SUB      r0,r0,r4
0000c4  e3500010          CMP      r0,#0x10
0000c8  9a00000b          BLS      |L1.252|
;;;215    				{
;;;216    					/* This block is to be split into two.  Create a new block
;;;217    					following the number of bytes requested. The void cast is
;;;218    					used to prevent byte alignment warnings from the compiler. */
;;;219    					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
0000cc  e0813004          ADD      r3,r1,r4
;;;220    
;;;221    					/* Calculate the sizes of two blocks split from the single
;;;222    					block. */
;;;223    					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
;;;224    					pxBlock->xBlockSize = xWantedSize;
0000d0  e5830004          STR      r0,[r3,#4]
;;;225    
;;;226    					/* Insert the new block into the list of free blocks. */
;;;227    					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
0000d4  e5814004          STR      r4,[r1,#4]
0000d8  e59f0048          LDR      r0,|L1.296|
0000dc  e593c004          LDR      r12,[r3,#4]
                  |L1.224|
0000e0  e5902000          LDR      r2,[r0,#0]
0000e4  e5924004          LDR      r4,[r2,#4]
0000e8  e154000c          CMP      r4,r12
0000ec  25832000          STRCS    r2,[r3,#0]
0000f0  31a00002          MOVCC    r0,r2
0000f4  25803000          STRCS    r3,[r0,#0]
0000f8  3afffff8          BCC      |L1.224|
                  |L1.252|
;;;228    				}
;;;229    
;;;230    				xFreeBytesRemaining -= pxBlock->xBlockSize;
0000fc  e5910004          LDR      r0,[r1,#4]
000100  e5961000          LDR      r1,[r6,#0]  ; xFreeBytesRemaining
000104  e0410000          SUB      r0,r1,r0
000108  e5860000          STR      r0,[r6,#0]  ; xFreeBytesRemaining
                  |L1.268|
;;;231    			}
;;;232    		}
;;;233    
;;;234    		traceMALLOC( pvReturn, xWantedSize );
;;;235    	}
;;;236    	( void ) xTaskResumeAll();
00010c  ebfffffe          BL       xTaskResumeAll
;;;237    
;;;238    	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
;;;239    	{
;;;240    		if( pvReturn == NULL )
;;;241    		{
;;;242    			extern void vApplicationMallocFailedHook( void );
;;;243    			vApplicationMallocFailedHook();
;;;244    		}
;;;245    	}
;;;246    	#endif
;;;247    
;;;248    	return pvReturn;
000110  e1a00005          MOV      r0,r5
;;;249    }
000114  e8bd8070          POP      {r4-r6,pc}
;;;250    /*-----------------------------------------------------------*/
                          ENDP

                  |L1.280|
                          DCD      ||.data||
                  |L1.284|
                          DCD      ||.bss||+0x8
                  |L1.288|
                          DCD      0x000033f8
                  |L1.292|
                          DCD      0x000033f7
                  |L1.296|
                          DCD      ||.data||+0x8

                          AREA ||i.vPortFree||, CODE, READONLY, ALIGN=2

                  vPortFree PROC
;;;251    
;;;252    void vPortFree( void *pv )
000000  e92d4010          PUSH     {r4,lr}
;;;253    {
;;;254    uint8_t *puc = ( uint8_t * ) pv;
;;;255    BlockLink_t *pxLink;
;;;256    
;;;257    	if( pv != NULL )
000004  e3500000          CMP      r0,#0
;;;258    	{
;;;259    		/* The memory being freed will have an BlockLink_t structure immediately
;;;260    		before it. */
;;;261    		puc -= heapSTRUCT_SIZE;
;;;262    
;;;263    		/* This unexpected casting is to keep some compilers from issuing
;;;264    		byte alignment warnings. */
;;;265    		pxLink = ( void * ) puc;
;;;266    
;;;267    		vTaskSuspendAll();
;;;268    		{
;;;269    			/* Add this block to the list of free blocks. */
;;;270    			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
;;;271    			xFreeBytesRemaining += pxLink->xBlockSize;
;;;272    			traceFREE( pv, pxLink->xBlockSize );
;;;273    		}
;;;274    		( void ) xTaskResumeAll();
;;;275    	}
;;;276    }
000008  08bd8010          POPEQ    {r4,pc}
00000c  e2404008          SUB      r4,r0,#8              ;261
000010  ebfffffe          BL       vTaskSuspendAll
000014  e59f0038          LDR      r0,|L2.84|
000018  e5942004          LDR      r2,[r4,#4]            ;270
                  |L2.28|
00001c  e5901000          LDR      r1,[r0,#0]            ;270
000020  e5913004          LDR      r3,[r1,#4]            ;270
000024  e1530002          CMP      r3,r2                 ;270
000028  31a00001          MOVCC    r0,r1                 ;270
00002c  3afffffa          BCC      |L2.28|
000030  e5841000          STR      r1,[r4,#0]            ;270
000034  e5804000          STR      r4,[r0,#0]            ;271
000038  e59f0018          LDR      r0,|L2.88|
00003c  e5941004          LDR      r1,[r4,#4]            ;271
000040  e5902000          LDR      r2,[r0,#0]            ;271  ; xFreeBytesRemaining
000044  e0811002          ADD      r1,r1,r2              ;271
000048  e5801000          STR      r1,[r0,#0]            ;271  ; xFreeBytesRemaining
00004c  e8bd4010          POP      {r4,lr}               ;274
000050  eafffffe          B        xTaskResumeAll
;;;277    /*-----------------------------------------------------------*/
                          ENDP

                  |L2.84|
                          DCD      ||.data||+0x8
                  |L2.88|
                          DCD      ||.data||

                          AREA ||i.vPortInitialiseBlocks||, CODE, READONLY, ALIGN=2

                  vPortInitialiseBlocks PROC
;;;284    
;;;285    void vPortInitialiseBlocks( void )
000000  e12fff1e          BX       lr
;;;286    {
;;;287    	/* This just exists to keep the linker quiet. */
;;;288    }
;;;289    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xPortGetFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetFreeHeapSize PROC
;;;278    
;;;279    size_t xPortGetFreeHeapSize( void )
000000  e59f0004          LDR      r0,|L4.12|
;;;280    {
;;;281    	return xFreeBytesRemaining;
000004  e5900000          LDR      r0,[r0,#0]  ; xFreeBytesRemaining
;;;282    }
000008  e12fff1e          BX       lr
;;;283    /*-----------------------------------------------------------*/
                          ENDP

                  |L4.12|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ucHeap
                          %        13312

                          AREA ||.data||, DATA, ALIGN=2

                  xFreeBytesRemaining
                          DCD      0x000033f8
                  xHeapHasBeenInitialised
                          DCD      0x00000000
                  xStart
                          %        8
                  xEnd
                          %        8
