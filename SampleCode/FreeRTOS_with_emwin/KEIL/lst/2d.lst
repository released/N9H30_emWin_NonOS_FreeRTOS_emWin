L 1 "..\..\..\Driver\Source\2d.c"
N/**************************************************************************//**
N* @file     2d.c
N* @brief    N9H30 GE2D driver source file
N*
N* @note
N* Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060037
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 9 "..\..\..\Driver\Source\2d.c" 2
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060037
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 10 "..\..\..\Driver\Source\2d.c" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 11 "..\..\..\Driver\Source\2d.c" 2
N
N#include "N9H30.h"
L 1 "..\..\..\Driver\Include\N9H30.h" 1
N/**************************************************************************//**
N * @file     N9H30.h
N * @version  V1.00
N * @brief    N9H30 peripheral access layer header file.
N *           This file contains all the peripheral register's definitions
N *           and memory mapping for NuMicro N9H30 MCU.
N *
N * @copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N/**
N   \mainpage NuMicro N9H30 Family Driver Reference Guide
N   *
N   * <b>Introduction</b>
N   *
N   * This user manual describes the usage of N9H30 family device driver
N   *
N   * <b>Disclaimer</b>
N   *
N   * The Software is furnished "AS IS", without warranty as to performance or results, and
N   * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N   * warranties, express, implied or otherwise, with regard to the Software, its use, or
N   * operation, including without limitation any and all warranties of merchantability, fitness
N   * for a particular purpose, and non-infringement of intellectual property rights.
N   *
N   * <b>Important Notice</b>
N   *
N   * Nuvoton Products are neither intended nor warranted for usage in systems or equipment,
N   * any malfunction or failure of which may cause loss of human life, bodily injury or severe
N   * property damage. Such applications are deemed, "Insecure Usage".
N   *
N   * Insecure usage includes, but is not limited to: equipment for surgical implementation,
N   * atomic energy control instruments, airplane or spaceship instruments, the control or
N   * operation of dynamic, brake or safety systems designed for vehicular use, traffic signal
N   * instruments, all types of safety devices, and other applications intended to support or
N   * sustain life.
N   *
N   * All Insecure Usage shall be made at customer's risk, and in the event that third parties
N   * lay claims to Nuvoton as a result of customer's Insecure Usage, customer shall indemnify
N   * the damages and liabilities thus incurred by Nuvoton.
N   *
N   * Please note that all data and specifications are subject to change without notice. All the
N   * trademarks of products and companies mentioned in this document belong to their respective
N   * owners.
N   *
N   * <b>Copyright Notice</b>
N   *
N   * Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N   */
N
N#ifndef __N9H30_H__
N#define __N9H30_H__
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 54 "..\..\..\Driver\Include\N9H30.h" 2
N
N/** @addtogroup N9H30_PERIPHERAL_MEM_MAP N9H30 Peripheral Memory Base
N  Memory Mapped Structure for N9H30 Peripheral
N  @{
N */
N
N/*!< AHB peripherals */
N#define    SYS_BA    0xB0000000  /*!< System Global Control */
N#define    CLK_BA    0xB0000200  /*!< Clock Control */
N#define    EBI_BA    0xB0001000  /*!< EBI Control */
N#define    SDIC_BA   0xB0001800  /*!< SDRAM (SDR/DDR/DDR2) Control */
N#define    EMC0_BA   0xB0002000  /*!< Ethernet MAC 0 Control */
N#define    EMC1_BA   0xB0003000  /*!< Ethernet MAC 1 Control */
N#define    GDMA_BA   0xB0004000  /*!< GDMA control */
N#define    USBH_BA   0xB0005000  /*!< USB Host EHCI Control */
N#define    USBD_BA   0xB0006000  /*!< USB Device Control */
N#define    USBO_BA   0xB0007000  /*!< OHCI USB Host Control */
N#define    LCM_BA    0xB0008000  /*!< Display, LCM Interface */
N#define    ACTL_BA   0xB0009000  /*!< Audio Control */
N#define    JPEG_BA   0xB000A000  /*!< JPEG Engine Control */
N#define    GE_BA     0xB000B000  /*!< 2-D Graphic Engine */
N#define    SDH_BA    0xB000C000  /*!< SD/SDIO Host Controller */
N#define    FMI_BA    0xB000D000  /*!< Flash Memory Card Interface */
N#define    CAP_BA    0xB000E000  /*!< Sensor (Capture) Interface Control */
N
N/*!< APB peripherals */
N#define    UART0_BA  0xB8000000  /*!< UART0 Control */
N#define    UART1_BA  0xB8000100  /*!< UART1 Control (High-Speed UART) */
N#define    UART2_BA  0xB8000200  /*!< UART2 Control (High-Speed UART) */
N#define    UART3_BA  0xB8000300  /*!< UART3 Control  */
N#define    UART4_BA  0xB8000400  /*!< UART4 Control (High-Speed UART) */
N#define    UART5_BA  0xB8000500  /*!< UART5 Control */
N#define    UART6_BA  0xB8000600  /*!< UART6 Control (High-Speed UART) */
N#define    UART7_BA  0xB8000700  /*!< UART7 Control */
N#define    UART8_BA  0xB8000800  /*!< UART8 Control (High-Speed UART) */
N#define    UART9_BA  0xB8000900  /*!< UART9 Control */
N#define    UARTA_BA  0xB8000A00  /*!< UARTA Control (High-Speed UART) */
N#define    TMR0_BA   0xB8001000  /*!< Timer 0 */
N#define    TMR1_BA   0xB8001010  /*!< Timer 1 */
N#define    TMR2_BA   0xB8001020  /*!< Timer 2 */
N#define    TMR3_BA   0xB8001030  /*!< Timer 3 */
N#define    TMR4_BA   0xB8001040  /*!< Timer 4 */
N#define    ETMR0_BA  0xB8001400  /*!< Enhanced Timer 0 */
N#define    ETMR1_BA  0xB8001500  /*!< Enhanced Timer 1 */
N#define    ETMR2_BA  0xB8001600  /*!< Enhanced Timer 2 */
N#define    ETMR3_BA  0xB8001700  /*!< Enhanced Timer 3 */
N#define    WDT_BA    0xB8001800  /*!< Watch Dog Timer */
N#define    WWDT_BA   0xB8001900  /*!< Window Watch Dog Timer */
N#define    AIC_BA    0xB8002000  /*!< Interrupt Controller */
N#define    GPIO_BA   0xB8003000  /*!< GPIO Control */
N#define    RTC_BA    0xB8004000  /*!< Real Time Clock Control */
N#define    SC0_BA    0xB8005000  /*!< Smart Card 0 Control */
N#define    SC1_BA    0xB8005400  /*!< Smart Card 1 Control */
N#define    I2C0_BA   0xB8006000  /*!< I2C 0 Control */
N#define    I2C1_BA   0xB8006100  /*!< I2C 1 Control */
N#define    SPI0_BA   0xB8006200  /*!< Serial Peripheral Interface 0 */
N#define    SPI1_BA   0xB8006300  /*!< Serial Peripheral Interface 1 */
N#define    PWM_BA    0xB8007000  /*!< Pulse Width Modulation (PWM) Control */
N#define    ADC_BA    0xB800A000  /*!< ADC Control */
N#define    CAN0_BA   0xB800B000  /*!< CAN 0 Control */
N#define    CAN1_BA   0xB800B400  /*!< CAN 1 Control */
N
N/*@}*/ /* end of group N9H30_PERIPHERAL_MEM_MAP */
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N/** @addtogroup N9H30_Peripherals N9H30 Control Register
N  N9H30 Device Specific Peripheral registers structures
N  @{
N*/
N
N/*---------------------- System Manger Controller -------------------------*/
N/**
N    @addtogroup SYS System Manger Controller(SYS)
N    Memory Mapped Structure for SYS Controller
N@{ */
N
N#define    REG_SYS_PDID         (SYS_BA+0x000)  /*!< Product Identifier Register */
N#define    REG_SYS_PWRON        (SYS_BA+0x004)  /*!< Power-On Setting Register */
N#define    REG_SYS_ARBCON       (SYS_BA+0x008)  /*!< Arbitration Control Register */
N#define    REG_SYS_LVRDCR       (SYS_BA+0x020)  /*!< Low Voltage Reset & Detect Control Register */
N#define    REG_SYS_MISCFCR      (SYS_BA+0x030)  /*!< Miscellaneous Function Control Register */
N#define    REG_SYS_MISCIER      (SYS_BA+0x040)  /*!< Miscellaneous Interrupt Enable Register */
N#define    REG_SYS_MISCISR      (SYS_BA+0x044)  /*!< Miscellaneous Interrupt Status Register */
N#define    REG_SYS_WKUPSER      (SYS_BA+0x058)  /*!< System Wakeup Source Enable Register */
N#define    REG_SYS_WKUPSSR      (SYS_BA+0x05C)  /*!< System Wakeup Source Status Register */
N#define    REG_SYS_AHBIPRST     (SYS_BA+0x060)  /*!< AHB IP Reset Control Register */
N#define    REG_SYS_APBIPRST0    (SYS_BA+0x064)  /*!< APB IP Reset Control Register 0 */
N#define    REG_SYS_APBIPRST1    (SYS_BA+0x068)  /*!< APB IP Reset Control Register 1 */
N#define    REG_SYS_RSTSTS       (SYS_BA+0x06C)  /*!< Reset Source Active Status Register */
N#define    REG_SYS_GPA_MFPL     (SYS_BA+0x070)  /*!< GPIOA Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPA_MFPH     (SYS_BA+0x074)  /*!< GPIOA High Byte Multiple Function Control Register */
N#define    REG_SYS_GPB_MFPL     (SYS_BA+0x078)  /*!< GPIOB Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPB_MFPH     (SYS_BA+0x07C)  /*!< GPIOB High Byte Multiple Function Control Register */
N#define    REG_SYS_GPC_MFPL     (SYS_BA+0x080)  /*!< GPIOC Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPC_MFPH     (SYS_BA+0x084)  /*!< GPIOC High Byte Multiple Function Control Register */
N#define    REG_SYS_GPD_MFPL     (SYS_BA+0x088)  /*!< GPIOD Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPD_MFPH     (SYS_BA+0x08C)  /*!< GPIOD High Byte Multiple Function Control Register */
N#define    REG_SYS_GPE_MFPL     (SYS_BA+0x090)  /*!< GPIOE Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPE_MFPH     (SYS_BA+0x094)  /*!< GPIOE High Byte Multiple Function Control Register */
N#define    REG_SYS_GPF_MFPL     (SYS_BA+0x098)  /*!< GPIOF Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPF_MFPH     (SYS_BA+0x09C)  /*!< GPIOF High Byte Multiple Function Control Register */
N#define    REG_SYS_GPG_MFPL     (SYS_BA+0x0A0)  /*!< GPIOG Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPG_MFPH     (SYS_BA+0x0A4)  /*!< GPIOG High Byte Multiple Function Control Register */
N#define    REG_SYS_GPH_MFPL     (SYS_BA+0x0A8)  /*!< GPIOH Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPH_MFPH     (SYS_BA+0x0AC)  /*!< GPIOH High Byte Multiple Function Control Register */
N#define    REG_SYS_GPI_MFPL     (SYS_BA+0x0B0)  /*!< GPIOI Low Byte Multiple Function Control Register */
N#define    REG_SYS_GPI_MFPH     (SYS_BA+0x0B4)  /*!< GPIOI High Byte Multiple Function Control Register */
N#define    REG_SYS_GPJ_MFPL     (SYS_BA+0x0B8)  /*!< GPIOJ Low Byte Multiple Function Control Register */
N#define    REG_SYS_DDR_DSCTL    (SYS_BA+0x0F0)  /*!< DDR I/O Driving Strength Control Register */
N#define    REG_SYS_PORDISCR     (SYS_BA+0x100)  /*!< Power-On-Reset Disable Control Register */
N#define    REG_SYS_ICEDBGCR     (SYS_BA+0x104)  /*!< ICE Debug Interface Control Register */
N#define    REG_SYS_ERRADDCR     (SYS_BA+0x108)  /*!< Error Response Address Control Regsiter */
N#define    REG_SYS_REGWPCTL     (SYS_BA+0x1FC)  /*!< Register Write-Protection Control Register */
N
N/**@}*/ /* end of SYS register group */
N
N/*---------------------- System Clock Controller -------------------------*/
N/**
N    @addtogroup CLK System Clock Controller(CLK)
N    Memory Mapped Structure for CLK Controller
N@{ */
N
N#define    REG_CLK_PMCON        (CLK_BA+0x00) /*!< Power Management Control Register */
N#define    REG_CLK_HCLKEN       (CLK_BA+0x10) /*!< AHB IP Clock Enable Control Register */
N#define    REG_CLK_PCLKEN0      (CLK_BA+0x18) /*!< APB IP Clock Enable Control Register 0 */
N#define    REG_CLK_PCLKEN1      (CLK_BA+0x1C) /*!< APB IP Clock Enable Control Register 1 */
N#define    REG_CLK_DIVCTL0      (CLK_BA+0x20) /*!< Clock Divider Control Register 0 */
N#define    REG_CLK_DIVCTL1      (CLK_BA+0x24) /*!< Clock Divider Control Register 1 */
N#define    REG_CLK_DIVCTL2      (CLK_BA+0x28) /*!< Clock Divider Control Register 2 */
N#define    REG_CLK_DIVCTL3      (CLK_BA+0x2C) /*!< Clock Divider Control Register 3 */
N#define    REG_CLK_DIVCTL4      (CLK_BA+0x30) /*!< Clock Divider Control Register 4 */
N#define    REG_CLK_DIVCTL5      (CLK_BA+0x34) /*!< Clock Divider Control Register 5 */
N#define    REG_CLK_DIVCTL6      (CLK_BA+0x38) /*!< Clock Divider Control Register 6 */
N#define    REG_CLK_DIVCTL7      (CLK_BA+0x3C) /*!< Clock Divider Control Register 7 */
N#define    REG_CLK_DIVCTL8      (CLK_BA+0x40) /*!< Clock Divider Control Register 8 */
N#define    REG_CLK_DIVCTL9      (CLK_BA+0x44) /*!< Clock Divider Control Register 9 */
N#define    REG_CLK_APLLCON      (CLK_BA+0x60) /*!< APLL Control Register */
N#define    REG_CLK_UPLLCON      (CLK_BA+0x64) /*!< UPLL Control Register */
N#define    REG_CLK_PLLSTBCNTR   (CLK_BA+0x80) /*!< PLL Stable Counter and Test Clock Control Register */
N
N/**@}*/ /* end of CLK register group */
N
N
N/*---------------------- External Bus Interface Controller -------------------------*/
N/**
N    @addtogroup EBI External Bus Interface Controller(EBI)
N    Memory Mapped Structure for EBI Controller
N@{ */
N
N#define    REG_EBI_CTL          (EBI_BA+0x000)  /*!< EBI control register */
N#define    REG_EBI_BNKCTL0      (EBI_BA+0x018)  /*!< External I/O 0 control register */
N#define    REG_EBI_BNKCTL1      (EBI_BA+0x01C)  /*!< External I/O 1 control register */
N#define    REG_EBI_BNKCTL2      (EBI_BA+0x020)  /*!< External I/O 2 control register */
N#define    REG_EBI_BNKCTL3      (EBI_BA+0x024)  /*!< External I/O 3 control register */
N#define    REG_EBI_BNKCTL4      (EBI_BA+0x028)  /*!< External I/O 4 control register */
N
N/**@}*/ /* end of EBI register group */
N
N
N/*---------------------- Ethernet MAC Controller -------------------------*/
N/**
N    @addtogroup EMAC Ethernet MAC Controller(EMAC)
N    Memory Mapped Structure for EMAC Controller
N@{ */
N
N#define     REG_EMAC0_CAMCMR      (EMC0_BA+0x000) /*!< CAM Command Register */
N#define     REG_EMAC0_CAMEN       (EMC0_BA+0x004) /*!< CAM Enable Register */
N#define     REG_EMAC0_CAM0M       (EMC0_BA+0x008)  /*!< CAM0 Most Significant Word Register */
N#define     REG_EMAC0_CAM0L       (EMC0_BA+0x00c)  /*!< CAM0 Least Significant Word Register */
N#define     REG_EMAC0_CAMxM_Reg(x)(REG_EMAC0_CAM0M+(x)*0x8)  /*!< CAMx Most Significant Word Register */
N#define     REG_EMAC0_CAMxL_Reg(x)(REG_EMAC0_CAM0L+(x)*0x8)  /*!< CAMx Least Significant Word Register */
N#define     REG_EMAC0_TXDLSA      (EMC0_BA+0x088) /*!< Transmit Descriptor Link List Start Address Register */
N#define     REG_EMAC0_RXDLSA      (EMC0_BA+0x08C) /*!< Receive Descriptor Link List Start Address Register */
N#define     REG_EMAC0_MCMDR       (EMC0_BA+0x090) /*!< MAC Command Register */
N#define     REG_EMAC0_MIID        (EMC0_BA+0x094) /*!< MII Management Data Register */
N#define     REG_EMAC0_MIIDA       (EMC0_BA+0x098) /*!< MII Management Control and Address Register */
N#define     REG_EMAC0_FFTCR       (EMC0_BA+0x09C) /*!< FIFO Threshold Control Register */
N#define     REG_EMAC0_TSDR        (EMC0_BA+0x0a0) /*!< Transmit Start Demand Register */
N#define     REG_EMAC0_RSDR        (EMC0_BA+0x0a4) /*!< Receive Start Demand Register */
N#define     REG_EMAC0_DMARFC      (EMC0_BA+0x0a8) /*!< Maximum Receive Frame Control Register */
N#define     REG_EMAC0_MIEN        (EMC0_BA+0x0ac) /*!< MAC Interrupt Enable Register */
N#define     REG_EMAC0_MISTA       (EMC0_BA+0x0b0) /*!< MAC Interrupt Status Register */
N#define     REG_EMAC0_MGSTA       (EMC0_BA+0x0b4) /*!< MAC General Status Register */
N#define     REG_EMAC0_MPCNT       (EMC0_BA+0x0b8) /*!< Missed Packet Count Register */
N#define     REG_EMAC0_MRPC        (EMC0_BA+0x0bc) /*!< MAC Receive Pause Count Register */
N#define     REG_EMAC0_DMARFS      (EMC0_BA+0x0c8) /*!< DMA Receive Frame Status Register */
N#define     REG_EMAC0_CTXDSA      (EMC0_BA+0x0cc) /*!< Current Transmit Descriptor Start Address Register */
N#define     REG_EMAC0_CTXBSA      (EMC0_BA+0x0d0) /*!< Current Transmit Buffer Start Address Register */
N#define     REG_EMAC0_CRXDSA      (EMC0_BA+0x0d4) /*!< Current Receive Descriptor Start Address Register */
N#define     REG_EMAC0_CRXBSA      (EMC0_BA+0x0d8) /*!< Current Receive Buffer Start Address Register */
N#define     REG_EMAC0_TSCTL       (EMC0_BA+0x100) /*!< Time Stamp Control Register */
N#define     REG_EMAC0_TSSEC       (EMC0_BA+0x110) /*!< Time Stamp Counter Second Register */
N#define     REG_EMAC0_TSSUBSEC    (EMC0_BA+0x114) /*!< Time Stamp Counter Sub Second Register */
N#define     REG_EMAC0_TSINC       (EMC0_BA+0x118) /*!< Time Stamp Increment Register  */
N#define     REG_EMAC0_TSADDEN     (EMC0_BA+0x11c) /*!< Time Stamp Addend Register */
N#define     REG_EMAC0_TSUPDSEC    (EMC0_BA+0x120) /*!< Time Stamp Update Second Register */
N#define     REG_EMAC0_TSUPDSUBSEC (EMC0_BA+0x124) /*!< Time Stamp Update Sub Second Register */
N#define     REG_EMAC0_TSALMSEC    (EMC0_BA+0x128) /*!< Time Stamp Alarm Second Register */
N#define     REG_EMAC0_TSALMSUBSEC (EMC0_BA+0x12c) /*!< Time Stamp Alarm Sub Second Register */
N
N#define     REG_EMAC1_CAMCMR      (EMC1_BA+0x000) /*!< CAM Command Register */
N#define     REG_EMAC1_CAMEN       (EMC1_BA+0x004) /*!< CAM Enable Register */
N#define     REG_EMAC1_CAM0M       (EMC1_BA+0x008)  /*!< CAM0 Most Significant Word Register */
N#define     REG_EMAC1_CAM0L       (EMC1_BA+0x00c)  /*!< CAM0 Least Significant Word Register */
N#define     REG_EMAC1_CAMxM_Reg(x)(REG_EMAC1_CAM0M+(x)*0x8)  /*!< CAMx Most Significant Word Register */
N#define     REG_EMAC1_CAMxL_Reg(x)(REG_EMAC1_CAM0L+(x)*0x8)  /*!< CAMx Least Significant Word Register */
N#define     REG_EMAC1_TXDLSA      (EMC1_BA+0x088) /*!< Transmit Descriptor Link List Start Address Register */
N#define     REG_EMAC1_RXDLSA      (EMC1_BA+0x08C) /*!< Receive Descriptor Link List Start Address Register */
N#define     REG_EMAC1_MCMDR       (EMC1_BA+0x090) /*!< MAC Command Register */
N#define     REG_EMAC1_MIID        (EMC1_BA+0x094) /*!< MII Management Data Register */
N#define     REG_EMAC1_MIIDA       (EMC1_BA+0x098) /*!< MII Management Control and Address Register */
N#define     REG_EMAC1_FFTCR       (EMC1_BA+0x09C) /*!< FIFO Threshold Control Register */
N#define     REG_EMAC1_TSDR        (EMC1_BA+0x0a0) /*!< Transmit Start Demand Register */
N#define     REG_EMAC1_RSDR        (EMC1_BA+0x0a4) /*!< Receive Start Demand Register */
N#define     REG_EMAC1_DMARFC      (EMC1_BA+0x0a8) /*!< Maximum Receive Frame Control Register */
N#define     REG_EMAC1_MIEN        (EMC1_BA+0x0ac) /*!< MAC Interrupt Enable Register */
N#define     REG_EMAC1_MISTA       (EMC1_BA+0x0b0) /*!< MAC Interrupt Status Register */
N#define     REG_EMAC1_MGSTA       (EMC1_BA+0x0b4) /*!< MAC General Status Register */
N#define     REG_EMAC1_MPCNT       (EMC1_BA+0x0b8) /*!< Missed Packet Count Register */
N#define     REG_EMAC1_MRPC        (EMC1_BA+0x0bc) /*!< MAC Receive Pause Count Register */
N#define     REG_EMAC1_DMARFS      (EMC1_BA+0x0c8) /*!< DMA Receive Frame Status Register */
N#define     REG_EMAC1_CTXDSA      (EMC1_BA+0x0cc) /*!< Current Transmit Descriptor Start Address Register */
N#define     REG_EMAC1_CTXBSA      (EMC1_BA+0x0d0) /*!< Current Transmit Buffer Start Address Register */
N#define     REG_EMAC1_CRXDSA      (EMC1_BA+0x0d4) /*!< Current Receive Descriptor Start Address Register */
N#define     REG_EMAC1_CRXBSA      (EMC1_BA+0x0d8) /*!< Current Receive Buffer Start Address Register */
N#define     REG_EMAC1_TSCTL       (EMC1_BA+0x100) /*!< Time Stamp Control Register */
N#define     REG_EMAC1_TSSEC       (EMC1_BA+0x110) /*!< Time Stamp Counter Second Register */
N#define     REG_EMAC1_TSSUBSEC    (EMC1_BA+0x114) /*!< Time Stamp Counter Sub Second Register */
N#define     REG_EMAC1_TSINC       (EMC1_BA+0x118) /*!< Time Stamp Increment Register  */
N#define     REG_EMAC1_TSADDEN     (EMC1_BA+0x11c) /*!< Time Stamp Addend Register */
N#define     REG_EMAC1_TSUPDSEC    (EMC1_BA+0x120) /*!< Time Stamp Update Second Register */
N#define     REG_EMAC1_TSUPDSUBSEC (EMC1_BA+0x124) /*!< Time Stamp Update Sub Second Register */
N#define     REG_EMAC1_TSALMSEC    (EMC1_BA+0x128) /*!< Time Stamp Alarm Second Register */
N#define     REG_EMAC1_TSALMSUBSEC (EMC1_BA+0x12c) /*!< Time Stamp Alarm Sub Second Register */
N
N/**@}*/ /* end of EMAC register group */
N
N/*----------------------  General Direct Memory Access Controller -------------------------*/
N/**
N    @addtogroup GDMA  General Direct Memory Access Controller(GDMA)
N    Memory Mapped Structure for GDMA Controller
N@{ */
N
N#define     REG_GDMA_CTL0   (GDMA_BA+0x000)  /*!< Channel 0 Control Register */
N#define     REG_GDMA_SRCB0  (GDMA_BA+0x004)  /*!< Channel 0 Source Base Address Register */
N#define     REG_GDMA_DSTB0  (GDMA_BA+0x008)  /*!< Channel 0 Destination Base Address Register */
N#define     REG_GDMA_TCNT0  (GDMA_BA+0x00C)  /*!< Channel 0 Transfer Count Register */
N#define     REG_GDMA_CSRC0  (GDMA_BA+0x010)  /*!< Channel 0 Current Source Address Register */
N#define     REG_GDMA_CDST0  (GDMA_BA+0x014)  /*!< Channel 0 Current Destination Address Register */
N#define     REG_GDMA_CTCNT0 (GDMA_BA+0x018)  /*!< Channel 0 Current Transfer Count Register */
N#define     REG_GDMA_DADR0  (GDMA_BA+0x01C)  /*!< Channel 0 Descriptor Address Register */
N#define     REG_GDMA_CTL1   (GDMA_BA+0x020)  /*!< Channel 1 Control Register */
N#define     REG_GDMA_SRCB1  (GDMA_BA+0x024)  /*!< Channel 1 Source Base Address Register */
N#define     REG_GDMA_DSTB1  (GDMA_BA+0x028)  /*!< Channel 1 Destination Base Address Register */
N#define     REG_GDMA_TCNT1  (GDMA_BA+0x02C)  /*!< Channel 1 Transfer Count Register */
N#define     REG_GDMA_CSRC1  (GDMA_BA+0x030)  /*!< Channel 1 Current Source Address Register */
N#define     REG_GDMA_CDST1  (GDMA_BA+0x034)  /*!< Channel 1 Current Destination Address Register */
N#define     REG_GDMA_CTCNT1 (GDMA_BA+0x038)  /*!< Channel 1 Current Transfer Count Register */
N#define     REG_GDMA_DADR1  (GDMA_BA+0x03C)  /*!< Channel 1 Descriptor Address Register */
N#define     REG_GDMA_INTBUF0    (GDMA_BA+0x080)  /*!< GDMA Internal Buffer Word 0 */
N#define     REG_GDMA_INTBUF1    (GDMA_BA+0x084)  /*!< GDMA Internal Buffer Word 1 */
N#define     REG_GDMA_INTBUF2    (GDMA_BA+0x088)  /*!< GDMA Internal Buffer Word 2 */
N#define     REG_GDMA_INTBUF3    (GDMA_BA+0x08C)  /*!< GDMA Internal Buffer Word 3 */
N#define     REG_GDMA_INTBUF4    (GDMA_BA+0x090)  /*!< GDMA Internal Buffer Word 4 */
N#define     REG_GDMA_INTBUF5    (GDMA_BA+0x094)  /*!< GDMA Internal Buffer Word 5 */
N#define     REG_GDMA_INTBUF6    (GDMA_BA+0x098)  /*!< GDMA Internal Buffer Word 6 */
N#define     REG_GDMA_INTBUF7    (GDMA_BA+0x09C)  /*!< GDMA Internal Buffer Word 7 */
N#define     REG_GDMA_INTCS  (GDMA_BA+0x0A0)  /*!< Interrupt Control and Status Register */
N
N/**@}*/ /* end of GDMA register group */
N
N
N
N/*---------------------- USB Device Controller -------------------------*/
N/**
N    @addtogroup USBD USB Device Controller(USBD)
N    Memory Mapped Structure for USBD Controller
N@{ */
N#define     REG_USBD_GINTSTS        (USBD_BA+0x00)  /*!< Interrupt Status Low Register */
N#define     REG_USBD_GINTEN         (USBD_BA+0x08)  /*!< Interrupt Enable Low Register */
N#define     REG_USBD_BUSINTSTS      (USBD_BA+0x10)  /*!< USB Bus Interrupt Status Register */
N#define     REG_USBD_BUSINTEN       (USBD_BA+0x14)  /*!< USB Bus Interrupt Enable Register */
N#define     REG_USBD_OPER           (USBD_BA+0x18)  /*!< USB Operational Register */
N#define     REG_USBD_FRAMECNT       (USBD_BA+0x1C)  /*!< USB Frame Count Register */
N#define     REG_USBD_FADDR          (USBD_BA+0x20)  /*!< USB Function Address Register */
N#define     REG_USBD_TEST           (USBD_BA+0x24)  /*!< USB Test Mode Register */
N#define     REG_USBD_CEPDAT         (USBD_BA+0x28)  /*!< Control-ep data buffer register */
N#define     REG_USBD_CEPCTL         (USBD_BA+0x2C)  /*!< Control-ep control and status register */
N#define     REG_USBD_CEPINTEN       (USBD_BA+0x30)  /*!< Control-ep interrupt enable register */
N#define     REG_USBD_CEPINTSTS      (USBD_BA+0x34)  /*!< Control-ep interrupt status register */
N#define     REG_USBD_CEPTXCNT       (USBD_BA+0x38)  /*!< In-transfer data count register */
N#define     REG_USBD_CEPRXCNT       (USBD_BA+0x3C)  /*!< Out-transfer data count register */
N#define     REG_USBD_CEPDATCNT      (USBD_BA+0x40)  /*!< Control-ep data count register */
N#define     REG_USBD_SETUP1_0       (USBD_BA+0x44)  /*!< Setup byte1 & byte0 register */
N#define     REG_USBD_SETUP3_2       (USBD_BA+0x48)  /*!< Setup byte3 & byte2 register */
N#define     REG_USBD_SETUP5_4       (USBD_BA+0x4C)  /*!< Setup byte5 & byte4 register */
N#define     REG_USBD_SETUP7_6       (USBD_BA+0x50)  /*!< Setup byte7 & byte6 register */
N#define     REG_USBD_CEPBUFSTART    (USBD_BA+0x54)  /*!< Control-ep ram start address register */
N#define     REG_USBD_CEPBUFEND      (USBD_BA+0x58)  /*!< Control-ep ram end address register */
N#define     REG_USBD_DMACTL         (USBD_BA+0x5C)  /*!< Dma control and status register */
N#define     REG_USBD_DMACNT         (USBD_BA+0x60)  /*!< Dma count register */
N
N#define     REG_USBD_EPADAT         (USBD_BA+0x64)  /*!< Endpoint A data buffer register */
N#define     REG_USBD_EPAINTSTS      (USBD_BA+0x68)  /*!< Endpoint A interrupt status register */
N#define     REG_USBD_EPAINTEN       (USBD_BA+0x6C)  /*!< Endpoint A interrupt enable register */
N#define     REG_USBD_EPADATCNT      (USBD_BA+0x70)  /*!< Data count available in endpoint A buffer */
N#define     REG_USBD_EPARSPCTL      (USBD_BA+0x74)  /*!< Endpoint A response register set/clear */
N#define     REG_USBD_EPAMPS         (USBD_BA+0x78)  /*!< Endpoint A max packet size register */
N#define     REG_USBD_EPATXCNT       (USBD_BA+0x7C)  /*!< Endpoint A transfer count register */
N#define     REG_USBD_EPACFG         (USBD_BA+0x80)  /*!< Endpoint A configuration register */
N#define     REG_USBD_EPABUFSTART    (USBD_BA+0x84)  /*!< Endpoint A ram start address register */
N#define     REG_USBD_EPABUFEND      (USBD_BA+0x88)  /*!< Endpoint A ram end address register */
N
N#define     REG_USBD_EPBDAT         (USBD_BA+0x8C)  /*!< Endpoint B data buffer register */
N#define     REG_USBD_EPBINTSTS      (USBD_BA+0x90)  /*!< Endpoint B interrupt status register */
N#define     REG_USBD_EPBINTEN       (USBD_BA+0x94)  /*!< Endpoint B interrupt enable register */
N#define     REG_USBD_EPBDATCNT      (USBD_BA+0x98)  /*!< Data count available in endpoint B buffer */
N#define     REG_USBD_EPBRSPCTL      (USBD_BA+0x9C)  /*!< Endpoint B response register set/clear */
N#define     REG_USBD_EPBMPS         (USBD_BA+0xA0)  /*!< Endpoint B max packet size register */
N#define     REG_USBD_EPBTXCNT       (USBD_BA+0xA4)  /*!< Endpoint B transfer count register */
N#define     REG_USBD_EPBCFG         (USBD_BA+0xA8)  /*!< Endpoint B configuration register */
N#define     REG_USBD_EPBBUFSTART    (USBD_BA+0xAC)  /*!< Endpoint B ram start address register */
N#define     REG_USBD_EPBBUFEND      (USBD_BA+0xB0)  /*!< Endpoint B ram end address register */
N
N#define     REG_USBD_EPCDAT         (USBD_BA+0xB4)  /*!< Endpoint C data buffer register */
N#define     REG_USBD_EPCINTSTS      (USBD_BA+0xB8)  /*!< Endpoint C interrupt status register */
N#define     REG_USBD_EPCINTEN       (USBD_BA+0xBC)  /*!< Endpoint C interrupt enable register */
N#define     REG_USBD_EPCDATCNT      (USBD_BA+0xC0)  /*!< Data count available in endpoint C buffer */
N#define     REG_USBD_EPCRSPCTL      (USBD_BA+0xC4)  /*!< Endpoint C response register set/clear */
N#define     REG_USBD_EPCMPS         (USBD_BA+0xC8)  /*!< Endpoint C max packet size register */
N#define     REG_USBD_EPCTXCNT       (USBD_BA+0xCC)  /*!< Endpoint C transfer count register */
N#define     REG_USBD_EPCCFG         (USBD_BA+0xD0)  /*!< Endpoint C configuration register */
N#define     REG_USBD_EPCBUFSTART    (USBD_BA+0xD4)  /*!< Endpoint C ram start address register */
N#define     REG_USBD_EPCBUFEND      (USBD_BA+0xD8)  /*!< Endpoint C ram end address register */
N
N#define     REG_USBD_EPDDAT         (USBD_BA+0xDC)  /*!< Endpoint D data buffer register */
N#define     REG_USBD_EPDINTSTS      (USBD_BA+0xE0)  /*!< Endpoint D interrupt status register */
N#define     REG_USBD_EPDINTEN       (USBD_BA+0xE4)  /*!< Endpoint D interrupt enable register */
N#define     REG_USBD_EPDDATCNT      (USBD_BA+0xE8)  /*!< Data count available in endpoint D buffer */
N#define     REG_USBD_EPDRSPCTL      (USBD_BA+0xEC)  /*!< Endpoint D response register set/clear */
N#define     REG_USBD_EPDMPS         (USBD_BA+0xF0)  /*!< Endpoint D max packet size register */
N#define     REG_USBD_EPDTXCNT       (USBD_BA+0xF4)  /*!< Endpoint D transfer count register */
N#define     REG_USBD_EPDCFG         (USBD_BA+0xF8)  /*!< Endpoint D configuration register */
N#define     REG_USBD_EPDBUFSTART    (USBD_BA+0xFC)  /*!< Endpoint D ram start address register */
N#define     REG_USBD_EPDBUFEND      (USBD_BA+0x100) /*!< Endpoint D ram end address register */
N
N#define     REG_USBD_EPEDAT         (USBD_BA+0x104) /*!< Endpoint E data buffer register */
N#define     REG_USBD_EPEINTSTS      (USBD_BA+0x108) /*!< Endpoint E interrupt status register */
N#define     REG_USBD_EPEINTEN       (USBD_BA+0x10C) /*!< Endpoint E interrupt enable register */
N#define     REG_USBD_EPEDATCNT      (USBD_BA+0x110) /*!< Data count available in endpoint E buffer */
N#define     REG_USBD_EPERSPCTL      (USBD_BA+0x114) /*!< Endpoint E response register set/clear */
N#define     REG_USBD_EPEMPS         (USBD_BA+0x118) /*!< Endpoint E max packet size register */
N#define     REG_USBD_EPETXCNT       (USBD_BA+0x11C) /*!< Endpoint E transfer count register */
N#define     REG_USBD_EPECFG         (USBD_BA+0x120) /*!< Endpoint E configuration register */
N#define     REG_USBD_EPEBUFSTART    (USBD_BA+0x124) /*!< Endpoint E ram start address register */
N#define     REG_USBD_EPEBUFEND      (USBD_BA+0x128) /*!< Endpoint E ram end address register */
N
N#define     REG_USBD_EPFDAT         (USBD_BA+0x12C) /*!< Endpoint F data buffer register */
N#define     REG_USBD_EPFINTSTS      (USBD_BA+0x130) /*!< Endpoint F interrupt status register */
N#define     REG_USBD_EPFINTEN       (USBD_BA+0x134) /*!< Endpoint F interrupt enable register */
N#define     REG_USBD_EPFDATCNT      (USBD_BA+0x138) /*!< Data count available in endpoint F buffer */
N#define     REG_USBD_EPFRSPCTL      (USBD_BA+0x13C) /*!< Endpoint F response register set/clear */
N#define     REG_USBD_EPFMPS         (USBD_BA+0x140) /*!< Endpoint F max packet size register */
N#define     REG_USBD_EPFTXCNT       (USBD_BA+0x144) /*!< Endpoint F transfer count register */
N#define     REG_USBD_EPFCFG         (USBD_BA+0x148) /*!< Endpoint F configuration register */
N#define     REG_USBD_EPFBUFSTART    (USBD_BA+0x14C) /*!< Endpoint F ram start address register */
N#define     REG_USBD_EPFBUFEND      (USBD_BA+0x150) /*!< Endpoint F ram end address register */
N
N#define     REG_USBD_EPGDAT         (USBD_BA+0x154) /*!< Endpoint G data buffer register */
N#define     REG_USBD_EPGINTSTS      (USBD_BA+0x158) /*!< Endpoint G interrupt status register */
N#define     REG_USBD_EPGINTEN       (USBD_BA+0x15C) /*!< Endpoint G interrupt enable register */
N#define     REG_USBD_EPGDATCNT      (USBD_BA+0x160) /*!< Data count available in endpoint G buffer */
N#define     REG_USBD_EPGRSPCTL      (USBD_BA+0x164) /*!< Endpoint G response register set/clear */
N#define     REG_USBD_EPGMPS         (USBD_BA+0x168) /*!< Endpoint G max packet size register */
N#define     REG_USBD_EPGTXCNT       (USBD_BA+0x16C) /*!< Endpoint G transfer count register */
N#define     REG_USBD_EPGCFG         (USBD_BA+0x170) /*!< Endpoint G configuration register */
N#define     REG_USBD_EPGBUFSTART    (USBD_BA+0x174) /*!< Endpoint G ram start address register */
N#define     REG_USBD_EPGBUFEND      (USBD_BA+0x178) /*!< Endpoint G ram end address register */
N
N#define     REG_USBD_EPHDAT         (USBD_BA+0x17C) /*!< Endpoint H data buffer register */
N#define     REG_USBD_EPHINTSTS      (USBD_BA+0x180) /*!< Endpoint H interrupt status register */
N#define     REG_USBD_EPHINTEN       (USBD_BA+0x184) /*!< Endpoint H interrupt enable register */
N#define     REG_USBD_EPHDATCNT      (USBD_BA+0x188) /*!< Data count available in endpoint H buffer */
N#define     REG_USBD_EPHRSPCTL      (USBD_BA+0x18C) /*!< Endpoint H response register set/clear */
N#define     REG_USBD_EPHMPS         (USBD_BA+0x190) /*!< Endpoint H max packet size register */
N#define     REG_USBD_EPHTXCNT       (USBD_BA+0x194) /*!< Endpoint H transfer count register */
N#define     REG_USBD_EPHCFG         (USBD_BA+0x198) /*!< Endpoint H configuration register */
N#define     REG_USBD_EPHBUFSTART    (USBD_BA+0x19C) /*!< Endpoint H ram start address register */
N#define     REG_USBD_EPHBUFEND      (USBD_BA+0x1A0) /*!< Endpoint H ram end address register */
N
N#define     REG_USBD_EPIDAT         (USBD_BA+0x1A4) /*!< Endpoint I data buffer register */
N#define     REG_USBD_EPIINTSTS      (USBD_BA+0x1A8) /*!< Endpoint I interrupt status register */
N#define     REG_USBD_EPIINTEN       (USBD_BA+0x1AC) /*!< Endpoint I interrupt enable register */
N#define     REG_USBD_EPIDATCNT      (USBD_BA+0x1B0) /*!< Data count available in endpoint I buffer */
N#define     REG_USBD_EPIRSPCTL      (USBD_BA+0x1B4) /*!< Endpoint I response register set/clear */
N#define     REG_USBD_EPIMPS         (USBD_BA+0x1B8) /*!< Endpoint I max packet size register */
N#define     REG_USBD_EPITXCNT       (USBD_BA+0x1BC) /*!< Endpoint I transfer count register */
N#define     REG_USBD_EPICFG         (USBD_BA+0x1C0) /*!< Endpoint I configuration register */
N#define     REG_USBD_EPIBUFSTART    (USBD_BA+0x1C4) /*!< Endpoint I ram start address register */
N#define     REG_USBD_EPIBUFEND      (USBD_BA+0x1C8) /*!< Endpoint I ram end address register */
N
N#define     REG_USBD_EPJDAT         (USBD_BA+0x1CC) /*!< Endpoint J data buffer register */
N#define     REG_USBD_EPJINTSTS      (USBD_BA+0x1D0) /*!< Endpoint J interrupt status register */
N#define     REG_USBD_EPJINTEN       (USBD_BA+0x1D4) /*!< Endpoint J interrupt enable register */
N#define     REG_USBD_EPJDATCNT      (USBD_BA+0x1D8) /*!< Data count available in endpoint J buffer */
N#define     REG_USBD_EPJRSPCTL      (USBD_BA+0x1DC) /*!< Endpoint J response register set/clear */
N#define     REG_USBD_EPJMPS         (USBD_BA+0x1E0) /*!< Endpoint J max packet size register */
N#define     REG_USBD_EPJTXCNT       (USBD_BA+0x1E4) /*!< Endpoint J transfer count register */
N#define     REG_USBD_EPJCFG         (USBD_BA+0x1E8) /*!< Endpoint J configuration register */
N#define     REG_USBD_EPJBUFSTART    (USBD_BA+0x1EC) /*!< Endpoint J ram start address register */
N#define     REG_USBD_EPJBUFEND      (USBD_BA+0x1F0) /*!< Endpoint J ram end address register */
N
N#define     REG_USBD_EPKDAT         (USBD_BA+0x1F4) /*!< Endpoint K data buffer register */
N#define     REG_USBD_EPKINTSTS      (USBD_BA+0x1F8) /*!< Endpoint K interrupt status register */
N#define     REG_USBD_EPKINTEN       (USBD_BA+0x1FC) /*!< Endpoint K interrupt enable register */
N#define     REG_USBD_EPKDATCNT      (USBD_BA+0x200) /*!< Data count available in endpoint K buffer */
N#define     REG_USBD_EPKRSPCTL      (USBD_BA+0x204) /*!< Endpoint K response register set/clear */
N#define     REG_USBD_EPKMPS         (USBD_BA+0x208) /*!< Endpoint K max packet size register */
N#define     REG_USBD_EPKTXCNT       (USBD_BA+0x20C) /*!< Endpoint K transfer count register */
N#define     REG_USBD_EPKCFG         (USBD_BA+0x210) /*!< Endpoint K configuration register */
N#define     REG_USBD_EPKBUFSTART    (USBD_BA+0x214) /*!< Endpoint K ram start address register */
N#define     REG_USBD_EPKBUFEND      (USBD_BA+0x218) /*!< Endpoint K ram end address register */
N
N#define     REG_USBD_EPLDAT         (USBD_BA+0x21C) /*!< Endpoint L data buffer register */
N#define     REG_USBD_EPLINTSTS      (USBD_BA+0x220) /*!< Endpoint L interrupt status register */
N#define     REG_USBD_EPLINTEN       (USBD_BA+0x224) /*!< Endpoint L interrupt enable register */
N#define     REG_USBD_EPLDATCNT      (USBD_BA+0x228) /*!< Data count available in endpoint L buffer */
N#define     REG_USBD_EPLRSPCTL      (USBD_BA+0x22C) /*!< Endpoint L response register set/clear */
N#define     REG_USBD_EPLMPS         (USBD_BA+0x230) /*!< Endpoint L max packet size register */
N#define     REG_USBD_EPLTXCNT       (USBD_BA+0x234) /*!< Endpoint L transfer count register */
N#define     REG_USBD_EPLCFG         (USBD_BA+0x238) /*!< Endpoint L configuration register */
N#define     REG_USBD_EPLBUFSTART    (USBD_BA+0x23C) /*!< Endpoint L ram start address register */
N#define     REG_USBD_EPLBUFEND      (USBD_BA+0x240) /*!< Endpoint L ram end address register */
N#define     REG_USBD_DMAADDR        (USBD_BA+0x700) /*!< AHB_DMA address register */
N#define     REG_USBD_PHYCTL         (USBD_BA+0x704) /*!< USB PHY control register */
N
N/**@}*/ /* end of USBD register group */
N
N
N/*----------------------  LCD Display Interface Controller -------------------------*/
N/**
N    @addtogroup LCM  LCD Display Interface Controller(LCM)
N    Memory Mapped Structure for LCM Controller
N@{ */
N
N#define     REG_LCM_DCCS        (LCM_BA+0x00)  /*!< Display Controller Control/Status Register */
N#define     REG_LCM_DEV_CTRL    (LCM_BA+0x04)  /*!< Display Output Device Control Register */
N#define     REG_LCM_MPU_CMD     (LCM_BA+0x08)  /*!< MPU-Interface LCD Write Command */
N#define     REG_LCM_INT_CS      (LCM_BA+0x0c)  /*!< Interrupt Control/Status Register */
N#define     REG_LCM_CRTC_SIZE   (LCM_BA+0x10)  /*!< CRTC Display Size Control Register */
N#define     REG_LCM_CRTC_DEND   (LCM_BA+0x14)  /*!< CRTC Display Enable End */
N#define     REG_LCM_CRTC_HR     (LCM_BA+0x18)  /*!< CRTC Internal Horizontal Retrace Control Register */
N#define     REG_LCM_CRTC_HSYNC  (LCM_BA+0x1C)  /*!< CRTC Horizontal Sync Control Register */
N#define     REG_LCM_CRTC_VR     (LCM_BA+0x20)  /*!< CRTC Internal Vertical Retrace Control Register */
N#define     REG_LCM_VA_BADDR0   (LCM_BA+0x24)  /*!< Video Stream Frame Buffer-0 Starting Address */
N#define     REG_LCM_VA_BADDR1   (LCM_BA+0x28)  /*!< Video Stream Frame Buffer-1 Starting Address */
N#define     REG_LCM_VA_FBCTRL   (LCM_BA+0x2C)  /*!< Video Stream Frame Buffer Control Register */
N#define     REG_LCM_VA_SCALE    (LCM_BA+0x30)  /*!< Video Stream Scaling Control Register */
N#define     REG_LCM_VA_WIN      (LCM_BA+0x38)  /*!< Image Stream Active Window Coordinates */
N#define     REG_LCM_VA_STUFF    (LCM_BA+0x3C)  /*!< Image Stream Stuff Pixel */
N#define     REG_LCM_OSD_WINS    (LCM_BA+0x40)  /*!< OSD Window Starting Coordinates */
N#define     REG_LCM_OSD_WINE    (LCM_BA+0x44)  /*!< OSD Window Ending Coordinates */
N#define     REG_LCM_OSD_BADDR   (LCM_BA+0x48)  /*!< OSD Stream Frame Buffer Starting Address */
N#define     REG_LCM_OSD_FBCTRL  (LCM_BA+0x4c)  /*!< OSD Stream Frame Buffer Control Register */
N#define     REG_LCM_OSD_OVERLAY (LCM_BA+0x50)  /*!< OSD Overlay Control Register */
N#define     REG_LCM_OSD_CKEY    (LCM_BA+0x54)  /*!< OSD Overlay Color-Key Pattern Register */
N#define     REG_LCM_OSD_CMASK   (LCM_BA+0x58)  /*!< OSD Overlay Color-Key Mask Register */
N#define     REG_LCM_OSD_SKIP1   (LCM_BA+0x5C)  /*!< OSD Window Skip1 Register */
N#define     REG_LCM_OSD_SKIP2   (LCM_BA+0x60)  /*!< OSD Window Skip2 Register */
N#define     REG_LCM_OSD_SCALE   (LCM_BA+0x64)  /*!< OSD horizontal up scaling control register */
N#define     REG_LCM_MPU_VSYNC   (LCM_BA+0x68)  /*!< MPU Vsync control register */
N#define     REG_LCM_HC_CTRL     (LCM_BA+0x6C)  /*!< Hardware cursor control Register */
N#define     REG_LCM_HC_POS      (LCM_BA+0x70)  /*!< Hardware cursot tip point potison on va picture */
N#define     REG_LCM_HC_WBCTRL   (LCM_BA+0x74)  /*!< Hardware Cursor Window Buffer Control Register */
N#define     REG_LCM_HC_BADDR    (LCM_BA+0x78)  /*!< Hardware cursor memory base address register */
N#define     REG_LCM_HC_COLOR0   (LCM_BA+0x7C)  /*!< Hardware cursor color ram register mapped to bpp = 0 */
N#define     REG_LCM_HC_COLOR1   (LCM_BA+0x80)  /*!< Hardware cursor color ram register mapped to bpp = 1 */
N#define     REG_LCM_HC_COLOR2   (LCM_BA+0x84)  /*!< Hardware cursor color ram register mapped to bpp = 2 */
N#define     REG_LCM_HC_COLOR3   (LCM_BA+0x88)  /*!< Hardware cursor color ram register mapped to bpp = 3 */
N
N/**@}*/ /* end of LCM register group */
N
N
N/*---------------------- I2S Interface Controller -------------------------*/
N/**
N    @addtogroup I2S I2S Interface Controller(I2S)
N    Memory Mapped Structure for I2S Controller
N@{ */
N
N#define     REG_ACTL_CON            (ACTL_BA+0x00)      /*!< Audio controller control register */
N#define     REG_ACTL_RESET          (ACTL_BA+0x04)      /*!< Sub block reset control register */
N#define     REG_ACTL_RDESB          (ACTL_BA+0x08)      /*!< DMA destination base address register for record */
N#define     REG_ACTL_RDES_LENGTH    (ACTL_BA+0x0C)      /*!< DMA destination length register for record */
N#define     REG_ACTL_RDESC          (ACTL_BA+0x10)      /*!< DMA destination current address for record */
N#define     REG_ACTL_PDESB          (ACTL_BA+0x14)      /*!< DMA destination current address for play */
N#define     REG_ACTL_PDES_LENGTH    (ACTL_BA+0x18)      /*!< DMA destination length register for play */
N#define     REG_ACTL_PDESC          (ACTL_BA+0x1C)      /*!< DMA destination current address register for play */
N#define     REG_ACTL_RSR            (ACTL_BA+0x20)      /*!< Record status register */
N#define     REG_ACTL_PSR            (ACTL_BA+0x24)      /*!< Play status register */
N#define     REG_ACTL_I2SCON         (ACTL_BA+0x28)      /*!< I2S control register */
N#define     REG_ACTL_COUNTER        (ACTL_BA+0x2C)      /*!< DMA count down values */
N#define     REG_ACTL_PCMCON         (ACTL_BA+0x30)      /*!< PCM interface control register */
N#define     REG_ACTL_PCMS1ST        (ACTL_BA+0x34)      /*!< PCM interface slot1 start register */
N#define     REG_ACTL_PCMS2ST        (ACTL_BA+0x38)      /*!< PCM interface slot2 start register */
N#define     REG_ACTL_RDESB2         (ACTL_BA+0x40)      /*!< DMA destination base address register for record right channel */
N#define     REG_ACTL_PDESB2         (ACTL_BA+0x44)      /*!< DMA destination base address register for play right channel */
N
N/**@}*/ /* end of I2S register group */
N
N/*---------------------- 2D Graphic Engine -------------------------*/
N/**
N    @addtogroup GE2D 2D Graphic Engine(GE2D)
N    Memory Mapped Structure for GE2D Controller
N@{ */
N
N#define     REG_GE2D_TRG            (GE_BA+0x00)  /*!< Graphic Engine Trigger Control Register */
N#define     REG_GE2D_XYSORG         (GE_BA+0x04)  /*!< Graphic Engine XY Mode Source Origin Starting Register */
N#define     REG_GE2D_TCNTVHSF       (GE_BA+0x08)  /*!< Graphic Engine Tile Width/Height or V/H Scale Factor N/M */
N#define     REG_GE2D_XYRRP          (GE_BA+0x0C)  /*!< Graphic Engine Rotate Reference Point XY Address */
N#define     REG_GE2D_INTSTS         (GE_BA+0x10)  /*!< Graphic Engine Interrupt Status Register */
N#define     REG_GE2D_PATSA          (GE_BA+0x14)  /*!< Graphic Engine Pattern Location Starting Address Register */
N#define     REG_GE2D_BETSC          (GE_BA+0x18)  /*!< GE Bresenham Error Term Stepping Constant Register */
N#define     REG_GE2D_BIEPC          (GE_BA+0x1C)  /*!< GE Bresenham Initial Error, Pixel Count Major M Register */
N#define     REG_GE2D_CTL            (GE_BA+0x20)  /*!< Graphic Engine Control Register */
N#define     REG_GE2D_BGCOLR         (GE_BA+0x24)  /*!< Graphic Engine Background Color Register */
N#define     REG_GE2D_FGCOLR         (GE_BA+0x28)  /*!< Graphic Engine Foreground Color Register */
N#define     REG_GE2D_TRNSCOLR       (GE_BA+0x2C)  /*!< Graphic Engine Transparency Color Register */
N#define     REG_GE2D_TCMSK          (GE_BA+0x30)  /*!< Graphic Engine Transparency Color Mask Register */
N#define     REG_GE2D_XYDORG         (GE_BA+0x34)  /*!< Graphic Engine XY Mode Display Origin Starting Register */
N#define     REG_GE2D_SDPITCH        (GE_BA+0x38)  /*!< Graphic Engine Source/Destination Pitch Register */
N#define     REG_GE2D_SRCSPA         (GE_BA+0x3C)  /*!< Graphic Engine Source Start XY/Linear Address Register */
N#define     REG_GE2D_DSTSPA         (GE_BA+0x40)  /*!< Graphic Engine Destination Start XY/Linear Register */
N#define     REG_GE2D_RTGLSZ         (GE_BA+0x44)  /*!< Graphic Engine Dimension XY/Linear Register */
N#define     REG_GE2D_CLPBTL         (GE_BA+0x48)  /*!< Graphic Engine Clipping Boundary Top/Left Register */
N#define     REG_GE2D_CLPBBR         (GE_BA+0x4C)  /*!< Graphic Engine Clipping Boundary Bottom/Right Register */
N#define     REG_GE2D_PTNA           (GE_BA+0x50)  /*!< Graphic Engine Pattern A Register */
N#define     REG_GE2D_PTNB           (GE_BA+0x54)  /*!< Graphic Engine Pattern B Register */
N#define     REG_GE2D_WRPLNMSK       (GE_BA+0x58)  /*!< Graphic Engine Write Plane Mask Register */
N#define     REG_GE2D_MISCTL         (GE_BA+0x5C)  /*!< Graphic Engine Miscellaneous Control Register */
N#define     REG_GE2D_GEHBDW0        (GE_BA+0x60)  /*!< Graphic Engine HostBLT data Port 0 Register */
N#define     REG_GE2D_GEHBDW1        (GE_BA+0x64)  /*!< Graphic Engine HostBLT data Port 1 Register */
N#define     REG_GE2D_GEHBDW2        (GE_BA+0x68)  /*!< Graphic Engine HostBLT data Port 2 Register */
N#define     REG_GE2D_GEHBDW3        (GE_BA+0x6C)  /*!< Graphic Engine HostBLT data Port 3 Register */
N#define     REG_GE2D_GEHBDW4        (GE_BA+0x70)  /*!< Graphic Engine HostBLT data Port 4 Register */
N#define     REG_GE2D_GEHBDW5        (GE_BA+0x74)  /*!< Graphic Engine HostBLT data Port 5 Register */
N#define     REG_GE2D_GEHBDW6        (GE_BA+0x78)  /*!< Graphic Engine HostBLT data Port 6 Register */
N#define     REG_GE2D_GEHBDW7        (GE_BA+0x7C)  /*!< Graphic Engine HostBLT data Port 7 Register */
N
N/**@}*/ /* end of GE2D register group */
N
N/*---------------------- Flash Memory Interface -------------------------*/
N/**
N    @addtogroup FMI Flash Memory Interface(FMI)
N    Memory Mapped Structure for FMI Controller
N@{ */
N
N/* DMAC Control Registers*/
N#define     REG_FMI_BUFFER      (FMI_BA+0x000)   /*!< FMI Embedded Buffer Word */
N#define     REG_FMI_DMACTL      (FMI_BA+0x400)   /*!< FMI DMA Control Register */
N#define     REG_FMI_DMASA       (FMI_BA+0x408)   /*!< FMI DMA Transfer Starting Address Register */
N#define     REG_FMI_DMABCNT     (FMI_BA+0x40C)   /*!< FMI DMA Transfer Byte Count Register */
N#define     REG_FMI_DMAINTEN    (FMI_BA+0x410)   /*!< FMI DMA Interrupt Enable Register */
N#define     REG_FMI_DMAINTSTS   (FMI_BA+0x414)   /*!< FMI DMA Interrupt Status Register */
N
N#define     REG_FMI_CTL         (FMI_BA+0x800)   /*!< Global Control and Status Register */
N#define     REG_FMI_INTEN       (FMI_BA+0x804)   /*!< Global Interrupt Control Register */
N#define     REG_FMI_INTSTS      (FMI_BA+0x808)   /*!< Global Interrupt Status Register */
N
N/* eMMC Registers */
N#define     REG_FMI_EMMCCTL     (FMI_BA+0x820)   /*!< eMMC control and status register */
N#define     REG_FMI_EMMCCMD     (FMI_BA+0x824)   /*!< eMMC command argument register */
N#define     REG_FMI_EMMCINTEN   (FMI_BA+0x828)   /*!< eMMC interrupt enable register */
N#define     REG_FMI_EMMCINTSTS  (FMI_BA+0x82C)   /*!< eMMC interrupt status register */
N#define     REG_FMI_EMMCRESP0   (FMI_BA+0x830)   /*!< eMMC receive response token register 0 */
N#define     REG_FMI_EMMCRESP1   (FMI_BA+0x834)   /*!< eMMC receive response token register 1 */
N#define     REG_FMI_EMMCBLEN    (FMI_BA+0x838)   /*!< eMMC block length register */
N#define     REG_FMI_EMMCTOUT    (FMI_BA+0x83C)   /*!< eMMC block length register */
N
N/* NAND-type Flash Registers */
N#define     REG_NANDCTL         (FMI_BA+0x8A0)   /*!< NAND Flash Control and Status Register */
N#define     REG_NANDTMCTL       (FMI_BA+0x8A4)   /*!< NAND Flash Timing Control Register */
N#define     REG_NANDINTEN       (FMI_BA+0x8A8)   /*!< NAND Flash Interrupt Control Register */
N#define     REG_NANDINTSTS      (FMI_BA+0x8AC)   /*!< NAND Flash Interrupt Status Register */
N#define     REG_NANDCMD         (FMI_BA+0x8B0)   /*!< NAND Flash Command Port Register */
N#define     REG_NANDADDR        (FMI_BA+0x8B4)   /*!< NAND Flash Address Port Register */
N#define     REG_NANDDATA        (FMI_BA+0x8B8)   /*!< NAND Flash Data Port Register */
N#define     REG_NANDRACTL       (FMI_BA+0x8BC)   /*!< NAND Flash Redundant Area Control Register */
N#define     REG_NANDECTL        (FMI_BA+0x8C0)   /*!< NAND Flash Extend Control Regsiter */
N#define     REG_NANDECCES0      (FMI_BA+0x8D0)   /*!< NAND Flash ECC Error Status 0 */
N#define     REG_NANDECCES1      (FMI_BA+0x8D4)   /*!< NAND Flash ECC Error Status 1 */
N#define     REG_NANDECCES2      (FMI_BA+0x8D8)   /*!< NAND Flash ECC Error Status 2 */
N#define     REG_NANDECCES3      (FMI_BA+0x8DC)   /*!< NAND Flash ECC Error Status 3 */
N#define     REG_NANDPROTA0      (FMI_BA+0x8E0)   /*!< NAND Flash Protect Region End Address 0 */
N#define     REG_NANDPROTA1      (FMI_BA+0x8E4)   /*!< NAND Flash Protect Region End Address 1 */
N
N/* NAND-type Flash BCH Error Address Registers */
N#define     REG_NANDECCEA0      (FMI_BA+0x900)   /*!< NAND Flash ECC Error Byte Address 0 */
N#define     REG_NANDECCEA1      (FMI_BA+0x904)   /*!< NAND Flash ECC Error Byte Address 1 */
N#define     REG_NANDECCEA2      (FMI_BA+0x908)   /*!< NAND Flash ECC Error Byte Address 2 */
N#define     REG_NANDECCEA3      (FMI_BA+0x90C)   /*!< NAND Flash ECC Error Byte Address 3 */
N#define     REG_NANDECCEA4      (FMI_BA+0x910)   /*!< NAND Flash ECC Error Byte Address 4 */
N#define     REG_NANDECCEA5      (FMI_BA+0x914)   /*!< NAND Flash ECC Error Byte Address 5 */
N#define     REG_NANDECCEA6      (FMI_BA+0x918)   /*!< NAND Flash ECC Error Byte Address 6 */
N#define     REG_NANDECCEA7      (FMI_BA+0x91C)   /*!< NAND Flash ECC Error Byte Address 7 */
N#define     REG_NANDECCEA8      (FMI_BA+0x920)   /*!< NAND Flash ECC Error Byte Address 8 */
N#define     REG_NANDECCEA9      (FMI_BA+0x924)   /*!< NAND Flash ECC Error Byte Address 9 */
N#define     REG_NANDECCEA10     (FMI_BA+0x928)   /*!< NAND Flash ECC Error Byte Address 10 */
N#define     REG_NANDECCEA11     (FMI_BA+0x92C)   /*!< NAND Flash ECC Error Byte Address 11 */
N
N/* NAND-type Flash BCH Error Data Registers */
N#define     REG_NANDECCED0      (FMI_BA+0x960)   /*!< NAND Flash ECC Error Data Register 0 */
N#define     REG_NANDECCED1      (FMI_BA+0x964)   /*!< NAND Flash ECC Error Data Register 1 */
N#define     REG_NANDECCED2      (FMI_BA+0x968)   /*!< NAND Flash ECC Error Data Register 2 */
N#define     REG_NANDECCED3      (FMI_BA+0x96C)   /*!< NAND Flash ECC Error Data Register 3 */
N#define     REG_NANDECCED4      (FMI_BA+0x970)   /*!< NAND Flash ECC Error Data Register 4 */
N#define     REG_NANDECCED5      (FMI_BA+0x974)   /*!< NAND Flash ECC Error Data Register 5 */
N
N/* NAND-type Flash Redundant Area Registers */
N#define     REG_NANDRA0         (FMI_BA+0xA00)   /*!< NAND Flash Redundant Area Register */
N#define     REG_NANDRA1         (FMI_BA+0xA04)   /*!< NAND Flash Redundant Area Register */
N
N/**@}*/ /* end of FMI register group */
N
N
N/*---------------------- SD/SDIO Host Controller -------------------------*/
N/**
N    @addtogroup SDH SD/SDIO Host Controller(SDH)
N    Memory Mapped Structure for SDH Controller
N@{ */
N
N/* DMAC Control Registers*/
N#define     REG_SDH_FB0         (SDH_BA+0x000)   /*!< SD Host Embedded Buffer Word */
N#define     REG_SDH_DMACTL      (SDH_BA+0x400)   /*!< SD Host DMA Control and Status Register */
N#define     REG_SDH_DMASA       (SDH_BA+0x408)   /*!< SD Host DMA Transfer Starting Address Register */
N#define     REG_SDH_DMABCNT     (SDH_BA+0x40C)   /*!< SD Host DMA Transfer Byte Count Register */
N#define     REG_SDH_DMAINTEN    (SDH_BA+0x410)   /*!< SD Host DMA Interrupt Enable Register */
N#define     REG_SDH_DMAINTSTS   (SDH_BA+0x414)   /*!< SD Host DMA Interrupt Status Register */
N
N#define     REG_SDH_GCTL        (SDH_BA+0x800)   /*!< SD Host Global Control and Status Register */
N#define     REG_SDH_GINTEN      (SDH_BA+0x804)   /*!< SD Host Global Interrupt Control Register */
N#define     REG_SDH_GINTSTS     (SDH_BA+0x808)   /*!< SD Host Global Interrupt Status Register */
N
N/* Secure Digit Registers */
N#define     REG_SDH_CTL         (SDH_BA+0x820)   /*!< SD Host control and status register */
N#define     REG_SDH_CMD         (SDH_BA+0x824)   /*!< SD Host command argument register */
N#define     REG_SDH_INTEN       (SDH_BA+0x828)   /*!< SD Host interrupt enable register */
N#define     REG_SDH_INTSTS      (SDH_BA+0x82C)   /*!< SD Host interrupt status register */
N#define     REG_SDH_RESP0       (SDH_BA+0x830)   /*!< SD Host receive response token register 0 */
N#define     REG_SDH_RESP1       (SDH_BA+0x834)   /*!< SD Host receive response token register 1 */
N#define     REG_SDH_BLEN        (SDH_BA+0x838)   /*!< SD Host block length register */
N#define     REG_SDH_TMOUT       (SDH_BA+0x83C)   /*!< SD Host Response/Data-in Time-out register */
N#define     REG_SDH_ECTL        (SDH_BA+0x840)   /*!< SD Host Extend Control Register */
N
N/**@}*/ /* end of SDH register group */
N
N
N
N/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
N/**
N    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
N    Memory Mapped Structure for UART Controller
N@{ */
N
N#define     REG_UART0_RBR    (UART0_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART0_THR    (UART0_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART0_IER    (UART0_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART0_FCR    (UART0_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART0_LCR    (UART0_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART0_MCR   (UART0_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART0_MSR    (UART0_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART0_FSR    (UART0_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART0_ISR   (UART0_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART0_TOR       (UART0_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART0_BAUD      (UART0_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART0_IRCR   (UART0_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART0_ALT_CSR   (UART0_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART0_FUN_SEL   (UART0_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART0_LIN_CTL   (UART0_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART0_LIN_SR    (UART0_BA+0x38)  /*!< LIN Status Register */
N
N
N
N
N/*
N  UART1 Control Registers
N*/
N#define     REG_UART1_RBR   (UART1_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART1_THR   (UART1_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART1_IER   (UART1_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART1_FCR   (UART1_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART1_LCR   (UART1_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART1_MCR   (UART1_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART1_MSR   (UART1_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART1_FSR       (UART1_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART1_ISR   (UART1_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART1_TOR       (UART1_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART1_BAUD      (UART1_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART1_IRCR      (UART1_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART1_ALT_CSR   (UART1_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART1_FUN_SEL   (UART1_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART1_LIN_CTL   (UART1_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART1_LIN_SR    (UART1_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART2 Control Registers
N*/
N#define     REG_UART2_RBR   (UART2_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART2_THR   (UART2_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART2_IER   (UART2_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART2_FCR   (UART2_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART2_LCR   (UART2_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART2_MCR   (UART2_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART2_MSR   (UART2_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART2_FSR   (UART2_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART2_ISR   (UART2_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART2_TOR   (UART2_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART2_BAUD  (UART2_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART2_IRCR  (UART2_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART2_ALT_CSR   (UART2_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART2_FUN_SEL   (UART2_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART2_LIN_CTL   (UART2_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART2_LIN_SR    (UART2_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART3 Control Registers
N*/
N#define     REG_UART3_RBR   (UART3_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART3_THR   (UART3_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART3_IER   (UART3_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART3_FCR   (UART3_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART3_LCR   (UART3_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART3_MCR   (UART3_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART3_MSR   (UART3_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART3_FSR   (UART3_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART3_ISR   (UART3_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART3_TOR   (UART3_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART3_BAUD  (UART3_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART3_IRCR  (UART3_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART3_ALT_CSR   (UART3_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART3_FUN_SEL   (UART3_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART3_LIN_CTL   (UART3_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART3_LIN_SR    (UART3_BA+0x38)  /*!< LIN Status Register */
N
N
N/*
N  UART4 Control Registers
N*/
N#define     REG_UART4_RBR   (UART4_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART4_THR   (UART4_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART4_IER   (UART4_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART4_FCR   (UART4_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART4_LCR   (UART4_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART4_MCR   (UART4_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART4_MSR   (UART4_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART4_FSR   (UART4_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART4_ISR   (UART4_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART4_TOR   (UART4_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART4_BAUD  (UART4_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART4_IRCR  (UART4_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART4_ALT_CSR   (UART4_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART4_FUN_SEL   (UART4_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART4_LIN_CTL   (UART4_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART4_LIN_SR    (UART4_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART5 Control Registers
N*/
N#define     REG_UART5_RBR   (UART5_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART5_THR   (UART5_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART5_IER   (UART5_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART5_FCR   (UART5_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART5_LCR   (UART5_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART5_MCR   (UART5_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART5_MSR   (UART5_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART5_FSR   (UART5_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART5_ISR   (UART5_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART5_TOR   (UART5_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART5_BAUD  (UART5_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART5_IRCR  (UART5_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART5_ALT_CSR   (UART5_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART5_FUN_SEL   (UART5_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART5_LIN_CTL   (UART5_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART5_LIN_SR    (UART5_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART6 Control Registers
N*/
N#define     REG_UART6_RBR   (UART6_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART6_THR   (UART6_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART6_IER   (UART6_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART6_FCR   (UART6_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART6_LCR   (UART6_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART6_MCR   (UART6_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART6_MSR   (UART6_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART6_FSR   (UART6_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART6_ISR   (UART6_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART6_TOR   (UART6_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART6_BAUD  (UART6_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART6_IRCR  (UART6_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART6_ALT_CSR   (UART6_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART6_FUN_SEL   (UART6_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART6_LIN_CTL   (UART6_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART6_LIN_SR    (UART6_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART7 Control Registers
N*/
N#define     REG_UART7_RBR   (UART7_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART7_THR   (UART7_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART7_IER   (UART7_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART7_FCR   (UART7_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART7_LCR   (UART7_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART7_MCR   (UART7_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART7_MSR   (UART7_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART7_FSR   (UART7_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART7_ISR   (UART7_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART7_TOR   (UART7_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART7_BAUD  (UART7_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART7_IRCR  (UART7_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART7_ALT_CSR   (UART7_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART7_FUN_SEL   (UART7_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART7_LIN_CTL   (UART7_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART7_LIN_SR    (UART7_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART8 Control Registers
N*/
N#define     REG_UART8_RBR   (UART8_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART8_THR   (UART8_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART8_IER   (UART8_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART8_FCR   (UART8_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART8_LCR   (UART8_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART8_MCR   (UART8_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART8_MSR   (UART8_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART8_FSR   (UART8_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART8_ISR   (UART8_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART8_TOR   (UART8_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART8_BAUD  (UART8_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART8_IRCR  (UART8_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART8_ALT_CSR   (UART8_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART8_FUN_SEL   (UART8_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART8_LIN_CTL   (UART8_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART8_LIN_SR    (UART8_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UART9 Control Registers
N*/
N#define     REG_UART9_RBR   (UART9_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UART9_THR   (UART9_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UART9_IER   (UART9_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UART9_FCR   (UART9_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UART9_LCR   (UART9_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UART9_MCR   (UART9_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UART9_MSR   (UART9_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UART9_FSR   (UART9_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UART9_ISR   (UART9_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UART9_TOR   (UART9_BA+0x20)  /*!< Time-out Register */
N#define     REG_UART9_BAUD  (UART9_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UART9_IRCR  (UART9_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UART9_ALT_CSR   (UART9_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UART9_FUN_SEL   (UART9_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UART9_LIN_CTL   (UART9_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UART9_LIN_SR    (UART9_BA+0x38)  /*!< LIN Status Register */
N
N/*
N  UARTA Control Registers
N*/
N#define     REG_UARTA_RBR   (UARTA_BA+0x00)  /*!< Receive Buffer Register */
N#define     REG_UARTA_THR   (UARTA_BA+0x00)  /*!< Transmit Holding Register */
N#define     REG_UARTA_IER   (UARTA_BA+0x04)  /*!< Interrupt Enable Register */
N#define     REG_UARTA_FCR   (UARTA_BA+0x08)  /*!< FIFO Control Register */
N#define     REG_UARTA_LCR   (UARTA_BA+0x0C)  /*!< Line Control Register */
N#define     REG_UARTA_MCR   (UARTA_BA+0x10)  /*!< Modem Control Register */
N#define     REG_UARTA_MSR   (UARTA_BA+0x14)  /*!< MODEM Status Register */
N#define     REG_UARTA_FSR   (UARTA_BA+0x18)  /*!< FIFO Status Register */
N#define     REG_UARTA_ISR   (UARTA_BA+0x1C)  /*!< Interrupt Status Control Register */
N#define     REG_UARTA_TOR   (UARTA_BA+0x20)  /*!< Time-out Register */
N#define     REG_UARTA_BAUD  (UARTA_BA+0x24)  /*!< Baud Rate Divider Register */
N#define     REG_UARTA_IRCR  (UARTA_BA+0x28)  /*!< IrDA Control Register */
N#define     REG_UARTA_ALT_CSR   (UARTA_BA+0x2C)  /*!< Alternate Control Register */
N#define     REG_UARTA_FUN_SEL   (UARTA_BA+0x30)  /*!< UART Function Select REgister */
N#define     REG_UARTA_LIN_CTL   (UARTA_BA+0x34)  /*!< UART LIN Control Register */
N#define     REG_UARTA_LIN_SR    (UARTA_BA+0x38)  /*!< LIN Status Register */
N
N
N/**@}*/ /* end of UART register group */
N
N
N/*---------------------- Timer Controller -------------------------*/
N/**
N    @addtogroup TIMER Timer Controller(TIMER)
N    Memory Mapped Structure for TIMER Controller
N@{ */
N
N#define     REG_TMR0_TCSR   (TMR0_BA+0x00)  /*!< Timer Control and Status Register 0  */
N#define     REG_TMR0_TICR   (TMR0_BA+0x04)  /*!< Timer Compare Register 0             */
N#define     REG_TMR0_TDR    (TMR0_BA+0x08)  /*!< Timer Data Register 0                */
N
N#define     REG_TMR1_TCSR   (TMR1_BA+0x00)  /*!< Timer Control and Status Register 1  */
N#define     REG_TMR1_TICR   (TMR1_BA+0x04)  /*!< Timer Compare Register 1             */
N#define     REG_TMR1_TDR    (TMR1_BA+0x08)  /*!< Timer Data Register 1                */
N
N#define     REG_TMR2_TCSR   (TMR2_BA+0x00)  /*!< Timer Control and Status Register 2  */
N#define     REG_TMR2_TICR   (TMR2_BA+0x04)  /*!< Timer Compare Register 2             */
N#define     REG_TMR2_TDR    (TMR2_BA+0x08)  /*!< Timer Data Register 2                */
N
N#define     REG_TMR3_TCSR   (TMR3_BA+0x00)  /*!< Timer Control and Status Register 3  */
N#define     REG_TMR3_TICR   (TMR3_BA+0x04)  /*!< Timer Compare Register 3             */
N#define     REG_TMR3_TDR    (TMR3_BA+0x08)  /*!< Timer Data Register 3                */
N
N#define     REG_TMR4_TCSR   (TMR4_BA+0x00)  /*!< Timer Control and Status Register 4  */
N#define     REG_TMR4_TICR   (TMR4_BA+0x04)  /*!< Timer Compare Register 4             */
N#define     REG_TMR4_TDR    (TMR4_BA+0x08)  /*!< Timer Data Register 4                */
N
N#define     REG_TMR_TISR    (TMR0_BA+0x60)  /*!< Timer Interrupt Status Register      */
N
N/**@}*/ /* end of TIMER register group */
N
N/*---------------------- Enhance Timer Controller -------------------------*/
N/**
N    @addtogroup ETIMER Enhance Timer Controller(ETIMER)
N    Memory Mapped Structure for TIMER Controller
N@{ */
N
N#define     REG_ETMR0_CTL       (ETMR0_BA+0x00)  /*!< Enhance Timer 0 Control Register */
N#define     REG_ETMR0_PRECNT    (ETMR0_BA+0x04)  /*!< Enhance Timer 0 Pre-Scale Counter Register */
N#define     REG_ETMR0_CMPR      (ETMR0_BA+0x08)  /*!< Enhance Timer 0 Compare Register */
N#define     REG_ETMR0_IER       (ETMR0_BA+0x0C)  /*!< Enhance Timer 0 Interrupt Enable Register */
N#define     REG_ETMR0_ISR       (ETMR0_BA+0x10)  /*!< Enhance Timer 0 Interrupt Status Register  */
N#define     REG_ETMR0_DR        (ETMR0_BA+0x14)  /*!< Enhance Timer 0 Data Register */
N#define     REG_ETMR0_TCAP      (ETMR0_BA+0x18)  /*!< Enhance Timer 0 Capture Data Register  */
N
N#define     REG_ETMR1_CTL       (ETMR1_BA+0x00)  /*!< Enhance Timer 1 Control Register */
N#define     REG_ETMR1_PRECNT    (ETMR1_BA+0x04)  /*!< Enhance Timer 1 Pre-Scale Counter Register */
N#define     REG_ETMR1_CMPR      (ETMR1_BA+0x08)  /*!< Enhance Timer 1 Compare Register */
N#define     REG_ETMR1_IER       (ETMR1_BA+0x0C)  /*!< Enhance Timer 1 Interrupt Enable Register */
N#define     REG_ETMR1_ISR       (ETMR1_BA+0x10)  /*!< Enhance Timer 1 Interrupt Status Register  */
N#define     REG_ETMR1_DR        (ETMR1_BA+0x14)  /*!< Enhance Timer 1 Data Register */
N#define     REG_ETMR1_TCAP      (ETMR1_BA+0x18)  /*!< Enhance Timer 1 Capture Data Register  */
N
N#define     REG_ETMR2_CTL       (ETMR2_BA+0x00)  /*!< Enhance Timer 2 Control Register */
N#define     REG_ETMR2_PRECNT    (ETMR2_BA+0x04)  /*!< Enhance Timer 2 Pre-Scale Counter Register */
N#define     REG_ETMR2_CMPR      (ETMR2_BA+0x08)  /*!< Enhance Timer 2 Compare Register */
N#define     REG_ETMR2_IER       (ETMR2_BA+0x0C)  /*!< Enhance Timer 2 Interrupt Enable Register */
N#define     REG_ETMR2_ISR       (ETMR2_BA+0x10)  /*!< Enhance Timer 2 Interrupt Status Register  */
N#define     REG_ETMR2_DR        (ETMR2_BA+0x14)  /*!< Enhance Timer 2 Data Register */
N#define     REG_ETMR2_TCAP      (ETMR2_BA+0x18)  /*!< Enhance Timer 2 Capture Data Register  */
N
N#define     REG_ETMR3_CTL       (ETMR3_BA+0x00)  /*!< Enhance Timer 3 Control Register */
N#define     REG_ETMR3_PRECNT    (ETMR3_BA+0x04)  /*!< Enhance Timer 3 Pre-Scale Counter Register */
N#define     REG_ETMR3_CMPR      (ETMR3_BA+0x08)  /*!< Enhance Timer 3 Compare Register */
N#define     REG_ETMR3_IER       (ETMR3_BA+0x0C)  /*!< Enhance Timer 3 Interrupt Enable Register */
N#define     REG_ETMR3_ISR       (ETMR3_BA+0x10)  /*!< Enhance Timer 3 Interrupt Status Register  */
N#define     REG_ETMR3_DR        (ETMR3_BA+0x14)  /*!< Enhance Timer 3 Data Register */
N#define     REG_ETMR3_TCAP      (ETMR3_BA+0x18)  /*!< Enhance Timer 3 Capture Data Register  */
N/**@}*/ /* end of ETIMER register group */
N
N/*---------------------- WDT Controller -------------------------*/
N/**
N    @addtogroup WDT Watch Dog Timer Controller(WDT)
N    Memory Mapped Structure for WDT Controller
N@{ */
N
N#define     REG_WDT_CTL         (WDT_BA+0x00)  /*!< WDT Control Register              */
N#define     REG_WDT_ATLCTL      (WDT_BA+0x04)  /*!< WDT Alternative Control Register  */
N
N/**@}*/ /* end of WDT register group */
N
N/*---------------------- WWDT Controller -------------------------*/
N/**
N    @addtogroup WWDT Window Watch Dog Timer Controller(WWDT)
N    Memory Mapped Structure for WWDT Controller
N@{ */
N
N#define     REG_WWDT_RLDCNT     (WWDT_BA+0x00)  /*!< WWDT Reload Counter Register             */
N#define     REG_WWDT_CTL        (WWDT_BA+0x04)  /*!< WWDT Control Register                    */
N#define     REG_WWDT_STATUS     (WWDT_BA+0x08)  /*!< WWDT Status Register                     */
N#define     REG_WWDT_CNT        (WWDT_BA+0x0C)  /*!< WWDT Counter Value Register              */
N
N/**@}*/ /* end of WWDT register group */
N
N/*---------------------- SC Host Interface -------------------------*/
N/**
N    @addtogroup SC Smart Card Host Interface (SC)
N    Memory Mapped Structure for Smart Card Host Interface
N@{ */
N
N#define     REG_SC0_DAT     (SC0_BA+0x00)  /*!< SC0 Receiving/Transmit Holding Buffer Register */
N#define     REG_SC0_CTL     (SC0_BA+0x04)  /*!< SC0 Control Register */
N#define     REG_SC0_ALTCTL  (SC0_BA+0x08)  /*!< SC0 Alternate Control Register  */
N#define     REG_SC0_EGT     (SC0_BA+0x0C)  /*!< SC0 Extend Guard Time Register  */
N#define     REG_SC0_RXTOUT  (SC0_BA+0x10)  /*!< SC0 Receive Buffer Time-out Register */
N#define     REG_SC0_ETUCTL  (SC0_BA+0x14)  /*!< SC0 ETU Control Register */
N#define     REG_SC0_INTEN   (SC0_BA+0x18)  /*!< SC0 Interrupt Enable Control Register */
N#define     REG_SC0_INTSTS  (SC0_BA+0x1C)  /*!< SC0 Interrupt Status Register */
N#define     REG_SC0_STATUS  (SC0_BA+0x20)  /*!< SC0 Status Register */
N#define     REG_SC0_PINCTL  (SC0_BA+0x24)  /*!< SC0 Pin Control State Register */
N#define     REG_SC0_TMRCTL0 (SC0_BA+0x28)  /*!< SC0 Internal Timer Control Register 0 */
N#define     REG_SC0_TMRCTL1 (SC0_BA+0x2C)  /*!< SC0 Internal Timer Control Register 1 */
N#define     REG_SC0_TMRCTL2 (SC0_BA+0x30)  /*!< SC0 Internal Timer Control Register 2 */
N#define     REG_SC0_UARTCTL (SC0_BA+0x34)  /*!< SC0 UART Mode Control Register */
N#define     REG_SC0_TMRDAT0 (SC0_BA+0x38)  /*!< SC0 Timer Current Data Register 0 */
N#define     REG_SC0_TMRDAT1 (SC0_BA+0x3C)  /*!< SC0 Timer Current Data Register 1 */
N
N#define     REG_SC1_DAT     (SC1_BA+0x00)  /*!< SC1 Receiving/Transmit Holding Buffer Register */
N#define     REG_SC1_CTL     (SC1_BA+0x04)  /*!< SC1 Control Register */
N#define     REG_SC1_ALTCTL  (SC1_BA+0x08)  /*!< SC1 Alternate Control Register  */
N#define     REG_SC1_EGT     (SC1_BA+0x0C)  /*!< SC1 Extend Guard Time Register  */
N#define     REG_SC1_RXTOUT  (SC1_BA+0x10)  /*!< SC1 Receive Buffer Time-out Register */
N#define     REG_SC1_ETUCTL  (SC1_BA+0x14)  /*!< SC1 ETU Control Register */
N#define     REG_SC1_INTEN   (SC1_BA+0x18)  /*!< SC1 Interrupt Enable Control Register */
N#define     REG_SC1_INTSTS  (SC1_BA+0x1C)  /*!< SC1 Interrupt Status Register */
N#define     REG_SC1_STATUS  (SC1_BA+0x20)  /*!< SC1 Status Register */
N#define     REG_SC1_PINCTL  (SC1_BA+0x24)  /*!< SC1 Pin Control State Register */
N#define     REG_SC1_TMRCTL0 (SC1_BA+0x28)  /*!< SC1 Internal Timer Control Register 0 */
N#define     REG_SC1_TMRCTL1 (SC1_BA+0x2C)  /*!< SC1 Internal Timer Control Register 1 */
N#define     REG_SC1_TMRCTL2 (SC1_BA+0x30)  /*!< SC1 Internal Timer Control Register 2 */
N#define     REG_SC1_UARTCTL (SC1_BA+0x34)  /*!< SC1 UART Mode Control Register */
N#define     REG_SC1_TMRDAT0 (SC1_BA+0x38)  /*!< SC1 Timer Current Data Register 0 */
N#define     REG_SC1_TMRDAT1 (SC1_BA+0x3C)  /*!< SC1 Timer Current Data Register 1 */
N
N/**@}*/ /* end of SC register group */
N
N
N/*---------------------- Advance Interrupt Controller -------------------------*/
N/**
N    @addtogroup AIC Advance Interrupt Controller(AIC)
N    Memory Mapped Structure for AIC Controller
N@{ */
N
N#define     REG_AIC_SCR1    (AIC_BA+0x00)    /*!< Source control register 1 */
N#define     REG_AIC_SCR2    (AIC_BA+0x04)    /*!< Source control register 2 */
N#define     REG_AIC_SCR3    (AIC_BA+0x08)    /*!< Source control register 3 */
N#define     REG_AIC_SCR4    (AIC_BA+0x0C)    /*!< Source control register 4 */
N#define     REG_AIC_SCR5    (AIC_BA+0x10)    /*!< Source control register 5 */
N#define     REG_AIC_SCR6    (AIC_BA+0x14)    /*!< Source control register 6 */
N#define     REG_AIC_SCR7    (AIC_BA+0x18)    /*!< Source control register 7 */
N#define     REG_AIC_SCR8    (AIC_BA+0x1C)    /*!< Source control register 8 */
N#define     REG_AIC_SCR9    (AIC_BA+0x20)    /*!< Source control register 9 */
N#define     REG_AIC_SCR10   (AIC_BA+0x24)    /*!< Source control register 10 */
N#define     REG_AIC_SCR11   (AIC_BA+0x28)    /*!< Source control register 11 */
N#define     REG_AIC_SCR12   (AIC_BA+0x2C)    /*!< Source control register 12 */
N#define     REG_AIC_SCR13   (AIC_BA+0x30)    /*!< Source control register 13 */
N#define     REG_AIC_SCR14   (AIC_BA+0x34)    /*!< Source control register 14 */
N#define     REG_AIC_SCR15   (AIC_BA+0x38)    /*!< Source control register 15 */
N#define     REG_AIC_SCR16   (AIC_BA+0x3C)    /*!< Source control register 16 */
N#define     REG_AIC_IRSR    (AIC_BA+0x100)   /*!< Interrupt raw status register */
N#define     REG_AIC_IRSRH   (AIC_BA+0x104)   /*!< Interrupt raw status register (Hign) */
N#define     REG_AIC_IASR    (AIC_BA+0x108)   /*!< Interrupt active status register */
N#define     REG_AIC_IASRH   (AIC_BA+0x10C)   /*!< Interrupt active status register (Hign) */
N#define     REG_AIC_ISR     (AIC_BA+0x110)   /*!< Interrupt status register */
N#define     REG_AIC_ISRH    (AIC_BA+0x114)   /*!< Interrupt status register (High) */
N#define     REG_AIC_IPER    (AIC_BA+0x118)   /*!< Interrupt priority encoding register */
N#define     REG_AIC_ISNR    (AIC_BA+0x120)   /*!< Interrupt source number register */
N#define     REG_AIC_OISR    (AIC_BA+0x124)   /*!< Output interrupt status register */
N#define     REG_AIC_IMR     (AIC_BA+0x128)   /*!< Interrupt mask register */
N#define     REG_AIC_IMRH    (AIC_BA+0x12C)   /*!< Interrupt mask register (High) */
N#define     REG_AIC_MECR    (AIC_BA+0x130)   /*!< Mask enable command register */
N#define     REG_AIC_MECRH   (AIC_BA+0x134)   /*!< Mask enable command register (High) */
N#define     REG_AIC_MDCR    (AIC_BA+0x138)   /*!< Mask disable command register */
N#define     REG_AIC_MDCRH   (AIC_BA+0x13C)   /*!< Mask disable command register (High) */
N#define     REG_AIC_SSCR    (AIC_BA+0x140)   /*!< Source Set Command Register */
N#define     REG_AIC_SSCRH   (AIC_BA+0x144)   /*!< Source Set Command Register (High) */
N#define     REG_AIC_SCCR    (AIC_BA+0x148)   /*!< Source Clear Command Register */
N#define     REG_AIC_SCCRH   (AIC_BA+0x14C)   /*!< Source Clear Command Register (High) */
N#define     REG_AIC_EOSCR   (AIC_BA+0x150)   /*!< End of service command register */
N
N/**@}*/ /* end of AIC register group */
N
N
N/*---------------------- General Purpose Input/Output Controller -------------------------*/
N/**
N    @addtogroup GPIO General Purpose Input/Output Controller(GPIO)
N    Memory Mapped Structure for GPIO Controller
N@{ */
N
N#define     REG_GPIOA_DIR       (GPIO_BA+0x000)  /*!< GPIO portA direction control register */
N#define     REG_GPIOA_DATAOUT   (GPIO_BA+0x004)  /*!< GPIO portA data output register */
N#define     REG_GPIOA_DATAIN    (GPIO_BA+0x008)  /*!< GPIO portA data input register */
N#define     REG_GPIOA_IMD       (GPIO_BA+0x00C)  /*!< GPIO Port A Interrupt Mode Register */
N#define     REG_GPIOA_IREN      (GPIO_BA+0x010)  /*!< GPIO Port A Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOA_IFEN      (GPIO_BA+0x014)  /*!< GPIO Port A Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOA_ISR       (GPIO_BA+0x018)  /*!< GPIO Port A Interrupt Status Register */
N#define     REG_GPIOA_DBEN      (GPIO_BA+0x01C)  /*!< GPIO Port A De-bounce Enable Register */
N#define     REG_GPIOA_PUEN      (GPIO_BA+0x020)  /*!< GPIO Port A Pull-Up Enable Register */
N#define     REG_GPIOA_PDEN      (GPIO_BA+0x024)  /*!< GPIO Port A Pull-Down Enable Register */
N#define     REG_GPIOA_ICEN      (GPIO_BA+0x028)  /*!< GPIO Port A CMOS Input Enable Register */
N#define     REG_GPIOA_ISEN      (GPIO_BA+0x02C)  /*!< GPIO Port A Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOB_DIR       (GPIO_BA+0x040)  /*!< GPIO port B direction control register */
N#define     REG_GPIOB_DATAOUT   (GPIO_BA+0x044)  /*!< GPIO port B data output register */
N#define     REG_GPIOB_DATAIN    (GPIO_BA+0x048)  /*!< GPIO port B data input register */
N#define     REG_GPIOB_IMD       (GPIO_BA+0x04C)  /*!< GPIO Port B Interrupt Mode Register */
N#define     REG_GPIOB_IREN      (GPIO_BA+0x050)  /*!< GPIO Port B Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOB_IFEN      (GPIO_BA+0x054)  /*!< GPIO Port B Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOB_ISR       (GPIO_BA+0x058)  /*!< GPIO Port B Interrupt Status Register */
N#define     REG_GPIOB_DBEN      (GPIO_BA+0x05C)  /*!< GPIO Port B De-bounce Enable Register */
N#define     REG_GPIOB_PUEN      (GPIO_BA+0x060)  /*!< GPIO Port B Pull-Up Enable Register */
N#define     REG_GPIOB_PDEN      (GPIO_BA+0x064)  /*!< GPIO Port B Pull-Down Enable Register */
N#define     REG_GPIOB_ICEN      (GPIO_BA+0x068)  /*!< GPIO Port B CMOS Input Enable Register */
N#define     REG_GPIOB_ISEN      (GPIO_BA+0x06C)  /*!< GPIO Port B Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOC_DIR       (GPIO_BA+0x080)  /*!< GPIO port C direction control register */
N#define     REG_GPIOC_DATAOUT   (GPIO_BA+0x084)  /*!< GPIO port C data output register */
N#define     REG_GPIOC_DATAIN    (GPIO_BA+0x088)  /*!< GPIO port C data input register */
N#define     REG_GPIOC_IMD       (GPIO_BA+0x08C)  /*!< GPIO Port C Interrupt Mode Register */
N#define     REG_GPIOC_IREN      (GPIO_BA+0x090)  /*!< GPIO Port C Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOC_IFEN      (GPIO_BA+0x094)  /*!< GPIO Port C Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOC_ISR       (GPIO_BA+0x098)  /*!< GPIO Port C Interrupt Status Register */
N#define     REG_GPIOC_DBEN      (GPIO_BA+0x09C)  /*!< GPIO Port C De-bounce Enable Register */
N#define     REG_GPIOC_PUEN      (GPIO_BA+0x0A0)  /*!< GPIO Port C Pull-Up Enable Register */
N#define     REG_GPIOC_PDEN      (GPIO_BA+0x0A4)  /*!< GPIO Port C Pull-Down Enable Register */
N#define     REG_GPIOC_ICEN      (GPIO_BA+0x0A8)  /*!< GPIO Port C CMOS Input Enable Register */
N#define     REG_GPIOC_ISEN      (GPIO_BA+0x0AC)  /*!< GPIO Port C Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOD_DIR       (GPIO_BA+0x0C0)  /*!< GPIO port D direction control register */
N#define     REG_GPIOD_DATAOUT   (GPIO_BA+0x0C4)  /*!< GPIO port D data output register */
N#define     REG_GPIOD_DATAIN    (GPIO_BA+0x0C8)  /*!< GPIO port D data input register */
N#define     REG_GPIOD_IMD       (GPIO_BA+0x0CC)  /*!< GPIO Port D Interrupt Mode Register */
N#define     REG_GPIOD_IREN      (GPIO_BA+0x0D0)  /*!< GPIO Port D Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOD_IFEN      (GPIO_BA+0x0D4)  /*!< GPIO Port D Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOD_ISR       (GPIO_BA+0x0D8)  /*!< GPIO Port D Interrupt Status Register */
N#define     REG_GPIOD_DBEN      (GPIO_BA+0x0DC)  /*!< GPIO Port D De-bounce Enable Register */
N#define     REG_GPIOD_PUEN      (GPIO_BA+0x0E0)  /*!< GPIO Port D Pull-Up Enable Register */
N#define     REG_GPIOD_PDEN      (GPIO_BA+0x0E4)  /*!< GPIO Port D Pull-Down Enable Register */
N#define     REG_GPIOD_ICEN      (GPIO_BA+0x0E8)  /*!< GPIO Port D CMOS Input Enable Register */
N#define     REG_GPIOD_ISEN      (GPIO_BA+0x0EC)  /*!< GPIO Port D Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOE_DIR       (GPIO_BA+0x100)  /*!< GPIO port E direction control register */
N#define     REG_GPIOE_DATAOUT   (GPIO_BA+0x104)  /*!< GPIO port E data output register */
N#define     REG_GPIOE_DATAIN    (GPIO_BA+0x108)  /*!< GPIO port E data input register */
N#define     REG_GPIOE_IMD       (GPIO_BA+0x10C)  /*!< GPIO Port E Interrupt Mode Register */
N#define     REG_GPIOE_IREN      (GPIO_BA+0x110)  /*!< GPIO Port E Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOE_IFEN      (GPIO_BA+0x114)  /*!< GPIO Port E Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOE_ISR       (GPIO_BA+0x118)  /*!< GPIO Port E Interrupt Status Register */
N#define     REG_GPIOE_DBEN      (GPIO_BA+0x11C)  /*!< GPIO Port E De-bounce Enable Register */
N#define     REG_GPIOE_PUEN      (GPIO_BA+0x120)  /*!< GPIO Port E Pull-Up Enable Register */
N#define     REG_GPIOE_PDEN      (GPIO_BA+0x124)  /*!< GPIO Port E Pull-Down Enable Register */
N#define     REG_GPIOE_ICEN      (GPIO_BA+0x128)  /*!< GPIO Port E CMOS Input Enable Register */
N#define     REG_GPIOE_ISEN      (GPIO_BA+0x12C)  /*!< GPIO Port E Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOF_DIR       (GPIO_BA+0x140)  /*!< GPIO port F direction control register */
N#define     REG_GPIOF_DATAOUT   (GPIO_BA+0x144)  /*!< GPIO port F data output register */
N#define     REG_GPIOF_DATAIN    (GPIO_BA+0x148)  /*!< GPIO port F data input register */
N#define     REG_GPIOF_IMD       (GPIO_BA+0x14C)  /*!< GPIO Port F Interrupt Mode Register */
N#define     REG_GPIOF_IREN      (GPIO_BA+0x150)  /*!< GPIO Port F Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOF_IFEN      (GPIO_BA+0x154)  /*!< GPIO Port F Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOF_ISR       (GPIO_BA+0x158)  /*!< GPIO Port F Interrupt Status Register */
N#define     REG_GPIOF_DBEN      (GPIO_BA+0x15C)  /*!< GPIO Port F De-bounce Enable Register */
N#define     REG_GPIOF_PUEN      (GPIO_BA+0x160)  /*!< GPIO Port F Pull-Up Enable Register */
N#define     REG_GPIOF_PDEN      (GPIO_BA+0x164)  /*!< GPIO Port F Pull-Down Enable Register */
N#define     REG_GPIOF_ICEN      (GPIO_BA+0x168)  /*!< GPIO Port F CMOS Input Enable Register */
N#define     REG_GPIOF_ISEN      (GPIO_BA+0x16C)  /*!< GPIO Port F Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOG_DIR       (GPIO_BA+0x180)  /*!< GPIO port G direction control register */
N#define     REG_GPIOG_DATAOUT   (GPIO_BA+0x184)  /*!< GPIO port G data output register */
N#define     REG_GPIOG_DATAIN    (GPIO_BA+0x188)  /*!< GPIO port G data input register */
N#define     REG_GPIOG_IMD       (GPIO_BA+0x18C)  /*!< GPIO Port G Interrupt Mode Register */
N#define     REG_GPIOG_IREN      (GPIO_BA+0x190)  /*!< GPIO Port G Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOG_IFEN      (GPIO_BA+0x194)  /*!< GPIO Port G Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOG_ISR       (GPIO_BA+0x198)  /*!< GPIO Port G Interrupt Status Register */
N#define     REG_GPIOG_DBEN      (GPIO_BA+0x19C)  /*!< GPIO Port G De-bounce Enable Register */
N#define     REG_GPIOG_PUEN      (GPIO_BA+0x1A0)  /*!< GPIO Port G Pull-Up Enable Register */
N#define     REG_GPIOG_PDEN      (GPIO_BA+0x1A4)  /*!< GPIO Port G Pull-Down Enable Register */
N#define     REG_GPIOG_ICEN      (GPIO_BA+0x1A8)  /*!< GPIO Port G CMOS Input Enable Register */
N#define     REG_GPIOG_ISEN      (GPIO_BA+0x1AC)  /*!< GPIO Port G Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOH_DIR       (GPIO_BA+0x1C0)  /*!< GPIO port H direction control register */
N#define     REG_GPIOH_DATAOUT   (GPIO_BA+0x1C4)  /*!< GPIO port H data output register */
N#define     REG_GPIOH_DATAIN    (GPIO_BA+0x1C8)  /*!< GPIO port H data input register */
N#define     REG_GPIOH_IMD       (GPIO_BA+0x1CC)  /*!< GPIO Port H Interrupt Mode Register */
N#define     REG_GPIOH_IREN      (GPIO_BA+0x1D0)  /*!< GPIO Port H Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOH_IFEN      (GPIO_BA+0x1D4)  /*!< GPIO Port H Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOH_ISR       (GPIO_BA+0x1D8)  /*!< GPIO Port H Interrupt Status Register */
N#define     REG_GPIOH_DBEN      (GPIO_BA+0x1DC)  /*!< GPIO Port H De-bounce Enable Register */
N#define     REG_GPIOH_PUEN      (GPIO_BA+0x1E0)  /*!< GPIO Port H Pull-Up Enable Register */
N#define     REG_GPIOH_PDEN      (GPIO_BA+0x1E4)  /*!< GPIO Port H Pull-Down Enable Register */
N#define     REG_GPIOH_ICEN      (GPIO_BA+0x1E8)  /*!< GPIO Port H CMOS Input Enable Register */
N#define     REG_GPIOH_ISEN      (GPIO_BA+0x1EC)  /*!< GPIO Port H Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOI_DIR       (GPIO_BA+0x200)  /*!< GPIO port I direction control register */
N#define     REG_GPIOI_DATAOUT   (GPIO_BA+0x204)  /*!< GPIO port I data output register */
N#define     REG_GPIOI_DATAIN    (GPIO_BA+0x208)  /*!< GPIO port I data input register */
N#define     REG_GPIOI_IMD       (GPIO_BA+0x20C)  /*!< GPIO Port I Interrupt Mode Register */
N#define     REG_GPIOI_IREN      (GPIO_BA+0x210)  /*!< GPIO Port I Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOI_IFEN      (GPIO_BA+0x214)  /*!< GPIO Port I Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOI_ISR       (GPIO_BA+0x218)  /*!< GPIO Port I Interrupt Status Register */
N#define     REG_GPIOI_DBEN      (GPIO_BA+0x21C)  /*!< GPIO Port I De-bounce Enable Register */
N#define     REG_GPIOI_PUEN      (GPIO_BA+0x220)  /*!< GPIO Port I Pull-Up Enable Register */
N#define     REG_GPIOI_PDEN      (GPIO_BA+0x224)  /*!< GPIO Port I Pull-Down Enable Register */
N#define     REG_GPIOI_ICEN      (GPIO_BA+0x228)  /*!< GPIO Port I CMOS Input Enable Register */
N#define     REG_GPIOI_ISEN      (GPIO_BA+0x22C)  /*!< GPIO Port I Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIOJ_DIR       (GPIO_BA+0x240)  /*!< GPIO port J direction control register */
N#define     REG_GPIOJ_DATAOUT   (GPIO_BA+0x244)  /*!< GPIO port J data output register */
N#define     REG_GPIOJ_DATAIN    (GPIO_BA+0x248)  /*!< GPIO port J data input register */
N#define     REG_GPIOJ_IMD       (GPIO_BA+0x24C)  /*!< GPIO Port J Interrupt Mode Register */
N#define     REG_GPIOJ_IREN      (GPIO_BA+0x250)  /*!< GPIO Port J Interrupt Rising-Edge or Level-High Enable Register */
N#define     REG_GPIOJ_IFEN      (GPIO_BA+0x254)  /*!< GPIO Port J Interrupt Falling-Edge or Level-Low Enable Register */
N#define     REG_GPIOJ_ISR       (GPIO_BA+0x258)  /*!< GPIO Port J Interrupt Status Register */
N#define     REG_GPIOJ_DBEN      (GPIO_BA+0x25C)  /*!< GPIO Port J De-bounce Enable Register */
N#define     REG_GPIOJ_PUEN      (GPIO_BA+0x260)  /*!< GPIO Port J Pull-Up Enable Register */
N#define     REG_GPIOJ_PDEN      (GPIO_BA+0x264)  /*!< GPIO Port J Pull-Down Enable Register */
N#define     REG_GPIOJ_ICEN      (GPIO_BA+0x268)  /*!< GPIO Port J CMOS Input Enable Register */
N#define     REG_GPIOJ_ISEN      (GPIO_BA+0x26C)  /*!< GPIO Port J Schmitt-Trigger Input Enable Register */
N
N#define     REG_GPIO_DBNCECON   (GPIO_BA+0x3F0)  /*!< GPIO Debounce Control Register */
N#define     REG_GPIO_ISR        (GPIO_BA+0x3FC)  /*!< GPIO Port Interrupt Status Register */
N
N/**@}*/ /* end of GPIO register group */
N
N
N/*---------------------- Real Time Clock Controller -------------------------*/
N/**
N    @addtogroup RTC Real Time Clock Controller(RTC)
N    Memory Mapped Structure for RTC Controller
N@{ */
N
N#define     REG_RTC_INIT    (RTC_BA+0x00)   /*!< RTC Initiation Register */
N#define     REG_RTC_RWEN    (RTC_BA+0x04)   /*!< RTC Access Enable Register */
N#define     REG_RTC_FREQADJ (RTC_BA+0x08)   /*!< RTC Frequency Compensation Register */
N#define     REG_RTC_TIME    (RTC_BA+0x0C)   /*!< Time Loading Register */
N#define     REG_RTC_CAL     (RTC_BA+0x10)   /*!< Calendar Loading Register */
N#define     REG_RTC_TIMEFMT (RTC_BA+0x14)   /*!< Time Format Selection Register */
N#define     REG_RTC_WEEKDAY (RTC_BA+0x18)   /*!< Day of the Week Register */
N#define     REG_RTC_TALM    (RTC_BA+0x1C)   /*!< Time Alarm Register */
N#define     REG_RTC_CALM    (RTC_BA+0x20)   /*!< Calendar Alarm Register */
N#define     REG_RTC_LEAPYEAR    (RTC_BA+0x24)   /*!< Leap year Indicator Register */
N#define     REG_RTC_INTEN   (RTC_BA+0x28)   /*!< RTC Interrupt Enable Register */
N#define     REG_RTC_INTSTS  (RTC_BA+0x2C)   /*!< RTC Interrupt Indicator Register */
N#define     REG_RTC_TICK    (RTC_BA+0x30)   /*!< RTC Time Tick Register */
N#define     REG_RTC_PWRCTL      (RTC_BA+0x34)   /*!< Power Control Register */
N#define     REG_RTC_PWRCNT      (RTC_BA+0x38)   /*!< Power Control Counter Register */
N#define     REG_RTC_SPR0        (RTC_BA+0x40)   /*!< Spare REgistger 0 */
N#define     REG_RTC_SPR1        (RTC_BA+0x44)   /*!< Spare REgistger 1 */
N#define     REG_RTC_SPR2        (RTC_BA+0x48)   /*!< Spare REgistger 2 */
N#define     REG_RTC_SPR3        (RTC_BA+0x4C)   /*!< Spare REgistger 3 */
N#define     REG_RTC_SPR4        (RTC_BA+0x50)   /*!< Spare REgistger 4 */
N#define     REG_RTC_SPR5        (RTC_BA+0x54)   /*!< Spare REgistger 5 */
N#define     REG_RTC_SPR6        (RTC_BA+0x58)   /*!< Spare REgistger 6 */
N#define     REG_RTC_SPR7        (RTC_BA+0x5C)   /*!< Spare REgistger 7 */
N#define     REG_RTC_SPR8        (RTC_BA+0x60)   /*!< Spare REgistger 8 */
N#define     REG_RTC_SPR9        (RTC_BA+0x64)   /*!< Spare REgistger 9 */
N#define     REG_RTC_SPR10       (RTC_BA+0x68)   /*!< Spare REgistger 10 */
N#define     REG_RTC_SPR11       (RTC_BA+0x6C)   /*!< Spare REgistger 11 */
N#define     REG_RTC_SPR12       (RTC_BA+0x70)   /*!< Spare REgistger 12 */
N#define     REG_RTC_SPR13       (RTC_BA+0x74)   /*!< Spare REgistger 13 */
N#define     REG_RTC_SPR14       (RTC_BA+0x78)   /*!< Spare REgistger 14 */
N#define     REG_RTC_SPR15       (RTC_BA+0x7C)   /*!< Spare REgistger 15 */
N
N/**@}*/ /* end of RTC register group */
N
N/*---------------------- Inter-IC Bus Controller -------------------------*/
N/**
N    @addtogroup I2C Inter-IC Bus Controller(I2C)
N    Memory Mapped Structure for I2C Controller
N@{ */
N
N#define     REG_I2C0_CSR        (I2C0_BA+0x00)  /*!< Control and Status Register */
N#define     REG_I2C0_DIVIDER    (I2C0_BA+0x04)  /*!< Clock Prescale Register */
N#define     REG_I2C0_CMDR       (I2C0_BA+0x08)  /*!< Command Register */
N#define     REG_I2C0_SWR        (I2C0_BA+0x0C)  /*!< Software Mode Control Register */
N#define     REG_I2C0_RXR        (I2C0_BA+0x10)  /*!< Data Receive Register */
N#define     REG_I2C0_TXR        (I2C0_BA+0x14)  /*!< Data Transmit Register */
N
N#define     REG_I2C1_CSR        (I2C1_BA+0x00)  /*!< Control and Status Register */
N#define     REG_I2C1_DIVIDER    (I2C1_BA+0x04)  /*!< Clock Prescale Register */
N#define     REG_I2C1_CMDR       (I2C1_BA+0x08)  /*!< Command Register */
N#define     REG_I2C1_SWR        (I2C1_BA+0x0C)  /*!< Software Mode Control Register */
N#define     REG_I2C1_RXR        (I2C1_BA+0x10)  /*!< Data Receive Register */
N#define     REG_I2C1_TXR        (I2C1_BA+0x14)  /*!< Data Transmit Register */
N
N/**@}*/ /* end of I2C register group */
N
N
N/*---------------------- Serial Peripheral Interface Controller -------------------------*/
N/**
N    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
N    Memory Mapped Structure for SPI Controller
N@{ */
N
N#define     REG_SPI0_CNTRL   (SPI0_BA+0x00)  /*!< Control and Status Register */
N#define     REG_SPI0_DIVIDER (SPI0_BA+0x04)  /*!< Clock Divider Register */
N#define     REG_SPI0_SSR     (SPI0_BA+0x08)  /*!< Slave Select Register */
N#define     REG_SPI0_RX0     (SPI0_BA+0x10)  /*!< Data Receive Register 0 */
N#define     REG_SPI0_RX1     (SPI0_BA+0x14)  /*!< Data Receive Register 1 */
N#define     REG_SPI0_RX2     (SPI0_BA+0x18)  /*!< Data Receive Register 2 */
N#define     REG_SPI0_RX3     (SPI0_BA+0x1C)  /*!< Data Receive Register 3 */
N#define     REG_SPI0_TX0     (SPI0_BA+0x10)  /*!< Data Transmit Register 0 */
N#define     REG_SPI0_TX1     (SPI0_BA+0x14)  /*!< Data Transmit Register 1 */
N#define     REG_SPI0_TX2     (SPI0_BA+0x18)  /*!< Data Transmit Register 2 */
N#define     REG_SPI0_TX3     (SPI0_BA+0x1C)  /*!< Data Transmit Register 3 */
N
N#define     REG_SPI1_CNTRL   (SPI1_BA+0x00)  /*!< Control and Status Register */
N#define     REG_SPI1_DIVIDER (SPI1_BA+0x04)  /*!< Clock Divider Register */
N#define     REG_SPI1_SSR     (SPI1_BA+0x08)  /*!< Slave Select Register */
N#define     REG_SPI1_RX0     (SPI1_BA+0x10)  /*!< Data Receive Register 0 */
N#define     REG_SPI1_RX1     (SPI1_BA+0x14)  /*!< Data Receive Register 1 */
N#define     REG_SPI1_RX2     (SPI1_BA+0x18)  /*!< Data Receive Register 2 */
N#define     REG_SPI1_RX3     (SPI1_BA+0x1C)  /*!< Data Receive Register 3 */
N#define     REG_SPI1_TX0     (SPI1_BA+0x10)  /*!< Data Transmit Register 0 */
N#define     REG_SPI1_TX1     (SPI1_BA+0x14)  /*!< Data Transmit Register 1 */
N#define     REG_SPI1_TX2     (SPI1_BA+0x18)  /*!< Data Transmit Register 2 */
N#define     REG_SPI1_TX3     (SPI1_BA+0x1C)  /*!< Data Transmit Register 3 */
N
N/**@}*/ /* end of SPI register group */
N
N
N/*---------------------- Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup PWM Pulse Width Modulation Controller(PWM)
N    Memory Mapped Structure for PWM Controller
N@{ */
N
N#define     REG_PWM_PPR     (PWM_BA+0x00)  /*!< PWM Pre-scale Register 0 */
N#define     REG_PWM_CSR     (PWM_BA+0x04)  /*!< PWM Clock Select Register */
N#define     REG_PWM_PCR     (PWM_BA+0x08)  /*!< PWM Control Register */
N#define     REG_PWM_CNR0    (PWM_BA+0x0C)  /*!< PWM Counter Register 0 */
N#define     REG_PWM_CMR0    (PWM_BA+0x10)  /*!< PWM Comparator Register 0 */
N#define     REG_PWM_PDR0    (PWM_BA+0x14)  /*!< PWM Data Register 0 */
N#define     REG_PWM_CNR1    (PWM_BA+0x18)  /*!< PWM Counter Register 1 */
N#define     REG_PWM_CMR1    (PWM_BA+0x1C)  /*!< PWM Comparator Register 1 */
N#define     REG_PWM_PDR1    (PWM_BA+0x20)  /*!< PWM Data Register 1 */
N#define     REG_PWM_CNR2    (PWM_BA+0x24)  /*!< PWM Counter Register 2 */
N#define     REG_PWM_CMR2    (PWM_BA+0x28)  /*!< PWM Comparator Register 2 */
N#define     REG_PWM_PDR2    (PWM_BA+0x2C)  /*!< PWM Data Register 2 */
N#define     REG_PWM_CNR3    (PWM_BA+0x30)  /*!< PWM Counter Register 3 */
N#define     REG_PWM_CMR3    (PWM_BA+0x34)  /*!< PWM Comparator Register 3 */
N#define     REG_PWM_PDR3    (PWM_BA+0x38)  /*!< PWM Data Register 3 */
N#define     REG_PWM_PIER    (PWM_BA+0x3C)  /*!< PWM Timer Interrupt Enable Register */
N#define     REG_PWM_PIIR    (PWM_BA+0x40)  /*!< PWM Timer Interrupt Identification Register */
N
N/**@}*/ /* end of PWM register group */
N
N
N/*---------------------- Analog to Digital Converter -------------------------*/
N/**
N    @addtogroup ADC Analog to Digital Converter(ADC)
N    Memory Mapped Structure for ADC Controller
N@{ */
N
N#define REG_ADC_CTL       (ADC_BA+0x000) /*!< ADC Contrl */
N#define REG_ADC_CONF      (ADC_BA+0x004) /*!< ADC Configure */
N#define REG_ADC_IER       (ADC_BA+0x008) /*!< ADC Interrupt Enable Register */
N#define REG_ADC_ISR       (ADC_BA+0x00C) /*!< ADC Interrupt Status Register */
N#define REG_ADC_WKISR     (ADC_BA+0x010) /*!< ADC Wake Up Interrupt Status Register */
N#define REG_ADC_XYDATA    (ADC_BA+0x020) /*!< ADC Touch XY Pressure Data */
N#define REG_ADC_ZDATA     (ADC_BA+0x024) /*!< ADC Touch Z Pressure Data */
N#define REG_ADC_DATA      (ADC_BA+0x028) /*!< ADC Normal Conversion Data */
N#define REG_ADC_VBADATA   (ADC_BA+0x02C) /*!< ADC Battery Detection Data */
N#define REG_ADC_KPDATA    (ADC_BA+0x030) /*!< ADC Key Pad Data */
N#define REG_ADC_SELFDATA  (ADC_BA+0x034) /*!< ADC Self-Test Data */
N#define REG_ADC_XYSORT0   (ADC_BA+0x1F4) /*!< ADC Touch XY Position Mean Value Sort 0 */
N#define REG_ADC_XYSORT1   (ADC_BA+0x1F8) /*!< ADC Touch XY Position Mean Value Sort 1 */
N#define REG_ADC_XYSORT2   (ADC_BA+0x1FC) /*!< ADC Touch XY Position Mean Value Sort 2 */
N#define REG_ADC_XYSORT3   (ADC_BA+0x200) /*!< ADC Touch XY Position Mean Value Sort 3 */
N#define REG_ADC_ZSORT0    (ADC_BA+0x204) /*!< ADC Touch Z Pressure Mean Value Sort 0 */
N#define REG_ADC_ZSORT1    (ADC_BA+0x208) /*!< ADC Touch Z Pressure Mean Value Sort 1 */
N#define REG_ADC_ZSORT2    (ADC_BA+0x20C) /*!< ADC Touch Z Pressure Mean Value Sort 2 */
N#define REG_ADC_ZSORT3    (ADC_BA+0x210) /*!< ADC Touch Z Pressure Mean Value Sort 3 */
N#define REG_ADC_MTMULCK   (ADC_BA+0x220) /*!< ADC Manual Test Mode Unlock */
N#define REG_ADC_MTCONF    (ADC_BA+0x224) /*!< ADC Manual Test Mode Configure */
N#define REG_ADC_MTCON     (ADC_BA+0x228) /*!< ADC Manual Test Mode Control */
N#define REG_ADC_ADCAII    (ADC_BA+0x22C) /*!< ADC Analog Interface Information */
N#define REG_ADC_ADCAIIRLT (ADC_BA+0x230) /*!< ADC Analog Interface Information Result */
N
N/**@}*/ /* end of ADC register group */
N
N/*------------------ Capture Sensor Interface Controller ---------------------*/
N/**
N    @addtogroup CAP Capture Sensor Interface Controller(CAP)
N    Memory Mapped Structure for CAP Controller
N@{ */
N
N#define REG_CAP_CTL            (CAP_BA+0x000)  /*!< Image Capture Interface Control Register */
N#define REG_CAP_PAR            (CAP_BA+0x004)  /*!< Image Capture Interface Parameter Register */
N#define REG_CAP_INT            (CAP_BA+0x008)  /*!< Image Capture Interface Interrupt Registe */
N#define REG_CAP_POSTERIZE      (CAP_BA+0x00C)  /*!< YUV Component Posterizing Factor Register */
N#define REG_CAP_MD             (CAP_BA+0x010)  /*!< Motion Detection Register */
N#define REG_CAP_MDADDR         (CAP_BA+0x014)  /*!< Motion Detection Output Address Register */
N#define REG_CAP_MDYADDR        (CAP_BA+0x018)  /*!< Motion Detection Temp YOutput Address Register */
N#define REG_CAP_SEPIA          (CAP_BA+0x01C)  /*!< Sepia Effect Control Register */
N#define REG_CAP_CWSP           (CAP_BA+0x020)  /*!< Cropping Window Starting Address Register */
N#define REG_CAP_CWS            (CAP_BA+0x024)  /*!< Cropping Window Size Register */
N#define REG_CAP_PKTSL          (CAP_BA+0x028)  /*!< Packet Scaling Vertical/Horizontal Factor Register (LSB) */
N#define REG_CAP_PLNSL          (CAP_BA+0x02C)  /*!< Planar Scaling Vertical/Horizontal Factor Register (LSB) */
N#define REG_CAP_FRCTL          (CAP_BA+0x030)  /*!< Scaling Frame Rate Factor Register */
N#define REG_CAP_STRIDE         (CAP_BA+0x034)  /*!< Frame Output Pixel Stride Register */
N#define REG_CAP_FIFOTH         (CAP_BA+0x03C)  /*!< FIFO threshold Register */
N#define REG_CAP_CMPADDR        (CAP_BA+0x040)  /*!< Compare Packet Memory Base Address Register */
N#define REG_CAP_PKTSM          (CAP_BA+0x048)  /*!< Packet Scaling Vertical/Horizontal Factor Register (MSB) */
N#define REG_CAP_PLNSM          (CAP_BA+0x04C)  /*!< Planar Scaling Vertical/Horizontal Factor Register (MSB) */
N#define REG_CAP_CURADDRP       (CAP_BA+0x050)  /*!< Current Packet System Memory Address Register */
N#define REG_CAP_CURADDRY       (CAP_BA+0x054)  /*!< Current Planar Y System Memory Address Register */
N#define REG_CAP_CURADDRU       (CAP_BA+0x058)  /*!< Current Planar U System Memory Address Register */
N#define REG_CAP_CURADDRV       (CAP_BA+0x05C)  /*!< Current Planar V System Memory Address Register */
N#define REG_CAP_PKTBA0         (CAP_BA+0x060)  /*!< System Memory Packet Base Address Register */
N#define REG_CAP_PKTBA1         (CAP_BA+0x064)  /*!< System Memory Packet Base Address Register */
N#define REG_CAP_YBA            (CAP_BA+0x080)  /*!< System Memory Planar Y Base Address Register */
N#define REG_CAP_UBA            (CAP_BA+0x084)  /*!< System Memory Planar U Base Address Register */
N#define REG_CAP_VBA            (CAP_BA+0x088)  /*!< System Memory Planar V Base Address Register */
N
N/**@}*/ /* end of CAP register group */
N
N/*------------------ SDRAM Interface Controller ---------------------*/
N/**
N    @addtogroup SDIC SDRAM Interface Controller(SDIC)
N    Memory Mapped Structure for SDIC Controller
N@{ */
N
N#define REG_SDIC_OPMCTL     (SDIC_BA+0x000)    /*!< SDRAM Controller Operation Mode Control Register */
N#define REG_SDIC_CMD        (SDIC_BA+0x004)    /*!< SDRAM Command Register */
N#define REG_SDIC_REFCTL     (SDIC_BA+0x008)    /*!< SDRAM Controller Refresh Control Register */
N#define REG_SDIC_SIZE0      (SDIC_BA+0x010)    /*!< SDRAM 0 Size Register */
N#define REG_SDIC_SIZE1      (SDIC_BA+0x014)    /*!< SDRAM 1 Size Register */
N#define REG_SDIC_MR         (SDIC_BA+0x018)    /*!< SDRAM Mode Register */
N#define REG_SDIC_EMR        (SDIC_BA+0x01C)    /*!< SDRAM Extended Mode Register */
N#define REG_SDIC_EMR2       (SDIC_BA+0x020)    /*!< SDRAM Extended Mode Register 2 */
N#define REG_SDIC_EMR3       (SDIC_BA+0x024)    /*!< SDRAM Extended Mode Register 3 */
N#define REG_SDIC_TIME       (SDIC_BA+0x028)    /*!< SDRAM Timing Control Register */
N#define REG_SDIC_DQSODS     (SDIC_BA+0x030)    /*!< DQS Output Delay Selection Register */
N#define REG_SDIC_CKDQSDS    (SDIC_BA+0x034)    /*!< Clock and DQS Delay Selection Register */
N#define REG_SDIC_DAENSEL    (SDIC_BA+0x038)    /*!< Data Latch Enable Selection Register */
N
N/**@}*/ /* end of SDIC register group */
N
N/*---------------------- Controller Area Network -------------------------*/
N/**
N    @addtogroup CAN Controller Area Network(CAN)
N    Memory Mapped Structure for CAN Controller
N@{ */
N
N#define REG_CAN0_CON       (CAN0_BA+0x00) /*!< Control Register */
N#define REG_CAN0_STATUS    (CAN0_BA+0x04) /*!< Status Register */
N#define REG_CAN0_ERR       (CAN0_BA+0x08) /*!< Error Counter Register */
N#define REG_CAN0_BTIME     (CAN0_BA+0x0C) /*!< Bit Time Register */
N#define REG_CAN0_IIDR      (CAN0_BA+0x10) /*!< Interrupt Identifier Register */
N#define REG_CAN0_TEST      (CAN0_BA+0x14) /*!< Test Register */
N#define REG_CAN0_BRPE      (CAN0_BA+0x18) /*!< BRP Extension Register */
N#define REG_CAN0_IF1_CREQ  (CAN0_BA+0x20) /*!< IF1 Command Request Register */
N#define REG_CAN0_IF2_CREQ  (CAN0_BA+0x80) /*!< IF2 Command Request Register */
N#define REG_CAN0_IF1_CMASK (CAN0_BA+0x24) /*!< IF1 Command Mask Register */
N#define REG_CAN0_IF2_CMASK (CAN0_BA+0x84) /*!< IF2 Command Mask Register */
N#define REG_CAN0_IF1_MASK1 (CAN0_BA+0x28) /*!< IF1 Msak 1 Register */
N#define REG_CNA0_IF2_MASK1 (CAN0_BA+0x88) /*!< IF2 Mask 1 Register */
N#define REG_CAN0_IF1_MASK2 (CAN0_BA+0x2C) /*!< IF1 Mask 2 Register */
N#define REG_CAN0_IF2_MASK2 (CAN0_BA+0x8C) /*!< IF2 Mask 2 REgister */
N#define REG_CAN0_IF1_ARB1  (CAN0_BA+0x30) /*!< IF1 Arbitration 1 Register */
N#define REG_CAN0_IF2_ARB1  (CAN0_BA+0x90) /*!< IF2 Arbitration 1 Register */
N#define REG_CAN0_IF1_ARB2  (CAN0_BA+0x34) /*!< IF1 Arbitration 2 Register */
N#define REG_CAN0_IF2_ARB2  (CAN0_BA+0x94) /*!< IF2 Arbitration 2 Register */
N#define REG_CAN0_IF1_MCON  (CAN0_BA+0x38) /*!< IF1 Message Control Register */
N#define REG_CAN0_IF2_MCON  (CAN0_BA+0x98) /*!< IF2 Message Control Register */
N#define REG_CAN0_IF1_DAT_A1 (CAN0_BA+0x3C) /*!< IF1 Data A1 Register */
N#define REG_CAN0_IF1_DAT_A2 (CAN0_BA+0x40) /*!< IF1 Data A2 Register */
N#define REG_CAN0_IF1_DAT_B1 (CAN0_BA+0x44) /*!< IF1 Data B1 Register */
N#define REG_CAN0_IF1_DAT_B2 (CAN0_BA+0x48) /*!< IF1 Data B2 Register */
N#define REG_CAN0_IF2_DAT_A1 (CAN0_BA+0x9C) /*!< IF2 Data A1 Register */
N#define REG_CAN0_IF2_DAT_A2 (CAN0_BA+0xA0) /*!< IF2 Data A2 Register */
N#define REG_CAN0_IF2_DAT_B1 (CAN0_BA+0xA4) /*!< IF2 Data B1 Register */
N#define REG_CAN0_IF2_DAT_B2 (CAN0_BA+0xA8) /*!< IF2 Data B2 Register */
N#define REG_CAN0_TXREQ1     (CAN0_BA+0x100) /*!< Transmission Request Register 1 */
N#define REG_CAN0_TXREQ2     (CAN0_BA+0x104) /*!< Transmission Request Register 2 */
N#define REG_CAN0_NDAT1      (CAN0_BA+0x120) /*!< New Data Register 1 */
N#define REG_CAN0_NDAT2      (CAN0_BA+0x124) /*!< New Data Register 2 */
N#define REG_CAN0_IPND1      (CAN0_BA+0x140) /*!< Interrupt Pending Register 1 */
N#define REG_CAN0_IPND2      (CAN0_BA+0x142) /*!< Interrupt Pending Register 2 */
N#define REG_CAN0_MVLD1      (CAN0_BA+0x160) /*!< Message Valid Register 1 */
N#define REG_CAN0_MVLD2      (CAN0_BA+0x164) /*!< Message Valid Register 2 */
N#define REG_CAN0_WU_EN      (CAN0_BA+0x168) /*!< Wake-up Function Enable */
N#define REG_CAN0_WU_STATUS  (CAN0_BA+0x16C) /*!< Wake-up Function Status */
N
N#define REG_CAN1_CON       (CAN1_BA+0x00) /*!< Control Register */
N#define REG_CAN1_STATUS    (CAN1_BA+0x04) /*!< Status Register */
N#define REG_CAN1_ERR       (CAN1_BA+0x08) /*!< Error Counter Register */
N#define REG_CAN1_BTIME     (CAN1_BA+0x0C) /*!< Bit Time Register */
N#define REG_CAN1_IIDR      (CAN1_BA+0x10) /*!< Interrupt Identifier Register */
N#define REG_CAN1_TEST      (CAN1_BA+0x14) /*!< Test Register */
N#define REG_CAN1_BRPE      (CAN1_BA+0x18) /*!< BRP Extension Register */
N#define REG_CAN1_IF1_CREQ  (CAN1_BA+0x20) /*!< IF1 Command Request Register */
N#define REG_CAN1_IF2_CREQ  (CAN1_BA+0x80) /*!< IF2 Command Request Register */
N#define REG_CAN1_IF1_CMASK (CAN1_BA+0x24) /*!< IF1 Command Mask Register */
N#define REG_CAN1_IF2_CMASK (CAN1_BA+0x84) /*!< IF2 Command Mask Register */
N#define REG_CAN1_IF1_MASK1 (CAN1_BA+0x28) /*!< IF1 Msak 1 Register */
N#define REG_CNA1_IF2_MASK1 (CAN1_BA+0x88) /*!< IF2 Mask 1 Register */
N#define REG_CAN1_IF1_MASK2 (CAN1_BA+0x2C) /*!< IF1 Mask 2 Register */
N#define REG_CAN1_IF2_MASK2 (CAN1_BA+0x8C) /*!< IF2 Mask 2 REgister */
N#define REG_CAN1_IF1_ARB1  (CAN1_BA+0x30) /*!< IF1 Arbitration 1 Register */
N#define REG_CAN1_IF2_ARB1  (CAN1_BA+0x90) /*!< IF2 Arbitration 1 Register */
N#define REG_CAN1_IF1_ARB2  (CAN1_BA+0x34) /*!< IF1 Arbitration 2 Register */
N#define REG_CAN1_IF2_ARB2  (CAN1_BA+0x94) /*!< IF2 Arbitration 2 Register */
N#define REG_CAN1_IF1_MCON  (CAN1_BA+0x38) /*!< IF1 Message Control Register */
N#define REG_CAN1_IF2_MCON  (CAN1_BA+0x98) /*!< IF2 Message Control Register */
N#define REG_CAN1_IF1_DAT_A1 (CAN1_BA+0x3C) /*!< IF1 Data A1 Register */
N#define REG_CAN1_IF1_DAT_A2 (CAN1_BA+0x40) /*!< IF1 Data A2 Register */
N#define REG_CAN1_IF1_DAT_B1 (CAN1_BA+0x44) /*!< IF1 Data B1 Register */
N#define REG_CAN1_IF1_DAT_B2 (CAN1_BA+0x48) /*!< IF1 Data B2 Register */
N#define REG_CAN1_IF2_DAT_A1 (CAN1_BA+0x9C) /*!< IF2 Data A1 Register */
N#define REG_CAN1_IF2_DAT_A2 (CAN1_BA+0xA0) /*!< IF2 Data A2 Register */
N#define REG_CAN1_IF2_DAT_B1 (CAN1_BA+0xA4) /*!< IF2 Data B1 Register */
N#define REG_CAN1_IF2_DAT_B2 (CAN1_BA+0xA8) /*!< IF2 Data B2 Register */
N#define REG_CAN1_TXREQ1     (CAN1_BA+0x100) /*!< Transmission Request Register 1 */
N#define REG_CAN1_TXREQ2     (CAN1_BA+0x104) /*!< Transmission Request Register 2 */
N#define REG_CAN1_NDAT1      (CAN1_BA+0x120) /*!< New Data Register 1 */
N#define REG_CAN1_NDAT2      (CAN1_BA+0x124) /*!< New Data Register 2 */
N#define REG_CAN1_IPND1      (CAN1_BA+0x140) /*!< Interrupt Pending Register 1 */
N#define REG_CAN1_IPND2      (CAN1_BA+0x142) /*!< Interrupt Pending Register 2 */
N#define REG_CAN1_MVLD1      (CAN1_BA+0x160) /*!< Message Valid Register 1 */
N#define REG_CAN1_MVLD2      (CAN1_BA+0x164) /*!< Message Valid Register 2 */
N#define REG_CAN1_WU_EN      (CAN1_BA+0x168) /*!< Wake-up Function Enable */
N#define REG_CAN1_WU_STATUS  (CAN1_BA+0x16C) /*!< Wake-up Function Status */
N
N/**@}*/ /* end of CAN register group */
N
N
N/*------------------- JPEG Controller --------------------*/
N/**
N    @addtogroup JPEG JPEG Controller (JPEG)
N    Memory Mapped Structure for JPEG Controller
N@{ */
N#define JMCR           (JPEG_BA+0x00)           /*!< JPEG Mode Control Register  */
N#define JHEADER        (JPEG_BA+0x04)           /*!< JPEG Encode Header Control Register  */
N#define JITCR          (JPEG_BA+0x08)           /*!< JPEG Image Type Control Register  */
N#define JPRIQC         (JPEG_BA+0x10)           /*!< JPEG Primary Q-Table Control Register  */
N#define JTHBQC         (JPEG_BA+0x14)           /*!< JPEG Thumbnail Q-Table Control Register  */
N#define JPRIWH         (JPEG_BA+0x18)           /*!< JPEG Encode Primary Width/Height Register  */
N#define JTHBWH         (JPEG_BA+0x1C)           /*!< JPEG Encode Thumbnail Width/Height Register  */
N#define JPRST          (JPEG_BA+0x20)           /*!< JPEG Encode Primary Restart Interval Register  */
N#define JTRST          (JPEG_BA+0x24)           /*!< JPEG Encode Thumbnail Restart Interval  */
N#define JDECWH         (JPEG_BA+0x28)           /*!< JPEG Decode Image Width/Height Register  */
N#define JINTCR         (JPEG_BA+0x2C)           /*!< JPEG Interrupt Control and Status Register  */
N#define JDOWFBS        (JPEG_BA+0x3c)           /*!< JPEG Decoding Output Wait Frame Buffer Size  */
N#define JPEG_BSBAD     (JPEG_BA+0x40)           /*!< JPEG Test Control Register  */
N#define JWINDEC0       (JPEG_BA+0x44)           /*!< JPEG Window Decode Mode Control Register 0  */
N#define JWINDEC1       (JPEG_BA+0x48)           /*!< JPEG Window Decode Mode Control Register 1  */
N#define JWINDEC2       (JPEG_BA+0x4C)           /*!< JPEG Window Decode Mode Control Register 2  */
N#define JMACR          (JPEG_BA+0x50)           /*!< JPEG Memory Address Mode Control Register  */
N#define JPSCALU        (JPEG_BA+0x54)           /*!< JPEG Primary Scaling-Up Control Register  */
N#define JPSCALD        (JPEG_BA+0x58)           /*!< JPEG Primary Scaling-Down Control Register  */
N#define JTSCALD        (JPEG_BA+0x5C)           /*!< JPEG Thumbnail  Scaling-Down Control Register  */
N#define JDBCR          (JPEG_BA+0x60)           /*!< JPEG Dual-Buffer Control Register  */
N#define JRESERVE       (JPEG_BA+0x70)           /*!< JPEG Encode Primary Bit-stream Reserved Size Register  */
N#define JOFFSET        (JPEG_BA+0x74)           /*!< JPEG Offset Between Primary & Thumbnail Register  */
N#define JFSTRIDE       (JPEG_BA+0x78)           /*!< JPEG Encode Bit-stream Frame Stride Register  */
N#define JYADDR0        (JPEG_BA+0x7C)           /*!< JPEG Y Component Frame Buffer-0 Starting Address Register  */
N#define JUADDR0        (JPEG_BA+0x80)           /*!< JPEG U Component Frame Buffer-0 Starting Address Register  */
N#define JVADDR0        (JPEG_BA+0x84)           /*!< JPEG V Component Frame Buffer-0 Starting Address Register  */
N#define JYADDR1        (JPEG_BA+0x88)           /*!< JPEG Y Component Frame Buffer-1 Starting Address Register  */
N#define JUADDR1        (JPEG_BA+0x8C)           /*!< JPEG U Component Frame Buffer-1 Starting Address Register  */
N#define JVADDR1        (JPEG_BA+0x90)           /*!< JPEG V Component Frame Buffer-1 Starting Address Register  */
N#define JYSTRIDE       (JPEG_BA+0x94)           /*!< JPEG Y Component Frame Buffer Stride Register  */
N#define JUSTRIDE       (JPEG_BA+0x98)           /*!< JPEG U Component Frame Buffer Stride Register  */
N#define JVSTRIDE       (JPEG_BA+0x9C)           /*!< JPEG V Component Frame Buffer Stride Register  */
N#define JIOADDR0       (JPEG_BA+0xA0)           /*!< JPEG Bit-stream Frame Buffer-0 Starting Address Register  */
N#define JIOADDR1       (JPEG_BA+0xA4)           /*!< JPEG Bit-stream Frame Buffer-1 Starting Address Register  */
N#define JPRI_SIZE      (JPEG_BA+0xA8)           /*!< JPEG Encode Primary Image Bit-stream Size Register  */
N#define JTHB_SIZE      (JPEG_BA+0xAC)           /*!< JPEG Encode Thumbnail Image Bit-stream Size Register  */
N#define JUPRAT         (JPEG_BA+0xB0)           /*!< JPEG Encode Up-Scale Ratio Register  */
N#define JBSFIFO        (JPEG_BA+0xB4)           /*!< JPEG Bit-stream FIFO Control Register  */
N#define JSRCH          (JPEG_BA+0xB8)           /*!< JPEG Encode Source Image Height  */
N#define JQTAB0         (JPEG_BA+0x100)          /*!< JPEG Quantization-Table 0 Register  */
N#define JQTAB1         (JPEG_BA+0x140)          /*!< JPEG Quantization-Table 1 Register  */
N#define JQTAB2         (JPEG_BA+0x180)          /*!< JPEG Quantization-Table 2 Register  */
N
N/**@}*/ /* end of JPEG register group */
N
N
N
N/*@}*/ /* end of group N9H30_Peripherals */
N
N
N/** @addtogroup N9H30_IO_ROUTINE N9H30 I/O Routines
N  The Declaration of N9H30 I/O Routines
N  @{
N */
N
Ntypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Ntypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Ntypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
N
N/**
N  * @brief Get a 8-bit unsigned value from specified address
N  * @param[in] addr Address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified address
N  */
N#define M8(addr)  (*((vu8  *) (addr)))
N
N/**
N  * @brief Get a 16-bit unsigned value from specified address
N  * @param[in] addr Address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified address
N  * @note The input address must be 16-bit aligned
N  */
N#define M16(addr) (*((vu16 *) (addr)))
N
N/**
N  * @brief Get a 32-bit unsigned value from specified address
N  * @param[in] addr Address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified address
N  * @note The input address must be 32-bit aligned
N  */
N#define M32(addr) (*((vu32 *) (addr)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outpw(port,value)     *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inpw(port)            (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outps(port,value)     *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inps(port)            (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outpb(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inpb(port)            (*((volatile unsigned char *)(port)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outp32(port,value)    *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inp32(port)           (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outp16(port,value)    *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inp16(port)           (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outp8(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inp8(port)            (*((volatile unsigned char *)(port)))
N
N
N/*@}*/ /* end of group N9H30_IO_ROUTINE */
N
N/******************************************************************************/
N/*                Legacy Constants                                            */
N/******************************************************************************/
N/** @addtogroup N9H30_legacy_Constants N9H30 Legacy Constants
N  N9H30 Legacy Constants
N  @{
N*/
Ntypedef void *            PVOID;    ///< Define void pointer data type
Ntypedef void              VOID;     ///< Define void data type
Ntypedef char              BOOL;     ///< Define bool data type
Ntypedef char *            PBOOL;    ///< Define bool pointer data type
N
Ntypedef char              INT8;     ///< Define 8-bit singed data type
Ntypedef char              CHAR;     ///< Define char data type
Ntypedef char *            PINT8;    ///< Define 8-bit singed pointer data type
Ntypedef char *            PCHAR;    ///< Define char pointer data type
Ntypedef unsigned char     UINT8;    ///< Define 8-bit unsigned data type
Ntypedef unsigned char     UCHAR;    ///< Define char unsigned data type
Ntypedef unsigned char *   PUINT8;   ///< Define 8-bit unsigned pointer data type
Ntypedef unsigned char *   PUCHAR;   ///< Define char unsigned pointer data type
Ntypedef char *            PSTR;     ///< Define string pointer data type
Ntypedef const char *      PCSTR;    ///< Define constant string pointer data type
N
Ntypedef short             SHORT;    ///< Define short signed data type
Ntypedef short *           PSHORT;   ///< Define short signed pointer data type
Ntypedef unsigned short    USHORT;   ///< Define short unsigned data type
Ntypedef unsigned short *  PUSHORT;  ///< Define short unsigned pointer data type
N
Ntypedef short             INT16;    ///< Define 16-bit signed data type
Ntypedef short *           PINT16;   ///< Define 16-bit signed pointer data type
Ntypedef unsigned short    UINT16;   ///< Define 16-bit unsigned data type
Ntypedef unsigned short *  PUINT16;  ///< Define 16-bit unsigned pointer data type
N
Ntypedef int               INT;      ///< Define integer signed data type
Ntypedef int *             PINT;     ///< Define integer signed pointer data type
Ntypedef unsigned int      UINT;     ///< Define integer unsigned data type
Ntypedef unsigned int *    PUINT;    ///< Define integer unsigned pointer data type
N
Ntypedef int               INT32;    ///< Define 32-bit signed data type
Ntypedef int *             PINT32;   ///< Define 32-bit signed pointer data type
Ntypedef unsigned int      UINT32;   ///< Define 32-bit unsigned data type
Ntypedef unsigned int *    PUINT32;  ///< Define 32-bit unsigned pointer data type
N
Ntypedef __int64           INT64;    ///< Define 64-bit signed data type
Ntypedef unsigned __int64  UINT64;   ///< Define 64-bit unsigned data type
N
Ntypedef float             FLOAT;    ///< Define float data type
Ntypedef float *           PFLOAT;   ///< Define float pointer data type
N
Ntypedef double            DOUBLE;   ///< Define double data type
Ntypedef double *          PDOUBLE;  ///< Define double pointer data type
N
Ntypedef int               SIZE_T;   ///< Define size of data type
N
Ntypedef unsigned char     REG8;     ///< Define 8-bit register data type
Ntypedef unsigned short    REG16;    ///< Define 16-bit register data type
Ntypedef unsigned int      REG32;    ///< Define 32-bit register data type
N
N
N#ifndef NULL
S#define NULL           (0)      ///< NULL pointer
N#endif
N
N#define TRUE           (1)      ///< Boolean true, define to use in API parameters or return value
N#define FALSE          (0)      ///< Boolean false, define to use in API parameters or return value
N
N#define ENABLE         (1)      ///< Enable, define to use in API parameters
N#define DISABLE        (0)      ///< Disable, define to use in API parameters
N
N
N#define   Successful  0         ///< Function return value success
N#define   Fail        1         ///< Function return value failed
N
N/* Define one bit mask */
N#define BIT0     (0x00000001)       ///< Bit 0 mask of an 32 bit integer
N#define BIT1     (0x00000002)       ///< Bit 1 mask of an 32 bit integer
N#define BIT2     (0x00000004)       ///< Bit 2 mask of an 32 bit integer
N#define BIT3     (0x00000008)       ///< Bit 3 mask of an 32 bit integer
N#define BIT4     (0x00000010)       ///< Bit 4 mask of an 32 bit integer
N#define BIT5     (0x00000020)       ///< Bit 5 mask of an 32 bit integer
N#define BIT6     (0x00000040)       ///< Bit 6 mask of an 32 bit integer
N#define BIT7     (0x00000080)       ///< Bit 7 mask of an 32 bit integer
N#define BIT8     (0x00000100)       ///< Bit 8 mask of an 32 bit integer
N#define BIT9     (0x00000200)       ///< Bit 9 mask of an 32 bit integer
N#define BIT10    (0x00000400)       ///< Bit 10 mask of an 32 bit integer
N#define BIT11    (0x00000800)       ///< Bit 11 mask of an 32 bit integer
N#define BIT12    (0x00001000)       ///< Bit 12 mask of an 32 bit integer
N#define BIT13    (0x00002000)       ///< Bit 13 mask of an 32 bit integer
N#define BIT14    (0x00004000)       ///< Bit 14 mask of an 32 bit integer
N#define BIT15    (0x00008000)       ///< Bit 15 mask of an 32 bit integer
N#define BIT16    (0x00010000)       ///< Bit 16 mask of an 32 bit integer
N#define BIT17    (0x00020000)       ///< Bit 17 mask of an 32 bit integer
N#define BIT18    (0x00040000)       ///< Bit 18 mask of an 32 bit integer
N#define BIT19    (0x00080000)       ///< Bit 19 mask of an 32 bit integer
N#define BIT20    (0x00100000)       ///< Bit 20 mask of an 32 bit integer
N#define BIT21    (0x00200000)       ///< Bit 21 mask of an 32 bit integer
N#define BIT22    (0x00400000)       ///< Bit 22 mask of an 32 bit integer
N#define BIT23    (0x00800000)       ///< Bit 23 mask of an 32 bit integer
N#define BIT24    (0x01000000)       ///< Bit 24 mask of an 32 bit integer
N#define BIT25    (0x02000000)       ///< Bit 25 mask of an 32 bit integer
N#define BIT26    (0x04000000)       ///< Bit 26 mask of an 32 bit integer
N#define BIT27    (0x08000000)       ///< Bit 27 mask of an 32 bit integer
N#define BIT28    (0x10000000)       ///< Bit 28 mask of an 32 bit integer
N#define BIT29    (0x20000000)       ///< Bit 29 mask of an 32 bit integer
N#define BIT30    (0x40000000)       ///< Bit 30 mask of an 32 bit integer
N#define BIT31    (0x80000000)       ///< Bit 31 mask of an 32 bit integer
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk              (0x000000FF)         ///< Mask to get bit0~bit7 from a 32 bit integer
N#define BYTE1_Msk              (0x0000FF00)         ///< Mask to get bit8~bit15 from a 32 bit integer
N#define BYTE2_Msk              (0x00FF0000)         ///< Mask to get bit16~bit23 from a 32 bit integer
N#define BYTE3_Msk              (0xFF000000)         ///< Mask to get bit24~bit31 from a 32 bit integer
N
N#define GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N
N#endif /* __N9H30_H__ */
N
N/*@}*/ /* end of group N9H30_legacy_Constants */
L 13 "..\..\..\Driver\Source\2d.c" 2
N#include "sys.h"
L 1 "..\..\..\Driver\Include\sys.h" 1
N/**************************************************************************//**
N* @file     sys.h
N* @brief    N9H30 SYS driver header file
N*
N* @note
N* Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup N9H30_Device_Driver N9H30 Device Driver
N  @{
N*/
N
N/** @addtogroup N9H30_SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup N9H30_SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/
N
N/**
N * @details  Interrupt Number Definition.
N */
Ntypedef enum IRQn {
N
N    /******  N9H30 Specific Interrupt Numbers *****************************************/
N
N    WDT_IRQn                = 1,       /*!< Watch Dog Timer Interrupt                  */
N    WWDT_IRQn               = 2,       /*!< Windowed-WDT Interrupt                     */
N    LVD_IRQn                = 3,       /*!< Low Voltage Detect Interrupt               */
N    EINT0_IRQn              = 4,       /*!< External Interrupt 0                       */
N    EINT1_IRQn              = 5,       /*!< External Interrupt 1                       */
N    EINT2_IRQn              = 6,       /*!< External Interrupt 2                       */
N    EINT3_IRQn              = 7,       /*!< External Interrupt 3                       */
N    EINT4_IRQn              = 8,       /*!< External Interrupt 4                       */
N    EINT5_IRQn              = 9,       /*!< External Interrupt 5                       */
N    EINT6_IRQn              = 10,      /*!< External Interrupt 6                       */
N    EINT7_IRQn              = 11,      /*!< External Interrupt 7                       */
N    ACTL_IRQn               = 12,      /*!< Audio Controller Interrupt                 */
N    LCD_IRQn                = 13,      /*!< LCD Controller Interrupt                   */
N    CAP_IRQn                = 14,      /*!< Sensor Interface Controller Interrupt      */
N    RTC_IRQn                = 15,      /*!< Real Time Clock Interrupt                  */
N    TMR0_IRQn               = 16,      /*!< Timer 0 Interrupt                          */
N    TMR1_IRQn               = 17,      /*!< Timer 1 Interrupt                          */
N    ADC_IRQn                = 18,      /*!< ADC Interrupt                              */
N    EMC0_RX_IRQn            = 19,      /*!< EMC 0 RX Interrupt                         */
N    EMC1_RX_IRQn            = 20,      /*!< EMC 1 RX Interrupt                         */
N    EMC0_TX_IRQn            = 21,      /*!< EMC 0 TX Interrupt                         */
N    EMC1_TX_IRQn            = 22,      /*!< EMC 1 TX Interrupt                         */
N    EHCI_IRQn               = 23,      /*!< USB 2.0 Host Controller Interrupt          */
N    OHCI_IRQn               = 24,      /*!< USB 1.1 Host Controller Interrupt          */
N    GDMA0_IRQn              = 25,      /*!< GDMA Channel 0 Interrupt                   */
N    GDMA1_IRQn              = 26,      /*!< GDMA Channel 1 Interrupt                   */
N    SDH_IRQn                = 27,      /*!< SD/SDIO Host Interrupt                     */
N    FMI_IRQn                = 28,      /*!< FMI Interrupt                              */
N    USBD_IRQn               = 29,      /*!< USB Device Interrupt                       */
N    TMR2_IRQn               = 30,      /*!< Timer 2 Interrupt                          */
N    TMR3_IRQn               = 31,      /*!< Timer 3 Interrupt                          */
N    TMR4_IRQn               = 32,      /*!< Timer 4 Interrupt                          */
N    JPEG_IRQn               = 33,      /*!< JPEG Engine Interrupt                      */
N    GE2D_IRQn               = 34,      /*!< 2D Graphic Engine Interrupt                */
N    UART0_IRQn              = 36,      /*!< UART 0 Interrupt                           */
N    UART1_IRQn              = 37,      /*!< UART 1 Interrupt                           */
N    UART2_IRQn              = 38,      /*!< UART 2 Interrupt                           */
N    UART4_IRQn              = 39,      /*!< UART 4 Interrupt                           */
N    UART6_IRQn              = 40,      /*!< UART 6 Interrupt                           */
N    UART8_IRQn              = 41,      /*!< UART 8 Interrupt                           */
N    UART10_IRQn             = 42,      /*!< UART 10 Interrupt                          */
N    UART3_IRQn              = 43,      /*!< UART 3 Interrupt                           */
N    UART5_IRQn              = 44,      /*!< UART 5 Interrupt                           */
N    UART7_IRQn              = 45,      /*!< UART 7 Interrupt                           */
N    UART9_IRQn              = 46,      /*!< UART 9 Interrupt                           */
N    ETMR0_IRQn              = 47,      /*!< Enhanced Timer 0 Interrupt                 */
N    ETMR1_IRQn              = 48,      /*!< Enhanced Timer 1 Interrupt                 */
N    ETMR2_IRQn              = 49,      /*!< Enhanced Timer 2 Interrupt                 */
N    ETMR3_IRQn              = 50,      /*!< Enhanced Timer 3 Interrupt                 */
N    SPI0_IRQn               = 51,      /*!< SPI 0 Interrupt                            */
N    SPI1_IRQn               = 52,      /*!< SPI 1 Interrupt                            */
N    I2C0_IRQn               = 53,      /*!< I2C 0 Interrupt                            */
N    I2C1_IRQn               = 54,      /*!< I2C 1 Interrupt                            */
N    SC0_IRQn                = 55,      /*!< Smart Card 0 Interrupt                     */
N    SC1_IRQn                = 56,      /*!< Smart Card 1 Interrupt                     */
N    GPIO_IRQn               = 57,      /*!< GPIO Interrupt                             */
N    CAN0_IRQn               = 58,      /*!< CAN 0 Interrupt                            */
N    CAN1_IRQn               = 59,      /*!< CAN 1 Interrupt                            */
N    PWM_IRQn                = 60,      /*!< PWM Interrupt                              */
N}
NIRQn_Type;
N
N/* Define constants for use timer in service parameters.  */
N#define TIMER0            0     /*!< Select Timer0 */
N#define TIMER1            1     /*!< Select Timer1 */
N
N#define ONE_SHOT_MODE     0     /*!< Timer Operation Mode - One Shot */
N#define PERIODIC_MODE     1     /*!< Timer Operation Mode - Periodic */
N#define TOGGLE_MODE       2     /*!< Timer Operation Mode - Toggle */
N
N/* The parameters for sysSetInterruptPriorityLevel() and
N   sysInstallISR() use */
N#define FIQ_LEVEL_0     0       /*!< FIQ Level 0 */
N#define IRQ_LEVEL_1     1       /*!< IRQ Level 1 */
N#define IRQ_LEVEL_2     2       /*!< IRQ Level 2 */
N#define IRQ_LEVEL_3     3       /*!< IRQ Level 3 */
N#define IRQ_LEVEL_4     4       /*!< IRQ Level 4 */
N#define IRQ_LEVEL_5     5       /*!< IRQ Level 5 */
N#define IRQ_LEVEL_6     6       /*!< IRQ Level 6 */
N#define IRQ_LEVEL_7     7       /*!< IRQ Level 7 */
N
N#define ONE_HALF_SECS     0     /*!< WDT interval - 1.5s */
N#define FIVE_SECS         1     /*!< WDT interval - 5s */
N#define TEN_SECS          2     /*!< WDT interval - 10s */
N#define TWENTY_SECS       3     /*!< WDT interval - 20s */
N
N/* Define constants for use AIC in service parameters.  */
N#define SYS_SWI           0     /*!< Exception - SWI */
N#define SYS_D_ABORT       1     /*!< Exception - Data abort */
N#define SYS_I_ABORT       2     /*!< Exception - Instruction abort */
N#define SYS_UNDEFINE      3     /*!< Exception - undefine */
N
N/* The parameters for sysSetLocalInterrupt() use */
N#define ENABLE_IRQ        0x7F  /*!< Enable I-bit of CP15  */
N#define ENABLE_FIQ        0xBF  /*!< Enable F-bit of CP15  */
N#define ENABLE_FIQ_IRQ    0x3F  /*!< Enable I-bit and F-bit of CP15  */
N#define DISABLE_IRQ       0x80  /*!< Disable I-bit of CP15  */
N#define DISABLE_FIQ       0x40  /*!< Disable F-bit of CP15  */
N#define DISABLE_FIQ_IRQ   0xC0  /*!< Disable I-bit and F-bit of CP15  */
N
N/* Define Cache type  */
N#define CACHE_WRITE_BACK        0     /*!< Cache Write-back mode  */
N#define CACHE_WRITE_THROUGH     1     /*!< Cache Write-through mode  */
N#define CACHE_DISABLE           -1    /*!< Cache Disable  */
N
N/** \brief  Structure type of clock source
N */
Ntypedef enum CLKn {
N
N    SYS_UPLL     = 1,   /*!< UPLL clock */
N    SYS_APLL     = 2,   /*!< APLL clock */
N    SYS_SYSTEM   = 3,   /*!< System clock */
N    SYS_HCLK1    = 4,   /*!< HCLK1 clock */
N    SYS_HCLK234  = 5,   /*!< HCLK234 clock */
N    SYS_PCLK     = 6,   /*!< PCLK clock */
N    SYS_CPU      = 7,   /*!< CPU clock */
N
N}  CLK_Type;
N
N
N
N/// @cond HIDDEN_SYMBOLS
Ntypedef struct datetime_t {
N    UINT32  year;
N    UINT32  mon;
N    UINT32  day;
N    UINT32  hour;
N    UINT32  min;
N    UINT32  sec;
N} DateTime_T;
N
N/* The parameters for sysSetInterruptType() use */
N#define LOW_LEVEL_SENSITIVE        0x00
N#define HIGH_LEVEL_SENSITIVE       0x40
N#define NEGATIVE_EDGE_TRIGGER      0x80
N#define POSITIVE_EDGE_TRIGGER      0xC0
N
N/* The parameters for sysSetGlobalInterrupt() use */
N#define ENABLE_ALL_INTERRUPTS      0
N#define DISABLE_ALL_INTERRUPTS     1
N
N#define MMU_DIRECT_MAPPING  0
N#define MMU_INVERSE_MAPPING 1
N
N
N/* Define constants for use Cache in service parameters.  */
N#define CACHE_4M        2
N#define CACHE_8M        3
N#define CACHE_16M       4
N#define CACHE_32M       5
N#define I_CACHE         6
N#define D_CACHE         7
N#define I_D_CACHE       8
N
N
N/// @endcond HIDDEN_SYMBOLS
N
N/*@}*/ /* end of group N9H30_SYS_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup N9H30_SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N/* Define system library Timer functions */
NUINT32  sysGetTicks (INT32 nTimeNo);
NINT32   sysResetTicks (INT32 nTimeNo);
NINT32   sysUpdateTickCount(INT32 nTimeNo, UINT32 uCount);
NINT32   sysSetTimerReferenceClock (INT32 nTimeNo, UINT32 uClockRate);
NINT32   sysStartTimer (INT32 nTimeNo, UINT32 uTicksPerSecond, INT32 nOpMode);
NINT32   sysStopTimer (INT32 nTimeNo);
Nvoid    sysClearWatchDogTimerCount (void);
Nvoid    sysClearWatchDogTimerInterruptStatus(void);
Nvoid    sysDisableWatchDogTimer (void);
Nvoid    sysDisableWatchDogTimerReset(void);
Nvoid    sysEnableWatchDogTimer (void);
Nvoid    sysEnableWatchDogTimerReset(void);
NPVOID   sysInstallWatchDogTimerISR (INT32 nIntTypeLevel, PVOID pvNewISR);
NINT32   sysSetWatchDogTimerInterval (INT32 nWdtInterval);
NINT32   sysSetTimerEvent(INT32 nTimeNo, UINT32 uTimeTick, PVOID pvFun);
Nvoid    sysClearTimerEvent(INT32 nTimeNo, UINT32 uTimeEventNo);
Nvoid    sysSetLocalTime(DateTime_T ltime);          /*!< Set local time \hideinitializer */
Nvoid    sysGetCurrentTime(DateTime_T *curTime);     /*!< Get current time \hideinitializer */
Nvoid    sysDelay(UINT32 uTicks);
N
N/* Define system library UART functions */
NINT8    sysGetChar (void);
NINT32   sysInitializeUART (void);
Nvoid    sysprintf (PINT8 pcStr,...);
Nvoid    sysPutChar (UINT8 ucCh);
NINT     sysIsKbHit(void);
N
N/* Define system library AIC functions */
NINT32   sysDisableInterrupt (IRQn_Type eIntNo);
NINT32   sysEnableInterrupt (IRQn_Type eIntNo);
NBOOL    sysGetIBitState(void);              /*!< Get I bit state \hideinitializer */
NUINT32  sysGetInterruptEnableStatus(void);  /*!< Get interrupt enable status \hideinitializer */
NUINT32  sysGetInterruptEnableStatusH(void); /*!< Get interrupt enable status \hideinitializer */
NPVOID   sysInstallExceptionHandler (INT32 nExceptType, PVOID pvNewHandler);
NPVOID   sysInstallFiqHandler (PVOID pvNewISR);
NPVOID   sysInstallIrqHandler (PVOID pvNewISR);
NPVOID   sysInstallISR (INT32 nIntTypeLevel, IRQn_Type eIntNo, PVOID pvNewISR);
NINT32   sysSetGlobalInterrupt (INT32 nIntState);    /*!< Enable/Disable all interrupt \hideinitializer */
NINT32   sysSetInterruptPriorityLevel (IRQn_Type eIntNo, UINT32 uIntLevel);
NINT32   sysSetInterruptType (IRQn_Type eIntNo, UINT32 uIntSourceType);      /*!< Change interrupt type \hideinitializer */
NINT32   sysSetLocalInterrupt (INT32 nIntState);
N
N
N/* Define system library Cache functions */
Nvoid    sysDisableCache(void);
NINT32   sysEnableCache(UINT32 uCacheOpMode);
Nvoid    sysFlushCache(INT32 nCacheType);    /*!< flush cache \hideinitializer */
NBOOL    sysGetCacheState(void);             /*!< get cache state \hideinitializer */
NINT32   sysGetSdramSizebyMB(void);          /*!< Get DRAM size \hideinitializer */
Nvoid    sysInvalidCache(void);              /*!< invalid cache \hideinitializer */
NINT32   sysSetCachePages(UINT32 addr, INT32 size, INT32 cache_mode);    /*!< set cache page \hideinitializer */
N
Nint sysSetMMUMappingMethod(int mode);   /*!< MMU mapping \hideinitializer */
N
NUINT32 sysGetClock(CLK_Type clk);
N
Ntypedef void (*sys_pvFunPtr)();   /* function pointer */
N/// @cond HIDDEN_SYMBOLS
Nextern sys_pvFunPtr sysIrqHandlerTable[];
Nextern BOOL volatile _sys_bIsAICInitial;
N/// @endcond
N#ifdef __cplusplus
S}
N#endif
N
N/*@}*/ /* end of group N9H30_SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group N9H30_SYS_Driver */
N
N/*@}*/ /* end of group N9H30_Device_Driver */
N
N#endif //__SYS_H__
N
N/*** (C) COPYRIGHT 2018 Nuvoton Technology Corp. ***/
N
L 14 "..\..\..\Driver\Source\2d.c" 2
N#include "2d.h"
L 1 "..\..\..\Driver\Include\2d.h" 1
N/**************************************************************************//**
N* @file     2d.h
N* @brief    N9H30 2DGE driver header file
N*
N* @note
N* Copyright (C) 2018 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef _2D_H_
N#define _2D_H_
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup N9H30_Device_Driver N9H30 Device Driver
N  @{
N*/
N
N/** @addtogroup N9H30_GE2D_Driver GE2D Driver
N  @{
N*/
N
N/** @addtogroup N9H30_GE2D_EXPORTED_CONSTANTS GE2D Exported Constants
N  @{
N*/
N
N/// @cond HIDDEN_SYMBOLS
Ntypedef struct {
N    UINT32    PatternA;
N    UINT32    PatternB;
N} MONOPATTERN;
N
N#define COLOR_KEY 0xFF000000
N/// @endcond HIDDEN_SYMBOLS
N
N///////////////////////////////////////////////////////////////////////////////
N// Definition of ROP2
N///////////////////////////////////////////////////////////////////////////////
N#define    BLACKNESS       0x00  /*!< rop code: 0 */
N#define    DSTINVERT       0x55  /*!< rop code: Dn  */
N#define    MERGECOPY       0xC0  /*!< rop code: PSa  */
N#define    MERGEPAINT      0xBB  /*!< rop code: DSno  */
N#define    NOTSRCCOPY      0x33  /*!< rop code: Sn  */
N#define    NOTSRCERASE     0x11  /*!< rop code: DSon  */
N#define    PATCOPY         0xF0  /*!< rop code: P  */
N#define    PATINVERT       0x5A  /*!< rop code: DPx  */
N#define    PATPAINT        0xFB  /*!< rop code: DPSnoo  */
N#define    SRCAND          0x88  /*!< rop code: DSa  */
N#define    SRCCOPY         0xCC  /*!< rop code: S  */
N#define    SRCERASE        0x44  /*!< rop code: SDna  */
N#define    SRCINVERT       0x66  /*!< rop code: DSx  */
N#define    SRCPAINT        0xEE  /*!< rop code: DSo  */
N#define    WHITENESS       0xFF  /*!< rop code: 1  */
N
N///////////////////////////////////////////////////////////////////////////////
N// Definition of Pen Styles
N///////////////////////////////////////////////////////////////////////////////
N#define PS_SOLID        0xffff     /*!< pan style: solid */ //1111111111111111 (1111111111111111)
N#define PS_DASH         0xcccc     /*!< pan style: dash */ //1100110011001100 (1111000011110000)
N#define PS_DOT          0xaaaa     /*!< pan style: dot */ //1010101010101010 (1100110011001100)
N#define PS_DASHDOT      0xe4e4     /*!< pan style: dash and dot */ //1110010011100100 (1111110000110000)
N#define PS_DASHDOTDOT   0xeaea     /*!< pan style: dash and two dots  */ //1110101011101010 (1111110011001100)
N#define PS_NULL         0x0000     /*!< pan style: null */ //0000000000000000 (0000000000000000)
N
N///////////////////////////////////////////////////////////////////////////////
N// Definition of Brush Styles
N//
N// HS_HORIZONTAL:   00000000     HS_BDIAGONAL:  00000001
N//                  00000000                    00000010
N//                  00000000                    00000100
N//                  00000000                    00001000
N//                  11111111                    00010000
N//                  00000000                    00100000
N//                  00000000                    01000000
N//                  00000000                    10000000
N//
N// HS_VERTICAL:     00001000     HS_CROSS:      00001000
N//                  00001000                    00001000
N//                  00001000                    00001000
N//                  00001000                    00001000
N//                  00001000                    11111111
N//                  00001000                    00001000
N//                  00001000                    00001000
N//                  00001000                    00001000
N//
N// HS_FDIAGONAL:    10000000     HS_DIAGCROSS:  10000001
N//                  01000000                    01000010
N//                  00100000                    00100100
N//                  00010000                    00011000
N//                  00001000                    00011000
N//                  00000100                    00100100
N//                  00000010                    01000010
N//                  00000001                    10000001
N///////////////////////////////////////////////////////////////////////////////
N#define HS_HORIZONTAL   0   /*!< brush style: horizontal */
N#define HS_VERTICAL     1   /*!< brush style: vertical */
N#define HS_FDIAGONAL    2   /*!< brush style: fdiagonal */
N#define HS_BDIAGONAL    3   /*!< brush style: bdiagonal */
N#define HS_CROSS        4   /*!< brush style: cross */
N#define HS_DIAGCROSS    5   /*!< brush style: diagcross */
N
N#define MODE_OPAQUE             0                   /*!< opaque mode */
N#define MODE_TRANSPARENT        1                   /*!< transparent mode */
N#define MODE_SRC_TRANSPARENT    MODE_TRANSPARENT    /*!< source transparent mode */
N#define MODE_DEST_TRANSPARENT   2                   /*!< destination transparent mode */
N
N#define MODE_INSIDE_CLIP    0   /*!< clip inside */
N#define MODE_OUTSIDE_CLIP   1   /*!< clip outside */
N
N#define TYPE_MONO           0   /*!< mono */
N#define TYPE_COLOR          1   /*!< color */
N
N#define GE_BPP_8    0x00000000  /*!< 8bpp display */
N#define GE_BPP_16   0x00000010  /*!< 16bpp display */
N#define GE_BPP_32   0x00000020  /*!< 32bpp display */
N
N#define RGB332 1    /*!< 8bpp display */
N#define RGB565 2    /*!< 16bpp display */
N#define RGB888 3    /*!< 24bpp display */
N
N#define F8x8            0   /*!< 8x8 font support */
N#define F8x16           1   /*!< 8x16 font support */
N
N/*@}*/ /* end of group N9H30_GE2D_EXPORTED_CONSTANTS */
N
N/** @addtogroup N9H30_GE2D_EXPORTED_FUNCTIONS GE2D Exported Functions
N  @{
N*/
N
Nvoid ge2dClearScreen(int color);
Nvoid ge2dSetWriteMask(int mask);
Nvoid ge2dSetSourceOriginStarting(void *ptr);
Nvoid ge2dSetDestinationOriginStarting(void *ptr);
Nvoid ge2dInit(int bpp, int width, int height, void *destination);
Nvoid ge2dReset(void);
Nvoid ge2dResetFIFO(void);
Nvoid ge2dBitblt_SetDrawMode(int opt, int ckey, int mask);
Nint ge2dBitblt_SetAlphaMode(int opt, int ks, int kd);
Nvoid ge2dBitblt_ScreenToScreen(int srcx, int srcy, int destx, int desty, int width, int height);
Nvoid ge2dBitblt_ScreenToScreenRop(int srcx, int srcy, int destx, int desty, int width, int height, int rop);
Nvoid ge2dBitblt_SourceToDestination(int srcx, int srcy, int destx, int desty, int width, int height, int srcpitch, int destpitch);
Nvoid ge2dClip_SetClip(int x1, int y1, int x2, int y2);
Nvoid ge2dClip_SetClipMode(int opt);
Nvoid ge2dDrawFrame(int x1, int y1, int x2, int y2, int color, int opt);
Nvoid ge2dLine_DrawSolidLine(int x1, int y1, int x2, int y2, int color);
Nvoid ge2dLine_DrawStyledLine(int x1, int y1, int x2, int y2, int style, int fgcolor, int bkcolor, int draw_mode);
Nvoid ge2dFill_Solid(int dx, int dy, int width, int height, int color);
Nvoid ge2dFill_Solid_RGB565(int dx, int dy, int width, int height, int color);
Nvoid ge2dFill_SolidBackground(int dx, int dy, int width, int height, int color);
Nvoid ge2dFill_ColorPattern(int dx, int dy, int width, int height);
Nvoid ge2dFill_MonoPattern(int dx, int dy, int width, int height, int opt);
Nvoid ge2dFill_ColorPatternROP(int sx, int sy, int width, int height, int rop);
Nvoid ge2dFill_MonoPatternROP(int sx, int sy, int width, int height, int rop, int opt);
Nvoid ge2dFill_TileBlt(int srcx, int srcy, int destx, int desty, int width, int height, int x_count, int y_count);
Nvoid ge2dHostBlt_Write(int x, int y, int width, int height, void *buf);
Nvoid ge2dHostBlt_Read(int x, int y, int width, int height, void *buf);
Nvoid ge2dHostBlt_Sprite(int x, int y, int width, int height, void *buf);
Nvoid ge2dRotation(int srcx, int srcy, int destx, int desty, int width, int height, int ctl);
Nvoid ge2dSpriteBlt_Screen(int destx, int desty, int sprite_width, int sprite_height, void *buf);
Nvoid ge2dSpriteBltx_Screen(int x, int y, int sprite_sx, int sprite_sy, int width, int height, int sprite_width, int sprite_height, void *buf);
Nvoid ge2dSpriteBlt_ScreenRop(int x, int y, int sprite_width, int sprite_height, void *buf, int rop);
Nvoid ge2dSpriteBltx_ScreenRop(int x, int y, int sprite_sx, int sprite_sy, int width, int height, int sprite_width, int sprite_height, void *buf, int rop);
Nvoid ge2dColorExpansionBlt(int x, int y, int width, int height, int fore_color, int back_color, int opt, void *buf);
Nvoid ge2dHostColorExpansionBlt(int x, int y, int width, int height, int fore_color, int back_color, int opt, void *buf);
Nvoid ge2dInitMonoPattern(int opt, int fore_color, int back_color);
Nvoid ge2dInitMonoInputPattern(UINT32 PatternA, UINT32 PatternB, int fore_color, int back_color);
Nvoid ge2dInitColorPattern(int patformat, void *patdata);
Nvoid ge2dFont_PutChar(int x, int y, char asc_code, int fore_color, int back_color, int draw_mode, int font_id);
Nvoid ge2dFont_PutString(int x, int y, char *str, int fore_color, int back_color, int draw_mode, int font_id);
N
N/*@}*/ /* end of group N9H30_GE2D_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group N9H30_GE2D_Driver */
N
N/*@}*/ /* end of group N9H30_Device_Driver */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__2D_H__
N
N/*** (C) COPYRIGHT 2018 Nuvoton Technology Corp. ***/
L 15 "..\..\..\Driver\Source\2d.c" 2
N
N/** @addtogroup N9H30_Device_Driver N9H30 Device Driver
N  @{
N*/
N
N/** @addtogroup N9H30_GE2D_Driver GE2D Driver
N  @{
N*/
N
N/** @addtogroup N9H30_GE2D_EXPORTED_CONSTANTS GE2D Exported Constants
N  @{
N*/
N
N/// @cond HIDDEN_SYMBOLS
Nstatic unsigned int GFX_Mem = 0;
Nstatic unsigned int GFX_BPP;
Nstatic unsigned int GFX_WIDTH;
Nstatic unsigned int GFX_HEIGHT;
Nstatic unsigned int GFX_PITCH;
Nstatic unsigned int GFX_SIZE;
N
Nstatic __align(32) void *GFX_START_ADDR;
Nstatic __align(32) void *MONO_SOURCE_ADDR;
Nstatic __align(32) void *COLOR_SOURCE_ADDR;
Nstatic __align(32) void *CMODEL_START_ADDR;
Nstatic __align(32) void *GFX_OFFSCREEN_ADDR;
Nstatic __align(32) void *GFX_PAT_ADDR;
N
Nvoid *Orig_GFX_START_ADDR;
Nvoid *Orig_MONO_SOURCE_ADDR;
Nvoid *Orig_COLOR_SOURCE_ADDR;
Nvoid *Orig_CMODEL_START_ADDR;
Nvoid *Orig_GFX_OFFSCREEN_ADDR;
Nvoid *Orig_GFX_PAT_ADDR;
N
N#define  PN   1  // Quadrant 1
N#define  NN   2  // Quadrant 2
N#define  NP   3  // Quadrant 3
N#define  PP   4  // Quadrant 4
N
N#define ABS(x)      (((x)>0)?(x):-(x))
N#define MAX(a,b)    (((a)>(b))?(a):(b))
N
N/* octant code of line drawing */
N
N#define XpYpXl      (0<<1)   // XY octant position is 1~3 in Control register
N#define XpYpYl      (1<<1)
N#define XpYmXl      (2<<1)
N#define XpYmYl      (3<<1)
N#define XmYpXl      (4<<1)
N#define XmYpYl      (5<<1)
N#define XmYmXl      (6<<1)
N#define XmYmYl      (7<<1)
N
Nstatic MONOPATTERN MonoPatternData[6] = {
N    {0x00000000, 0xff000000}, // HS_HORIZONTAL
N    {0x08080808, 0x08080808}, // HS_VERTICAL
N    {0x80402010, 0x08040201}, // HS_FDIAGONAL
N    {0x01020408, 0x10204080}, // HS_BDIAGONAL
N    {0x08080808, 0xff080808}, // HS_CROSS
N    {0x81422418, 0x18244281}  // HS_DIAGCROSS
N};
N
Nstatic char _DrawMode = MODE_OPAQUE;
Xstatic char _DrawMode = 0;
Nstatic UINT32 _ColorKey;
Nstatic UINT32 _ColorKeyMask;
N
Nstatic BOOL _EnableAlpha = FALSE;
Xstatic BOOL _EnableAlpha = (0);
Nstatic int _AlphaKs, _AlphaKd;
Nstatic BOOL _ClipEnable = FALSE;
Xstatic BOOL _ClipEnable = (0);
Nstatic BOOL _OutsideClip = FALSE;
Xstatic BOOL _OutsideClip = (0);
Nstatic UINT32 _ClipTL, _ClipBR;
Nstatic int _PatternType;
N
Nstatic unsigned	char FontData8[256][8] = {
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  //0
N    {0x7E,0x81,0xA5,0x81,0xBD,0x99,0x81,0x7E},  //1
N    {0x7E,0xFF,0xDB,0xFF,0xC3,0xE7,0xFF,0x7E},  //2
N    {0x6C,0xFE,0xFE,0xFE,0x7C,0x38,0x10,0x00},  //3
N    {0x10,0x38,0x7C,0xFE,0x7C,0x38,0x10,0x00},  //4
N    {0x38,0x7C,0x38,0xFE,0xFE,0x92,0x10,0x7C},  //5
N    {0x00,0x10,0x38,0x7C,0xFE,0x7C,0x38,0x7C},  //6
N    {0x00,0x00,0x18,0x3C,0x3C,0x18,0x00,0x00},  //7
N    {0xFF,0xFF,0xE7,0xC3,0xC3,0xE7,0xFF,0xFF},  //8
N    {0x00,0x3C,0x66,0x42,0x42,0x66,0x3C,0x00},  //9
N    {0xFF,0xC3,0x99,0xBD,0xBD,0x99,0xC3,0xFF},  //10
N    {0x0F,0x07,0x0F,0x7D,0xCC,0xCC,0xCC,0x78},  //11
N    {0x3C,0x66,0x66,0x66,0x3C,0x18,0x7E,0x18},  //12
N    {0x3F,0x33,0x3F,0x30,0x30,0x70,0xF0,0xE0},  //13
N    {0x7F,0x63,0x7F,0x63,0x63,0x67,0xE6,0xC0},  //14
N    {0x99,0x5A,0x3C,0xE7,0xE7,0x3C,0x5A,0x99},  //15
N    {0x80,0xE0,0xF8,0xFE,0xF8,0xE0,0x80,0x00},  //16
N    {0x02,0x0E,0x3E,0xFE,0x3E,0x0E,0x02,0x00},  //17
N    {0x18,0x3C,0x7E,0x18,0x18,0x7E,0x3C,0x18},  //18
N    {0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x00},  //19
N    {0x7F,0xDB,0xDB,0x7B,0x1B,0x1B,0x1B,0x00},  //20
N    {0x3E,0x63,0x38,0x6C,0x6C,0x38,0x86,0xFC},  //21
N    {0x00,0x00,0x00,0x00,0x7E,0x7E,0x7E,0x00},  //22
N    {0x18,0x3C,0x7E,0x18,0x7E,0x3C,0x18,0xFF},  //23
N    {0x18,0x3C,0x7E,0x18,0x18,0x18,0x18,0x00},  //24
N    {0x18,0x18,0x18,0x18,0x7E,0x3C,0x18,0x00},  //25
N    {0x00,0x18,0x0C,0xFE,0x0C,0x18,0x00,0x00},  //26
N    {0x00,0x30,0x60,0xFE,0x60,0x30,0x00,0x00},  //27
N    {0x00,0x00,0xC0,0xC0,0xC0,0xFE,0x00,0x00},  //28
N    {0x00,0x24,0x66,0xFF,0x66,0x24,0x00,0x00},  //29
N    {0x00,0x18,0x3C,0x7E,0xFF,0xFF,0x00,0x00},  //30
N    {0x00,0xFF,0xFF,0x7E,0x3C,0x18,0x00,0x00},  //31
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},  //32
N    {0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00},  //33
N    {0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00},  //34
N    {0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00},  //35
N    {0x18,0x7E,0xC0,0x7C,0x06,0xFC,0x18,0x00},  //36
N    {0x00,0xC6,0xCC,0x18,0x30,0x66,0xC6,0x00},  //37
N    {0x38,0x6C,0x38,0x76,0xDC,0xCC,0x76,0x00},  //38
N    {0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00},  //39
N    {0x18,0x30,0x60,0x60,0x60,0x30,0x18,0x00},  //40
N    {0x60,0x30,0x18,0x18,0x18,0x30,0x60,0x00},  //41
N    {0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00},  //42
N    {0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00},  //43
N    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30},  //44
N    {0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00},  //45
N    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00},  //46
N    {0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00},  //47
N    {0x7C,0xCE,0xDE,0xF6,0xE6,0xC6,0x7C,0x00},  //48
N    {0x30,0x70,0x30,0x30,0x30,0x30,0xFC,0x00},  //49
N    {0x78,0xCC,0x0C,0x38,0x60,0xCC,0xFC,0x00},  //50
N    {0x78,0xCC,0x0C,0x38,0x0C,0xCC,0x78,0x00},  //51
N    {0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x1E,0x00},  //52
N    {0xFC,0xC0,0xF8,0x0C,0x0C,0xCC,0x78,0x00},  //53
N    {0x38,0x60,0xC0,0xF8,0xCC,0xCC,0x78,0x00},  //54
N    {0xFC,0xCC,0x0C,0x18,0x30,0x30,0x30,0x00},  //55
N    {0x78,0xCC,0xCC,0x78,0xCC,0xCC,0x78,0x00},  //56
N    {0x78,0xCC,0xCC,0x7C,0x0C,0x18,0x70,0x00},  //57
N    {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00},  //58
N    {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30},  //59
N    {0x18,0x30,0x60,0xC0,0x60,0x30,0x18,0x00},  //60
N    {0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00},  //61
N    {0x60,0x30,0x18,0x0C,0x18,0x30,0x60,0x00},  //62
N    {0x3C,0x66,0x0C,0x18,0x18,0x00,0x18,0x00},  //63
N    {0x7C,0xC6,0xDE,0xDE,0xDC,0xC0,0x7C,0x00},  //64
N    {0x30,0x78,0xCC,0xCC,0xFC,0xCC,0xCC,0x00},  //65
N    {0xFC,0x66,0x66,0x7C,0x66,0x66,0xFC,0x00},  //66
N    {0x3C,0x66,0xC0,0xC0,0xC0,0x66,0x3C,0x00},  //67
N    {0xF8,0x6C,0x66,0x66,0x66,0x6C,0xF8,0x00},  //68
N    {0xFE,0x62,0x68,0x78,0x68,0x62,0xFE,0x00},  //69
N    {0xFE,0x62,0x68,0x78,0x68,0x60,0xF0,0x00},  //70
N    {0x3C,0x66,0xC0,0xC0,0xCE,0x66,0x3A,0x00},  //71
N    {0xCC,0xCC,0xCC,0xFC,0xCC,0xCC,0xCC,0x00},  //72
N    {0x78,0x30,0x30,0x30,0x30,0x30,0x78,0x00},  //73
N    {0x1E,0x0C,0x0C,0x0C,0xCC,0xCC,0x78,0x00},  //74
N    {0xE6,0x66,0x6C,0x78,0x6C,0x66,0xE6,0x00},  //75
N    {0xF0,0x60,0x60,0x60,0x62,0x66,0xFE,0x00},  //76
N    {0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0x00},  //77
N    {0xC6,0xE6,0xF6,0xDE,0xCE,0xC6,0xC6,0x00},  //78
N    {0x38,0x6C,0xC6,0xC6,0xC6,0x6C,0x38,0x00},  //79
N    {0xFC,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00},  //80
N    {0x7C,0xC6,0xC6,0xC6,0xD6,0x7C,0x0E,0x00},  //81
N    {0xFC,0x66,0x66,0x7C,0x6C,0x66,0xE6,0x00},  //82
N    {0x7C,0xC6,0xE0,0x78,0x0E,0xC6,0x7C,0x00},  //83
N    {0xFC,0xB4,0x30,0x30,0x30,0x30,0x78,0x00},  //84
N    {0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xFC,0x00},  //85
N    {0xCC,0xCC,0xCC,0xCC,0xCC,0x78,0x30,0x00},  //86
N    {0xC6,0xC6,0xC6,0xC6,0xD6,0xFE,0x6C,0x00},  //87
N    {0xC6,0xC6,0x6C,0x38,0x6C,0xC6,0xC6,0x00},  //88
N    {0xCC,0xCC,0xCC,0x78,0x30,0x30,0x78,0x00},  //89
N    {0xFE,0xC6,0x8C,0x18,0x32,0x66,0xFE,0x00},  //90
N    {0x78,0x60,0x60,0x60,0x60,0x60,0x78,0x00},  //91
N    {0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00},  //92
N    {0x78,0x18,0x18,0x18,0x18,0x18,0x78,0x00},  //93
N    {0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00},  //94
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},  //95
N    {0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00},  //96
N    {0x00,0x00,0x78,0x0C,0x7C,0xCC,0x76,0x00},  //97
N    {0xE0,0x60,0x60,0x7C,0x66,0x66,0xDC,0x00},  //98
N    {0x00,0x00,0x78,0xCC,0xC0,0xCC,0x78,0x00},  //99
N    {0x1C,0x0C,0x0C,0x7C,0xCC,0xCC,0x76,0x00},  //100
N    {0x00,0x00,0x78,0xCC,0xFC,0xC0,0x78,0x00},  //101
N    {0x38,0x6C,0x64,0xF0,0x60,0x60,0xF0,0x00},  //102
N    {0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0xF8},  //103
N    {0xE0,0x60,0x6C,0x76,0x66,0x66,0xE6,0x00},  //104
N    {0x30,0x00,0x70,0x30,0x30,0x30,0x78,0x00},  //105
N    {0x0C,0x00,0x1C,0x0C,0x0C,0xCC,0xCC,0x78},  //106
N    {0xE0,0x60,0x66,0x6C,0x78,0x6C,0xE6,0x00},  //107
N    {0x70,0x30,0x30,0x30,0x30,0x30,0x78,0x00},  //108
N    {0x00,0x00,0xCC,0xFE,0xFE,0xD6,0xD6,0x00},  //109
N    {0x00,0x00,0xB8,0xCC,0xCC,0xCC,0xCC,0x00},  //110
N    {0x00,0x00,0x78,0xCC,0xCC,0xCC,0x78,0x00},  //111
N    {0x00,0x00,0xDC,0x66,0x66,0x7C,0x60,0xF0},  //112
N    {0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0x1E},  //113
N    {0x00,0x00,0xDC,0x76,0x62,0x60,0xF0,0x00},  //114
N    {0x00,0x00,0x7C,0xC0,0x70,0x1C,0xF8,0x00},  //115
N    {0x10,0x30,0xFC,0x30,0x30,0x34,0x18,0x00},  //116
N    {0x00,0x00,0xCC,0xCC,0xCC,0xCC,0x76,0x00},  //117
N    {0x00,0x00,0xCC,0xCC,0xCC,0x78,0x30,0x00},  //118
N    {0x00,0x00,0xC6,0xC6,0xD6,0xFE,0x6C,0x00},  //119
N    {0x00,0x00,0xC6,0x6C,0x38,0x6C,0xC6,0x00},  //120
N    {0x00,0x00,0xCC,0xCC,0xCC,0x7C,0x0C,0xF8},  //121
N    {0x00,0x00,0xFC,0x98,0x30,0x64,0xFC,0x00},  //122
N    {0x1C,0x30,0x30,0xE0,0x30,0x30,0x1C,0x00},  //123
N    {0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00},  //124
N    {0xE0,0x30,0x30,0x1C,0x30,0x30,0xE0,0x00},  //125
N    {0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00},  //126
N    {0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0x00},  //127
N    {0x7C,0xC6,0xC0,0xC6,0x7C,0x0C,0x06,0x7C},  //128
N    {0x00,0xCC,0x00,0xCC,0xCC,0xCC,0x76,0x00},  //129
N    {0x1C,0x00,0x78,0xCC,0xFC,0xC0,0x78,0x00},  //130
N    {0x7E,0x81,0x3C,0x06,0x3E,0x66,0x3B,0x00},  //131
N    {0xCC,0x00,0x78,0x0C,0x7C,0xCC,0x76,0x00},  //132
N    {0xE0,0x00,0x78,0x0C,0x7C,0xCC,0x76,0x00},  //133
N    {0x30,0x30,0x78,0x0C,0x7C,0xCC,0x76,0x00},  //134
N    {0x00,0x00,0x7C,0xC6,0xC0,0x78,0x0C,0x38},  //135
N    {0x7E,0x81,0x3C,0x66,0x7E,0x60,0x3C,0x00},  //136
N    {0xCC,0x00,0x78,0xCC,0xFC,0xC0,0x78,0x00},  //137
N    {0xE0,0x00,0x78,0xCC,0xFC,0xC0,0x78,0x00},  //138
N    {0xCC,0x00,0x70,0x30,0x30,0x30,0x78,0x00},  //139
N    {0x7C,0x82,0x38,0x18,0x18,0x18,0x3C,0x00},  //140
N    {0xE0,0x00,0x70,0x30,0x30,0x30,0x78,0x00},  //141
N    {0xC6,0x10,0x7C,0xC6,0xFE,0xC6,0xC6,0x00},  //142
N    {0x30,0x30,0x00,0x78,0xCC,0xFC,0xCC,0x00},  //143
N    {0x1C,0x00,0xFC,0x60,0x78,0x60,0xFC,0x00},  //144
N    {0x00,0x00,0x7F,0x0C,0x7F,0xCC,0x7F,0x00},  //145
N    {0x3E,0x6C,0xCC,0xFE,0xCC,0xCC,0xCE,0x00},  //146
N    {0x78,0x84,0x00,0x78,0xCC,0xCC,0x78,0x00},  //147
N    {0x00,0xCC,0x00,0x78,0xCC,0xCC,0x78,0x00},  //148
N    {0x00,0xE0,0x00,0x78,0xCC,0xCC,0x78,0x00},  //149
N    {0x78,0x84,0x00,0xCC,0xCC,0xCC,0x76,0x00},  //150
N    {0x00,0xE0,0x00,0xCC,0xCC,0xCC,0x76,0x00},  //151
N    {0x00,0xCC,0x00,0xCC,0xCC,0x7C,0x0C,0xF8},  //152
N    {0xC3,0x18,0x3C,0x66,0x66,0x3C,0x18,0x00},  //153
N    {0xCC,0x00,0xCC,0xCC,0xCC,0xCC,0x78,0x00},  //154
N    {0x18,0x18,0x7E,0xC0,0xC0,0x7E,0x18,0x18},  //155
N    {0x38,0x6C,0x64,0xF0,0x60,0xE6,0xFC,0x00},  //156
N    {0xCC,0xCC,0x78,0x30,0xFC,0x30,0xFC,0x30},  //157
N    {0xF8,0xCC,0xCC,0xFA,0xC6,0xCF,0xC6,0xC3},  //158
N    {0x0E,0x1B,0x18,0x3C,0x18,0x18,0xD8,0x70},  //159
N    {0x1C,0x00,0x78,0x0C,0x7C,0xCC,0x76,0x00},  //160
N    {0x38,0x00,0x70,0x30,0x30,0x30,0x78,0x00},  //161
N    {0x00,0x1C,0x00,0x78,0xCC,0xCC,0x78,0x00},  //162
N    {0x00,0x1C,0x00,0xCC,0xCC,0xCC,0x76,0x00},  //163
N    {0x00,0xF8,0x00,0xB8,0xCC,0xCC,0xCC,0x00},  //164
N    {0xFC,0x00,0xCC,0xEC,0xFC,0xDC,0xCC,0x00},  //165
N    {0x3C,0x6C,0x6C,0x3E,0x00,0x7E,0x00,0x00},  //166
N    {0x38,0x6C,0x6C,0x38,0x00,0x7C,0x00,0x00},  //167
N    {0x18,0x00,0x18,0x18,0x30,0x66,0x3C,0x00},  //168
N    {0x00,0x00,0x00,0xFC,0xC0,0xC0,0x00,0x00},  //169
N    {0x00,0x00,0x00,0xFC,0x0C,0x0C,0x00,0x00},  //170
N    {0xC6,0xCC,0xD8,0x36,0x6B,0xC2,0x84,0x0F},  //171
N    {0xC3,0xC6,0xCC,0xDB,0x37,0x6D,0xCF,0x03},  //172
N    {0x18,0x00,0x18,0x18,0x3C,0x3C,0x18,0x00},  //173
N    {0x00,0x33,0x66,0xCC,0x66,0x33,0x00,0x00},  //174
N    {0x00,0xCC,0x66,0x33,0x66,0xCC,0x00,0x00},  //175
N    {0x22,0x88,0x22,0x88,0x22,0x88,0x22,0x88},  //176
N    {0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA},  //177
N    {0xDB,0xF6,0xDB,0x6F,0xDB,0x7E,0xD7,0xED},  //178
N    {0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18},  //179
N    {0x18,0x18,0x18,0x18,0xF8,0x18,0x18,0x18},  //180
N    {0x18,0x18,0xF8,0x18,0xF8,0x18,0x18,0x18},  //181
N    {0x36,0x36,0x36,0x36,0xF6,0x36,0x36,0x36},  //182
N    {0x00,0x00,0x00,0x00,0xFE,0x36,0x36,0x36},  //183
N    {0x00,0x00,0xF8,0x18,0xF8,0x18,0x18,0x18},  //184
N    {0x36,0x36,0xF6,0x06,0xF6,0x36,0x36,0x36},  //185
N    {0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36},  //186
N    {0x00,0x00,0xFE,0x06,0xF6,0x36,0x36,0x36},  //187
N    {0x36,0x36,0xF6,0x06,0xFE,0x00,0x00,0x00},  //188
N    {0x36,0x36,0x36,0x36,0xFE,0x00,0x00,0x00},  //189
N    {0x18,0x18,0xF8,0x18,0xF8,0x00,0x00,0x00},  //190
N    {0x00,0x00,0x00,0x00,0xF8,0x18,0x18,0x18},  //191
N    {0x18,0x18,0x18,0x18,0x1F,0x00,0x00,0x00},  //192
N    {0x18,0x18,0x18,0x18,0xFF,0x00,0x00,0x00},  //193
N    {0x00,0x00,0x00,0x00,0xFF,0x18,0x18,0x18},  //194
N    {0x18,0x18,0x18,0x18,0x1F,0x18,0x18,0x18},  //195
N    {0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},  //196
N    {0x18,0x18,0x18,0x18,0xFF,0x18,0x18,0x18},  //197
N    {0x18,0x18,0x1F,0x18,0x1F,0x18,0x18,0x18},  //198
N    {0x36,0x36,0x36,0x36,0x37,0x36,0x36,0x36},  //199
N    {0x36,0x36,0x37,0x30,0x3F,0x00,0x00,0x00},  //200
N    {0x00,0x00,0x3F,0x30,0x37,0x36,0x36,0x36},  //201
N    {0x36,0x36,0xF7,0x00,0xFF,0x00,0x00,0x00},  //202
N    {0x00,0x00,0xFF,0x00,0xF7,0x36,0x36,0x36},  //203
N    {0x36,0x36,0x37,0x30,0x37,0x36,0x36,0x36},  //204
N    {0x00,0x00,0xFF,0x00,0xFF,0x00,0x00,0x00},  //205
N    {0x36,0x36,0xF7,0x00,0xF7,0x36,0x36,0x36},  //206
N    {0x18,0x18,0xFF,0x00,0xFF,0x00,0x00,0x00},  //207
N    {0x36,0x36,0x36,0x36,0xFF,0x00,0x00,0x00},  //208
N    {0x00,0x00,0xFF,0x00,0xFF,0x18,0x18,0x18},  //209
N    {0x00,0x00,0x00,0x00,0xFF,0x36,0x36,0x36},  //210
N    {0x36,0x36,0x36,0x36,0x3F,0x00,0x00,0x00},  //211
N    {0x18,0x18,0x1F,0x18,0x1F,0x00,0x00,0x00},  //212
N    {0x00,0x00,0x1F,0x18,0x1F,0x18,0x18,0x18},  //213
N    {0x00,0x00,0x00,0x00,0x3F,0x36,0x36,0x36},  //214
N    {0x36,0x36,0x36,0x36,0xFF,0x36,0x36,0x36},  //215
N    {0x18,0x18,0xFF,0x18,0xFF,0x18,0x18,0x18},  //216
N    {0x18,0x18,0x18,0x18,0xF8,0x00,0x00,0x00},  //217
N    {0x00,0x00,0x00,0x00,0x1F,0x18,0x18,0x18},  //218
N    {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},  //219
N    {0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF},  //220
N    {0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0},  //221
N    {0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F},  //222
N    {0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00},  //223
N    {0x00,0x00,0x76,0xDC,0xC8,0xDC,0x76,0x00},  //224
N    {0x00,0x78,0xCC,0xF8,0xCC,0xF8,0xC0,0xC0},  //225
N    {0x00,0xFC,0xCC,0xC0,0xC0,0xC0,0xC0,0x00},  //226
N    {0x00,0x00,0xFE,0x6C,0x6C,0x6C,0x6C,0x00},  //227
N    {0xFC,0xCC,0x60,0x30,0x60,0xCC,0xFC,0x00},  //228
N    {0x00,0x00,0x7E,0xD8,0xD8,0xD8,0x70,0x00},  //229
N    {0x00,0x66,0x66,0x66,0x66,0x7C,0x60,0xC0},  //230
N    {0x00,0x76,0xDC,0x18,0x18,0x18,0x18,0x00},  //231
N    {0xFC,0x30,0x78,0xCC,0xCC,0x78,0x30,0xFC},  //232
N    {0x38,0x6C,0xC6,0xFE,0xC6,0x6C,0x38,0x00},  //233
N    {0x38,0x6C,0xC6,0xC6,0x6C,0x6C,0xEE,0x00},  //234
N    {0x1C,0x30,0x18,0x7C,0xCC,0xCC,0x78,0x00},  //235
N    {0x00,0x00,0x7E,0xDB,0xDB,0x7E,0x00,0x00},  //236
N    {0x06,0x0C,0x7E,0xDB,0xDB,0x7E,0x60,0xC0},  //237
N    {0x38,0x60,0xC0,0xF8,0xC0,0x60,0x38,0x00},  //238
N    {0x78,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x00},  //239
N    {0x00,0x7E,0x00,0x7E,0x00,0x7E,0x00,0x00},  //240
N    {0x18,0x18,0x7E,0x18,0x18,0x00,0x7E,0x00},  //241
N    {0x60,0x30,0x18,0x30,0x60,0x00,0xFC,0x00},  //242
N    {0x18,0x30,0x60,0x30,0x18,0x00,0xFC,0x00},  //243
N    {0x0E,0x1B,0x1B,0x18,0x18,0x18,0x18,0x18},  //244
N    {0x18,0x18,0x18,0x18,0x18,0xD8,0xD8,0x70},  //245
N    {0x18,0x18,0x00,0x7E,0x00,0x18,0x18,0x00},  //246
N    {0x00,0x76,0xDC,0x00,0x76,0xDC,0x00,0x00},  //247
N    {0x38,0x6C,0x6C,0x38,0x00,0x00,0x00,0x00},  //248
N    {0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00},  //249
N    {0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00},  //250
N    {0x0F,0x0C,0x0C,0x0C,0xEC,0x6C,0x3C,0x1C},  //251
N    {0x58,0x6C,0x6C,0x6C,0x6C,0x00,0x00,0x00},  //252
N    {0x70,0x98,0x30,0x60,0xF8,0x00,0x00,0x00},  //253
N    {0x00,0x00,0x3C,0x3C,0x3C,0x3C,0x00,0x00},  //254
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}   //255
N};
N
Nstatic unsigned	char FontData16[256][16] = {
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //0
N    {0x00,0x00,0x7E,0x81,0xA5,0x81,0x81,0xBD,0x99,0x81,0x81,0x7E,0x00,0x00,0x00,0x00}, //1
N    {0x00,0x00,0x7E,0xFF,0xDB,0xFF,0xFF,0xC3,0xE7,0xFF,0xFF,0x7E,0x00,0x00,0x00,0x00}, //2
N    {0x00,0x00,0x00,0x00,0x6C,0xFE,0xFE,0xFE,0xFE,0x7C,0x38,0x10,0x00,0x00,0x00,0x00}, //3
N    {0x00,0x00,0x00,0x00,0x10,0x38,0x7C,0xFE,0x7C,0x38,0x10,0x00,0x00,0x00,0x00,0x00}, //4
N    {0x00,0x00,0x00,0x18,0x3C,0x3C,0xE7,0xE7,0xE7,0x99,0x18,0x3C,0x00,0x00,0x00,0x00}, //5
N    {0x00,0x00,0x00,0x18,0x3C,0x7E,0xFF,0xFF,0x7E,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, //6
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x3C,0x3C,0x18,0x00,0x00,0x00,0x00,0x00,0x00}, //7
N    {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE7,0xC3,0xC3,0xE7,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}, //8
N    {0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x42,0x42,0x66,0x3C,0x00,0x00,0x00,0x00,0x00}, //9
N    {0xFF,0xFF,0xFF,0xFF,0xFF,0xC3,0x99,0xBD,0xBD,0x99,0xC3,0xFF,0xFF,0xFF,0xFF,0xFF}, //10
N    {0x00,0x00,0x1E,0x0E,0x1A,0x32,0x78,0xCC,0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00}, //11
N    {0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x3C,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00}, //12
N    {0x00,0x00,0x3F,0x33,0x3F,0x30,0x30,0x30,0x30,0x70,0xF0,0xE0,0x00,0x00,0x00,0x00}, //13
N    {0x00,0x00,0x7F,0x63,0x7F,0x63,0x63,0x63,0x63,0x67,0xE7,0xE6,0xC0,0x00,0x00,0x00}, //14
N    {0x00,0x00,0x00,0x18,0x18,0xDB,0x3C,0xE7,0x3C,0xDB,0x18,0x18,0x00,0x00,0x00,0x00}, //15
N    {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFE,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00}, //16
N    {0x00,0x02,0x06,0x0E,0x1E,0x3E,0xFE,0x3E,0x1E,0x0E,0x06,0x02,0x00,0x00,0x00,0x00}, //17
N    {0x00,0x00,0x18,0x3C,0x7E,0x18,0x18,0x18,0x18,0x7E,0x3C,0x18,0x00,0x00,0x00,0x00}, //18
N    {0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x66,0x00,0x00,0x00,0x00}, //19
N    {0x00,0x00,0x7F,0xDB,0xDB,0xDB,0x7B,0x1B,0x1B,0x1B,0x1B,0x1B,0x00,0x00,0x00,0x00}, //20
N    {0x00,0x7C,0xC6,0x60,0x38,0x6C,0xC6,0xC6,0x6C,0x38,0x0C,0xC6,0x7C,0x00,0x00,0x00}, //21
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xFE,0xFE,0xFE,0x00,0x00,0x00,0x00}, //22
N    {0x00,0x00,0x18,0x3C,0x7E,0x18,0x18,0x18,0x18,0x7E,0x3C,0x18,0x7E,0x00,0x00,0x00}, //23
N    {0x00,0x00,0x18,0x3C,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00}, //24
N    {0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x3C,0x18,0x00,0x00,0x00,0x00}, //25
N    {0x00,0x00,0x00,0x00,0x00,0x18,0x0C,0xFE,0x0C,0x18,0x00,0x00,0x00,0x00,0x00,0x00}, //26
N    {0x00,0x00,0x00,0x00,0x00,0x30,0x60,0xFE,0x60,0x30,0x00,0x00,0x00,0x00,0x00,0x00}, //27
N    {0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0xC0,0xFE,0x00,0x00,0x00,0x00,0x00,0x00}, //28
N    {0x00,0x00,0x00,0x00,0x00,0x28,0x6C,0xFE,0x6C,0x28,0x00,0x00,0x00,0x00,0x00,0x00}, //29
N    {0x00,0x00,0x00,0x00,0x10,0x38,0x38,0x7C,0x7C,0xFE,0xFE,0x00,0x00,0x00,0x00,0x00}, //30
N    {0x00,0x00,0x00,0x00,0xFE,0xFE,0x7C,0x7C,0x38,0x38,0x10,0x00,0x00,0x00,0x00,0x00}, //31
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //32
N    {0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00}, //33
N    {0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //34
N    {0x00,0x00,0x00,0x6C,0x6C,0xFE,0x6C,0x6C,0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00}, //35
N    {0x18,0x18,0x7C,0xC6,0xC2,0xC0,0x7C,0x06,0x86,0xC6,0x7C,0x18,0x18,0x00,0x00,0x00}, //36
N    {0x00,0x00,0x00,0x00,0xC2,0xC6,0x0C,0x18,0x30,0x60,0xC6,0x86,0x00,0x00,0x00,0x00}, //37
N    {0x00,0x00,0x38,0x6C,0x6C,0x38,0x76,0xDC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, //38
N    {0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //39
N    {0x00,0x00,0x0C,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0C,0x00,0x00,0x00,0x00}, //40
N    {0x00,0x00,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0x00,0x00,0x00,0x00}, //41
N    {0x00,0x00,0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00}, //42
N    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00}, //43
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,0x00}, //44
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //45
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00}, //46
N    {0x00,0x00,0x00,0x00,0x02,0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00}, //47
N    {0x00,0x00,0x7C,0xC6,0xC6,0xCE,0xD6,0xD6,0xE6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, //48
N    {0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00}, //49
N    {0x00,0x00,0x7C,0xC6,0x06,0x0C,0x18,0x30,0x60,0xC0,0xC6,0xFE,0x00,0x00,0x00,0x00}, //50
N    {0x00,0x00,0x7C,0xC6,0x06,0x06,0x3C,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00}, //51
N    {0x00,0x00,0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00}, //52
N    {0x00,0x00,0xFE,0xC0,0xC0,0xC0,0xFC,0x0E,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00}, //53
N    {0x00,0x00,0x38,0x60,0xC0,0xC0,0xFC,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, //54
N    {0x00,0x00,0xFE,0xC6,0x06,0x06,0x0C,0x18,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00}, //55
N    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, //56
N    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7E,0x06,0x06,0x06,0x0C,0x78,0x00,0x00,0x00,0x00}, //57
N    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00}, //58
N    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00}, //59
N    {0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00}, //60
N    {0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00}, //61
N    {0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00}, //62
N    {0x00,0x00,0x7C,0xC6,0xC6,0x0C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00}, //63
N    {0x00,0x00,0x00,0x7C,0xC6,0xC6,0xDE,0xDE,0xDE,0xDC,0xC0,0x7C,0x00,0x00,0x00,0x00}, //64
N    {0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00}, //65
N    {0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x66,0x66,0x66,0x66,0xFC,0x00,0x00,0x00,0x00}, //66
N    {0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC0,0xC0,0xC2,0x66,0x3C,0x00,0x00,0x00,0x00}, //67
N    {0x00,0x00,0xF8,0x6C,0x66,0x66,0x66,0x66,0x66,0x66,0x6C,0xF8,0x00,0x00,0x00,0x00}, //68
N    {0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00}, //69
N    {0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00}, //70
N    {0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xDE,0xC6,0xC6,0x66,0x3A,0x00,0x00,0x00,0x00}, //71
N    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00}, //72
N    {0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, //73
N    {0x00,0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00}, //74
N    {0x00,0x00,0xE6,0x66,0x6C,0x6C,0x78,0x78,0x6C,0x66,0x66,0xE6,0x00,0x00,0x00,0x00}, //75
N    {0x00,0x00,0xF0,0x60,0x60,0x60,0x60,0x60,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00}, //76
N    {0x00,0x00,0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00}, //77
N    {0x00,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00}, //78
N    {0x00,0x00,0x38,0x6C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00,0x00}, //79
N    {0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00}, //80
N    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xD6,0xDE,0x7C,0x0C,0x0E,0x00,0x00}, //81
N    {0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x6C,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00}, //82
N    {0x00,0x00,0x7C,0xC6,0xC6,0x60,0x38,0x0C,0x06,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, //83
N    {0x00,0x00,0x7E,0x7E,0x5A,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, //84
N    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, //85
N    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x10,0x00,0x00,0x00,0x00}, //86
N    {0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xD6,0xD6,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00}, //87
N    {0x00,0x00,0xC6,0xC6,0x6C,0x6C,0x38,0x38,0x6C,0x6C,0xC6,0xC6,0x00,0x00,0x00,0x00}, //88
N    {0x00,0x00,0x66,0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, //89
N    {0x00,0x00,0xFE,0xC6,0x86,0x0C,0x18,0x30,0x60,0xC2,0xC6,0xFE,0x00,0x00,0x00,0x00}, //90
N    {0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00}, //91
N    {0x00,0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x06,0x02,0x00,0x00,0x00,0x00}, //92
N    {0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00}, //93
N    {0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //94
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00}, //95
N    {0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //96
N    {0x00,0x00,0x00,0x00,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, //97
N    {0x00,0x00,0xE0,0x60,0x60,0x78,0x6C,0x66,0x66,0x66,0x66,0xDC,0x00,0x00,0x00,0x00}, //98
N    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC0,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00}, //99
N    {0x00,0x00,0x1C,0x0C,0x0C,0x3C,0x6C,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, //100
N    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00}, //101
N    {0x00,0x00,0x38,0x6C,0x64,0x60,0xF0,0x60,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00}, //102
N    {0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0xCC,0x78,0x00}, //103
N    {0x00,0x00,0xE0,0x60,0x60,0x6C,0x76,0x66,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00}, //104
N    {0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, //105
N    {0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00}, //106
N    {0x00,0x00,0xE0,0x60,0x60,0x66,0x6C,0x78,0x78,0x6C,0x66,0xE6,0x00,0x00,0x00,0x00}, //107
N    {0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, //108
N    {0x00,0x00,0x00,0x00,0x00,0xEC,0xFE,0xD6,0xD6,0xD6,0xD6,0xD6,0x00,0x00,0x00,0x00}, //109
N    {0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00}, //110
N    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, //111
N    {0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00}, //112
N    {0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0x0C,0x1E,0x00}, //113
N    {0x00,0x00,0x00,0x00,0x00,0xDC,0x76,0x62,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00}, //114
N    {0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0x60,0x38,0x0C,0xC6,0x7C,0x00,0x00,0x00,0x00}, //115
N    {0x00,0x00,0x10,0x30,0x30,0xFC,0x30,0x30,0x30,0x30,0x36,0x1C,0x00,0x00,0x00,0x00}, //116
N    {0x00,0x00,0x00,0x00,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, //117
N    {0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00,0x00,0x00,0x00}, //118
N    {0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xD6,0xD6,0xFE,0x6C,0x00,0x00,0x00,0x00}, //119
N    {0x00,0x00,0x00,0x00,0x00,0xC6,0x6C,0x38,0x38,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00}, //120
N    {0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0xF8,0x00}, //121
N    {0x00,0x00,0x00,0x00,0x00,0xFE,0xCC,0x18,0x30,0x60,0xC6,0xFE,0x00,0x00,0x00,0x00}, //122
N    {0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00}, //123
N    {0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00}, //124
N    {0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00}, //125
N    {0x00,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //126
N    {0x00,0x00,0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xC6,0xFE,0x00,0x00,0x00,0x00,0x00}, //127
N    {0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC0,0xC2,0x66,0x3C,0x0C,0x06,0x7C,0x00,0x00}, //128
N    {0x00,0x00,0xCC,0xCC,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, //129
N    {0x00,0x0C,0x18,0x30,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00}, //130
N    {0x00,0x10,0x38,0x6C,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, //131
N    {0x00,0x00,0xCC,0xCC,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, //132
N    {0x00,0x60,0x30,0x18,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, //133
N    {0x00,0x38,0x6C,0x38,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, //134
N    {0x00,0x00,0x00,0x00,0x3C,0x66,0x60,0x60,0x66,0x3C,0x0C,0x06,0x3C,0x00,0x00,0x00}, //135
N    {0x00,0x10,0x38,0x6C,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00}, //136
N    {0x00,0x00,0xC6,0xC6,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00}, //137
N    {0x00,0x60,0x30,0x18,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00}, //138
N    {0x00,0x00,0x66,0x66,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, //139
N    {0x00,0x18,0x3C,0x66,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, //140
N    {0x00,0x60,0x30,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, //141
N    {0x00,0xC6,0xC6,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00}, //142
N    {0x38,0x6C,0x38,0x00,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00}, //143
N    {0x18,0x30,0x60,0x00,0xFE,0x66,0x60,0x7C,0x60,0x60,0x66,0xFE,0x00,0x00,0x00,0x00}, //144
N    {0x00,0x00,0x00,0x00,0x00,0xCC,0x76,0x36,0x7E,0xD8,0xD8,0x6E,0x00,0x00,0x00,0x00}, //145
N    {0x00,0x00,0x3E,0x6C,0xCC,0xCC,0xFE,0xCC,0xCC,0xCC,0xCC,0xCE,0x00,0x00,0x00,0x00}, //146
N    {0x00,0x10,0x38,0x6C,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, //147
N    {0x00,0x00,0xC6,0xC6,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, //148
N    {0x00,0x60,0x30,0x18,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, //149
N    {0x00,0x30,0x78,0xCC,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, //150
N    {0x00,0x60,0x30,0x18,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, //151
N    {0x00,0x00,0xC6,0xC6,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0x78,0x00}, //152
N    {0x00,0xC6,0xC6,0x00,0x38,0x6C,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00,0x00}, //153
N    {0x00,0xC6,0xC6,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, //154
N    {0x00,0x18,0x18,0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x18,0x18,0x00,0x00,0x00,0x00}, //155
N    {0x00,0x38,0x6C,0x64,0x60,0xF0,0x60,0x60,0x60,0x60,0xE6,0xFC,0x00,0x00,0x00,0x00}, //156
N    {0x00,0x00,0x66,0x66,0x3C,0x18,0x7E,0x18,0x7E,0x18,0x18,0x18,0x00,0x00,0x00,0x00}, //157
N    {0x00,0xF8,0xCC,0xCC,0xF8,0xC4,0xCC,0xDE,0xCC,0xCC,0xCC,0xC6,0x00,0x00,0x00,0x00}, //158
N    {0x00,0x0E,0x1B,0x18,0x18,0x18,0x7E,0x18,0x18,0x18,0x18,0x18,0xD8,0x70,0x00,0x00}, //159
N    {0x00,0x18,0x30,0x60,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, //160
N    {0x00,0x0C,0x18,0x30,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, //161
N    {0x00,0x18,0x30,0x60,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, //162
N    {0x00,0x18,0x30,0x60,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00}, //163
N    {0x00,0x00,0x76,0xDC,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00}, //164
N    {0x76,0xDC,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00}, //165
N    {0x00,0x3C,0x6C,0x6C,0x3E,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //166
N    {0x00,0x38,0x6C,0x6C,0x38,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //167
N    {0x00,0x00,0x30,0x30,0x00,0x30,0x30,0x60,0xC0,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00}, //168
N    {0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00}, //169
N    {0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x06,0x06,0x06,0x06,0x00,0x00,0x00,0x00,0x00}, //170
N    {0x00,0xC0,0xC0,0xC2,0xC6,0xCC,0x18,0x30,0x60,0xCE,0x93,0x06,0x0C,0x1F,0x00,0x00}, //171
N    {0x00,0xC0,0xC0,0xC2,0xC6,0xCC,0x18,0x30,0x66,0xCE,0x9A,0x3F,0x06,0x0F,0x00,0x00}, //172
N    {0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x18,0x3C,0x3C,0x3C,0x18,0x00,0x00,0x00,0x00}, //173
N    {0x00,0x00,0x00,0x00,0x00,0x33,0x66,0xCC,0x66,0x33,0x00,0x00,0x00,0x00,0x00,0x00}, //174
N    {0x00,0x00,0x00,0x00,0x00,0xCC,0x66,0x33,0x66,0xCC,0x00,0x00,0x00,0x00,0x00,0x00}, //175
N    {0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44}, //176
N    {0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA}, //177
N    {0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77}, //178
N    {0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, //179
N    {0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xF8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, //180
N    {0x18,0x18,0x18,0x18,0x18,0xF8,0x18,0xF8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, //181
N    {0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xF6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36}, //182
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36}, //183
N    {0x00,0x00,0x00,0x00,0x00,0xF8,0x18,0xF8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, //184
N    {0x36,0x36,0x36,0x36,0x36,0xF6,0x06,0xF6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36}, //185
N    {0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36}, //186
N    {0x00,0x00,0x00,0x00,0x00,0xFE,0x06,0xF6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36}, //187
N    {0x36,0x36,0x36,0x36,0x36,0xF6,0x06,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //188
N    {0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //189
N    {0x18,0x18,0x18,0x18,0x18,0xF8,0x18,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //190
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, //191
N    {0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //192
N    {0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //193
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, //194
N    {0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1F,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, //195
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //196
N    {0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xFF,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, //197
N    {0x18,0x18,0x18,0x18,0x18,0x1F,0x18,0x1F,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, //198
N    {0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36}, //199
N    {0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //200
N    {0x00,0x00,0x00,0x00,0x00,0x3F,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36}, //201
N    {0x36,0x36,0x36,0x36,0x36,0xF7,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //202
N    {0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xF7,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36}, //203
N    {0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36}, //204
N    {0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //205
N    {0x36,0x36,0x36,0x36,0x36,0xF7,0x00,0xF7,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36}, //206
N    {0x18,0x18,0x18,0x18,0x18,0xFF,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //207
N    {0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //208
N    {0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xFF,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, //209
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36}, //210
N    {0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //211
N    {0x18,0x18,0x18,0x18,0x18,0x1F,0x18,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //212
N    {0x00,0x00,0x00,0x00,0x00,0x1F,0x18,0x1F,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, //213
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36}, //214
N    {0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xFF,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36}, //215
N    {0x18,0x18,0x18,0x18,0x18,0xFF,0x18,0xFF,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, //216
N    {0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //217
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, //218
N    {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}, //219
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}, //220
N    {0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0}, //221
N    {0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F}, //222
N    {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //223
N    {0x00,0x00,0x00,0x00,0x00,0x76,0xDC,0xD8,0xD8,0xD8,0xDC,0x76,0x00,0x00,0x00,0x00}, //224
N    {0x00,0x00,0x00,0x00,0x00,0xFC,0xC6,0xFC,0xC6,0xC6,0xFC,0xC0,0xC0,0xC0,0x00,0x00}, //225
N    {0x00,0x00,0xFE,0xC6,0xC6,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00}, //226
N    {0x00,0x00,0x00,0x00,0x80,0xFE,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00}, //227
N    {0x00,0x00,0x00,0xFE,0xC6,0x60,0x30,0x18,0x30,0x60,0xC6,0xFE,0x00,0x00,0x00,0x00}, //228
N    {0x00,0x00,0x00,0x00,0x00,0x7E,0xD8,0xD8,0xD8,0xD8,0xD8,0x70,0x00,0x00,0x00,0x00}, //229
N    {0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0xC0,0x00,0x00,0x00}, //230
N    {0x00,0x00,0x00,0x00,0x76,0xDC,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00}, //231
N    {0x00,0x00,0x00,0x7E,0x18,0x3C,0x66,0x66,0x66,0x3C,0x18,0x7E,0x00,0x00,0x00,0x00}, //232
N    {0x00,0x00,0x00,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00,0x00}, //233
N    {0x00,0x00,0x38,0x6C,0xC6,0xC6,0xC6,0x6C,0x6C,0x6C,0x6C,0xEE,0x00,0x00,0x00,0x00}, //234
N    {0x00,0x00,0x1E,0x30,0x18,0x0C,0x3E,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00}, //235
N    {0x00,0x00,0x00,0x00,0x00,0x7E,0xDB,0xDB,0xDB,0x7E,0x00,0x00,0x00,0x00,0x00,0x00}, //236
N    {0x00,0x00,0x00,0x03,0x06,0x7E,0xCF,0xDB,0xF3,0x7E,0x60,0xC0,0x00,0x00,0x00,0x00}, //237
N    {0x00,0x00,0x1C,0x30,0x60,0x60,0x7C,0x60,0x60,0x60,0x30,0x1C,0x00,0x00,0x00,0x00}, //238
N    {0x00,0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00}, //239
N    {0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0xFE,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00}, //240
N    {0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0xFF,0x00,0x00,0x00,0x00}, //241
N    {0x00,0x00,0x00,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00,0x7E,0x00,0x00,0x00,0x00}, //242
N    {0x00,0x00,0x00,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00,0x7E,0x00,0x00,0x00,0x00}, //243
N    {0x00,0x00,0x0E,0x1B,0x1B,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18}, //244
N    {0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xD8,0xD8,0xD8,0x70,0x00,0x00,0x00,0x00}, //245
N    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x7E,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00}, //246
N    {0x00,0x00,0x00,0x00,0x00,0x76,0xDC,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00}, //247
N    {0x00,0x38,0x6C,0x6C,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //248
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //249
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //250
N    {0x00,0x0F,0x0C,0x0C,0x0C,0x0C,0x0C,0xEC,0x6C,0x6C,0x3C,0x1C,0x00,0x00,0x00,0x00}, //251
N    {0x00,0xD8,0x6C,0x6C,0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //252
N    {0x00,0x70,0x98,0x30,0x60,0xC8,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, //253
N    {0x00,0x00,0x00,0x00,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x00,0x00,0x00,0x00,0x00}, //254
N    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}  //255
N};
N/// @endcond /* HIDDEN_SYMBOLS */
N
N/*@}*/ /* end of group N9H30_GE2D_EXPORTED_CONSTANTS */
N
N/** @addtogroup N9H30_GE2D_EXPORTED_FUNCTIONS GE2D Exported Functions
N  @{
N*/
N
N/// @cond HIDDEN_SYMBOLS
N
N/* For align 32 */
Nstatic unsigned int shift_pointer(int ptr, int align)
N{
N    unsigned int pos;
N    int remain;
N    pos = ptr;
N
N    if( (ptr%align)!=0) {
N        remain = ptr % align;
N        ptr = ptr + (align - remain);
N        return ptr;
N    } else
N        return pos;
N}
N
Nstatic unsigned long make_color(int color)
N{
N    UINT32 r, g, b;
N
N    if (GFX_BPP==8) {
N        r = (color & 0x00e00000) >> 16; // 3 bits
N        g = (color & 0x0000e000) >> 11; // 3 bits
N        b = (color & 0x000000c0) >> 6;  // 2 bits
N        return (r | g | b);
N    } else if (GFX_BPP==16) {
N        r = (color & 0x00f80000) >> 8; // 5 bits
N        g = (color & 0x0000fc00) >> 5; // 6 bits
N        b = (color & 0x000000f8) >> 3; // 5 bits
N        return (r | g | b);
N    } else return (UINT32)color;
N}
N/// @endcond /* HIDDEN_SYMBOLS */
N
N/**
N  * @brief  Clear the on screen buffer with a specified color.
N  * @param[in] color clear with this color.
N  * @return none
N  */
Nvoid ge2dClearScreen(int color)
N{
N    UINT32 cmd32;
N    UINT32 color32, dest_pitch, dest_dimension;
N
N    color32 = make_color(color);
N
N    cmd32 = 0xcc430040;
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N    outpw(REG_GE2D_BGCOLR, color32); // fill with background color
X    *((volatile unsigned int *)((0xB000B000+0x24))) = color32; 
N
N    dest_pitch = GFX_WIDTH << 16; // pitch in pixels
N    outpw(REG_GE2D_SDPITCH, dest_pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = dest_pitch;
N
N    outpw(REG_GE2D_DSTSPA, 0); // starts from (0,0)
X    *((volatile unsigned int *)((0xB000B000+0x40))) = 0; 
N
N    dest_dimension = GFX_HEIGHT << 16 | GFX_WIDTH;
N    outpw(REG_GE2D_RTGLSZ, dest_dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dest_dimension;
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Set output data mask.
N  * @param[in] mask is mask value
N  * @return none
N  */
Nvoid ge2dSetWriteMask(int mask)
N{
N    outpw(REG_GE2D_WRPLNMSK, make_color(mask));
X    *((volatile unsigned int *)((0xB000B000+0x58))) = make_color(mask);
N}
N
N/**
N  * @brief Set source origin starting address.
N  * @param[in] ptr pointer of start address
N  * @return none
N  */
Nvoid ge2dSetSourceOriginStarting(void *ptr)
N{
N    outpw(REG_GE2D_XYSORG, (int)ptr);
X    *((volatile unsigned int *)((0xB000B000+0x04))) = (int)ptr;
N}
N
N/**
N  * @brief Set destination origin starting address.
N  * @param[in] ptr pointer of start address
N  * @return none
N  */
Nvoid ge2dSetDestinationOriginStarting(void *ptr)
N{
N    outpw(REG_GE2D_XYDORG, (int)ptr);
X    *((volatile unsigned int *)((0xB000B000+0x34))) = (int)ptr;
N}
N
N/**
N  * @brief Graphics engine initialization.
N  * @param[in] bpp bit per pixel
N  * @param[in] width is width of display memory
N  * @param[in] height is height of display memory
N  * @param[in] destination is pointer of destination buffer address
N  * @return none
N  */
Nvoid ge2dInit(int bpp, int width, int height, void *destination)
N{
N    UINT32 data32;
N
N    GFX_BPP = bpp;
N    GFX_WIDTH = width;
N    GFX_HEIGHT = height;
N    GFX_PITCH = (GFX_WIDTH*(GFX_BPP/8));
N    GFX_SIZE = (GFX_HEIGHT*GFX_PITCH);
N
N    if(destination == NULL)
X    if(destination == 0)
N        return;
N
N    Orig_GFX_START_ADDR = GFX_START_ADDR = (void *)destination;
N    if(GFX_Mem == 0)
N    {
N        /* Only allocate memory once. Avoid memory fragmentation if calling ge2DInit() and ge2dReset repeatedly */
N        Orig_GFX_PAT_ADDR = GFX_PAT_ADDR = (void *)malloc((8*8*(GFX_BPP/8))*2);
N        GFX_PAT_ADDR = (void *)shift_pointer((int)GFX_PAT_ADDR, (8*8*(GFX_BPP/8))*2);  // two times of boundary size
N
N
N        Orig_MONO_SOURCE_ADDR = MONO_SOURCE_ADDR = (void *)malloc(GFX_SIZE+32);
N        MONO_SOURCE_ADDR = (void *)shift_pointer((int)MONO_SOURCE_ADDR, 32);
N        Orig_COLOR_SOURCE_ADDR = COLOR_SOURCE_ADDR = (void *)malloc(GFX_SIZE+32);
N        COLOR_SOURCE_ADDR = (void *)shift_pointer((int)COLOR_SOURCE_ADDR, 32);
N        Orig_CMODEL_START_ADDR = CMODEL_START_ADDR = (void *)malloc(GFX_SIZE+32);
N        CMODEL_START_ADDR = (void *)shift_pointer((int)CMODEL_START_ADDR, 32);
N        Orig_GFX_OFFSCREEN_ADDR = GFX_OFFSCREEN_ADDR = (void *)malloc(GFX_SIZE+32);
N        GFX_OFFSCREEN_ADDR = (void *)shift_pointer((int)GFX_OFFSCREEN_ADDR, 32);
N        GFX_Mem = 1;
N    }
N#ifdef DEBUG
S    sysprintf("init_GE()\n");
S    sysprintf("screen width = %d\n", GFX_WIDTH);
S    sysprintf("screen height = %d\n", GFX_HEIGHT);
S    sysprintf("screen bpp = %d\n", GFX_BPP);
S    sysprintf("screen size = 0x%x\n", GFX_SIZE);
N#endif
N
N    outpw(REG_CLK_HCLKEN, inpw(REG_CLK_HCLKEN) | (1<<28));
X    *((volatile unsigned int *)((0xB0000200+0x10))) = (*((volatile unsigned int *)((0xB0000200+0x10)))) | (1<<28);
N
N    outpw(REG_GE2D_INTSTS, 0); // clear interrupt
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 0; 
N    outpw(REG_GE2D_PATSA, (unsigned int)GFX_PAT_ADDR);
X    *((volatile unsigned int *)((0xB000B000+0x14))) = (unsigned int)GFX_PAT_ADDR;
N    outpw(REG_GE2D_CTL, 0); // disable interrupt
X    *((volatile unsigned int *)((0xB000B000+0x20))) = 0; 
N    outpw(REG_GE2D_XYDORG, (unsigned int)GFX_START_ADDR);
X    *((volatile unsigned int *)((0xB000B000+0x34))) = (unsigned int)GFX_START_ADDR;
N    outpw(REG_GE2D_XYSORG, (unsigned int)GFX_START_ADDR);
X    *((volatile unsigned int *)((0xB000B000+0x04))) = (unsigned int)GFX_START_ADDR;
N
N    outpw(REG_GE2D_WRPLNMSK, 0x00ffffff); // write plane mask
X    *((volatile unsigned int *)((0xB000B000+0x58))) = 0x00ffffff; 
N
N    data32 = GE_BPP_8; // default is 8 bpp
X    data32 = 0x00000000; 
N
N    if (GFX_BPP==16) {
N        data32 |= GE_BPP_16;
X        data32 |= 0x00000010;
N    } else if (GFX_BPP==32) {
N        data32 |= GE_BPP_32;
X        data32 |= 0x00000020;
N    }
N
N    outpw(REG_GE2D_MISCTL, data32);
X    *((volatile unsigned int *)((0xB000B000+0x5C))) = data32;
N}
N
N/**
N  * @brief Reset graphics engine.
N  * @param none
N  * @return none
N  */
Nvoid ge2dReset(void)
N{
N    outpw(REG_GE2D_MISCTL, 0x40); // FIFO reset
X    *((volatile unsigned int *)((0xB000B000+0x5C))) = 0x40; 
N    outpw(REG_GE2D_MISCTL, 0x00);
X    *((volatile unsigned int *)((0xB000B000+0x5C))) = 0x00;
N
N    outpw(REG_GE2D_MISCTL, 0x80); // Engine reset
X    *((volatile unsigned int *)((0xB000B000+0x5C))) = 0x80; 
N    outpw(REG_GE2D_MISCTL, 0x00);
X    *((volatile unsigned int *)((0xB000B000+0x5C))) = 0x00;
N
N}
N
N/**
N  * @brief Reset FIFO of graphics engine.
N  * @param none
N  * @return none
N  */
Nvoid ge2dResetFIFO(void)
N{
N    UINT32 temp32;
N
N    temp32 = inpw(REG_GE2D_MISCTL);
X    temp32 = (*((volatile unsigned int *)((0xB000B000+0x5C))));
N    temp32 |= 0x00000040;
N    outpw(REG_GE2D_MISCTL, temp32);
X    *((volatile unsigned int *)((0xB000B000+0x5C))) = temp32;
N    temp32 &= 0xffffffbf;
N    outpw(REG_GE2D_MISCTL, temp32);
X    *((volatile unsigned int *)((0xB000B000+0x5C))) = temp32;
N}
N
N/**
N  * @brief Set BitBlt drawing mode.
N  * @param[in] opt is drawing mode
N  * @param[in] ckey is value of color key
N  * @param[in] mask is value of color mask
N  * @return none
N  */
Nvoid ge2dBitblt_SetDrawMode(int opt, int ckey, int mask)
N{
N    if (opt==MODE_TRANSPARENT) {
X    if (opt==1) {
N        _DrawMode = MODE_TRANSPARENT;
X        _DrawMode = 1;
N
N        _ColorKey = make_color(ckey);
N        _ColorKeyMask = make_color(mask);
N
N        outpw(REG_GE2D_TRNSCOLR, _ColorKey);
X        *((volatile unsigned int *)((0xB000B000+0x2C))) = _ColorKey;
N        outpw(REG_GE2D_TCMSK, _ColorKeyMask);
X        *((volatile unsigned int *)((0xB000B000+0x30))) = _ColorKeyMask;
N    } else if (opt==MODE_DEST_TRANSPARENT) {
X    } else if (opt==2) {
N        _DrawMode = MODE_DEST_TRANSPARENT;
X        _DrawMode = 2;
N
N        _ColorKey = make_color(ckey);
N        _ColorKeyMask = make_color(mask);
N
N        outpw(REG_GE2D_TRNSCOLR, _ColorKey);
X        *((volatile unsigned int *)((0xB000B000+0x2C))) = _ColorKey;
N        outpw(REG_GE2D_TCMSK, _ColorKeyMask);
X        *((volatile unsigned int *)((0xB000B000+0x30))) = _ColorKeyMask;
N    } else {
N        _DrawMode = MODE_OPAQUE; // default is OPAQUE
X        _DrawMode = 0; 
N    }
N}
N
N/**
N  * @brief Set alpha blending programming.
N  * @param[in] opt is selection for enable or disable
N  * @param[in] ks is value of alpha blending factor Ks
N  * @param[in] kd is value of alpha blending factor Kd
N  * @return none
N  */
Nint ge2dBitblt_SetAlphaMode(int opt, int ks, int kd)
N{
N    if (ks + kd > 255)
N        return -1;
N
N    if (opt==1) {
N        _EnableAlpha = TRUE;
X        _EnableAlpha = (1);
N        _AlphaKs = ks;
N        _AlphaKd = kd;
N    } else {
N        _EnableAlpha = FALSE;
X        _EnableAlpha = (0);
N    }
N
N    return 0;
N}
N
N/**
N  * @brief Screen-to-Screen BitBlt with SRCCOPY ROP operation.
N  * @param[in] srcx is source x position
N  * @param[in] srcy is source y position
N  * @param[in] destx is destination x position
N  * @param[in] desty is destination y position
N  * @param[in] width is display width
N  * @param[in] height is display width
N  * @return none
N  */
Nvoid ge2dBitblt_ScreenToScreen(int srcx, int srcy, int destx, int desty, int width, int height)
N{
N    UINT32 cmd32, pitch, dest_start, src_start, dimension;
N    UINT32 data32, alpha;
N
N#ifdef DEBUG
S    sysprintf("screen_to_screen_blt():\n");
S    sysprintf("(%d,%d)=>(%d,%d)\n", srcx, srcy, destx, desty);
S    sysprintf("width=%d height=%d\n", width, height);
N#endif
N
N    cmd32 = 0xcc430000;
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    if (srcx > destx) { //+X
N        if (srcy > desty) { //+Y
N        } else { //-Y
N            cmd32 |= 0x08;
N            srcy = srcy + height - 1;
N            desty = desty + height - 1;
N        }
N    } else { //-X
N        if (srcy > desty) { //+Y
N            cmd32 |= 0x04; // 010
N            srcx = srcx + width - 1;
N            destx = destx + width - 1;
N        } else { //-Y
N            cmd32 |= 0xc; // 110
N            srcx = srcx + width - 1;
N            destx = destx + width - 1;
N            srcy = srcy + height - 1;
N            desty = desty + height - 1;
N        }
N    }
N
N#ifdef DEBUG
S    sysprintf("new srcx=%d srcy=%d\n", srcx, srcy);
S    sysprintf("new destx=%d desty=%d\n", destx, desty);
N#endif
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    pitch = GFX_WIDTH << 16 | GFX_WIDTH;
N    outpw(REG_GE2D_SDPITCH, pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = pitch;
N
N    src_start = srcy << 16 | srcx;
N    outpw(REG_GE2D_SRCSPA, src_start);
X    *((volatile unsigned int *)((0xB000B000+0x3C))) = src_start;
N
N    dest_start = desty << 16 | destx;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dimension;
N
N    //
N    // force to use the same starting address
N    //
N    outpw(REG_GE2D_XYSORG, (int)GFX_START_ADDR);
X    *((volatile unsigned int *)((0xB000B000+0x04))) = (int)GFX_START_ADDR;
N    outpw(REG_GE2D_XYDORG, (int)GFX_START_ADDR);  //smf
X    *((volatile unsigned int *)((0xB000B000+0x34))) = (int)GFX_START_ADDR;  
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    if (_DrawMode==MODE_TRANSPARENT) {
X    if (_DrawMode==1) {
N        cmd32 |= 0x00008000; // color transparency
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_TRNSCOLR, _ColorKey);
X        *((volatile unsigned int *)((0xB000B000+0x2C))) = _ColorKey;
N        outpw(REG_GE2D_TCMSK, _ColorKeyMask);
X        *((volatile unsigned int *)((0xB000B000+0x30))) = _ColorKeyMask;
N    } else if (_DrawMode==MODE_DEST_TRANSPARENT) {
X    } else if (_DrawMode==2) {
N        cmd32 |= 0x00009000;   // destination pixels control transparency
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_TRNSCOLR, _ColorKey);
X        *((volatile unsigned int *)((0xB000B000+0x2C))) = _ColorKey;
N        outpw(REG_GE2D_TCMSK, _ColorKeyMask);
X        *((volatile unsigned int *)((0xB000B000+0x30))) = _ColorKeyMask;
N    }
N
N    if (_EnableAlpha) {
N        cmd32 |= 0x00200000;
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N        data32 = inpw(REG_GE2D_MISCTL) & 0x0000ffff;
X        data32 = (*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x0000ffff;
N        alpha = (UINT32)((_AlphaKs << 8) | _AlphaKd);
N        data32 |= (alpha << 16);
N
N        outpw(REG_GE2D_MISCTL, data32);
X        *((volatile unsigned int *)((0xB000B000+0x5C))) = data32;
N    }
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Screen-to-Screen BitBlt with ROP option.
N  * @param[in] srcx is source x position
N  * @param[in] srcy is source y position
N  * @param[in] destx is destination x position
N  * @param[in] desty is destination y position
N  * @param[in] width is display width
N  * @param[in] height is display width
N  * @param[in] rop is rop option
N  * @return none
N  */
Nvoid ge2dBitblt_ScreenToScreenRop(int srcx, int srcy, int destx, int desty, int width, int height, int rop)
N{
N    UINT32 cmd32, pitch, dest_start, src_start, dimension;
N    UINT32 data32, alpha;
N
N#ifdef DEBUG
S    sysprintf("screen_to_screen_rop_blt():\n");
S    sysprintf("ROP=0x%x\n", rop);
S    sysprintf("(%d,%d)=>(%d,%d)\n", srcx, srcy, destx, desty);
S    sysprintf("width=%d height=%d\n", width, height);
N#endif
N
N    cmd32 = 0x00430000 | (rop << 24);
N
N    if (_PatternType==TYPE_MONO) {
X    if (_PatternType==0) {
N        cmd32 |= 0x00000010; // default is TYPE_COLOR
N    }
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    if (srcx > destx) { //+X
N        if (srcy > desty) { //+Y
N        } else { //-Y
N            cmd32 |= 0x08;
N            srcy = srcy + height - 1;
N            desty = desty + height - 1;
N        }
N    } else { //-X
N        if (srcy > desty) { //+Y
N            cmd32 |= 0x04; // 010
N            srcx = srcx + width - 1;
N            destx = destx + width - 1;
N        } else { //-Y
N            cmd32 |= 0xc; // 110
N            srcx = srcx + width - 1;
N            destx = destx + width - 1;
N            srcy = srcy + height - 1;
N            desty = desty + height - 1;
N        }
N    }
N
N#ifdef DEBUG
S    sysprintf("new srcx=%d srcy=%d\n", srcx, srcy);
S    sysprintf("new destx=%d desty=%d\n", destx, desty);
N#endif
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    pitch = GFX_WIDTH << 16 | GFX_WIDTH; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = pitch;
N
N    src_start = srcy << 16 | srcx;
N    outpw(REG_GE2D_SRCSPA, src_start);
X    *((volatile unsigned int *)((0xB000B000+0x3C))) = src_start;
N
N    dest_start = desty << 16 | destx;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dimension;
N
N    //
N    // force to use the same starting address
N    //
N    outpw(REG_GE2D_XYSORG, (int)GFX_START_ADDR);
X    *((volatile unsigned int *)((0xB000B000+0x04))) = (int)GFX_START_ADDR;
N    outpw(REG_GE2D_XYDORG, (int)GFX_START_ADDR);  //smf
X    *((volatile unsigned int *)((0xB000B000+0x34))) = (int)GFX_START_ADDR;  
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    if (_DrawMode==MODE_TRANSPARENT) {
X    if (_DrawMode==1) {
N        cmd32 |= 0x00008000; // color transparency
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_TRNSCOLR, _ColorKey);
X        *((volatile unsigned int *)((0xB000B000+0x2C))) = _ColorKey;
N        outpw(REG_GE2D_TCMSK, _ColorKeyMask);
X        *((volatile unsigned int *)((0xB000B000+0x30))) = _ColorKeyMask;
N    } else if (_DrawMode==MODE_DEST_TRANSPARENT) {
X    } else if (_DrawMode==2) {
N        cmd32 |= 0x00009000;
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_TRNSCOLR, _ColorKey);
X        *((volatile unsigned int *)((0xB000B000+0x2C))) = _ColorKey;
N        outpw(REG_GE2D_TCMSK, _ColorKeyMask);
X        *((volatile unsigned int *)((0xB000B000+0x30))) = _ColorKeyMask;
N    }
N
N    if (_EnableAlpha) {
N        cmd32 |= 0x00200000;
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N        data32 = inpw(REG_GE2D_MISCTL) & 0x0000ffff;
X        data32 = (*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x0000ffff;
N        alpha = (UINT32)((_AlphaKs << 8) | _AlphaKd);
N        data32 |= (alpha << 16);
N
N        outpw(REG_GE2D_MISCTL, data32);
X        *((volatile unsigned int *)((0xB000B000+0x5C))) = data32;
N    }
N
N    if ((rop==0x00) || (rop==0xff)) {
N        cmd32 = (cmd32 & 0xffff0fff) | 0x00009000;
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N    }
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Source to destination BitBlt with SRCCOPY ROP operation.
N  * @param[in] srcx is source x position
N  * @param[in] srcy is source y position
N  * @param[in] destx is destination x position
N  * @param[in] desty is destination y position
N  * @param[in] width is display width
N  * @param[in] height is display width
N  * @param[in] srcpitch is source pixel pitch
N  * @param[in] destpitch is destination pixel pitch
N  * @return none
N  * @note before calling this function, it would set the source and destination origin starting place
N  */
Nvoid ge2dBitblt_SourceToDestination(int srcx, int srcy, int destx, int desty, int width, int height, int srcpitch, int destpitch)
N{
N    UINT32 cmd32, pitch, dest_start, src_start, dimension;
N    UINT32 data32, alpha;
N
N#ifdef DEBUG
S    sysprintf("source_to_destination_blt():\n");
S    sysprintf("(%d,%d)=>(%d,%d)\n", srcx, srcy, destx, desty);
S    sysprintf("width=%d height=%d\n", width, height);
N#endif
N
N    cmd32 = 0xcc430000;
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    if (srcx > destx) { //+X
N        if (srcy > desty) { //+Y
N        } else { //-Y
N            cmd32 |= 0x08;
N            srcy = srcy + height - 1;
N            desty = desty + height - 1;
N        }
N    } else { //-X
N        if (srcy > desty) { //+Y
N            cmd32 |= 0x04; // 010
N            srcx = srcx + width - 1;
N            destx = destx + width - 1;
N        } else { //-Y
N            cmd32 |= 0xc; // 110
N            srcx = srcx + width - 1;
N            destx = destx + width - 1;
N            srcy = srcy + height - 1;
N            desty = desty + height - 1;
N        }
N    }
N
N#ifdef DEBUG
S    sysprintf("new srcx=%d srcy=%d\n", srcx, srcy);
S    sysprintf("new destx=%d desty=%d\n", destx, desty);
N#endif
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    pitch = destpitch << 16 | srcpitch; // pitch in pixel, back | GFX_WIDTH ??
N    outpw(REG_GE2D_SDPITCH, pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = pitch;
N
N    src_start = srcy << 16 | srcx;
N    outpw(REG_GE2D_SRCSPA, src_start);
X    *((volatile unsigned int *)((0xB000B000+0x3C))) = src_start;
N
N    dest_start = desty << 16 | destx;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dimension;
N
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    if (_DrawMode==MODE_TRANSPARENT) {
X    if (_DrawMode==1) {
N        cmd32 |= 0x00008000; // color transparency
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_TRNSCOLR, _ColorKey);
X        *((volatile unsigned int *)((0xB000B000+0x2C))) = _ColorKey;
N        outpw(REG_GE2D_TCMSK, _ColorKeyMask);
X        *((volatile unsigned int *)((0xB000B000+0x30))) = _ColorKeyMask;
N    } else if (_DrawMode==MODE_DEST_TRANSPARENT) {
X    } else if (_DrawMode==2) {
N        cmd32 |= 0x00009000;   // destination pixels control transparency
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_TRNSCOLR, _ColorKey);
X        *((volatile unsigned int *)((0xB000B000+0x2C))) = _ColorKey;
N        outpw(REG_GE2D_TCMSK, _ColorKeyMask);
X        *((volatile unsigned int *)((0xB000B000+0x30))) = _ColorKeyMask;
N    }
N
N    if (_EnableAlpha) {
N        cmd32 |= 0x00200000;
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N        data32 = inpw(REG_GE2D_MISCTL) & 0x0000ffff;
X        data32 = (*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x0000ffff;
N        alpha = (UINT32)((_AlphaKs << 8) | _AlphaKd);
N        data32 |= (alpha << 16);
N
N        outpw(REG_GE2D_MISCTL, data32);
X        *((volatile unsigned int *)((0xB000B000+0x5C))) = data32;
N    }
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Set the clip rectangle. (top-left to down-right).
N  * @param[in] x1 is top-left x position
N  * @param[in] y1 is top-left y position
N  * @param[in] x2 is down-right x position
N  * @param[in] y2 is down-right y position
N  * @return none
N  */
Nvoid ge2dClip_SetClip(int x1, int y1, int x2, int y2)
N{
N
N#ifdef DEBUG
S    sysprintf("set_clip(): (%d,%d)-(%d,%d)\n", x1, y1, x2, y2);
N#endif
N
N    if ((x1>=0) && (y1>=0) && (x2>=0) && (y2>=0)) {
N        if ((x2 > x1) && (y2 > y1)) {
N            _ClipEnable = TRUE;
X            _ClipEnable = (1);
N            /* hardware clipper not includes last pixel */
N            x2++;
N            y2++;
N            _ClipTL = (UINT32)((y1 << 16) | x1);
N            _ClipBR = (UINT32)((y2 << 16) | x2);
N        } else {
N            _ClipEnable = FALSE;
X            _ClipEnable = (0);
N        }
N    } else {
N        _ClipEnable = FALSE;
X        _ClipEnable = (0);
N    }
N}
N
N/**
N  * @brief Set the clip to inside clip or outside clip.
N  * @param[in] opt is option for setting clip inside or outside, value could be
N  *                                 - \ref MODE_INSIDE_CLIP
N  *                                 - \ref MODE_OUTSIDE_CLIP
N  * @return none
N  */
Nvoid ge2dClip_SetClipMode(int opt)
N{
N    _OutsideClip = (opt==0) ? FALSE : TRUE;
X    _OutsideClip = (opt==0) ? (0) : (1);
N
N    if (_OutsideClip) {
N#ifdef DEBUG
S        sysprintf("set_clip_mode(): OUTSIDE\n");
N#endif
N    } else {
N#ifdef DEBUG
S        sysprintf("set_clip_mode(): INSIDE\n");
N#endif
N    }
N}
N
N/**
N  * @brief Draw an one-pixel rectangle frame.
N  * @param[in] x1 is top-left x position
N  * @param[in] y1 is top-left y position
N  * @param[in] x2 is down-right x position
N  * @param[in] y2 is down-right y position
N  * @param[in] color is color of this rectangle
N  * @param[in] opt is draw option, value could be
N  *                                - 0: rectangle
N  *                                - 1: diagonal
N  * @return none
N  */
Nvoid ge2dDrawFrame(int x1, int y1, int x2, int y2, int color, int opt)
N{
N    UINT32 dest_pitch, dest_start, dest_dimension;
N    UINT32 color32;
N
N#ifdef DEBUG
S    sysprintf("draw_frame():\n");
S    sysprintf("(%d,%d)-(%d,%d)\n", x1, y1, x2, y2);
S    sysprintf("color=0x%x opt=%d\n", color, opt);
N#endif
N
N    /*
N    ** The opt==1 case must be specially handled.
N    */
N
N    if (opt==0) {
N        outpw(REG_GE2D_CTL, 0xcccb0000); // rectangle
X        *((volatile unsigned int *)((0xB000B000+0x20))) = 0xcccb0000; 
N    } else {
N        outpw(REG_GE2D_CTL, 0xcccf0000); // diagonal
X        *((volatile unsigned int *)((0xB000B000+0x20))) = 0xcccf0000; 
N    }
N
N#ifdef DEBUG
S    sysprintf("(%d,%d)-(%d,%d)\n", x1, y1, x2, y2);
N#endif
N
N    color32 = make_color(color);
N    outpw(REG_GE2D_FGCOLR, color32);
X    *((volatile unsigned int *)((0xB000B000+0x28))) = color32;
N
N    dest_pitch = GFX_WIDTH << 16; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, dest_pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = dest_pitch;
N
N    dest_start = y1 << 16 | x1;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dest_dimension = (y2-y1) << 16 | (x2-x1);
N    outpw(REG_GE2D_RTGLSZ, dest_dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dest_dimension;
N
N    outpw(REG_GE2D_MISCTL, inpw(REG_GE2D_MISCTL)); // address caculation
X    *((volatile unsigned int *)((0xB000B000+0x5C))) = (*((volatile unsigned int *)((0xB000B000+0x5C)))); 
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Draw an solid rectangle line.
N  * @param[in] x1 is top-left x position
N  * @param[in] y1 is top-left y position
N  * @param[in] x2 is down-right x position
N  * @param[in] y2 is down-right y position
N  * @param[in] color is color of this line
N  * @return none
N  */
Nvoid ge2dLine_DrawSolidLine(int x1, int y1, int x2, int y2, int color)
N{
N    int abs_X, abs_Y, min, max;
N    UINT32 step_constant, initial_error, direction_code;
N    UINT32 cmd32, dest_pitch, dest_start;
N
N#ifdef DEBUG
S    sysprintf("draw_solid_line():\n");
S    sysprintf("(%d,%d)-(%d,%d)\n", x1, y1, x2, y2);
S    sysprintf("color=0x%x\n", color);
N#endif
N
N    abs_X = ABS(x2-x1);   //absolute value
X    abs_X = (((x2-x1)>0)?(x2-x1):-(x2-x1));   
N    abs_Y = ABS(y2-y1);   //absolute value
X    abs_Y = (((y2-y1)>0)?(y2-y1):-(y2-y1));   
N    if (abs_X > abs_Y) {  // X major
N        max = abs_X;
N        min = abs_Y;
N
N        step_constant = (((UINT32)(2*(min-max))) << 16) | (UINT32)(2*min);
N        initial_error = (((UINT32)(2*(min)-max)) << 16) | (UINT32)(max);
N
N        if (x2 > x1) { // +X direction
N            if (y2 > y1) // +Y direction
N                direction_code = XpYpXl;
X                direction_code = (0<<1);
N            else // -Y direction
N                direction_code = XpYmXl;
X                direction_code = (2<<1);
N        } else { // -X direction
N            if (y2 > y1) // +Y direction
N                direction_code = XmYpXl;
X                direction_code = (4<<1);
N            else // -Y direction
N                direction_code = XmYmXl;
X                direction_code = (6<<1);
N        }
N    } else { // Y major
N        max = abs_Y;
N        min = abs_X;
N
N        step_constant = (((UINT32)(2*(min-max))) << 16) | (UINT32)(2*min);
N        initial_error = (((UINT32)(2*(min)-max)) << 16) | (UINT32)(max);
N
N        if (x2 > x1) { // +X direction
N            if (y2 > y1) // +Y direction
N                direction_code = XpYpYl;
X                direction_code = (1<<1);
N            else // -Y direction
N                direction_code = XpYmYl;
X                direction_code = (3<<1);
N        } else { // -X direction
N            if (y2 > y1) // +Y direction
N                direction_code = XmYpYl;
X                direction_code = (5<<1);
N            else // -Y direction
N                direction_code = XmYmYl;
X                direction_code = (7<<1);
N        }
N    }
N
N    outpw(REG_GE2D_BETSC, step_constant);
X    *((volatile unsigned int *)((0xB000B000+0x18))) = step_constant;
N    outpw(REG_GE2D_BIEPC, initial_error);
X    *((volatile unsigned int *)((0xB000B000+0x1C))) = initial_error;
N
N    cmd32 = 0x008b0000 | direction_code;
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    outpw(REG_GE2D_BGCOLR, make_color(color));
X    *((volatile unsigned int *)((0xB000B000+0x24))) = make_color(color);
N    outpw(REG_GE2D_FGCOLR, make_color(color));
X    *((volatile unsigned int *)((0xB000B000+0x28))) = make_color(color);
N
N    dest_pitch = GFX_WIDTH << 16; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, dest_pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = dest_pitch;
N
N    outpw(REG_GE2D_XYDORG, (int)GFX_START_ADDR);
X    *((volatile unsigned int *)((0xB000B000+0x34))) = (int)GFX_START_ADDR;
N
N    dest_start = y1 << 16 | x1;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Draw a styled line.
N  * @param[in] x1 is top-left x position
N  * @param[in] y1 is top-left y position
N  * @param[in] x2 is down-right x position
N  * @param[in] y2 is down-right y position
N  * @param[in] style is style of line pattern
N  * @param[in] fgcolor is color of foreground
N  * @param[in] bkcolor is color of background
N  * @param[in] draw_mode is transparent is enable or not
N  * @return none
N  */
Nvoid ge2dLine_DrawStyledLine(int x1, int y1, int x2, int y2, int style, int fgcolor, int bkcolor, int draw_mode)
N{
N    int abs_X, abs_Y, min, max;
N    UINT32 step_constant, initial_error, direction_code;
N    UINT32 cmd32, dest_pitch, dest_start;
N    UINT32 temp32, line_control_code;
N
N    abs_X = ABS(x2-x1);
X    abs_X = (((x2-x1)>0)?(x2-x1):-(x2-x1));
N    abs_Y = ABS(y2-y1);
X    abs_Y = (((y2-y1)>0)?(y2-y1):-(y2-y1));
N    if (abs_X > abs_Y) { // X major
N        max = abs_X;
N        min = abs_Y;
N
N        step_constant = (((UINT32)(2*(min-max))) << 16) | (UINT32)(2*min);
N        initial_error = (((UINT32)(2*min-max)) << 16) | (UINT32)(max);
N
N        if (x2 > x1) { // +X direction
N            if (y2 > y1) // +Y direction
N                direction_code = XpYpXl;
X                direction_code = (0<<1);
N            else // -Y direction
N                direction_code = XpYmXl;
X                direction_code = (2<<1);
N        } else { // -X direction
N            if (y2 > y1) // +Y direction
N                direction_code = XmYpXl;
X                direction_code = (4<<1);
N            else // -Y direction
N                direction_code = XmYmXl;
X                direction_code = (6<<1);
N        }
N    } else { // Y major
N        max = abs_Y;
N        min = abs_X;
N
N        step_constant = (((UINT32)(2*(min-max))) << 16) | (UINT32)(2*min);
N        initial_error = (((UINT32)(2*min-max)) << 16) | (UINT32)(max);
N
N        if (x2 > x1) { // +X direction
N            if (y2 > y1) // +Y direction
N                direction_code = XpYpYl;
X                direction_code = (1<<1);
N            else // -Y direction
N                direction_code = XpYmYl;
X                direction_code = (3<<1);
N        } else { // -X direction
N            if (y2 > y1) // +Y direction
N                direction_code = XmYpYl;
X                direction_code = (5<<1);
N            else // -Y direction
N                direction_code = XmYmYl;
X                direction_code = (7<<1);
N        }
N    }
N
N    outpw(REG_GE2D_BETSC, step_constant);
X    *((volatile unsigned int *)((0xB000B000+0x18))) = step_constant;
N    outpw(REG_GE2D_BIEPC, initial_error);
X    *((volatile unsigned int *)((0xB000B000+0x1C))) = initial_error;
N
N    cmd32 = 0x009b0000 | direction_code; // styled line
N    if (draw_mode==MODE_TRANSPARENT) {
X    if (draw_mode==1) {
N        cmd32 |= 0x00008000; // default is MODE_OPAQUE
N    }
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    outpw(REG_GE2D_BGCOLR, make_color(bkcolor));
X    *((volatile unsigned int *)((0xB000B000+0x24))) = make_color(bkcolor);
N    outpw(REG_GE2D_FGCOLR, make_color(fgcolor));
X    *((volatile unsigned int *)((0xB000B000+0x28))) = make_color(fgcolor);
N
N    dest_pitch = GFX_WIDTH << 16; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, dest_pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = dest_pitch;
N
N    outpw(REG_GE2D_XYDORG, (int)GFX_START_ADDR);
X    *((volatile unsigned int *)((0xB000B000+0x34))) = (int)GFX_START_ADDR;
N
N    dest_start = y1 << 16 | x1;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    line_control_code = style;
N    temp32 = inpw(REG_GE2D_MISCTL) & 0x0000ffff;
X    temp32 = (*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x0000ffff;
N    temp32 = (line_control_code << 16) | temp32;
N
N    outpw(REG_GE2D_MISCTL, temp32); // address caculation
X    *((volatile unsigned int *)((0xB000B000+0x5C))) = temp32; 
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Rectangle solid color fill with foreground color.
N  * @param[in] dx x position
N  * @param[in] dy y position
N  * @param[in] width is display width
N  * @param[in] height is display height
N  * @param[in] color is color of foreground
N  * @return none
N  */
Nvoid ge2dFill_Solid(int dx, int dy, int width, int height, int color)
N{
N    UINT32 cmd32, color32;
N    UINT32 dest_start, dest_pitch, dest_dimension;
N
N#ifdef DEBUG
S    sysprintf("solid_fill()\n");
S    sysprintf("(%d,%d)-(%d,%d)\n", dx, dy, dx+width-1, dy+height-1);
S    sysprintf("color=0x%x\n", color);
N#endif
N
N    color32 = make_color(color);
N    cmd32 = 0xcc430060;
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N    outpw(REG_GE2D_FGCOLR, color32); // fill with foreground color
X    *((volatile unsigned int *)((0xB000B000+0x28))) = color32; 
N
N    dest_pitch = GFX_WIDTH << 16; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, dest_pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = dest_pitch;
N
N    dest_start = dy << 16 | dx;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dest_dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dest_dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dest_dimension;
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Rectangle solid color fill with RGB565 foreground color.
N  * @param[in] dx x position
N  * @param[in] dy y position
N  * @param[in] width is display width
N  * @param[in] height is display height
N  * @param[in] color is RGB565 color of foreground
N  * @return none
N  */
Nvoid ge2dFill_Solid_RGB565(int dx, int dy, int width, int height, int color)
N{
N    UINT32 cmd32;
N    UINT32 dest_start, dest_pitch, dest_dimension;
N
N#ifdef DEBUG
S    sysprintf("solid_fill()\n");
S    sysprintf("(%d,%d)-(%d,%d)\n", dx, dy, dx+width-1, dy+height-1);
S    sysprintf("color=0x%x\n", color);
N#endif
N
N    cmd32 = 0xcc430060;
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N    outpw(REG_GE2D_FGCOLR, color); // fill with foreground color
X    *((volatile unsigned int *)((0xB000B000+0x28))) = color; 
N
N    dest_pitch = GFX_WIDTH << 16; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, dest_pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = dest_pitch;
N
N    dest_start = dy << 16 | dx;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dest_dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dest_dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dest_dimension;
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Rectangle solid color fill with background color.
N  * @param[in] dx x position
N  * @param[in] dy y position
N  * @param[in] width is display width
N  * @param[in] height is display height
N  * @param[in] color is color of background
N  * @return none
N  */
Nvoid ge2dFill_SolidBackground(int dx, int dy, int width, int height, int color)
N{
N    UINT32 cmd32, color32;
N    UINT32 dest_start, dest_pitch, dest_dimension;
N
N#ifdef DEBUG
S    sysprintf("solid_fill_back()\n");
S    sysprintf("(%d,%d)-(%d,%d)\n", dx, dy, dx+width-1,dy+height-1);
S    sysprintf("color=0x%x\n", color);
N#endif
N
N    color32 = make_color(color);
N
N    cmd32 = 0xcc430040;
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N    outpw(REG_GE2D_BGCOLR, color32); // fill with foreground color
X    *((volatile unsigned int *)((0xB000B000+0x24))) = color32; 
N
N    dest_pitch = GFX_WIDTH << 16; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, dest_pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = dest_pitch;
N
N    dest_start = dy << 16 | dx;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dest_dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dest_dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dest_dimension;
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Rectangle fill with 8x8 color pattern.
N  * @param[in] dx x position
N  * @param[in] dy y position
N  * @param[in] width is display width
N  * @param[in] height is display height
N  * @return none
N  * @note The color pattern data is stored in the off-screen buffer.
N  */
Nvoid ge2dFill_ColorPattern(int dx, int dy, int width, int height)
N{
N    UINT32 cmd32;
N    UINT32 dest_start, dest_pitch, dest_dimension;
N
N#ifdef DEBUG
S    sysprintf("color_pattern_fill()\n");
S    sysprintf("(%d,%d)-(%d,%d)\n", dx, dy, dx+width-1, dy+height-1);
S    sysprintf("pattern offset (%d,%d)\n", dx%8, dy%8);
N#endif
N
N    cmd32 = 0xf0430000;
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    dest_pitch = GFX_WIDTH << 16; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, dest_pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = dest_pitch;
N
N    dest_start = dy << 16 | dx;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dest_dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dest_dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dest_dimension;
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Rectangle fill with 8x8 mono pattern.
N  * @param[in] dx x position
N  * @param[in] dy y position
N  * @param[in] width is display width
N  * @param[in] height is display height
N  * @param[in] opt is transparent is enable or not
N  * @return none
N  */
Nvoid ge2dFill_MonoPattern(int dx, int dy, int width, int height, int opt)
N{
N    UINT32 cmd32;
N    UINT32 dest_start, dest_pitch, dest_dimension;
N
N#ifdef DEBUG
S    sysprintf("mono_pattern_fill()\n");
S    sysprintf("(%d,%d)-(%d,%d)\n", dx, dy, dx+width-1, dy+height-1);
N#endif
N
N    cmd32 = 0xf0430010;
N    if (opt==MODE_TRANSPARENT) {
X    if (opt==1) {
N        cmd32 |= 0x00006000;
N    }
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    dest_pitch = GFX_WIDTH << 16; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, dest_pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = dest_pitch;
N
N    dest_start = dy << 16 | dx;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dest_dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dest_dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dest_dimension;
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Rectangle fill with 8x8 color pattern.
N  * @param[in] sx x position
N  * @param[in] sy y position
N  * @param[in] width is display width
N  * @param[in] height is display height
N  * @param[in] rop is ROP operation code
N  * @return none
N  */
Nvoid ge2dFill_ColorPatternROP(int sx, int sy, int width, int height, int rop)
N{
N    UINT32 cmd32;
N    UINT32 dest_start, dest_pitch, dest_dimension;
N
N#ifdef DEBUG
S    sysprintf("color_pattern_fill()\n");
S    sysprintf("(%d,%d)-(%d,%d)\n", sx, sy, sx+width-1, sy+height-1);
S    sysprintf("pattern offset (%d,%d)\n", sx%8, sy%8);
N#endif
N
N    cmd32 = 0x00430000 | (rop<<24);
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    dest_pitch = GFX_WIDTH << 16; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, dest_pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = dest_pitch;
N
N    dest_start = sy << 16 | sx;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dest_dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dest_dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dest_dimension;
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Rectangle fill with 8x8 mono pattern.
N  * @param[in] sx x position
N  * @param[in] sy y position
N  * @param[in] width is display width
N  * @param[in] height is display height
N  * @param[in] opt is transparent is enable or not
N  * @param[in] rop is ROP operation code
N  * @return none
N  */
Nvoid ge2dFill_MonoPatternROP(int sx, int sy, int width, int height, int rop, int opt)
N{
N    UINT32 cmd32;
N    UINT32 dest_start, dest_pitch, dest_dimension;
N
N#ifdef DEBUG
S    sysprintf("mono_pattern_fill()\n");
S    sysprintf("(%d,%d)-(%d,%d)\n", sx, sy, sx+width-1, sy+height-1);
N#endif
N
N    cmd32 = 0x00430010 | (rop<<24);
N    if (opt==MODE_TRANSPARENT) {
X    if (opt==1) {
N        cmd32 |= 0x00006000;
N    }
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    dest_pitch = GFX_WIDTH << 16; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, dest_pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = dest_pitch;
N
N    dest_start = sy << 16 | sx;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dest_dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dest_dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dest_dimension;
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief TileBLT function.
N  * @param[in] srcx source x position
N  * @param[in] srcy source y position
N  * @param[in] destx destination x position
N  * @param[in] desty destination y position
N  * @param[in] width is display width
N  * @param[in] height is display height
N  * @param[in] x_count is tile count for x-axis
N  * @param[in] y_count is tile count for y-axis
N  * @return none
N  */
Nvoid ge2dFill_TileBlt(int srcx, int srcy, int destx, int desty, int width, int height, int x_count, int y_count)
N{
N    UINT32 cmd32, pitch, dest_start, src_start, dimension;
N    UINT32 tile_ctl;
N
N#ifdef DEBUG
S    sysprintf("tile_blt_image()\n");
S    sysprintf("(%d,%d)=>(%d,%d)\n", srcx, srcy, destx, desty);
S    sysprintf("width=%d height=%d\n", width, height);
S    sysprintf("%dx%d grids\n", x_count, y_count);
N#endif
N
N    if (x_count > 0) x_count--;
N    if (y_count > 0) y_count--;
N
N    cmd32 = 0xcc430400; // b10 is the tile control
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    pitch = GFX_WIDTH << 16 | GFX_WIDTH; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = pitch;
N
N    src_start = srcy << 16 | srcx;           // redundancy ??
N    outpw(REG_GE2D_SRCSPA, src_start);  // redundancy ??
X    *((volatile unsigned int *)((0xB000B000+0x3C))) = src_start;  
N
N    dest_start = desty << 16 | destx;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dimension;
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    tile_ctl = (y_count << 8) | (x_count);
N    outpw(REG_GE2D_TCNTVHSF, tile_ctl);
X    *((volatile unsigned int *)((0xB000B000+0x08))) = tile_ctl;
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Host-to-Screen BitBlt with SRCCOPY (through data port)
N  * @param[in] x x position
N  * @param[in] y y position
N  * @param[in] width is display width
N  * @param[in] height is display height
N  * @param[in] buf is pointer of HostBLT data
N  * @return none
N  */
Nvoid ge2dHostBlt_Write(int x, int y, int width, int height, void *buf)
N{
N    UINT32 cmd32, dest_pitch, dest_start, dest_dimension;
N    int transfer_count, i, j;
N    UINT32 *ptr32, data32;
N
N#ifdef DEBUG
S    sysprintf("host_write_blt()\n");
S    sysprintf("(%d,%d)-(%d,%d)\n", x, y, x+width-1, y+height-1);
S    sysprintf("width=%d height=%d\n", width, height);
N#endif
N
N    cmd32 = 0xcc430020;
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    dest_pitch = GFX_WIDTH << 16; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, dest_pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = dest_pitch;
N
N    dest_start = y << 16 | x;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dest_dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dest_dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dest_dimension;
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N
N    ptr32 = (UINT32 *)buf;
N    for (i=0; i<height; i++) { // 120
N        transfer_count = (width * (GFX_BPP/8) + 3) / 4; // 4-byte count
N
N        while (transfer_count >= 8) {
N            while ((inpw(REG_GE2D_MISCTL) & 0x00000800)==0); // check empty
X            while (((*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x00000800)==0); 
N            for (j=0; j<8; j++) {
N                data32 = *ptr32++;
N                outpw(REG_GE2D_GEHBDW0, data32);
X                *((volatile unsigned int *)((0xB000B000+0x60))) = data32;
N            }
N            transfer_count -= 8;
N        }
N
N        if (transfer_count > 0) {
N            while ((inpw(REG_GE2D_MISCTL) & 0x00000800)==0); // check empty
X            while (((*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x00000800)==0); 
N            for (j=0; j<transfer_count; j++) {
N                data32 = *ptr32++;
N                outpw(REG_GE2D_GEHBDW0, data32);
X                *((volatile unsigned int *)((0xB000B000+0x60))) = data32;
N            }
N        }
N    }
N
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Screen-to-Host BitBlt with SRCCOPY (through data port).
N  * @param[in] x x position
N  * @param[in] y y position
N  * @param[in] width is display width
N  * @param[in] height is display height
N  * @param[in] buf is pointer of HostBLT data
N  * @return none
N  */
Nvoid ge2dHostBlt_Read(int x, int y, int width, int height, void *buf)
N{
N    UINT32 cmd32, dest_pitch, dest_start, dest_dimension;
N    int transfer_count, i, j;
N    UINT32 *ptr32;
N
N#ifdef DEBUG
S    sysprintf("host_read_blt()\n");
S    sysprintf("(%d,%d)-(%d,%d)\n", x, y, x+width-1, y+height-1);
S    sysprintf("width=%d height=%d\n", width, height);
N#endif
N
N    cmd32 = 0xcc430001;
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    dest_pitch = GFX_WIDTH << 16; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, dest_pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = dest_pitch;
N
N    dest_start = y << 16 | x;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dest_dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dest_dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dest_dimension;
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N
N    ptr32 = (UINT32 *)buf;
N    for (i=0; i<height; i++) {
N        transfer_count = (width * (GFX_BPP/8) + 3) / 4; // 4-byte count
N
N        while (transfer_count >= 8) {
N            while ((inpw(REG_GE2D_MISCTL) & 0x00000400)==0);
X            while (((*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x00000400)==0);
N            for (j=0; j<8; j++) {
N                *ptr32++ = inpw(REG_GE2D_GEHBDW0);
X                *ptr32++ = (*((volatile unsigned int *)((0xB000B000+0x60))));
N            }
N            transfer_count -= 8;
N        }
N
N        if (transfer_count > 0) {
N            while (((inpw(REG_GE2D_MISCTL) & 0x0000f000)>>12) != transfer_count);
X            while ((((*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x0000f000)>>12) != transfer_count);
N            for (j=0; j<transfer_count; j++) {
N                *ptr32++ = inpw(REG_GE2D_GEHBDW0);
X                *ptr32++ = (*((volatile unsigned int *)((0xB000B000+0x60))));
N            }
N        }
N    }
N
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Host-to-Screen SpriteBlt with SRCCOPY.
N  * @param[in] x x position
N  * @param[in] y y position
N  * @param[in] width is display width
N  * @param[in] height is display height
N  * @param[in] buf is pointer of HostBLT data
N  * @return none
N  */
Nvoid ge2dHostBlt_Sprite(int x, int y, int width, int height, void *buf)
N{
N    UINT32 cmd32, dest_pitch, dest_start, dest_dimension;
N    int transfer_count, i, j;
N    UINT32 *ptr32, data32, alpha;
N
N#ifdef DEBUG
S    sysprintf("host_sprite_blt()\n");
S    sysprintf("(%d,%d)-(%d,%d)\n", x, y, x+width-1, y+height-1);
N#endif
N
N    cmd32 = 0xcc430020;
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    dest_pitch = GFX_WIDTH << 16; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, dest_pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = dest_pitch;
N
N    dest_start = y << 16 | x;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dest_dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dest_dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dest_dimension;
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    if (_DrawMode==MODE_TRANSPARENT) {
X    if (_DrawMode==1) {
N        cmd32 |= 0x00008000; // color transparency
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_TRNSCOLR, _ColorKey);
X        *((volatile unsigned int *)((0xB000B000+0x2C))) = _ColorKey;
N        outpw(REG_GE2D_TCMSK, _ColorKeyMask);
X        *((volatile unsigned int *)((0xB000B000+0x30))) = _ColorKeyMask;
N    } else if (_DrawMode==MODE_DEST_TRANSPARENT) {
X    } else if (_DrawMode==2) {
N        cmd32 |= 0x00009000;
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_TRNSCOLR, _ColorKey);
X        *((volatile unsigned int *)((0xB000B000+0x2C))) = _ColorKey;
N        outpw(REG_GE2D_TCMSK, _ColorKeyMask);
X        *((volatile unsigned int *)((0xB000B000+0x30))) = _ColorKeyMask;
N    }
N
N    if (_EnableAlpha) {
N        cmd32 |= 0x00200000;
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N        data32 = inpw(REG_GE2D_MISCTL) & 0x0000ffff;
X        data32 = (*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x0000ffff;
N        alpha = (UINT32)((_AlphaKs << 8) | _AlphaKd);
N        data32 |= (alpha << 16);
N
N        outpw(REG_GE2D_MISCTL, data32);
X        *((volatile unsigned int *)((0xB000B000+0x5C))) = data32;
N    }
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N
N    ptr32 = (UINT32 *)buf;
N    for (i=0; i<height; i++) {
N        transfer_count = width * (GFX_BPP/8) / 4; // 4-byte count
N
N        while (transfer_count > 8) {
N            while ((inpw(REG_GE2D_MISCTL) & 0x00000800)==0); // check empty
X            while (((*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x00000800)==0); 
N            for (j=0; j<8; j++) {
N                data32 = *ptr32++;
N                outpw(REG_GE2D_GEHBDW0, data32);
X                *((volatile unsigned int *)((0xB000B000+0x60))) = data32;
N            }
N            transfer_count -= 8;
N        }
N
N        if (transfer_count > 0) {
N            while ((inpw(REG_GE2D_MISCTL) & 0x00000800)==0); // check empty
X            while (((*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x00000800)==0); 
N            for (j=0; j<transfer_count; j++) {
N                data32 = *ptr32++;
N                outpw(REG_GE2D_GEHBDW0, data32);
X                *((volatile unsigned int *)((0xB000B000+0x60))) = data32;
N            }
N        }
N    }
N
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Captured the specified photo data from display memory, then displayed on display memory by rotation angle
N  * @param[in] srcx source x position
N  * @param[in] srcy source y position
N  * @param[in] destx destination x position
N  * @param[in] desty destination y position
N  * @param[in] width is display width
N  * @param[in] height is display height
N  * @param[in] ctl is drawing direction
N  * @return none
N  */
Nvoid ge2dRotation(int srcx, int srcy, int destx, int desty, int width, int height, int ctl)
N{
N    UINT32 cmd32, dest_start, src_start, dimension, pitch;
N    void *tmpscreen,*orig_dest_start00;
N
N    tmpscreen = (void *)malloc(width*height*GFX_BPP/8);
N
N#ifdef DEBUG
S    sysprintf("rotation_image()\n");
S    sysprintf("(%d,%d)=>(%d,%d)\n", srcx, srcy, destx, desty);
S    sysprintf("width=%d height=%d\n", width, height);
N#endif
N
N    memset(tmpscreen,0,width*height*GFX_BPP/8);
N
N    orig_dest_start00 = (void *)inpw(REG_GE2D_XYDORG);
X    orig_dest_start00 = (void *)(*((volatile unsigned int *)((0xB000B000+0x34))));
N    outpw(REG_GE2D_XYDORG, (int)tmpscreen);   //captured photo to another position
X    *((volatile unsigned int *)((0xB000B000+0x34))) = (int)tmpscreen;   
N    outpw(REG_GE2D_XYSORG, (int)GFX_START_ADDR);
X    *((volatile unsigned int *)((0xB000B000+0x04))) = (int)GFX_START_ADDR;
N
N    ge2dBitblt_SourceToDestination(srcx,srcy,0,0,width,height,GFX_WIDTH,width);
N
N    src_start = dest_start = dimension = cmd32 = pitch = 0;
N
N    outpw(REG_GE2D_XYDORG, (int)orig_dest_start00);
X    *((volatile unsigned int *)((0xB000B000+0x34))) = (int)orig_dest_start00;
N    outpw(REG_GE2D_XYSORG, (int)tmpscreen);
X    *((volatile unsigned int *)((0xB000B000+0x04))) = (int)tmpscreen;
N
N    pitch = GFX_WIDTH << 16 | width;
N    outpw(REG_GE2D_SDPITCH, pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = pitch;
N
N    src_start = 0 << 16 | 0;  // captured photo at (0,0) position
N    outpw(REG_GE2D_SRCSPA, src_start);
X    *((volatile unsigned int *)((0xB000B000+0x3C))) = src_start;
N
N    dest_start = desty << 16 | destx;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dimension;
N
N    cmd32 = 0xcc030000 | (ctl << 1);
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    /* set rotation reference point xy register, then nothing happened */
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N
N    free(tmpscreen);
N}
N
N/**
N  * @brief OffScreen-to-OnScreen SpriteBlt with SRCCOPY.
N  * @param[in] destx destination x position
N  * @param[in] desty destination y position
N  * @param[in] sprite_width is sprite width
N  * @param[in] sprite_height is sprite height
N  * @param[in] buf is pointer of origin data
N  * @return none
N  */
Nvoid ge2dSpriteBlt_Screen(int destx, int desty, int sprite_width, int sprite_height, void *buf)
N{
N    UINT32 cmd32, pitch, dest_start, src_start, dimension;
N    UINT32 data32, alpha;
N
N#ifdef DEBUG
S    sysprintf("screen_sprite_blt():\n");
S    sysprintf("x=%d y=%d width=%d height=%d\n", destx, desty, sprite_width, sprite_height);
N#endif
N
N    cmd32 = 0xcc430000;
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    pitch = GFX_WIDTH << 16 | sprite_width; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = pitch;
N
N    src_start = 0; // start from (0,0) of sprite
N    outpw(REG_GE2D_SRCSPA, src_start);
X    *((volatile unsigned int *)((0xB000B000+0x3C))) = src_start;
N
N    dest_start = desty << 16 | destx;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dimension = sprite_height << 16 | sprite_width;
N    outpw(REG_GE2D_RTGLSZ, dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dimension;
N
N    outpw(REG_GE2D_XYSORG, (UINT32)buf);
X    *((volatile unsigned int *)((0xB000B000+0x04))) = (UINT32)buf;
N    outpw(REG_GE2D_XYDORG, (int)GFX_START_ADDR);
X    *((volatile unsigned int *)((0xB000B000+0x34))) = (int)GFX_START_ADDR;
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    //
N    // default source color transparent is ON
N    //
N
N    cmd32 |= 0x00008000; // color transparency
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N    outpw(REG_GE2D_TRNSCOLR, make_color(COLOR_KEY));
X    *((volatile unsigned int *)((0xB000B000+0x2C))) = make_color(0xFF000000);
N    outpw(REG_GE2D_TCMSK, 0xffffff);
X    *((volatile unsigned int *)((0xB000B000+0x30))) = 0xffffff;
N
N    if (_EnableAlpha) {
N        cmd32 |= 0x00200000;
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N        data32 = inpw(REG_GE2D_MISCTL) & 0x0000ffff;
X        data32 = (*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x0000ffff;
N        alpha = (UINT32)((_AlphaKs << 8) | _AlphaKd);
N        data32 |= (alpha << 16);
N
N        outpw(REG_GE2D_MISCTL, data32);
X        *((volatile unsigned int *)((0xB000B000+0x5C))) = data32;
N    }
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief OffScreen-to-OnScreen SpriteBlt with SRCCOPY.
N  * @param[in] x x position
N  * @param[in] y y position
N  * @param[in] sprite_sx sprite x position
N  * @param[in] sprite_sy sprite y position
N  * @param[in] width is width
N  * @param[in] height is height
N  * @param[in] sprite_width is sprite width
N  * @param[in] sprite_height is sprite height
N  * @param[in] buf is pointer of origin data
N  * @return none
N  * @note The sprite starting address can be programmed.
N  */
Nvoid ge2dSpriteBltx_Screen(int x, int y, int sprite_sx, int sprite_sy, int width, int height, int sprite_width, int sprite_height, void *buf)
N{
N    UINT32 cmd32, pitch, dest_start, src_start, dimension;
N    UINT32 data32, alpha;
N
N#ifdef DEBUG
S    sysprintf("screen_sprite_bltx(): (%d,%d)\n", x, y);
S    sysprintf("sprite width=%d height=%d\n", sprite_width, sprite_height);
S    sysprintf("x=%d y=%d width=%d height=%d\n", sprite_sx, sprite_sy, width, height);
N#endif
N
N    cmd32 = 0xcc430000;
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    pitch = GFX_WIDTH << 16 | sprite_width; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = pitch;
N
N    outpw(REG_GE2D_XYSORG, (UINT32)buf);
X    *((volatile unsigned int *)((0xB000B000+0x04))) = (UINT32)buf;
N    outpw(REG_GE2D_XYDORG, (int)GFX_START_ADDR);
X    *((volatile unsigned int *)((0xB000B000+0x34))) = (int)GFX_START_ADDR;
N
N    src_start = sprite_sy << 16 | sprite_sx;
N    outpw(REG_GE2D_SRCSPA, src_start);
X    *((volatile unsigned int *)((0xB000B000+0x3C))) = src_start;
N
N    dest_start = y << 16 | x;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dimension;
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    //
N    // default source color transparent is ON
N    //
N    cmd32 |= 0x00008000; // color transparency
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N    outpw(REG_GE2D_TRNSCOLR, make_color(COLOR_KEY));
X    *((volatile unsigned int *)((0xB000B000+0x2C))) = make_color(0xFF000000);
N    outpw(REG_GE2D_TCMSK, 0xffffff);
X    *((volatile unsigned int *)((0xB000B000+0x30))) = 0xffffff;
N
N    if (_EnableAlpha) {
N        cmd32 |= 0x00200000;
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N        data32 = inpw(REG_GE2D_MISCTL) & 0x0000ffff;
X        data32 = (*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x0000ffff;
N        alpha = (UINT32)((_AlphaKs << 8) | _AlphaKd);
N        data32 |= (alpha << 16);
N
N        outpw(REG_GE2D_MISCTL, data32);
X        *((volatile unsigned int *)((0xB000B000+0x5C))) = data32;
N    }
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief OffScreen-to-OnScreen SpriteBlt with ROP.
N  * @param[in] x x position
N  * @param[in] y y position
N  * @param[in] sprite_width is sprite width
N  * @param[in] sprite_height is sprite height
N  * @param[in] buf is pointer of origin data
N  * @param[in] rop is ROP operation code
N  * @return none
N  * @note The sprite always starts from (0,0) for the BLT.
N  */
Nvoid ge2dSpriteBlt_ScreenRop(int x, int y, int sprite_width, int sprite_height, void *buf, int rop)
N{
N    UINT32 cmd32, pitch, dest_start, src_start, dimension;
N    UINT32 data32, alpha;
N
N#ifdef DEBUG
S    sysprintf("screen_sprite_rop_blt():\n");
S    sysprintf("x=%d y=%d width=%d height=%d\n", x, y, sprite_width, sprite_height);
S    sysprintf("rop=0x%x\n", rop);
N#endif
N
N    cmd32 = 0x00430000 | (rop << 24);
N
N    if (_PatternType==TYPE_MONO) {
X    if (_PatternType==0) {
N        cmd32 |= 0x00000010; // default is TYPE_COLOR
N    }
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    pitch = GFX_WIDTH << 16 | sprite_width; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = pitch;
N
N    src_start = 0; // start from (0,0) of sprite
N    outpw(REG_GE2D_SRCSPA, src_start);
X    *((volatile unsigned int *)((0xB000B000+0x3C))) = src_start;
N
N    dest_start = y << 16 | x;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dimension = sprite_height << 16 | sprite_width;
N    outpw(REG_GE2D_RTGLSZ, dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dimension;
N
N    outpw(REG_GE2D_XYSORG, (UINT32)buf);
X    *((volatile unsigned int *)((0xB000B000+0x04))) = (UINT32)buf;
N    outpw(REG_GE2D_XYDORG,(int) GFX_START_ADDR);  //smf
X    *((volatile unsigned int *)((0xB000B000+0x34))) = (int) GFX_START_ADDR;  
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    //
N    // default source color transparent is ON
N    //
N    cmd32 |= 0x00008000; // color transparency
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N    outpw(REG_GE2D_TRNSCOLR, make_color(COLOR_KEY));
X    *((volatile unsigned int *)((0xB000B000+0x2C))) = make_color(0xFF000000);
N    outpw(REG_GE2D_TCMSK, 0xffffff);
X    *((volatile unsigned int *)((0xB000B000+0x30))) = 0xffffff;
N
N    if (_EnableAlpha) {
N        cmd32 |= 0x00200000;
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N        data32 = inpw(REG_GE2D_MISCTL) & 0x0000ffff;
X        data32 = (*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x0000ffff;
N        alpha = (UINT32)((_AlphaKs << 8) | _AlphaKd);
N        data32 |= (alpha << 16);
N
N        outpw(REG_GE2D_MISCTL, data32);
X        *((volatile unsigned int *)((0xB000B000+0x5C))) = data32;
N    }
N
N    if ((rop==0x00) || (rop==0xff)) {
N        cmd32 = (cmd32 & 0xffff0fff) | 0x00009000;
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N    }
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief OffScreen-to-OnScreen SpriteBlt with ROP.
N  * @param[in] x x position
N  * @param[in] y y position
N  * @param[in] sprite_sx sprite x position
N  * @param[in] sprite_sy sprite y position
N  * @param[in] width is width
N  * @param[in] height is height
N  * @param[in] sprite_width is sprite width
N  * @param[in] sprite_height is sprite height
N  * @param[in] buf is pointer of origin data
N  * @param[in] rop is ROP operation code
N  * @return none
N  * @note The sprite always starts from (0,0) for the BLT.
N  */
Nvoid ge2dSpriteBltx_ScreenRop(int x, int y, int sprite_sx, int sprite_sy, int width, int height, int sprite_width, int sprite_height, void *buf, int rop)
N{
N    UINT32 cmd32, pitch, dest_start, src_start, dimension;
N    UINT32 data32, alpha;
N
N#ifdef DEBUG
S    sysprintf("screen_sprite_rop_bltx():\n");
S    sysprintf("x=%d y=%d width=%d height=%d\n", x, y, sprite_width, sprite_height);
S    sysprintf("rop=0x%x\n", rop);
N#endif
N
N    cmd32 = 0x00430000 | (rop << 24);
N
N    if (_PatternType==TYPE_MONO) {
X    if (_PatternType==0) {
N        cmd32 |= 0x00000010; // default is TYPE_COLOR
N    }
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    pitch = GFX_WIDTH << 16 | sprite_width; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = pitch;
N
N    src_start = sprite_sy << 16 | sprite_sx;
N    outpw(REG_GE2D_SRCSPA, src_start);
X    *((volatile unsigned int *)((0xB000B000+0x3C))) = src_start;
N
N    dest_start = y << 16 | x;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dimension;
N
N    outpw(REG_GE2D_XYSORG, (UINT32)buf);
X    *((volatile unsigned int *)((0xB000B000+0x04))) = (UINT32)buf;
N    outpw(REG_GE2D_XYDORG, (int)GFX_START_ADDR);  //smf
X    *((volatile unsigned int *)((0xB000B000+0x34))) = (int)GFX_START_ADDR;  
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    //
N    // default source color transparent is ON
N    //
N    cmd32 |= 0x00008000; // color transparency
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N    outpw(REG_GE2D_TRNSCOLR, make_color(COLOR_KEY));
X    *((volatile unsigned int *)((0xB000B000+0x2C))) = make_color(0xFF000000);
N    outpw(REG_GE2D_TCMSK, 0xffffff);
X    *((volatile unsigned int *)((0xB000B000+0x30))) = 0xffffff;
N
N    if (_EnableAlpha) {
N        cmd32 |= 0x00200000;
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N        data32 = inpw(REG_GE2D_MISCTL) & 0x0000ffff;
X        data32 = (*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x0000ffff;
N        alpha = (UINT32)((_AlphaKs << 8) | _AlphaKd);
N        data32 |= (alpha << 16);
N
N        outpw(REG_GE2D_MISCTL, data32);
X        *((volatile unsigned int *)((0xB000B000+0x5C))) = data32;
N    }
N
N    if ((rop==0x00) || (rop==0xff)) {
N        cmd32 = (cmd32 & 0xffff0fff) | 0x00009000;
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N    }
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief OffScreen-to-OnScreen TextBLT.
N  * @param[in] x x position
N  * @param[in] y y position
N  * @param[in] width is width
N  * @param[in] height is height
N  * @param[in] fore_color is color of foreground
N  * @param[in] back_color is color of background
N  * @param[in] opt is transparent is enable or not
N  * @param[in] buf is pointer of origin data
N  * @return none
N  * @note Fetch the monochrome source data from off-screen memory to the desired destination area
N  */
Nvoid ge2dColorExpansionBlt(int x, int y, int width, int height, int fore_color, int back_color, int opt, void *buf)
N{
N    UINT32 cmd32, dest_pitch, src_pitch, pitch, dest_start, dest_dimension;
N    UINT32 fore_color32, back_color32;
N
N    fore_color32 = make_color(fore_color);
N    back_color32 = make_color(back_color);
N
N    cmd32 = 0xcc430080;
N    if (opt==MODE_TRANSPARENT) {
X    if (opt==1) {
N        cmd32 |= 0x00004000; // mono transparency
N    }
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    outpw(REG_GE2D_FGCOLR, fore_color32);
X    *((volatile unsigned int *)((0xB000B000+0x28))) = fore_color32;
N    outpw(REG_GE2D_BGCOLR, back_color32);
X    *((volatile unsigned int *)((0xB000B000+0x24))) = back_color32;
N
N    dest_pitch = GFX_WIDTH; // pitch in pixels
N    src_pitch = width; // pitch in pixels
N
N    pitch = (dest_pitch << 16) | src_pitch;
N    outpw(REG_GE2D_SDPITCH, pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = pitch;
N
N    outpw(REG_GE2D_XYSORG, (int)buf);
X    *((volatile unsigned int *)((0xB000B000+0x04))) = (int)buf;
N    outpw(REG_GE2D_SRCSPA, 0); // always start from (0,0)
X    *((volatile unsigned int *)((0xB000B000+0x3C))) = 0; 
N
N    dest_start = y << 16 | x;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dest_dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dest_dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dest_dimension;
N
N    if (_ClipEnable) {
N        cmd32 |= 0x00000200;
N        if (_OutsideClip) {
N            cmd32 |= 0x00000100;
N        }
N        outpw(REG_GE2D_CTL, cmd32);
X        *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N        outpw(REG_GE2D_CLPBTL, _ClipTL);
X        *((volatile unsigned int *)((0xB000B000+0x48))) = _ClipTL;
N        outpw(REG_GE2D_CLPBBR, _ClipBR);
X        *((volatile unsigned int *)((0xB000B000+0x4C))) = _ClipBR;
N    }
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Host-to-Screen TextBLT through data port.
N  * @param[in] x x position
N  * @param[in] y y position
N  * @param[in] width is width
N  * @param[in] height is height
N  * @param[in] fore_color is color of foreground
N  * @param[in] back_color is color of background
N  * @param[in] opt is transparent is enable or not
N  * @param[in] buf is pointer of origin data
N  * @return none
N  */
Nvoid ge2dHostColorExpansionBlt(int x, int y, int width, int height, int fore_color, int back_color, int opt, void *buf)
N{
N    UINT32 cmd32, dest_pitch, dest_start, dest_dimension;
N    UINT32 fore_color32, back_color32;
N    UINT32 *ptr32, data32;
N    int transfer_count, i, j;
N
N    fore_color32 = make_color(fore_color);
N    back_color32 = make_color(back_color);
N
N    cmd32 = 0xcc4300a0;
N    if (opt==MODE_TRANSPARENT) {
X    if (opt==1) {
N        cmd32 |= 0x00004000; // mono transparency
N    }
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    outpw(REG_GE2D_FGCOLR, fore_color32);
X    *((volatile unsigned int *)((0xB000B000+0x28))) = fore_color32;
N    outpw(REG_GE2D_BGCOLR, back_color32);
X    *((volatile unsigned int *)((0xB000B000+0x24))) = back_color32;
N
N    dest_pitch = GFX_WIDTH << 16; // pitch in pixel
N    outpw(REG_GE2D_SDPITCH, dest_pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = dest_pitch;
N
N    dest_start = y << 16 | x;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N    outpw(REG_GE2D_SRCSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x3C))) = dest_start;
N
N    dest_dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dest_dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dest_dimension;
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N
N    ptr32 = (UINT32 *)buf;
N    for (i=0; i<height; i++) {
N        transfer_count = (width+31) / 32; // 32 pixels unit
N
N        while (transfer_count > 8) {
N            while ((inpw(REG_GE2D_MISCTL) & 0x00000800)==0); // check empty
X            while (((*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x00000800)==0); 
N            for (j=0; j<8; j++) {
N                data32 = *ptr32++;
N                outpw(REG_GE2D_GEHBDW0, data32);
X                *((volatile unsigned int *)((0xB000B000+0x60))) = data32;
N            }
N            transfer_count -= 8;
N        }
N
N        if (transfer_count > 0) {
N            while ((inpw(REG_GE2D_MISCTL) & 0x00000800)==0); // check empty
X            while (((*((volatile unsigned int *)((0xB000B000+0x5C)))) & 0x00000800)==0); 
N            for (j=0; j<transfer_count; j++) {
N                data32 = *ptr32++;
N                outpw(REG_GE2D_GEHBDW0, data32);
X                *((volatile unsigned int *)((0xB000B000+0x60))) = data32;
N            }
N        }
N    }
N
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Set the 8x8 mono pattern for following BitBLT functions.
N  * @param[in] opt is index for build-in pattern
N  * @param[in] fore_color is color of foreground
N  * @param[in] back_color is color of background
N  * @return none
N  */
Nvoid ge2dInitMonoPattern(int opt, int fore_color, int back_color)
N{
N    UINT32 color32;
N
N    /*
N    ** If hardware pattern definition is a little different from software.
N    ** Need to do the BYTE swap before programming the pattern registers.
N    */
N
N    outpw(REG_GE2D_PTNA, MonoPatternData[opt].PatternA);
X    *((volatile unsigned int *)((0xB000B000+0x50))) = MonoPatternData[opt]. PatternA;
N    outpw(REG_GE2D_PTNB, MonoPatternData[opt].PatternB);
X    *((volatile unsigned int *)((0xB000B000+0x54))) = MonoPatternData[opt]. PatternB;
N
N    color32 = make_color(fore_color);
N    outpw(REG_GE2D_FGCOLR, color32);
X    *((volatile unsigned int *)((0xB000B000+0x28))) = color32;
N
N    color32 = make_color(back_color);
N    outpw(REG_GE2D_BGCOLR, color32);
X    *((volatile unsigned int *)((0xB000B000+0x24))) = color32;
N
N    _PatternType = TYPE_MONO;
X    _PatternType = 0;
N}
N
N/**
N  * @brief Set the 8x8 mono pattern for following BitBLT functions.
N  * @param[in] PatternA is pattern A
N  * @param[in] PatternB is pattern B
N  * @param[in] fore_color is color of foreground
N  * @param[in] back_color is color of background
N  * @return none
N  */
Nvoid ge2dInitMonoInputPattern(UINT32 PatternA, UINT32 PatternB, int fore_color, int back_color)
N{
N    UINT32 color32;
N
N    /*
N    ** If hardware pattern definition is a little different from software.
N    ** Need to do the BYTE swap before programming the pattern registers.
N    */
N
N    outpw(REG_GE2D_PTNA, PatternA);
X    *((volatile unsigned int *)((0xB000B000+0x50))) = PatternA;
N    outpw(REG_GE2D_PTNB, PatternB);
X    *((volatile unsigned int *)((0xB000B000+0x54))) = PatternB;
N
N    color32 = make_color(fore_color);
N    outpw(REG_GE2D_FGCOLR, color32);
X    *((volatile unsigned int *)((0xB000B000+0x28))) = color32;
N
N    color32 = make_color(back_color);
N    outpw(REG_GE2D_BGCOLR, color32);
X    *((volatile unsigned int *)((0xB000B000+0x24))) = color32;
N
N    _PatternType = TYPE_MONO;
X    _PatternType = 0;
N}
N
N/**
N  * @brief Set the 8x8 color pattern for following BitBLT functions.
N  * @param[in] patformat is format of pattern, value could be
N  *                                     - \ref RGB888
N  *                                     - \ref RGB565
N  *                                     - \ref RGB332
N  * @param[in] patdata is pointer of input pattern image
N  * @return none
N  * @note This function transfers those forms:
N  *   RGB888 to RGB565 or RGB332
N  *   RGB565 to RGB332 or RGB888
N  *   RGB332 to RGB565 or RGB888
N  */
Nvoid ge2dInitColorPattern(int patformat, void *patdata)
N{
N    UINT8 *ptr_pat;
N    UINT8 *ptr8, r8, g8, b8;
N    UINT16 *ptr16, r16, g16, b16, g16_1, g16_2;
N    UINT32 *ptr32, r32, g32, b32, g32_1, g32_2;
N    int idx;
N
N    ptr_pat = (UINT8 *)patdata;
N    if(patformat == RGB888) {
X    if(patformat == 3) {
N        if (GFX_BPP==8) {
N            ptr8 = (UINT8 *)GFX_PAT_ADDR;
N            for (idx=0; idx<64; idx++) {
N                b8 = (UINT8)(*ptr_pat++) & 0xc0; // 2 bits
N                g8 = (UINT8)(*ptr_pat++) & 0xe0; // 3 bits
N                r8 = (UINT8)(*ptr_pat++) & 0xe0; // 3 bits
N                ptr_pat++;
N                *ptr8++ = r8 | (g8>>3) | (b8>>6);
N            }
N        } else if (GFX_BPP==16) {
N            ptr16 = (UINT16 *)GFX_PAT_ADDR;
N            for (idx=0; idx<64; idx++) {
N                b16 = (UINT16)(*ptr_pat++) & 0x000f8; // 5 bits
N                g16 = (UINT16)(*ptr_pat++) & 0x000fc; // 6 bits
N                r16 = (UINT16)(*ptr_pat++) & 0x000f8; // 5 bits
N                ptr_pat++;
N                *ptr16++ = (r16<<8) | (g16<<3) | (b16>>3);
N            }
N        } else if (GFX_BPP==32) {
N            ptr32 = (UINT32 *)GFX_PAT_ADDR;
N            for (idx=0; idx<64; idx++) {
N                b32 = (UINT32)(*ptr_pat++);
N                g32 = (UINT32)(*ptr_pat++);
N                r32 = (UINT32)(*ptr_pat++);
N                ptr_pat++;
N                *ptr32++ = (r32<<16) | (g32<<8) | b32;
N            }
N        }
N    } else if(patformat == RGB565) {
X    } else if(patformat == 2) {
N        if (GFX_BPP==8) {
N            ptr8 = (UINT8 *)GFX_PAT_ADDR;
N
N            for (idx=0; idx<64; idx++) {
N                b8 = (UINT8)(*ptr_pat++) & 0x00018; // 2 bits
N                g8 = (UINT8)(*ptr_pat) & 0x00007;  // 3 bits
N                r8 = (UINT8)(*ptr_pat++) & 0x000e0;  // 3bits
N                *ptr8++ = r8 | (g8<<2) | (b8>>3);
N            }
N        } else if (GFX_BPP==16) {
N            ptr16 = (UINT16 *)GFX_PAT_ADDR;
N
N            for (idx=0; idx<64; idx++) {
N                *ptr16++ = (*ptr_pat) | (*(ptr_pat+1)) << 8;
N                ptr_pat+=2;
N            }
N        } else if (GFX_BPP==32) {
N            ptr32 = (UINT32 *)GFX_PAT_ADDR;
N
N            for (idx=0; idx<64; idx++) {
N                b32 = (UINT8)(*ptr_pat) & 0x1f;      // 5 bits
N                g32_1 = (UINT8)(*ptr_pat++) & 0xe0;  // front 3 bits
N                g32_2 = (UINT8)(*ptr_pat) & 0x07;    // back 3 bits
N                g32 = ((g32_1>>5) | (g32_2<<3))<<2;
N                r32 = (UINT8)(*ptr_pat++) & 0xf8;    // 5 bits
N                *ptr32++ = 0<<24 | (r32<<16) | (g32<<8) | (b32<<3);
N            }
N        }
N    } else if(patformat == RGB332) {
X    } else if(patformat == 1) {
N        if (GFX_BPP==8) {
N            ptr8 = (UINT8 *)GFX_PAT_ADDR;
N
N            for (idx=0; idx<64; idx++) {
N                *ptr8++ = *ptr_pat;
N                ptr_pat++;
N            }
N        } else if (GFX_BPP==16) {
N            ptr16 = (UINT16 *)GFX_PAT_ADDR;
N
N            for (idx=0; idx<64; idx++) {
N                r16 = (UINT8)(*ptr_pat) & 0xe0; // 3 bits
N                g16_1 = (UINT8)(*ptr_pat) & 0x10;
N                g16_2 = (UINT8)(*ptr_pat) & 0x0c;
N                g16 = (g16_1>>2) | (g16_2>>2);
N                b16 = (UINT8)(*ptr_pat++) & 0x3; // 2 bits
N                *ptr16++ = (r16<<8) | (g16<<8) | (b16<<3);
N            }
N        } else if (GFX_BPP==32) {
N            ptr32 = (UINT32 *)GFX_PAT_ADDR;
N
N            for (idx=0; idx<64; idx++) {
N                r32 = (UINT8)(*ptr_pat) & 0xe0;  // 3 bits
N                g32 = (UINT8)(*ptr_pat) & 0x1c;  // 3 bits
N                b32 = (UINT8)(*ptr_pat++) & 0x3;  // 2 bits
N                *ptr32++ = 0<<24 | (r32<<15) | (g32<<11) | (b32<<6);
N            }
N        }
N    }
N
N    _PatternType = TYPE_COLOR;
X    _PatternType = 1;
N}
N
N/**
N  * @brief Display font character.
N  * @param[in] x x position
N  * @param[in] y y position
N  * @param[in] asc_code is ascii code
N  * @param[in] fore_color is color of foreground
N  * @param[in] back_color is color of background
N  * @param[in] draw_mode is transparent is enable or not
N  * @param[in] font_id is selection of 8x8 or 8x16 font
N  * @return none
N  */
Nvoid ge2dFont_PutChar(int x, int y, char asc_code, int fore_color, int back_color, int draw_mode, int font_id)
N{
N    int cmd32, dest_pitch, src_pitch, pitch, dest_start, dest_dimension;
N    UINT32 width, height;
N    UINT32 fore_color32, back_color32;
N    UINT8 *fptr;
N    UINT8 *temp_buf[32*32], *ptr8;
N    int idx;
N
N    fore_color32 = make_color(fore_color);
N    back_color32 = make_color(back_color);
N
N    cmd32 = 0xcc430080;
N
N    if (draw_mode==MODE_TRANSPARENT) {
X    if (draw_mode==1) {
N        cmd32 |= 0x00004000; // mono transparency
N    }
N
N    outpw(REG_GE2D_CTL, cmd32);
X    *((volatile unsigned int *)((0xB000B000+0x20))) = cmd32;
N
N    outpw(REG_GE2D_FGCOLR, fore_color32);
X    *((volatile unsigned int *)((0xB000B000+0x28))) = fore_color32;
N    outpw(REG_GE2D_BGCOLR, back_color32);
X    *((volatile unsigned int *)((0xB000B000+0x24))) = back_color32;
N
N    if (font_id==F8x16) {
X    if (font_id==1) {
N        fptr = (UINT8 *)&FontData16[asc_code][0];
N        src_pitch = 32;
N        width = 32;
N        height = 16;
N
N        ptr8 = (UINT8 *)&temp_buf[0];
N        for (idx=0; idx<16; idx++) {
N            *ptr8++ = *fptr++;
N            *ptr8++ = 0;
N            *ptr8++ = 0;
N            *ptr8++ = 0;
N        }
N        fptr =  (UINT8 *)&temp_buf[0];
N    } else { /* F8x8 */
N        fptr = (UINT8 *)&FontData8[asc_code][0];
N        src_pitch = 32;
N        width = 32;
N        height = 8;
N        ptr8 = (UINT8 *)&temp_buf[0];
N        for (idx=0; idx<8; idx++) {
N            *ptr8++ = *fptr++;
N            *ptr8++ = 0;
N            *ptr8++ = 0;
N            *ptr8++ = 0;
N        }
N        fptr =  (UINT8 *)&temp_buf[0];
N    }
N
N    dest_pitch = GFX_WIDTH; // pitch in pixels
N
N    pitch = (dest_pitch << 16) | src_pitch;
N    outpw(REG_GE2D_SDPITCH, pitch);
X    *((volatile unsigned int *)((0xB000B000+0x38))) = pitch;
N
N    outpw(REG_GE2D_XYSORG, (int)fptr);
X    *((volatile unsigned int *)((0xB000B000+0x04))) = (int)fptr;
N    outpw(REG_GE2D_SRCSPA, 0); // always start from (0,0)
X    *((volatile unsigned int *)((0xB000B000+0x3C))) = 0; 
N
N    dest_start = y << 16 | x;
N    outpw(REG_GE2D_DSTSPA, dest_start);
X    *((volatile unsigned int *)((0xB000B000+0x40))) = dest_start;
N
N    dest_dimension = height << 16 | width;
N    outpw(REG_GE2D_RTGLSZ, dest_dimension);
X    *((volatile unsigned int *)((0xB000B000+0x44))) = dest_dimension;
N
N    outpw(REG_GE2D_TRG, 1);
X    *((volatile unsigned int *)((0xB000B000+0x00))) = 1;
N    while ((inpw(REG_GE2D_INTSTS)&0x01)==0); // wait for command complete
X    while (((*((volatile unsigned int *)((0xB000B000+0x10))))&0x01)==0); 
N    outpw(REG_GE2D_INTSTS, 1); // clear interrupt status
X    *((volatile unsigned int *)((0xB000B000+0x10))) = 1; 
N}
N
N/**
N  * @brief Display font string.
N  * @param[in] x x position
N  * @param[in] y y position
N  * @param[in] str is pointer of display string
N  * @param[in] fore_color is color of foreground
N  * @param[in] back_color is color of background
N  * @param[in] draw_mode is transparent is enable or not
N  * @param[in] font_id is selection of 8x8 or 8x16 font
N  * @return none
N  */
Nvoid ge2dFont_PutString(int x, int y, char *str, int fore_color, int back_color, int draw_mode, int font_id)
N{
N    char *ptr;
N    int idx, sx;
N
N    ptr =	str;
N    sx = x;
N    for (idx=0; idx<strlen(str); idx++) {
N        ge2dFont_PutChar(sx, y, *ptr++, fore_color, back_color, draw_mode, font_id);
N        sx += 8;	//char width
N    }
N}
N/*@}*/ /* end of group N9H30_GE2D_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group N9H30_GE2D_Driver */
N
N/*@}*/ /* end of group N9H30_Device_Driver */
N
N/*** (C) COPYRIGHT 2018 Nuvoton Technology Corp. ***/
